{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"autogenerated/code-summary/","title":"Code Summary","text":""},{"location":"autogenerated/code-summary/#prisma","title":"Prisma","text":"<p>Source: <code>my-backend/node_modules/.prisma/client/edge.js</code></p> <p>Signature: <code>Prisma(.TransactionIsolationLevel = makeStrictEnum({   ReadUncommitted: 'ReadUncommitted',   ReadCommitted: 'ReadCommitted',   RepeatableRead: 'RepeatableRead',   Serializable: 'Serializable' })</code></p> <p>JSDoc:</p> <p>Prisma Client JS version: 6.16.3 Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a / Prisma.prismaVersion = {   client: \"6.16.3\",   engine: \"bb420e667c1820a8c05a38023385f6cc7ef8e83a\" }</p> <p>Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError; Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError Prisma.PrismaClientInitializationError = PrismaClientInitializationError Prisma.PrismaClientValidationError = PrismaClientValidationError Prisma.Decimal = Decimal</p> <p>/** Re-export of sql-template-tag / Prisma.sql = sqltag Prisma.empty = empty Prisma.join = join Prisma.raw = raw Prisma.validator = Public.validator</p> <p>/** Extensions / Prisma.getExtensionContext = Extensions.getExtensionContext Prisma.defineExtension = Extensions.defineExtension</p> <p>/** Shorthand utilities for JSON filtering / Prisma.DbNull = objectEnumValues.instances.DbNull Prisma.JsonNull = objectEnumValues.instances.JsonNull Prisma.AnyNull = objectEnumValues.instances.AnyNull</p> <p>Prisma.NullTypes = {   DbNull: objectEnumValues.classes.DbNull,   JsonNull: objectEnumValues.classes.JsonNull,   AnyNull: objectEnumValues.classes.AnyNull }</p> <p>/** Enums</p>"},{"location":"autogenerated/code-summary/#prisma_1","title":"Prisma","text":"<p>Source: <code>my-backend/node_modules/.prisma/client/index-browser.js</code></p> <p>Signature: <code>Prisma(.TransactionIsolationLevel = makeStrictEnum({   ReadUncommitted: 'ReadUncommitted',   ReadCommitted: 'ReadCommitted',   RepeatableRead: 'RepeatableRead',   Serializable: 'Serializable' })</code></p> <p>JSDoc:</p> <p>Prisma Client JS version: 6.16.3 Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a / Prisma.prismaVersion = {   client: \"6.16.3\",   engine: \"bb420e667c1820a8c05a38023385f6cc7ef8e83a\" }</p> <p>Prisma.PrismaClientKnownRequestError = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>PrismaClientKnownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )}; Prisma.PrismaClientUnknownRequestError = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>PrismaClientUnknownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.PrismaClientRustPanicError = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>PrismaClientRustPanicError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.PrismaClientInitializationError = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>PrismaClientInitializationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.PrismaClientValidationError = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>PrismaClientValidationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.Decimal = Decimal</p> <p>/** Re-export of sql-template-tag / Prisma.sql = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>sqltag is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.empty = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>empty is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.join = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>join is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.raw = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>raw is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.validator = Public.validator</p> <p>/** Extensions / Prisma.getExtensionContext = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>Extensions.getExtensionContext is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )} Prisma.defineExtension = () =&gt; {   const runtimeName = getRuntime().prettyName;   throw new Error(<code>Extensions.defineExtension is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}). In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report</code>, )}</p> <p>/** Shorthand utilities for JSON filtering / Prisma.DbNull = objectEnumValues.instances.DbNull Prisma.JsonNull = objectEnumValues.instances.JsonNull Prisma.AnyNull = objectEnumValues.instances.AnyNull</p> <p>Prisma.NullTypes = {   DbNull: objectEnumValues.classes.DbNull,   JsonNull: objectEnumValues.classes.JsonNull,   AnyNull: objectEnumValues.classes.AnyNull }</p> <p>/** Enums</p>"},{"location":"autogenerated/code-summary/#prisma_2","title":"Prisma","text":"<p>Source: <code>my-backend/node_modules/.prisma/client/index.js</code></p> <p>Signature: <code>Prisma(.TransactionIsolationLevel = makeStrictEnum({   ReadUncommitted: 'ReadUncommitted',   ReadCommitted: 'ReadCommitted',   RepeatableRead: 'RepeatableRead',   Serializable: 'Serializable' })</code></p> <p>JSDoc:</p> <p>Prisma Client JS version: 6.16.3 Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a / Prisma.prismaVersion = {   client: \"6.16.3\",   engine: \"bb420e667c1820a8c05a38023385f6cc7ef8e83a\" }</p> <p>Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError; Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError Prisma.PrismaClientInitializationError = PrismaClientInitializationError Prisma.PrismaClientValidationError = PrismaClientValidationError Prisma.Decimal = Decimal</p> <p>/** Re-export of sql-template-tag / Prisma.sql = sqltag Prisma.empty = empty Prisma.join = join Prisma.raw = raw Prisma.validator = Public.validator</p> <p>/** Extensions / Prisma.getExtensionContext = Extensions.getExtensionContext Prisma.defineExtension = Extensions.defineExtension</p> <p>/** Shorthand utilities for JSON filtering / Prisma.DbNull = objectEnumValues.instances.DbNull Prisma.JsonNull = objectEnumValues.instances.JsonNull Prisma.AnyNull = objectEnumValues.instances.AnyNull</p> <p>Prisma.NullTypes = {   DbNull: objectEnumValues.classes.DbNull,   JsonNull: objectEnumValues.classes.JsonNull,   AnyNull: objectEnumValues.classes.AnyNull }</p> <p>const path = require('path')</p> <p>/** Enums</p>"},{"location":"autogenerated/code-summary/#prisma_3","title":"Prisma","text":"<p>Source: <code>my-backend/node_modules/.prisma/client/wasm.js</code></p> <p>Signature: <code>Prisma(.TransactionIsolationLevel = makeStrictEnum({   ReadUncommitted: 'ReadUncommitted',   ReadCommitted: 'ReadCommitted',   RepeatableRead: 'RepeatableRead',   Serializable: 'Serializable' })</code></p> <p>JSDoc:</p> <p>Prisma Client JS version: 6.16.3 Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a / Prisma.prismaVersion = {   client: \"6.16.3\",   engine: \"bb420e667c1820a8c05a38023385f6cc7ef8e83a\" }</p> <p>Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError; Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError Prisma.PrismaClientInitializationError = PrismaClientInitializationError Prisma.PrismaClientValidationError = PrismaClientValidationError Prisma.Decimal = Decimal</p> <p>/** Re-export of sql-template-tag / Prisma.sql = sqltag Prisma.empty = empty Prisma.join = join Prisma.raw = raw Prisma.validator = Public.validator</p> <p>/** Extensions / Prisma.getExtensionContext = Extensions.getExtensionContext Prisma.defineExtension = Extensions.defineExtension</p> <p>/** Shorthand utilities for JSON filtering / Prisma.DbNull = objectEnumValues.instances.DbNull Prisma.JsonNull = objectEnumValues.instances.JsonNull Prisma.AnyNull = objectEnumValues.instances.AnyNull</p> <p>Prisma.NullTypes = {   DbNull: objectEnumValues.classes.DbNull,   JsonNull: objectEnumValues.classes.JsonNull,   AnyNull: objectEnumValues.classes.AnyNull }</p> <p>/** Enums</p>"},{"location":"autogenerated/code-summary/#formatargs","title":"formatArgs","text":"<p>Source: <code>my-backend/node_modules/@babel/core/node_modules/debug/src/browser.js</code></p> <p>Signature: <code>formatArgs(= formatArgs; exports.save = save; exports.load = load; exports.useColors = useColors; exports.storage = localstorage()</code></p> <p>JSDoc:</p> <p>This is the web browser implementation of <code>debug()</code>.</p>"},{"location":"autogenerated/code-summary/#colors","title":"colors","text":"<p>Source: <code>my-backend/node_modules/@babel/core/node_modules/debug/src/browser.js</code></p> <p>Signature: `colors(= [     '#0000CC',     '#0000FF',     '#0033CC',     '#0033FF',     '#0066CC',     '#0066FF',     '#0099CC',     '#0099FF',     '#00CC00',     '#00CC33',     '#00CC66',     '#00CC99',     '#00CCCC',     '#00CCFF',     '#3300CC',     '#3300FF',     '#3333CC',     '#3333FF',     '#3366CC',     '#3366FF',     '#3399CC',     '#3399FF',     '#33CC00',     '#33CC33',     '#33CC66',     '#33CC99',     '#33CCCC',     '#33CCFF',     '#6600CC',     '#6600FF',     '#6633CC',     '#6633FF',     '#66CC00',     '#66CC33',     '#9900CC',     '#9900FF',     '#9933CC',     '#9933FF',     '#99CC00',     '#99CC33',     '#CC0000',     '#CC0033',     '#CC0066',     '#CC0099',     '#CC00CC',     '#CC00FF',     '#CC3300',     '#CC3333',     '#CC3366',     '#CC3399',     '#CC33CC',     '#CC33FF',     '#CC6600',     '#CC6633',     '#CC9900',     '#CC9933',     '#CCCC00',     '#CCCC33',     '#FF0000',     '#FF0033',     '#FF0066',     '#FF0099',     '#FF00CC',     '#FF00FF',     '#FF3300',     '#FF3333',     '#FF3366',     '#FF3399',     '#FF33CC',     '#FF33FF',     '#FF6600',     '#FF6633',     '#FF9900',     '#FF9933',     '#FFCC00',     '#FFCC33' ];</p> <p>/**  * Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,  * and the Firebug extension (any Firefox version)`</p> <p>JSDoc:</p> <p>Colors.</p>"},{"location":"autogenerated/code-summary/#log","title":"log","text":"<p>Source: <code>my-backend/node_modules/@babel/core/node_modules/debug/src/browser.js</code></p> <p>Signature: <code>log(= console.debug || console.log || (()</code></p> <p>JSDoc:</p> <p>Colorize log arguments if enabled.</p> <p>@api public /</p> <p>function formatArgs(args) {     args0 = (this.useColors ? '%c' : '') +         this.namespace +         (this.useColors ? ' %c' : ' ') +         args0 +         (this.useColors ? '%c ' : ' ') +         '+' + module.exports.humanize(this.diff);</p> <pre><code>if (!this.useColors) {\n    return;\n}\n\nconst c = 'color: ' + this.color;\nargs.splice(1, 0, c, 'color: inherit');\n\n// The final \"%c\" is somewhat tricky, because there could be other\n// arguments passed either before or after the %c, so we need to\n// figure out the correct index to insert the CSS into\nlet index = 0;\nlet lastC = 0;\nargs[0].replace(/%[a-zA-Z%]/g, match =&gt; {\n    if (match === '%%') {\n        return;\n    }\n    index++;\n    if (match === '%c') {\n        // We only are interested in the *last* %c\n        // (the user may have provided their own)\n        lastC = index;\n    }\n});\n\nargs.splice(lastC, 0, c);\n</code></pre> <p>}</p> <p>/** Invokes <code>console.debug()</code> when available. No-op when <code>console.debug</code> is not a \"function\". If <code>console.debug</code> is not available, falls back to <code>console.log</code>.</p> <p>@api public</p>"},{"location":"autogenerated/code-summary/#init","title":"init","text":"<p>Source: <code>my-backend/node_modules/@babel/core/node_modules/debug/src/node.js</code></p> <p>Signature: <code>init(= init; exports.log = log; exports.formatArgs = formatArgs; exports.save = save; exports.load = load; exports.useColors = useColors; exports.destroy = util.deprecate(     ()</code></p> <p>JSDoc:</p> <p>Module dependencies. /</p> <p>const tty = require('tty'); const util = require('util');</p> <p>/** This is the Node.js implementation of <code>debug()</code>.</p>"},{"location":"autogenerated/code-summary/#colors_1","title":"colors","text":"<p>Source: <code>my-backend/node_modules/@babel/core/node_modules/debug/src/node.js</code></p> <p>Signature: `colors(= [6, 2, 3, 4, 5, 1];</p> <p>try {     // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)`</p> <p>JSDoc:</p> <p>Colors.</p>"},{"location":"autogenerated/code-summary/#inspectopts","title":"inspectOpts","text":"<p>Source: <code>my-backend/node_modules/@babel/core/node_modules/debug/src/node.js</code></p> <p>Signature: <code>inspectOpts(= Object.keys(process.env)</code></p> <p>JSDoc:</p> <p>Build up the default <code>inspectOpts</code> object from the environment variables.</p> <p>$ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js</p>"},{"location":"autogenerated/code-summary/#formatargs_1","title":"formatArgs","text":"<p>Source: <code>my-backend/node_modules/@babel/traverse/node_modules/debug/src/browser.js</code></p> <p>Signature: <code>formatArgs(= formatArgs; exports.save = save; exports.load = load; exports.useColors = useColors; exports.storage = localstorage()</code></p> <p>JSDoc:</p> <p>This is the web browser implementation of <code>debug()</code>.</p>"},{"location":"autogenerated/code-summary/#colors_2","title":"colors","text":"<p>Source: <code>my-backend/node_modules/@babel/traverse/node_modules/debug/src/browser.js</code></p> <p>Signature: `colors(= [     '#0000CC',     '#0000FF',     '#0033CC',     '#0033FF',     '#0066CC',     '#0066FF',     '#0099CC',     '#0099FF',     '#00CC00',     '#00CC33',     '#00CC66',     '#00CC99',     '#00CCCC',     '#00CCFF',     '#3300CC',     '#3300FF',     '#3333CC',     '#3333FF',     '#3366CC',     '#3366FF',     '#3399CC',     '#3399FF',     '#33CC00',     '#33CC33',     '#33CC66',     '#33CC99',     '#33CCCC',     '#33CCFF',     '#6600CC',     '#6600FF',     '#6633CC',     '#6633FF',     '#66CC00',     '#66CC33',     '#9900CC',     '#9900FF',     '#9933CC',     '#9933FF',     '#99CC00',     '#99CC33',     '#CC0000',     '#CC0033',     '#CC0066',     '#CC0099',     '#CC00CC',     '#CC00FF',     '#CC3300',     '#CC3333',     '#CC3366',     '#CC3399',     '#CC33CC',     '#CC33FF',     '#CC6600',     '#CC6633',     '#CC9900',     '#CC9933',     '#CCCC00',     '#CCCC33',     '#FF0000',     '#FF0033',     '#FF0066',     '#FF0099',     '#FF00CC',     '#FF00FF',     '#FF3300',     '#FF3333',     '#FF3366',     '#FF3399',     '#FF33CC',     '#FF33FF',     '#FF6600',     '#FF6633',     '#FF9900',     '#FF9933',     '#FFCC00',     '#FFCC33' ];</p> <p>/**  * Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,  * and the Firebug extension (any Firefox version)`</p> <p>JSDoc:</p> <p>Colors.</p>"},{"location":"autogenerated/code-summary/#log_1","title":"log","text":"<p>Source: <code>my-backend/node_modules/@babel/traverse/node_modules/debug/src/browser.js</code></p> <p>Signature: <code>log(= console.debug || console.log || (()</code></p> <p>JSDoc:</p> <p>Colorize log arguments if enabled.</p> <p>@api public /</p> <p>function formatArgs(args) {     args0 = (this.useColors ? '%c' : '') +         this.namespace +         (this.useColors ? ' %c' : ' ') +         args0 +         (this.useColors ? '%c ' : ' ') +         '+' + module.exports.humanize(this.diff);</p> <pre><code>if (!this.useColors) {\n    return;\n}\n\nconst c = 'color: ' + this.color;\nargs.splice(1, 0, c, 'color: inherit');\n\n// The final \"%c\" is somewhat tricky, because there could be other\n// arguments passed either before or after the %c, so we need to\n// figure out the correct index to insert the CSS into\nlet index = 0;\nlet lastC = 0;\nargs[0].replace(/%[a-zA-Z%]/g, match =&gt; {\n    if (match === '%%') {\n        return;\n    }\n    index++;\n    if (match === '%c') {\n        // We only are interested in the *last* %c\n        // (the user may have provided their own)\n        lastC = index;\n    }\n});\n\nargs.splice(lastC, 0, c);\n</code></pre> <p>}</p> <p>/** Invokes <code>console.debug()</code> when available. No-op when <code>console.debug</code> is not a \"function\". If <code>console.debug</code> is not available, falls back to <code>console.log</code>.</p> <p>@api public</p>"},{"location":"autogenerated/code-summary/#init_1","title":"init","text":"<p>Source: <code>my-backend/node_modules/@babel/traverse/node_modules/debug/src/node.js</code></p> <p>Signature: <code>init(= init; exports.log = log; exports.formatArgs = formatArgs; exports.save = save; exports.load = load; exports.useColors = useColors; exports.destroy = util.deprecate(     ()</code></p> <p>JSDoc:</p> <p>Module dependencies. /</p> <p>const tty = require('tty'); const util = require('util');</p> <p>/** This is the Node.js implementation of <code>debug()</code>.</p>"},{"location":"autogenerated/code-summary/#colors_3","title":"colors","text":"<p>Source: <code>my-backend/node_modules/@babel/traverse/node_modules/debug/src/node.js</code></p> <p>Signature: `colors(= [6, 2, 3, 4, 5, 1];</p> <p>try {     // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)`</p> <p>JSDoc:</p> <p>Colors.</p>"},{"location":"autogenerated/code-summary/#inspectopts_1","title":"inspectOpts","text":"<p>Source: <code>my-backend/node_modules/@babel/traverse/node_modules/debug/src/node.js</code></p> <p>Signature: <code>inspectOpts(= Object.keys(process.env)</code></p> <p>JSDoc:</p> <p>Build up the default <code>inspectOpts</code> object from the environment variables.</p> <p>$ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js</p>"},{"location":"autogenerated/code-summary/#isnumberliteral","title":"isNumberLiteral","text":"<p>Source: <code>my-backend/node_modules/@babel/types/lib/index-legacy.d.ts</code></p> <p>Signature: <code>isNumberLiteral(node: object | null | undefined, opts?: object | null)</code></p> <p>JSDoc:</p> <p>@deprecated Use <code>NumericLiteral</code> / export type NumberLiteral = NumericLiteral;</p> <p>/** @deprecated Use <code>RegExpLiteral</code> / export type RegexLiteral = RegExpLiteral;</p> <p>/** @deprecated Use <code>RestElement</code> / export type RestProperty = RestElement;</p> <p>/** @deprecated Use <code>SpreadElement</code> / export type SpreadProperty = SpreadElement;</p> <p>export type Standardized = ArrayExpression | AssignmentExpression | BinaryExpression | InterpreterDirective | Directive | DirectiveLiteral | BlockStatement | BreakStatement | CallExpression | CatchClause | ConditionalExpression | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | File | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Identifier | IfStatement | LabeledStatement | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | Program | ObjectExpression | ObjectMethod | ObjectProperty | RestElement | ReturnStatement | SequenceExpression | ParenthesizedExpression | SwitchCase | SwitchStatement | ThisExpression | ThrowStatement | TryStatement | UnaryExpression | UpdateExpression | VariableDeclaration | VariableDeclarator | WhileStatement | WithStatement | AssignmentPattern | ArrayPattern | ArrowFunctionExpression | ClassBody | ClassExpression | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExportSpecifier | ForOfStatement | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ImportExpression | MetaProperty | ClassMethod | ObjectPattern | SpreadElement | Super | TaggedTemplateExpression | TemplateElement | TemplateLiteral | YieldExpression | AwaitExpression | Import | BigIntLiteral | ExportNamespaceSpecifier | OptionalMemberExpression | OptionalCallExpression | ClassProperty | ClassAccessorProperty | ClassPrivateProperty | ClassPrivateMethod | PrivateName | StaticBlock | ImportAttribute; export type Expression = ArrayExpression | AssignmentExpression | BinaryExpression | CallExpression | ConditionalExpression | FunctionExpression | Identifier | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | ObjectExpression | SequenceExpression | ParenthesizedExpression | ThisExpression | UnaryExpression | UpdateExpression | ArrowFunctionExpression | ClassExpression | ImportExpression | MetaProperty | Super | TaggedTemplateExpression | TemplateLiteral | YieldExpression | AwaitExpression | Import | BigIntLiteral | OptionalMemberExpression | OptionalCallExpression | TypeCastExpression | JSXElement | JSXFragment | BindExpression | DoExpression | RecordExpression | TupleExpression | DecimalLiteral | ModuleExpression | TopicReference | PipelineTopicExpression | PipelineBareFunction | PipelinePrimaryTopicReference | TSInstantiationExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression; export type Binary = BinaryExpression | LogicalExpression; export type Scopable = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ClassExpression | ClassDeclaration | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock; export type BlockParent = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock; export type Block = BlockStatement | Program | TSModuleBlock; export type Statement = BlockStatement | BreakStatement | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | ForInStatement | ForStatement | FunctionDeclaration | IfStatement | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | VariableDeclaration | WhileStatement | WithStatement | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ForOfStatement | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration | TSExportAssignment | TSNamespaceExportDeclaration; export type Terminatorless = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement | YieldExpression | AwaitExpression; export type CompletionStatement = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement; export type Conditional = ConditionalExpression | IfStatement; export type Loop = DoWhileStatement | ForInStatement | ForStatement | WhileStatement | ForOfStatement; export type While = DoWhileStatement | WhileStatement; export type ExpressionWrapper = ExpressionStatement | ParenthesizedExpression | TypeCastExpression; export type For = ForInStatement | ForStatement | ForOfStatement; export type ForXStatement = ForInStatement | ForOfStatement; export type Function = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod; export type FunctionParent = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock; export type Pureish = FunctionDeclaration | FunctionExpression | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | ArrowFunctionExpression | BigIntLiteral | DecimalLiteral; export type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration; export type FunctionParameter = Identifier | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | VoidPattern; export type PatternLike = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | VoidPattern | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression; export type LVal = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSParameterProperty | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression; export type TSEntityName = Identifier | TSQualifiedName; export type Literal = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | TemplateLiteral | BigIntLiteral | DecimalLiteral; export type Immutable = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | BigIntLiteral | JSXAttribute | JSXClosingElement | JSXElement | JSXExpressionContainer | JSXSpreadChild | JSXOpeningElement | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment | DecimalLiteral; export type UserWhitespacable = ObjectMethod | ObjectProperty | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty; export type Method = ObjectMethod | ClassMethod | ClassPrivateMethod; export type ObjectMember = ObjectMethod | ObjectProperty; export type Property = ObjectProperty | ClassProperty | ClassAccessorProperty | ClassPrivateProperty; export type UnaryLike = UnaryExpression | SpreadElement; export type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern | VoidPattern; export type Class = ClassExpression | ClassDeclaration; export type ImportOrExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration; export type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration; export type ModuleSpecifier = ExportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ExportNamespaceSpecifier | ExportDefaultSpecifier; export type Accessor = ClassAccessorProperty; export type Private = ClassPrivateProperty | ClassPrivateMethod | PrivateName; export type Flow = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ClassImplements | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | DeclaredPredicate | ExistsTypeAnnotation | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | InferredPredicate | InterfaceExtends | InterfaceDeclaration | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | QualifiedTypeIdentifier | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | UnionTypeAnnotation | Variance | VoidTypeAnnotation | EnumDeclaration | EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody | EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember | IndexedAccessType | OptionalIndexedAccessType; export type FlowType = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ExistsTypeAnnotation | FunctionTypeAnnotation | GenericTypeAnnotation | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | UnionTypeAnnotation | VoidTypeAnnotation | IndexedAccessType | OptionalIndexedAccessType; export type FlowBaseAnnotation = AnyTypeAnnotation | BooleanTypeAnnotation | NullLiteralTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NumberTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | VoidTypeAnnotation; export type FlowDeclaration = DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias; export type FlowPredicate = DeclaredPredicate | InferredPredicate; export type EnumBody = EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody; export type EnumMember = EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember; export type JSX = JSXAttribute | JSXClosingElement | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXSpreadChild | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXSpreadAttribute | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment; export type Miscellaneous = Noop | Placeholder | V8IntrinsicIdentifier; export type TypeScript = TSParameterProperty | TSDeclareFunction | TSDeclareMethod | TSQualifiedName | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature | TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSOptionalType | TSRestType | TSNamedTupleMember | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSTemplateLiteralType | TSLiteralType | TSExpressionWithTypeArguments | TSInterfaceDeclaration | TSInterfaceBody | TSTypeAliasDeclaration | TSInstantiationExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSEnumBody | TSEnumDeclaration | TSEnumMember | TSModuleDeclaration | TSModuleBlock | TSImportType | TSImportEqualsDeclaration | TSExternalModuleReference | TSNonNullExpression | TSExportAssignment | TSNamespaceExportDeclaration | TSTypeAnnotation | TSTypeParameterInstantiation | TSTypeParameterDeclaration | TSTypeParameter; export type TSTypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature; export type TSType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSOptionalType | TSRestType | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSTemplateLiteralType | TSLiteralType | TSExpressionWithTypeArguments | TSImportType; export type TSBaseType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSTemplateLiteralType | TSLiteralType; export type ModuleDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;</p> <p>export interface Aliases {   Standardized: Standardized;   Expression: Expression;   Binary: Binary;   Scopable: Scopable;   BlockParent: BlockParent;   Block: Block;   Statement: Statement;   Terminatorless: Terminatorless;   CompletionStatement: CompletionStatement;   Conditional: Conditional;   Loop: Loop;   While: While;   ExpressionWrapper: ExpressionWrapper;   For: For;   ForXStatement: ForXStatement;   Function: Function;   FunctionParent: FunctionParent;   Pureish: Pureish;   Declaration: Declaration;   FunctionParameter: FunctionParameter;   PatternLike: PatternLike;   LVal: LVal;   TSEntityName: TSEntityName;   Literal: Literal;   Immutable: Immutable;   UserWhitespacable: UserWhitespacable;   Method: Method;   ObjectMember: ObjectMember;   Property: Property;   UnaryLike: UnaryLike;   Pattern: Pattern;   Class: Class;   ImportOrExportDeclaration: ImportOrExportDeclaration;   ExportDeclaration: ExportDeclaration;   ModuleSpecifier: ModuleSpecifier;   Accessor: Accessor;   Private: Private;   Flow: Flow;   FlowType: FlowType;   FlowBaseAnnotation: FlowBaseAnnotation;   FlowDeclaration: FlowDeclaration;   FlowPredicate: FlowPredicate;   EnumBody: EnumBody;   EnumMember: EnumMember;   JSX: JSX;   Miscellaneous: Miscellaneous;   TypeScript: TypeScript;   TSTypeElement: TSTypeElement;   TSType: TSType;   TSBaseType: TSBaseType;   ModuleDeclaration: ModuleDeclaration; }</p> <p>export function arrayExpression(elements?: Array): ArrayExpression; export function assignmentExpression(operator: string, left: LVal | OptionalMemberExpression, right: Expression): AssignmentExpression; export function binaryExpression(operator: \"+\" | \"-\" | \"/\" | \"%\" | \"\" | \"\" | \"&amp;\" | \"|\" | \"&gt;&gt;\" | \"&gt;&gt;&gt;\" | \"&lt;&lt;\" | \"^\" | \"==\" | \"===\" | \"!=\" | \"!==\" | \"in\" | \"instanceof\" | \"&gt;\" | \"&lt;\" | \"&gt;=\" | \"&lt;=\" | \"|&gt;\", left: Expression | PrivateName, right: Expression): BinaryExpression; export function interpreterDirective(value: string): InterpreterDirective; export function directive(value: DirectiveLiteral): Directive; export function directiveLiteral(value: string): DirectiveLiteral; export function blockStatement(body: Array, directives?: Array): BlockStatement; export function breakStatement(label?: Identifier | null): BreakStatement; export function callExpression(callee: Expression | Super | V8IntrinsicIdentifier, _arguments: Array): CallExpression; export function catchClause(param: Identifier | ArrayPattern | ObjectPattern | null | undefined, body: BlockStatement): CatchClause; export function conditionalExpression(test: Expression, consequent: Expression, alternate: Expression): ConditionalExpression; export function continueStatement(label?: Identifier | null): ContinueStatement; export function debuggerStatement(): DebuggerStatement; export function doWhileStatement(test: Expression, body: Statement): DoWhileStatement; export function emptyStatement(): EmptyStatement; export function expressionStatement(expression: Expression): ExpressionStatement; export function file(program: Program, comments?: Array | null, tokens?: Array | null): File; export function forInStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement): ForInStatement; export function forStatement(init: VariableDeclaration | Expression | null | undefined, test: Expression | null | undefined, update: Expression | null | undefined, body: Statement): ForStatement; export function functionDeclaration(id: Identifier | null | undefined, params: Array, body: BlockStatement, generator?: boolean, async?: boolean): FunctionDeclaration; export function functionExpression(id: Identifier | null | undefined, params: Array, body: BlockStatement, generator?: boolean, async?: boolean): FunctionExpression; export function identifier(name: string): Identifier; export function ifStatement(test: Expression, consequent: Statement, alternate?: Statement | null): IfStatement; export function labeledStatement(label: Identifier, body: Statement): LabeledStatement; export function stringLiteral(value: string): StringLiteral; export function numericLiteral(value: number): NumericLiteral; export function nullLiteral(): NullLiteral; export function booleanLiteral(value: boolean): BooleanLiteral; export function regExpLiteral(pattern: string, flags?: string): RegExpLiteral; export function logicalExpression(operator: \"||\" | \"&amp;&amp;\" | \"??\", left: Expression, right: Expression): LogicalExpression; export function memberExpression(object: Expression | Super, property: Expression | Identifier | PrivateName, computed?: boolean, optional?: boolean | null): MemberExpression; export function newExpression(callee: Expression | Super | V8IntrinsicIdentifier, _arguments: Array): NewExpression; export function program(body: Array, directives?: Array, sourceType?: \"script\" | \"module\", interpreter?: InterpreterDirective | null): Program; export function objectExpression(properties: Array): ObjectExpression; export function objectMethod(kind: \"method\" | \"get\" | \"set\" | undefined, key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral, params: Array, body: BlockStatement, computed?: boolean, generator?: boolean, async?: boolean): ObjectMethod; export function objectProperty(key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral | DecimalLiteral | PrivateName, value: Expression | PatternLike, computed?: boolean, shorthand?: boolean, decorators?: Array | null): ObjectProperty; export function restElement(argument: Identifier | ArrayPattern | ObjectPattern | MemberExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression | RestElement | AssignmentPattern): RestElement; export function returnStatement(argument?: Expression | null): ReturnStatement; export function sequenceExpression(expressions: Array): SequenceExpression; export function parenthesizedExpression(expression: Expression): ParenthesizedExpression; export function switchCase(test: Expression | null | undefined, consequent: Array): SwitchCase; export function switchStatement(discriminant: Expression, cases: Array): SwitchStatement; export function thisExpression(): ThisExpression; export function throwStatement(argument: Expression): ThrowStatement; export function tryStatement(block: BlockStatement, handler?: CatchClause | null, finalizer?: BlockStatement | null): TryStatement; export function unaryExpression(operator: \"void\" | \"throw\" | \"delete\" | \"!\" | \"+\" | \"-\" | \"~\" | \"typeof\", argument: Expression, prefix?: boolean): UnaryExpression; export function updateExpression(operator: \"++\" | \"--\", argument: Expression, prefix?: boolean): UpdateExpression; export function variableDeclaration(kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\", declarations: Array): VariableDeclaration; export function variableDeclarator(id: LVal | VoidPattern, init?: Expression | null): VariableDeclarator; export function whileStatement(test: Expression, body: Statement): WhileStatement; export function withStatement(object: Expression, body: Statement): WithStatement; export function assignmentPattern(left: Identifier | ObjectPattern | ArrayPattern | MemberExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression, right: Expression): AssignmentPattern; export function arrayPattern(elements: Array): ArrayPattern; export function arrowFunctionExpression(params: Array, body: BlockStatement | Expression, async?: boolean): ArrowFunctionExpression; export function classBody(body: Array): ClassBody; export function classExpression(id: Identifier | null | undefined, superClass: Expression | null | undefined, body: ClassBody, decorators?: Array | null): ClassExpression; export function classDeclaration(id: Identifier | null | undefined, superClass: Expression | null | undefined, body: ClassBody, decorators?: Array | null): ClassDeclaration; export function exportAllDeclaration(source: StringLiteral): ExportAllDeclaration; export function exportDefaultDeclaration(declaration: TSDeclareFunction | FunctionDeclaration | ClassDeclaration | Expression): ExportDefaultDeclaration; export function exportNamedDeclaration(declaration?: Declaration | null, specifiers?: Array, source?: StringLiteral | null): ExportNamedDeclaration; export function exportSpecifier(local: Identifier, exported: Identifier | StringLiteral): ExportSpecifier; export function forOfStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement, _await?: boolean): ForOfStatement; export function importDeclaration(specifiers: Array, source: StringLiteral): ImportDeclaration; export function importDefaultSpecifier(local: Identifier): ImportDefaultSpecifier; export function importNamespaceSpecifier(local: Identifier): ImportNamespaceSpecifier; export function importSpecifier(local: Identifier, imported: Identifier | StringLiteral): ImportSpecifier; export function importExpression(source: Expression, options?: Expression | null): ImportExpression; export function metaProperty(meta: Identifier, property: Identifier): MetaProperty; export function classMethod(kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined, key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, params: Array, body: BlockStatement, computed?: boolean, _static?: boolean, generator?: boolean, async?: boolean): ClassMethod; export function objectPattern(properties: Array): ObjectPattern; export function spreadElement(argument: Expression): SpreadElement; declare function _super(): Super; export { _super as super} export function taggedTemplateExpression(tag: Expression, quasi: TemplateLiteral): TaggedTemplateExpression; export function templateElement(value: { raw: string, cooked?: string }, tail?: boolean): TemplateElement; export function templateLiteral(quasis: Array, expressions: Array): TemplateLiteral; export function yieldExpression(argument?: Expression | null, delegate?: boolean): YieldExpression; export function awaitExpression(argument: Expression): AwaitExpression; declare function _import(): Import; export { _import as import} export function bigIntLiteral(value: string): BigIntLiteral; export function exportNamespaceSpecifier(exported: Identifier): ExportNamespaceSpecifier; export function optionalMemberExpression(object: Expression, property: Expression | Identifier, computed: boolean | undefined, optional: boolean): OptionalMemberExpression; export function optionalCallExpression(callee: Expression, _arguments: Array, optional: boolean): OptionalCallExpression; export function classProperty(key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, value?: Expression | null, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null, decorators?: Array | null, computed?: boolean, _static?: boolean): ClassProperty; export function classAccessorProperty(key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression | PrivateName, value?: Expression | null, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null, decorators?: Array | null, computed?: boolean, _static?: boolean): ClassAccessorProperty; export function classPrivateProperty(key: PrivateName, value?: Expression | null, decorators?: Array | null, _static?: boolean): ClassPrivateProperty; export function classPrivateMethod(kind: \"get\" | \"set\" | \"method\" | undefined, key: PrivateName, params: Array, body: BlockStatement, _static?: boolean): ClassPrivateMethod; export function privateName(id: Identifier): PrivateName; export function staticBlock(body: Array): StaticBlock; export function importAttribute(key: Identifier | StringLiteral, value: StringLiteral): ImportAttribute; export function anyTypeAnnotation(): AnyTypeAnnotation; export function arrayTypeAnnotation(elementType: FlowType): ArrayTypeAnnotation; export function booleanTypeAnnotation(): BooleanTypeAnnotation; export function booleanLiteralTypeAnnotation(value: boolean): BooleanLiteralTypeAnnotation; export function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation; export function classImplements(id: Identifier, typeParameters?: TypeParameterInstantiation | null): ClassImplements; export function declareClass(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array | null | undefined, body: ObjectTypeAnnotation): DeclareClass; export function declareFunction(id: Identifier): DeclareFunction; export function declareInterface(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array | null | undefined, body: ObjectTypeAnnotation): DeclareInterface; export function declareModule(id: Identifier | StringLiteral, body: BlockStatement, kind?: \"CommonJS\" | \"ES\" | null): DeclareModule; export function declareModuleExports(typeAnnotation: TypeAnnotation): DeclareModuleExports; export function declareTypeAlias(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, right: FlowType): DeclareTypeAlias; export function declareOpaqueType(id: Identifier, typeParameters?: TypeParameterDeclaration | null, supertype?: FlowType | null): DeclareOpaqueType; export function declareVariable(id: Identifier): DeclareVariable; export function declareExportDeclaration(declaration?: Flow | null, specifiers?: Array | null, source?: StringLiteral | null, attributes?: Array | null): DeclareExportDeclaration; export function declareExportAllDeclaration(source: StringLiteral, attributes?: Array | null): DeclareExportAllDeclaration; export function declaredPredicate(value: Flow): DeclaredPredicate; export function existsTypeAnnotation(): ExistsTypeAnnotation; export function functionTypeAnnotation(typeParameters: TypeParameterDeclaration | null | undefined, params: Array, rest: FunctionTypeParam | null | undefined, returnType: FlowType): FunctionTypeAnnotation; export function functionTypeParam(name: Identifier | null | undefined, typeAnnotation: FlowType): FunctionTypeParam; export function genericTypeAnnotation(id: Identifier | QualifiedTypeIdentifier, typeParameters?: TypeParameterInstantiation | null): GenericTypeAnnotation; export function inferredPredicate(): InferredPredicate; export function interfaceExtends(id: Identifier | QualifiedTypeIdentifier, typeParameters?: TypeParameterInstantiation | null): InterfaceExtends; export function interfaceDeclaration(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array | null | undefined, body: ObjectTypeAnnotation): InterfaceDeclaration; export function interfaceTypeAnnotation(_extends: Array | null | undefined, body: ObjectTypeAnnotation): InterfaceTypeAnnotation; export function intersectionTypeAnnotation(types: Array): IntersectionTypeAnnotation; export function mixedTypeAnnotation(): MixedTypeAnnotation; export function emptyTypeAnnotation(): EmptyTypeAnnotation; export function nullableTypeAnnotation(typeAnnotation: FlowType): NullableTypeAnnotation; export function numberLiteralTypeAnnotation(value: number): NumberLiteralTypeAnnotation; export function numberTypeAnnotation(): NumberTypeAnnotation; export function objectTypeAnnotation(properties: Array, indexers?: Array, callProperties?: Array, internalSlots?: Array, exact?: boolean): ObjectTypeAnnotation; export function objectTypeInternalSlot(id: Identifier, value: FlowType, optional: boolean, _static: boolean, method: boolean): ObjectTypeInternalSlot; export function objectTypeCallProperty(value: FlowType): ObjectTypeCallProperty; export function objectTypeIndexer(id: Identifier | null | undefined, key: FlowType, value: FlowType, variance?: Variance | null): ObjectTypeIndexer; export function objectTypeProperty(key: Identifier | StringLiteral, value: FlowType, variance?: Variance | null): ObjectTypeProperty; export function objectTypeSpreadProperty(argument: FlowType): ObjectTypeSpreadProperty; export function opaqueType(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, supertype: FlowType | null | undefined, impltype: FlowType): OpaqueType; export function qualifiedTypeIdentifier(id: Identifier, qualification: Identifier | QualifiedTypeIdentifier): QualifiedTypeIdentifier; export function stringLiteralTypeAnnotation(value: string): StringLiteralTypeAnnotation; export function stringTypeAnnotation(): StringTypeAnnotation; export function symbolTypeAnnotation(): SymbolTypeAnnotation; export function thisTypeAnnotation(): ThisTypeAnnotation; export function tupleTypeAnnotation(types: Array): TupleTypeAnnotation; export function typeofTypeAnnotation(argument: FlowType): TypeofTypeAnnotation; export function typeAlias(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, right: FlowType): TypeAlias; export function typeAnnotation(typeAnnotation: FlowType): TypeAnnotation; export function typeCastExpression(expression: Expression, typeAnnotation: TypeAnnotation): TypeCastExpression; export function typeParameter(bound?: TypeAnnotation | null, _default?: FlowType | null, variance?: Variance | null): TypeParameter; export function typeParameterDeclaration(params: Array): TypeParameterDeclaration; export function typeParameterInstantiation(params: Array): TypeParameterInstantiation; export function unionTypeAnnotation(types: Array): UnionTypeAnnotation; export function variance(kind: \"minus\" | \"plus\"): Variance; export function voidTypeAnnotation(): VoidTypeAnnotation; export function enumDeclaration(id: Identifier, body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody): EnumDeclaration; export function enumBooleanBody(members: Array): EnumBooleanBody; export function enumNumberBody(members: Array): EnumNumberBody; export function enumStringBody(members: Array): EnumStringBody; export function enumSymbolBody(members: Array): EnumSymbolBody; export function enumBooleanMember(id: Identifier): EnumBooleanMember; export function enumNumberMember(id: Identifier, init: NumericLiteral): EnumNumberMember; export function enumStringMember(id: Identifier, init: StringLiteral): EnumStringMember; export function enumDefaultedMember(id: Identifier): EnumDefaultedMember; export function indexedAccessType(objectType: FlowType, indexType: FlowType): IndexedAccessType; export function optionalIndexedAccessType(objectType: FlowType, indexType: FlowType): OptionalIndexedAccessType; export function jsxAttribute(name: JSXIdentifier | JSXNamespacedName, value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer | null): JSXAttribute; export function jsxClosingElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName): JSXClosingElement; export function jsxElement(openingElement: JSXOpeningElement, closingElement: JSXClosingElement | null | undefined, children: Array, selfClosing?: boolean | null): JSXElement; export function jsxEmptyExpression(): JSXEmptyExpression; export function jsxExpressionContainer(expression: Expression | JSXEmptyExpression): JSXExpressionContainer; export function jsxSpreadChild(expression: Expression): JSXSpreadChild; export function jsxIdentifier(name: string): JSXIdentifier; export function jsxMemberExpression(object: JSXMemberExpression | JSXIdentifier, property: JSXIdentifier): JSXMemberExpression; export function jsxNamespacedName(namespace: JSXIdentifier, name: JSXIdentifier): JSXNamespacedName; export function jsxOpeningElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName, attributes: Array, selfClosing?: boolean): JSXOpeningElement; export function jsxSpreadAttribute(argument: Expression): JSXSpreadAttribute; export function jsxText(value: string): JSXText; export function jsxFragment(openingFragment: JSXOpeningFragment, closingFragment: JSXClosingFragment, children: Array): JSXFragment; export function jsxOpeningFragment(): JSXOpeningFragment; export function jsxClosingFragment(): JSXClosingFragment; export function noop(): Noop; export function placeholder(expectedNode: \"Identifier\" | \"StringLiteral\" | \"Expression\" | \"Statement\" | \"Declaration\" | \"BlockStatement\" | \"ClassBody\" | \"Pattern\", name: Identifier): Placeholder; export function v8IntrinsicIdentifier(name: string): V8IntrinsicIdentifier; export function argumentPlaceholder(): ArgumentPlaceholder; export function bindExpression(object: Expression, callee: Expression): BindExpression; export function decorator(expression: Expression): Decorator; export function doExpression(body: BlockStatement, async?: boolean): DoExpression; export function exportDefaultSpecifier(exported: Identifier): ExportDefaultSpecifier; export function recordExpression(properties: Array): RecordExpression; export function tupleExpression(elements?: Array): TupleExpression; export function decimalLiteral(value: string): DecimalLiteral; export function moduleExpression(body: Program): ModuleExpression; export function topicReference(): TopicReference; export function pipelineTopicExpression(expression: Expression): PipelineTopicExpression; export function pipelineBareFunction(callee: Expression): PipelineBareFunction; export function pipelinePrimaryTopicReference(): PipelinePrimaryTopicReference; export function voidPattern(): VoidPattern; export function tsParameterProperty(parameter: Identifier | AssignmentPattern): TSParameterProperty; export function tsDeclareFunction(id: Identifier | null | undefined, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array, returnType?: TSTypeAnnotation | Noop | null): TSDeclareFunction; export function tsDeclareMethod(decorators: Array | null | undefined, key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array, returnType?: TSTypeAnnotation | Noop | null): TSDeclareMethod; export function tsQualifiedName(left: TSEntityName, right: Identifier): TSQualifiedName; export function tsCallSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array, typeAnnotation?: TSTypeAnnotation | null): TSCallSignatureDeclaration; export function tsConstructSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array, typeAnnotation?: TSTypeAnnotation | null): TSConstructSignatureDeclaration; export function tsPropertySignature(key: Expression, typeAnnotation?: TSTypeAnnotation | null): TSPropertySignature; export function tsMethodSignature(key: Expression, typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array, typeAnnotation?: TSTypeAnnotation | null): TSMethodSignature; export function tsIndexSignature(parameters: Array, typeAnnotation?: TSTypeAnnotation | null): TSIndexSignature; export function tsAnyKeyword(): TSAnyKeyword; export function tsBooleanKeyword(): TSBooleanKeyword; export function tsBigIntKeyword(): TSBigIntKeyword; export function tsIntrinsicKeyword(): TSIntrinsicKeyword; export function tsNeverKeyword(): TSNeverKeyword; export function tsNullKeyword(): TSNullKeyword; export function tsNumberKeyword(): TSNumberKeyword; export function tsObjectKeyword(): TSObjectKeyword; export function tsStringKeyword(): TSStringKeyword; export function tsSymbolKeyword(): TSSymbolKeyword; export function tsUndefinedKeyword(): TSUndefinedKeyword; export function tsUnknownKeyword(): TSUnknownKeyword; export function tsVoidKeyword(): TSVoidKeyword; export function tsThisType(): TSThisType; export function tsFunctionType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array, typeAnnotation?: TSTypeAnnotation | null): TSFunctionType; export function tsConstructorType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array, typeAnnotation?: TSTypeAnnotation | null): TSConstructorType; export function tsTypeReference(typeName: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSTypeReference; export function tsTypePredicate(parameterName: Identifier | TSThisType, typeAnnotation?: TSTypeAnnotation | null, asserts?: boolean | null): TSTypePredicate; export function tsTypeQuery(exprName: TSEntityName | TSImportType, typeParameters?: TSTypeParameterInstantiation | null): TSTypeQuery; export function tsTypeLiteral(members: Array): TSTypeLiteral; export function tsArrayType(elementType: TSType): TSArrayType; export function tsTupleType(elementTypes: Array): TSTupleType; export function tsOptionalType(typeAnnotation: TSType): TSOptionalType; export function tsRestType(typeAnnotation: TSType): TSRestType; export function tsNamedTupleMember(label: Identifier, elementType: TSType, optional?: boolean): TSNamedTupleMember; export function tsUnionType(types: Array): TSUnionType; export function tsIntersectionType(types: Array): TSIntersectionType; export function tsConditionalType(checkType: TSType, extendsType: TSType, trueType: TSType, falseType: TSType): TSConditionalType; export function tsInferType(typeParameter: TSTypeParameter): TSInferType; export function tsParenthesizedType(typeAnnotation: TSType): TSParenthesizedType; export function tsTypeOperator(typeAnnotation: TSType, operator?: string): TSTypeOperator; export function tsIndexedAccessType(objectType: TSType, indexType: TSType): TSIndexedAccessType; export function tsMappedType(typeParameter: TSTypeParameter, typeAnnotation?: TSType | null, nameType?: TSType | null): TSMappedType; export function tsTemplateLiteralType(quasis: Array, types: Array): TSTemplateLiteralType; export function tsLiteralType(literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral | TemplateLiteral | UnaryExpression): TSLiteralType; export function tsExpressionWithTypeArguments(expression: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSExpressionWithTypeArguments; export function tsInterfaceDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, _extends: Array | null | undefined, body: TSInterfaceBody): TSInterfaceDeclaration; export function tsInterfaceBody(body: Array): TSInterfaceBody; export function tsTypeAliasDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, typeAnnotation: TSType): TSTypeAliasDeclaration; export function tsInstantiationExpression(expression: Expression, typeParameters?: TSTypeParameterInstantiation | null): TSInstantiationExpression; export function tsAsExpression(expression: Expression, typeAnnotation: TSType): TSAsExpression; export function tsSatisfiesExpression(expression: Expression, typeAnnotation: TSType): TSSatisfiesExpression; export function tsTypeAssertion(typeAnnotation: TSType, expression: Expression): TSTypeAssertion; export function tsEnumBody(members: Array): TSEnumBody; export function tsEnumDeclaration(id: Identifier, members: Array): TSEnumDeclaration; export function tsEnumMember(id: Identifier | StringLiteral, initializer?: Expression | null): TSEnumMember; export function tsModuleDeclaration(id: Identifier | StringLiteral, body: TSModuleBlock | TSModuleDeclaration): TSModuleDeclaration; export function tsModuleBlock(body: Array): TSModuleBlock; export function tsImportType(argument: StringLiteral, qualifier?: TSEntityName | null, typeParameters?: TSTypeParameterInstantiation | null): TSImportType; export function tsImportEqualsDeclaration(id: Identifier, moduleReference: TSEntityName | TSExternalModuleReference): TSImportEqualsDeclaration; export function tsExternalModuleReference(expression: StringLiteral): TSExternalModuleReference; export function tsNonNullExpression(expression: Expression): TSNonNullExpression; export function tsExportAssignment(expression: Expression): TSExportAssignment; export function tsNamespaceExportDeclaration(id: Identifier): TSNamespaceExportDeclaration; export function tsTypeAnnotation(typeAnnotation: TSType): TSTypeAnnotation; export function tsTypeParameterInstantiation(params: Array): TSTypeParameterInstantiation; export function tsTypeParameterDeclaration(params: Array): TSTypeParameterDeclaration; export function tsTypeParameter(constraint: TSType | null | undefined, _default: TSType | null | undefined, name: string): TSTypeParameter; export function isAccessor(node: object | null | undefined, opts?: object | null): node is Accessor; export function assertAccessor(node: object | null | undefined, opts?: object | null): void; export function isAnyTypeAnnotation(node: object | null | undefined, opts?: object | null): node is AnyTypeAnnotation; export function assertAnyTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isArgumentPlaceholder(node: object | null | undefined, opts?: object | null): node is ArgumentPlaceholder; export function assertArgumentPlaceholder(node: object | null | undefined, opts?: object | null): void; export function isArrayExpression(node: object | null | undefined, opts?: object | null): node is ArrayExpression; export function assertArrayExpression(node: object | null | undefined, opts?: object | null): void; export function isArrayPattern(node: object | null | undefined, opts?: object | null): node is ArrayPattern; export function assertArrayPattern(node: object | null | undefined, opts?: object | null): void; export function isArrayTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ArrayTypeAnnotation; export function assertArrayTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isArrowFunctionExpression(node: object | null | undefined, opts?: object | null): node is ArrowFunctionExpression; export function assertArrowFunctionExpression(node: object | null | undefined, opts?: object | null): void; export function isAssignmentExpression(node: object | null | undefined, opts?: object | null): node is AssignmentExpression; export function assertAssignmentExpression(node: object | null | undefined, opts?: object | null): void; export function isAssignmentPattern(node: object | null | undefined, opts?: object | null): node is AssignmentPattern; export function assertAssignmentPattern(node: object | null | undefined, opts?: object | null): void; export function isAwaitExpression(node: object | null | undefined, opts?: object | null): node is AwaitExpression; export function assertAwaitExpression(node: object | null | undefined, opts?: object | null): void; export function isBigIntLiteral(node: object | null | undefined, opts?: object | null): node is BigIntLiteral; export function assertBigIntLiteral(node: object | null | undefined, opts?: object | null): void; export function isBinary(node: object | null | undefined, opts?: object | null): node is Binary; export function assertBinary(node: object | null | undefined, opts?: object | null): void; export function isBinaryExpression(node: object | null | undefined, opts?: object | null): node is BinaryExpression; export function assertBinaryExpression(node: object | null | undefined, opts?: object | null): void; export function isBindExpression(node: object | null | undefined, opts?: object | null): node is BindExpression; export function assertBindExpression(node: object | null | undefined, opts?: object | null): void; export function isBlock(node: object | null | undefined, opts?: object | null): node is Block; export function assertBlock(node: object | null | undefined, opts?: object | null): void; export function isBlockParent(node: object | null | undefined, opts?: object | null): node is BlockParent; export function assertBlockParent(node: object | null | undefined, opts?: object | null): void; export function isBlockStatement(node: object | null | undefined, opts?: object | null): node is BlockStatement; export function assertBlockStatement(node: object | null | undefined, opts?: object | null): void; export function isBooleanLiteral(node: object | null | undefined, opts?: object | null): node is BooleanLiteral; export function assertBooleanLiteral(node: object | null | undefined, opts?: object | null): void; export function isBooleanLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): node is BooleanLiteralTypeAnnotation; export function assertBooleanLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isBooleanTypeAnnotation(node: object | null | undefined, opts?: object | null): node is BooleanTypeAnnotation; export function assertBooleanTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isBreakStatement(node: object | null | undefined, opts?: object | null): node is BreakStatement; export function assertBreakStatement(node: object | null | undefined, opts?: object | null): void; export function isCallExpression(node: object | null | undefined, opts?: object | null): node is CallExpression; export function assertCallExpression(node: object | null | undefined, opts?: object | null): void; export function isCatchClause(node: object | null | undefined, opts?: object | null): node is CatchClause; export function assertCatchClause(node: object | null | undefined, opts?: object | null): void; export function isClass(node: object | null | undefined, opts?: object | null): node is Class; export function assertClass(node: object | null | undefined, opts?: object | null): void; export function isClassAccessorProperty(node: object | null | undefined, opts?: object | null): node is ClassAccessorProperty; export function assertClassAccessorProperty(node: object | null | undefined, opts?: object | null): void; export function isClassBody(node: object | null | undefined, opts?: object | null): node is ClassBody; export function assertClassBody(node: object | null | undefined, opts?: object | null): void; export function isClassDeclaration(node: object | null | undefined, opts?: object | null): node is ClassDeclaration; export function assertClassDeclaration(node: object | null | undefined, opts?: object | null): void; export function isClassExpression(node: object | null | undefined, opts?: object | null): node is ClassExpression; export function assertClassExpression(node: object | null | undefined, opts?: object | null): void; export function isClassImplements(node: object | null | undefined, opts?: object | null): node is ClassImplements; export function assertClassImplements(node: object | null | undefined, opts?: object | null): void; export function isClassMethod(node: object | null | undefined, opts?: object | null): node is ClassMethod; export function assertClassMethod(node: object | null | undefined, opts?: object | null): void; export function isClassPrivateMethod(node: object | null | undefined, opts?: object | null): node is ClassPrivateMethod; export function assertClassPrivateMethod(node: object | null | undefined, opts?: object | null): void; export function isClassPrivateProperty(node: object | null | undefined, opts?: object | null): node is ClassPrivateProperty; export function assertClassPrivateProperty(node: object | null | undefined, opts?: object | null): void; export function isClassProperty(node: object | null | undefined, opts?: object | null): node is ClassProperty; export function assertClassProperty(node: object | null | undefined, opts?: object | null): void; export function isCompletionStatement(node: object | null | undefined, opts?: object | null): node is CompletionStatement; export function assertCompletionStatement(node: object | null | undefined, opts?: object | null): void; export function isConditional(node: object | null | undefined, opts?: object | null): node is Conditional; export function assertConditional(node: object | null | undefined, opts?: object | null): void; export function isConditionalExpression(node: object | null | undefined, opts?: object | null): node is ConditionalExpression; export function assertConditionalExpression(node: object | null | undefined, opts?: object | null): void; export function isContinueStatement(node: object | null | undefined, opts?: object | null): node is ContinueStatement; export function assertContinueStatement(node: object | null | undefined, opts?: object | null): void; export function isDebuggerStatement(node: object | null | undefined, opts?: object | null): node is DebuggerStatement; export function assertDebuggerStatement(node: object | null | undefined, opts?: object | null): void; export function isDecimalLiteral(node: object | null | undefined, opts?: object | null): node is DecimalLiteral; export function assertDecimalLiteral(node: object | null | undefined, opts?: object | null): void; export function isDeclaration(node: object | null | undefined, opts?: object | null): node is Declaration; export function assertDeclaration(node: object | null | undefined, opts?: object | null): void; export function isDeclareClass(node: object | null | undefined, opts?: object | null): node is DeclareClass; export function assertDeclareClass(node: object | null | undefined, opts?: object | null): void; export function isDeclareExportAllDeclaration(node: object | null | undefined, opts?: object | null): node is DeclareExportAllDeclaration; export function assertDeclareExportAllDeclaration(node: object | null | undefined, opts?: object | null): void; export function isDeclareExportDeclaration(node: object | null | undefined, opts?: object | null): node is DeclareExportDeclaration; export function assertDeclareExportDeclaration(node: object | null | undefined, opts?: object | null): void; export function isDeclareFunction(node: object | null | undefined, opts?: object | null): node is DeclareFunction; export function assertDeclareFunction(node: object | null | undefined, opts?: object | null): void; export function isDeclareInterface(node: object | null | undefined, opts?: object | null): node is DeclareInterface; export function assertDeclareInterface(node: object | null | undefined, opts?: object | null): void; export function isDeclareModule(node: object | null | undefined, opts?: object | null): node is DeclareModule; export function assertDeclareModule(node: object | null | undefined, opts?: object | null): void; export function isDeclareModuleExports(node: object | null | undefined, opts?: object | null): node is DeclareModuleExports; export function assertDeclareModuleExports(node: object | null | undefined, opts?: object | null): void; export function isDeclareOpaqueType(node: object | null | undefined, opts?: object | null): node is DeclareOpaqueType; export function assertDeclareOpaqueType(node: object | null | undefined, opts?: object | null): void; export function isDeclareTypeAlias(node: object | null | undefined, opts?: object | null): node is DeclareTypeAlias; export function assertDeclareTypeAlias(node: object | null | undefined, opts?: object | null): void; export function isDeclareVariable(node: object | null | undefined, opts?: object | null): node is DeclareVariable; export function assertDeclareVariable(node: object | null | undefined, opts?: object | null): void; export function isDeclaredPredicate(node: object | null | undefined, opts?: object | null): node is DeclaredPredicate; export function assertDeclaredPredicate(node: object | null | undefined, opts?: object | null): void; export function isDecorator(node: object | null | undefined, opts?: object | null): node is Decorator; export function assertDecorator(node: object | null | undefined, opts?: object | null): void; export function isDirective(node: object | null | undefined, opts?: object | null): node is Directive; export function assertDirective(node: object | null | undefined, opts?: object | null): void; export function isDirectiveLiteral(node: object | null | undefined, opts?: object | null): node is DirectiveLiteral; export function assertDirectiveLiteral(node: object | null | undefined, opts?: object | null): void; export function isDoExpression(node: object | null | undefined, opts?: object | null): node is DoExpression; export function assertDoExpression(node: object | null | undefined, opts?: object | null): void; export function isDoWhileStatement(node: object | null | undefined, opts?: object | null): node is DoWhileStatement; export function assertDoWhileStatement(node: object | null | undefined, opts?: object | null): void; export function isEmptyStatement(node: object | null | undefined, opts?: object | null): node is EmptyStatement; export function assertEmptyStatement(node: object | null | undefined, opts?: object | null): void; export function isEmptyTypeAnnotation(node: object | null | undefined, opts?: object | null): node is EmptyTypeAnnotation; export function assertEmptyTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isEnumBody(node: object | null | undefined, opts?: object | null): node is EnumBody; export function assertEnumBody(node: object | null | undefined, opts?: object | null): void; export function isEnumBooleanBody(node: object | null | undefined, opts?: object | null): node is EnumBooleanBody; export function assertEnumBooleanBody(node: object | null | undefined, opts?: object | null): void; export function isEnumBooleanMember(node: object | null | undefined, opts?: object | null): node is EnumBooleanMember; export function assertEnumBooleanMember(node: object | null | undefined, opts?: object | null): void; export function isEnumDeclaration(node: object | null | undefined, opts?: object | null): node is EnumDeclaration; export function assertEnumDeclaration(node: object | null | undefined, opts?: object | null): void; export function isEnumDefaultedMember(node: object | null | undefined, opts?: object | null): node is EnumDefaultedMember; export function assertEnumDefaultedMember(node: object | null | undefined, opts?: object | null): void; export function isEnumMember(node: object | null | undefined, opts?: object | null): node is EnumMember; export function assertEnumMember(node: object | null | undefined, opts?: object | null): void; export function isEnumNumberBody(node: object | null | undefined, opts?: object | null): node is EnumNumberBody; export function assertEnumNumberBody(node: object | null | undefined, opts?: object | null): void; export function isEnumNumberMember(node: object | null | undefined, opts?: object | null): node is EnumNumberMember; export function assertEnumNumberMember(node: object | null | undefined, opts?: object | null): void; export function isEnumStringBody(node: object | null | undefined, opts?: object | null): node is EnumStringBody; export function assertEnumStringBody(node: object | null | undefined, opts?: object | null): void; export function isEnumStringMember(node: object | null | undefined, opts?: object | null): node is EnumStringMember; export function assertEnumStringMember(node: object | null | undefined, opts?: object | null): void; export function isEnumSymbolBody(node: object | null | undefined, opts?: object | null): node is EnumSymbolBody; export function assertEnumSymbolBody(node: object | null | undefined, opts?: object | null): void; export function isExistsTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ExistsTypeAnnotation; export function assertExistsTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isExportAllDeclaration(node: object | null | undefined, opts?: object | null): node is ExportAllDeclaration; export function assertExportAllDeclaration(node: object | null | undefined, opts?: object | null): void; export function isExportDeclaration(node: object | null | undefined, opts?: object | null): node is ExportDeclaration; export function assertExportDeclaration(node: object | null | undefined, opts?: object | null): void; export function isExportDefaultDeclaration(node: object | null | undefined, opts?: object | null): node is ExportDefaultDeclaration; export function assertExportDefaultDeclaration(node: object | null | undefined, opts?: object | null): void; export function isExportDefaultSpecifier(node: object | null | undefined, opts?: object | null): node is ExportDefaultSpecifier; export function assertExportDefaultSpecifier(node: object | null | undefined, opts?: object | null): void; export function isExportNamedDeclaration(node: object | null | undefined, opts?: object | null): node is ExportNamedDeclaration; export function assertExportNamedDeclaration(node: object | null | undefined, opts?: object | null): void; export function isExportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): node is ExportNamespaceSpecifier; export function assertExportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): void; export function isExportSpecifier(node: object | null | undefined, opts?: object | null): node is ExportSpecifier; export function assertExportSpecifier(node: object | null | undefined, opts?: object | null): void; export function isExpression(node: object | null | undefined, opts?: object | null): node is Expression; export function assertExpression(node: object | null | undefined, opts?: object | null): void; export function isExpressionStatement(node: object | null | undefined, opts?: object | null): node is ExpressionStatement; export function assertExpressionStatement(node: object | null | undefined, opts?: object | null): void; export function isExpressionWrapper(node: object | null | undefined, opts?: object | null): node is ExpressionWrapper; export function assertExpressionWrapper(node: object | null | undefined, opts?: object | null): void; export function isFile(node: object | null | undefined, opts?: object | null): node is File; export function assertFile(node: object | null | undefined, opts?: object | null): void; export function isFlow(node: object | null | undefined, opts?: object | null): node is Flow; export function assertFlow(node: object | null | undefined, opts?: object | null): void; export function isFlowBaseAnnotation(node: object | null | undefined, opts?: object | null): node is FlowBaseAnnotation; export function assertFlowBaseAnnotation(node: object | null | undefined, opts?: object | null): void; export function isFlowDeclaration(node: object | null | undefined, opts?: object | null): node is FlowDeclaration; export function assertFlowDeclaration(node: object | null | undefined, opts?: object | null): void; export function isFlowPredicate(node: object | null | undefined, opts?: object | null): node is FlowPredicate; export function assertFlowPredicate(node: object | null | undefined, opts?: object | null): void; export function isFlowType(node: object | null | undefined, opts?: object | null): node is FlowType; export function assertFlowType(node: object | null | undefined, opts?: object | null): void; export function isFor(node: object | null | undefined, opts?: object | null): node is For; export function assertFor(node: object | null | undefined, opts?: object | null): void; export function isForInStatement(node: object | null | undefined, opts?: object | null): node is ForInStatement; export function assertForInStatement(node: object | null | undefined, opts?: object | null): void; export function isForOfStatement(node: object | null | undefined, opts?: object | null): node is ForOfStatement; export function assertForOfStatement(node: object | null | undefined, opts?: object | null): void; export function isForStatement(node: object | null | undefined, opts?: object | null): node is ForStatement; export function assertForStatement(node: object | null | undefined, opts?: object | null): void; export function isForXStatement(node: object | null | undefined, opts?: object | null): node is ForXStatement; export function assertForXStatement(node: object | null | undefined, opts?: object | null): void; export function isFunction(node: object | null | undefined, opts?: object | null): node is Function; export function assertFunction(node: object | null | undefined, opts?: object | null): void; export function isFunctionDeclaration(node: object | null | undefined, opts?: object | null): node is FunctionDeclaration; export function assertFunctionDeclaration(node: object | null | undefined, opts?: object | null): void; export function isFunctionExpression(node: object | null | undefined, opts?: object | null): node is FunctionExpression; export function assertFunctionExpression(node: object | null | undefined, opts?: object | null): void; export function isFunctionParameter(node: object | null | undefined, opts?: object | null): node is FunctionParameter; export function assertFunctionParameter(node: object | null | undefined, opts?: object | null): void; export function isFunctionParent(node: object | null | undefined, opts?: object | null): node is FunctionParent; export function assertFunctionParent(node: object | null | undefined, opts?: object | null): void; export function isFunctionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is FunctionTypeAnnotation; export function assertFunctionTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isFunctionTypeParam(node: object | null | undefined, opts?: object | null): node is FunctionTypeParam; export function assertFunctionTypeParam(node: object | null | undefined, opts?: object | null): void; export function isGenericTypeAnnotation(node: object | null | undefined, opts?: object | null): node is GenericTypeAnnotation; export function assertGenericTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isIdentifier(node: object | null | undefined, opts?: object | null): node is Identifier; export function assertIdentifier(node: object | null | undefined, opts?: object | null): void; export function isIfStatement(node: object | null | undefined, opts?: object | null): node is IfStatement; export function assertIfStatement(node: object | null | undefined, opts?: object | null): void; export function isImmutable(node: object | null | undefined, opts?: object | null): node is Immutable; export function assertImmutable(node: object | null | undefined, opts?: object | null): void; export function isImport(node: object | null | undefined, opts?: object | null): node is Import; export function assertImport(node: object | null | undefined, opts?: object | null): void; export function isImportAttribute(node: object | null | undefined, opts?: object | null): node is ImportAttribute; export function assertImportAttribute(node: object | null | undefined, opts?: object | null): void; export function isImportDeclaration(node: object | null | undefined, opts?: object | null): node is ImportDeclaration; export function assertImportDeclaration(node: object | null | undefined, opts?: object | null): void; export function isImportDefaultSpecifier(node: object | null | undefined, opts?: object | null): node is ImportDefaultSpecifier; export function assertImportDefaultSpecifier(node: object | null | undefined, opts?: object | null): void; export function isImportExpression(node: object | null | undefined, opts?: object | null): node is ImportExpression; export function assertImportExpression(node: object | null | undefined, opts?: object | null): void; export function isImportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): node is ImportNamespaceSpecifier; export function assertImportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): void; export function isImportOrExportDeclaration(node: object | null | undefined, opts?: object | null): node is ImportOrExportDeclaration; export function assertImportOrExportDeclaration(node: object | null | undefined, opts?: object | null): void; export function isImportSpecifier(node: object | null | undefined, opts?: object | null): node is ImportSpecifier; export function assertImportSpecifier(node: object | null | undefined, opts?: object | null): void; export function isIndexedAccessType(node: object | null | undefined, opts?: object | null): node is IndexedAccessType; export function assertIndexedAccessType(node: object | null | undefined, opts?: object | null): void; export function isInferredPredicate(node: object | null | undefined, opts?: object | null): node is InferredPredicate; export function assertInferredPredicate(node: object | null | undefined, opts?: object | null): void; export function isInterfaceDeclaration(node: object | null | undefined, opts?: object | null): node is InterfaceDeclaration; export function assertInterfaceDeclaration(node: object | null | undefined, opts?: object | null): void; export function isInterfaceExtends(node: object | null | undefined, opts?: object | null): node is InterfaceExtends; export function assertInterfaceExtends(node: object | null | undefined, opts?: object | null): void; export function isInterfaceTypeAnnotation(node: object | null | undefined, opts?: object | null): node is InterfaceTypeAnnotation; export function assertInterfaceTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isInterpreterDirective(node: object | null | undefined, opts?: object | null): node is InterpreterDirective; export function assertInterpreterDirective(node: object | null | undefined, opts?: object | null): void; export function isIntersectionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is IntersectionTypeAnnotation; export function assertIntersectionTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isJSX(node: object | null | undefined, opts?: object | null): node is JSX; export function assertJSX(node: object | null | undefined, opts?: object | null): void; export function isJSXAttribute(node: object | null | undefined, opts?: object | null): node is JSXAttribute; export function assertJSXAttribute(node: object | null | undefined, opts?: object | null): void; export function isJSXClosingElement(node: object | null | undefined, opts?: object | null): node is JSXClosingElement; export function assertJSXClosingElement(node: object | null | undefined, opts?: object | null): void; export function isJSXClosingFragment(node: object | null | undefined, opts?: object | null): node is JSXClosingFragment; export function assertJSXClosingFragment(node: object | null | undefined, opts?: object | null): void; export function isJSXElement(node: object | null | undefined, opts?: object | null): node is JSXElement; export function assertJSXElement(node: object | null | undefined, opts?: object | null): void; export function isJSXEmptyExpression(node: object | null | undefined, opts?: object | null): node is JSXEmptyExpression; export function assertJSXEmptyExpression(node: object | null | undefined, opts?: object | null): void; export function isJSXExpressionContainer(node: object | null | undefined, opts?: object | null): node is JSXExpressionContainer; export function assertJSXExpressionContainer(node: object | null | undefined, opts?: object | null): void; export function isJSXFragment(node: object | null | undefined, opts?: object | null): node is JSXFragment; export function assertJSXFragment(node: object | null | undefined, opts?: object | null): void; export function isJSXIdentifier(node: object | null | undefined, opts?: object | null): node is JSXIdentifier; export function assertJSXIdentifier(node: object | null | undefined, opts?: object | null): void; export function isJSXMemberExpression(node: object | null | undefined, opts?: object | null): node is JSXMemberExpression; export function assertJSXMemberExpression(node: object | null | undefined, opts?: object | null): void; export function isJSXNamespacedName(node: object | null | undefined, opts?: object | null): node is JSXNamespacedName; export function assertJSXNamespacedName(node: object | null | undefined, opts?: object | null): void; export function isJSXOpeningElement(node: object | null | undefined, opts?: object | null): node is JSXOpeningElement; export function assertJSXOpeningElement(node: object | null | undefined, opts?: object | null): void; export function isJSXOpeningFragment(node: object | null | undefined, opts?: object | null): node is JSXOpeningFragment; export function assertJSXOpeningFragment(node: object | null | undefined, opts?: object | null): void; export function isJSXSpreadAttribute(node: object | null | undefined, opts?: object | null): node is JSXSpreadAttribute; export function assertJSXSpreadAttribute(node: object | null | undefined, opts?: object | null): void; export function isJSXSpreadChild(node: object | null | undefined, opts?: object | null): node is JSXSpreadChild; export function assertJSXSpreadChild(node: object | null | undefined, opts?: object | null): void; export function isJSXText(node: object | null | undefined, opts?: object | null): node is JSXText; export function assertJSXText(node: object | null | undefined, opts?: object | null): void; export function isLVal(node: object | null | undefined, opts?: object | null): node is LVal; export function assertLVal(node: object | null | undefined, opts?: object | null): void; export function isLabeledStatement(node: object | null | undefined, opts?: object | null): node is LabeledStatement; export function assertLabeledStatement(node: object | null | undefined, opts?: object | null): void; export function isLiteral(node: object | null | undefined, opts?: object | null): node is Literal; export function assertLiteral(node: object | null | undefined, opts?: object | null): void; export function isLogicalExpression(node: object | null | undefined, opts?: object | null): node is LogicalExpression; export function assertLogicalExpression(node: object | null | undefined, opts?: object | null): void; export function isLoop(node: object | null | undefined, opts?: object | null): node is Loop; export function assertLoop(node: object | null | undefined, opts?: object | null): void; export function isMemberExpression(node: object | null | undefined, opts?: object | null): node is MemberExpression; export function assertMemberExpression(node: object | null | undefined, opts?: object | null): void; export function isMetaProperty(node: object | null | undefined, opts?: object | null): node is MetaProperty; export function assertMetaProperty(node: object | null | undefined, opts?: object | null): void; export function isMethod(node: object | null | undefined, opts?: object | null): node is Method; export function assertMethod(node: object | null | undefined, opts?: object | null): void; export function isMiscellaneous(node: object | null | undefined, opts?: object | null): node is Miscellaneous; export function assertMiscellaneous(node: object | null | undefined, opts?: object | null): void; export function isMixedTypeAnnotation(node: object | null | undefined, opts?: object | null): node is MixedTypeAnnotation; export function assertMixedTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isModuleDeclaration(node: object | null | undefined, opts?: object | null): node is ModuleDeclaration; export function assertModuleDeclaration(node: object | null | undefined, opts?: object | null): void; export function isModuleExpression(node: object | null | undefined, opts?: object | null): node is ModuleExpression; export function assertModuleExpression(node: object | null | undefined, opts?: object | null): void; export function isModuleSpecifier(node: object | null | undefined, opts?: object | null): node is ModuleSpecifier; export function assertModuleSpecifier(node: object | null | undefined, opts?: object | null): void; export function isNewExpression(node: object | null | undefined, opts?: object | null): node is NewExpression; export function assertNewExpression(node: object | null | undefined, opts?: object | null): void; export function isNoop(node: object | null | undefined, opts?: object | null): node is Noop; export function assertNoop(node: object | null | undefined, opts?: object | null): void; export function isNullLiteral(node: object | null | undefined, opts?: object | null): node is NullLiteral; export function assertNullLiteral(node: object | null | undefined, opts?: object | null): void; export function isNullLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): node is NullLiteralTypeAnnotation; export function assertNullLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): void; export function isNullableTypeAnnotation(node: object | null | undefined, opts?: object | null): node is NullableTypeAnnotation; export function assertNullableTypeAnnotation(node: object | null | undefined, opts?: object | null): void; /* @deprecated Use <code>isNumericLiteral</code>"},{"location":"autogenerated/code-summary/#assertnumberliteral","title":"assertNumberLiteral","text":"<p>Source: <code>my-backend/node_modules/@babel/types/lib/index-legacy.d.ts</code></p> <p>Signature: <code>assertNumberLiteral(node: object | null | undefined, opts?: object | null)</code></p> <p>JSDoc:</p> <p>@deprecated Use <code>assertNumericLiteral</code></p>"},{"location":"autogenerated/code-summary/#isregexliteral","title":"isRegexLiteral","text":"<p>Source: <code>my-backend/node_modules/@babel/types/lib/index-legacy.d.ts</code></p> <p>Signature: <code>isRegexLiteral(node: object | null | undefined, opts?: object | null)</code></p> <p>JSDoc:</p> <p>@deprecated Use <code>isRegExpLiteral</code></p>"},{"location":"autogenerated/code-summary/#assertregexliteral","title":"assertRegexLiteral","text":"<p>Source: <code>my-backend/node_modules/@babel/types/lib/index-legacy.d.ts</code></p> <p>Signature: <code>assertRegexLiteral(node: object | null | undefined, opts?: object | null)</code></p> <p>JSDoc:</p> <p>@deprecated Use <code>assertRegExpLiteral</code></p>"},{"location":"autogenerated/code-summary/#isrestproperty","title":"isRestProperty","text":"<p>Source: <code>my-backend/node_modules/@babel/types/lib/index-legacy.d.ts</code></p> <p>Signature: <code>isRestProperty(node: object | null | undefined, opts?: object | null)</code></p> <p>JSDoc:</p> <p>@deprecated Use <code>isRestElement</code></p>"},{"location":"autogenerated/code-summary/#assertrestproperty","title":"assertRestProperty","text":"<p>Source: <code>my-backend/node_modules/@babel/types/lib/index-legacy.d.ts</code></p> <p>Signature: <code>assertRestProperty(node: object | null | undefined, opts?: object | null)</code></p> <p>JSDoc:</p> <p>@deprecated Use <code>assertRestElement</code></p>"},{"location":"autogenerated/code-summary/#isspreadproperty","title":"isSpreadProperty","text":"<p>Source: <code>my-backend/node_modules/@babel/types/lib/index-legacy.d.ts</code></p> <p>Signature: <code>isSpreadProperty(node: object | null | undefined, opts?: object | null)</code></p> <p>JSDoc:</p> <p>@deprecated Use <code>isSpreadElement</code></p>"},{"location":"autogenerated/code-summary/#assertspreadproperty","title":"assertSpreadProperty","text":"<p>Source: <code>my-backend/node_modules/@babel/types/lib/index-legacy.d.ts</code></p> <p>Signature: <code>assertSpreadProperty(node: object | null | undefined, opts?: object | null)</code></p> <p>JSDoc:</p> <p>@deprecated Use <code>assertSpreadElement</code></p>"},{"location":"autogenerated/code-summary/#cloneprocesscov","title":"cloneProcessCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/clone.ts</code></p> <p>Signature: <code>cloneProcessCov(processCov: Readonly&lt;ProcessCov&gt;)</code></p> <p>JSDoc:</p> <p>Creates a deep copy of a process coverage.</p> <p>@param processCov Process coverage to clone. @return Cloned process coverage.</p>"},{"location":"autogenerated/code-summary/#clonescriptcov","title":"cloneScriptCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/clone.ts</code></p> <p>Signature: <code>cloneScriptCov(scriptCov: Readonly&lt;ScriptCov&gt;)</code></p> <p>JSDoc:</p> <p>Creates a deep copy of a script coverage.</p> <p>@param scriptCov Script coverage to clone. @return Cloned script coverage.</p>"},{"location":"autogenerated/code-summary/#clonefunctioncov","title":"cloneFunctionCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/clone.ts</code></p> <p>Signature: <code>cloneFunctionCov(functionCov: Readonly&lt;FunctionCov&gt;)</code></p> <p>JSDoc:</p> <p>Creates a deep copy of a function coverage.</p> <p>@param functionCov Function coverage to clone. @return Cloned function coverage.</p>"},{"location":"autogenerated/code-summary/#clonerangecov","title":"cloneRangeCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/clone.ts</code></p> <p>Signature: <code>cloneRangeCov(rangeCov: Readonly&lt;RangeCov&gt;)</code></p> <p>JSDoc:</p> <p>Creates a deep copy of a function coverage.</p> <p>@param rangeCov Range coverage to clone. @return Cloned range coverage.</p>"},{"location":"autogenerated/code-summary/#comparescriptcovs","title":"compareScriptCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/compare.ts</code></p> <p>Signature: <code>compareScriptCovs(a: Readonly&lt;ScriptCov&gt;, b: Readonly&lt;ScriptCov&gt;)</code></p> <p>JSDoc:</p> <p>Compares two script coverages.</p> <p>The result corresponds to the comparison of their <code>url</code> value (alphabetical sort).</p>"},{"location":"autogenerated/code-summary/#comparefunctioncovs","title":"compareFunctionCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/compare.ts</code></p> <p>Signature: <code>compareFunctionCovs(a: Readonly&lt;FunctionCov&gt;, b: Readonly&lt;FunctionCov&gt;)</code></p> <p>JSDoc:</p> <p>Compares two function coverages.</p> <p>The result corresponds to the comparison of the root ranges.</p>"},{"location":"autogenerated/code-summary/#comparerangecovs","title":"compareRangeCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/compare.ts</code></p> <p>Signature: <code>compareRangeCovs(a: Readonly&lt;RangeCov&gt;, b: Readonly&lt;RangeCov&gt;)</code></p> <p>JSDoc:</p> <p>Compares two range coverages.</p> <p>The ranges are first ordered by ascending <code>startOffset</code> and then by descending <code>endOffset</code>. This corresponds to a pre-order tree traversal.</p>"},{"location":"autogenerated/code-summary/#mergeprocesscovs","title":"mergeProcessCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/merge.ts</code></p> <p>Signature: <code>mergeProcessCovs(processCovs: ReadonlyArray&lt;ProcessCov&gt;)</code></p> <p>JSDoc:</p> <p>Merges a list of process coverages.</p> <p>The result is normalized. The input values may be mutated, it is not safe to use them after passing them to this function. The computation is synchronous.</p> <p>@param processCovs Process coverages to merge. @return Merged process coverage.</p>"},{"location":"autogenerated/code-summary/#mergescriptcovs","title":"mergeScriptCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/merge.ts</code></p> <p>Signature: <code>mergeScriptCovs(scriptCovs: ReadonlyArray&lt;ScriptCov&gt;)</code></p> <p>JSDoc:</p> <p>Merges a list of matching script coverages.</p> <p>Scripts are matching if they have the same <code>url</code>. The result is normalized. The input values may be mutated, it is not safe to use them after passing them to this function. The computation is synchronous.</p> <p>@param scriptCovs Process coverages to merge. @return Merged script coverage, or <code>undefined</code> if the input list was empty.</p>"},{"location":"autogenerated/code-summary/#mergefunctioncovs","title":"mergeFunctionCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/merge.ts</code></p> <p>Signature: <code>mergeFunctionCovs(funcCovs: ReadonlyArray&lt;FunctionCov&gt;)</code></p> <p>JSDoc:</p> <p>Returns a string representation of the root range of the function.</p> <p>This string can be used to match function with same root range. The string is derived from the start and end offsets of the root range of the function. This assumes that <code>ranges</code> is non-empty (true for valid function coverages).</p> <p>@param funcCov Function coverage with the range to stringify @internal / function stringifyFunctionRootRange(funcCov: Readonly): string {   const rootRange: RangeCov = funcCov.ranges0;   return <code>${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}</code>; } <p>/** Merges a list of matching function coverages.</p> <p>Functions are matching if their root ranges have the same span. The result is normalized. The input values may be mutated, it is not safe to use them after passing them to this function. The computation is synchronous.</p> <p>@param funcCovs Function coverages to merge. @return Merged function coverage, or <code>undefined</code> if the input list was empty.</p>"},{"location":"autogenerated/code-summary/#normalizeprocesscov","title":"normalizeProcessCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts</code></p> <p>Signature: <code>normalizeProcessCov(processCov: ProcessCov)</code></p> <p>JSDoc:</p> <p>Normalizes a process coverage.</p> <p>Sorts the scripts alphabetically by <code>url</code>. Reassigns script ids: the script at index <code>0</code> receives <code>\"0\"</code>, the script at index <code>1</code> receives <code>\"1\"</code> etc. This does not normalize the script coverages.</p> <p>@param processCov Process coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#deepnormalizeprocesscov","title":"deepNormalizeProcessCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts</code></p> <p>Signature: <code>deepNormalizeProcessCov(processCov: ProcessCov)</code></p> <p>JSDoc:</p> <p>Normalizes a process coverage deeply.</p> <p>Normalizes the script coverages deeply, then normalizes the process coverage itself.</p> <p>@param processCov Process coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#normalizescriptcov","title":"normalizeScriptCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts</code></p> <p>Signature: <code>normalizeScriptCov(scriptCov: ScriptCov)</code></p> <p>JSDoc:</p> <p>Normalizes a script coverage.</p> <p>Sorts the function by root range (pre-order sort). This does not normalize the function coverages.</p> <p>@param scriptCov Script coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#deepnormalizescriptcov","title":"deepNormalizeScriptCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts</code></p> <p>Signature: <code>deepNormalizeScriptCov(scriptCov: ScriptCov)</code></p> <p>JSDoc:</p> <p>Normalizes a script coverage deeply.</p> <p>Normalizes the function coverages deeply, then normalizes the script coverage itself.</p> <p>@param scriptCov Script coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#normalizefunctioncov","title":"normalizeFunctionCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts</code></p> <p>Signature: <code>normalizeFunctionCov(funcCov: FunctionCov)</code></p> <p>JSDoc:</p> <p>Normalizes a function coverage.</p> <p>Sorts the ranges (pre-order sort). TODO: Tree-based normalization of the ranges.</p> <p>@param funcCov Function coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#normalizerangetree","title":"normalizeRangeTree","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts</code></p> <p>Signature: <code>normalizeRangeTree(tree: RangeTree)</code></p> <p>JSDoc:</p> <p>@internal</p>"},{"location":"autogenerated/code-summary/#cloneprocesscov_1","title":"cloneProcessCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/clone.ts</code></p> <p>Signature: <code>cloneProcessCov(processCov: Readonly&lt;ProcessCov&gt;)</code></p> <p>JSDoc:</p> <p>Creates a deep copy of a process coverage.</p> <p>@param processCov Process coverage to clone. @return Cloned process coverage.</p>"},{"location":"autogenerated/code-summary/#clonescriptcov_1","title":"cloneScriptCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/clone.ts</code></p> <p>Signature: <code>cloneScriptCov(scriptCov: Readonly&lt;ScriptCov&gt;)</code></p> <p>JSDoc:</p> <p>Creates a deep copy of a script coverage.</p> <p>@param scriptCov Script coverage to clone. @return Cloned script coverage.</p>"},{"location":"autogenerated/code-summary/#clonefunctioncov_1","title":"cloneFunctionCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/clone.ts</code></p> <p>Signature: <code>cloneFunctionCov(functionCov: Readonly&lt;FunctionCov&gt;)</code></p> <p>JSDoc:</p> <p>Creates a deep copy of a function coverage.</p> <p>@param functionCov Function coverage to clone. @return Cloned function coverage.</p>"},{"location":"autogenerated/code-summary/#clonerangecov_1","title":"cloneRangeCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/clone.ts</code></p> <p>Signature: <code>cloneRangeCov(rangeCov: Readonly&lt;RangeCov&gt;)</code></p> <p>JSDoc:</p> <p>Creates a deep copy of a function coverage.</p> <p>@param rangeCov Range coverage to clone. @return Cloned range coverage.</p>"},{"location":"autogenerated/code-summary/#comparescriptcovs_1","title":"compareScriptCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/compare.ts</code></p> <p>Signature: <code>compareScriptCovs(a: Readonly&lt;ScriptCov&gt;, b: Readonly&lt;ScriptCov&gt;)</code></p> <p>JSDoc:</p> <p>Compares two script coverages.</p> <p>The result corresponds to the comparison of their <code>url</code> value (alphabetical sort).</p>"},{"location":"autogenerated/code-summary/#comparefunctioncovs_1","title":"compareFunctionCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/compare.ts</code></p> <p>Signature: <code>compareFunctionCovs(a: Readonly&lt;FunctionCov&gt;, b: Readonly&lt;FunctionCov&gt;)</code></p> <p>JSDoc:</p> <p>Compares two function coverages.</p> <p>The result corresponds to the comparison of the root ranges.</p>"},{"location":"autogenerated/code-summary/#comparerangecovs_1","title":"compareRangeCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/compare.ts</code></p> <p>Signature: <code>compareRangeCovs(a: Readonly&lt;RangeCov&gt;, b: Readonly&lt;RangeCov&gt;)</code></p> <p>JSDoc:</p> <p>Compares two range coverages.</p> <p>The ranges are first ordered by ascending <code>startOffset</code> and then by descending <code>endOffset</code>. This corresponds to a pre-order tree traversal.</p>"},{"location":"autogenerated/code-summary/#mergeprocesscovs_1","title":"mergeProcessCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/merge.ts</code></p> <p>Signature: <code>mergeProcessCovs(processCovs: ReadonlyArray&lt;ProcessCov&gt;)</code></p> <p>JSDoc:</p> <p>Merges a list of process coverages.</p> <p>The result is normalized. The input values may be mutated, it is not safe to use them after passing them to this function. The computation is synchronous.</p> <p>@param processCovs Process coverages to merge. @return Merged process coverage.</p>"},{"location":"autogenerated/code-summary/#mergescriptcovs_1","title":"mergeScriptCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/merge.ts</code></p> <p>Signature: <code>mergeScriptCovs(scriptCovs: ReadonlyArray&lt;ScriptCov&gt;)</code></p> <p>JSDoc:</p> <p>Merges a list of matching script coverages.</p> <p>Scripts are matching if they have the same <code>url</code>. The result is normalized. The input values may be mutated, it is not safe to use them after passing them to this function. The computation is synchronous.</p> <p>@param scriptCovs Process coverages to merge. @return Merged script coverage, or <code>undefined</code> if the input list was empty.</p>"},{"location":"autogenerated/code-summary/#mergefunctioncovs_1","title":"mergeFunctionCovs","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/merge.ts</code></p> <p>Signature: <code>mergeFunctionCovs(funcCovs: ReadonlyArray&lt;FunctionCov&gt;)</code></p> <p>JSDoc:</p> <p>Returns a string representation of the root range of the function.</p> <p>This string can be used to match function with same root range. The string is derived from the start and end offsets of the root range of the function. This assumes that <code>ranges</code> is non-empty (true for valid function coverages).</p> <p>@param funcCov Function coverage with the range to stringify @internal / function stringifyFunctionRootRange(funcCov: Readonly): string {   const rootRange: RangeCov = funcCov.ranges0;   return <code>${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}</code>; } <p>/** Merges a list of matching function coverages.</p> <p>Functions are matching if their root ranges have the same span. The result is normalized. The input values may be mutated, it is not safe to use them after passing them to this function. The computation is synchronous.</p> <p>@param funcCovs Function coverages to merge. @return Merged function coverage, or <code>undefined</code> if the input list was empty.</p>"},{"location":"autogenerated/code-summary/#normalizeprocesscov_1","title":"normalizeProcessCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts</code></p> <p>Signature: <code>normalizeProcessCov(processCov: ProcessCov)</code></p> <p>JSDoc:</p> <p>Normalizes a process coverage.</p> <p>Sorts the scripts alphabetically by <code>url</code>. Reassigns script ids: the script at index <code>0</code> receives <code>\"0\"</code>, the script at index <code>1</code> receives <code>\"1\"</code> etc. This does not normalize the script coverages.</p> <p>@param processCov Process coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#deepnormalizeprocesscov_1","title":"deepNormalizeProcessCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts</code></p> <p>Signature: <code>deepNormalizeProcessCov(processCov: ProcessCov)</code></p> <p>JSDoc:</p> <p>Normalizes a process coverage deeply.</p> <p>Normalizes the script coverages deeply, then normalizes the process coverage itself.</p> <p>@param processCov Process coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#normalizescriptcov_1","title":"normalizeScriptCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts</code></p> <p>Signature: <code>normalizeScriptCov(scriptCov: ScriptCov)</code></p> <p>JSDoc:</p> <p>Normalizes a script coverage.</p> <p>Sorts the function by root range (pre-order sort). This does not normalize the function coverages.</p> <p>@param scriptCov Script coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#deepnormalizescriptcov_1","title":"deepNormalizeScriptCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts</code></p> <p>Signature: <code>deepNormalizeScriptCov(scriptCov: ScriptCov)</code></p> <p>JSDoc:</p> <p>Normalizes a script coverage deeply.</p> <p>Normalizes the function coverages deeply, then normalizes the script coverage itself.</p> <p>@param scriptCov Script coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#normalizefunctioncov_1","title":"normalizeFunctionCov","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts</code></p> <p>Signature: <code>normalizeFunctionCov(funcCov: FunctionCov)</code></p> <p>JSDoc:</p> <p>Normalizes a function coverage.</p> <p>Sorts the ranges (pre-order sort). TODO: Tree-based normalization of the ranges.</p> <p>@param funcCov Function coverage to normalize.</p>"},{"location":"autogenerated/code-summary/#normalizerangetree_1","title":"normalizeRangeTree","text":"<p>Source: <code>my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts</code></p> <p>Signature: <code>normalizeRangeTree(tree: RangeTree)</code></p> <p>JSDoc:</p> <p>@internal</p>"},{"location":"autogenerated/code-summary/#getpath","title":"getPath","text":"<p>Source: <code>my-backend/node_modules/@jest/expect-utils/build/utils.js</code></p> <p>Signature: <code>getPath(= getPath; const getObjectSubset = (   object,   subset,   customTesters = [],   seenReferences = new WeakMap()</code></p> <p>JSDoc:</p> <p>Copyright (c) Meta Platforms, Inc. and affiliates.</p> <p>This source code is licensed under the MIT license found in the LICENSE file in the root directory of this source tree.</p> <p>/ /** Checks if <code>hasOwnProperty(object, key)</code> up the prototype chain, stopping at <code>Object.prototype</code>. / const hasPropertyInObject = (object, key) =&gt; {   const shouldTerminate =     !object || typeof object !== 'object' || object === Object.prototype;   if (shouldTerminate) {     return false;   }   return (     Object.prototype.hasOwnProperty.call(object, key) ||     hasPropertyInObject(Object.getPrototypeOf(object), key)   ); };</p> <p>// Retrieves an object's keys for evaluation by getObjectSubset.  This evaluates // the prototype chain for string keys but not for symbols.  (Otherwise, it // could find values such as a Set or Map's Symbol.toStringTag, with unexpected // results.) const getObjectKeys = object =&gt; [   ...Object.keys(object),   ...Object.getOwnPropertySymbols(object) ]; exports.getObjectKeys = getObjectKeys; const getPath = (object, propertyPath) =&gt; {   if (!Array.isArray(propertyPath)) {     propertyPath = pathAsArray(propertyPath);   }   if (propertyPath.length) {     const lastProp = propertyPath.length === 1;     const prop = propertyPath0;     const newObject = object[prop];     if (!lastProp &amp;&amp; (newObject === null || newObject === undefined)) {       // This is not the last prop in the chain. If we keep recursing it will       // hit a <code>can't access property X of undefined | null</code>. At this point we       // know that the chain has broken and we can return right away.       return {         hasEndProp: false,         lastTraversedObject: object,         traversedPath: []       };     }     const result = getPath(newObject, propertyPath.slice(1));     if (result.lastTraversedObject === null) {       result.lastTraversedObject = object;     }     result.traversedPath.unshift(prop);     if (lastProp) {       // Does object have the property with an undefined value?       // Although primitive values support bracket notation (above)       // they would throw TypeError for in operator (below).       result.endPropIsDefined =         !(0, _jestGetType.isPrimitive)(object) &amp;&amp; prop in object;       result.hasEndProp = newObject !== undefined || result.endPropIsDefined;       if (!result.hasEndProp) {         result.traversedPath.shift();       }     }     return result;   }   return {     lastTraversedObject: null,     traversedPath: [],     value: object   }; };</p> <p>// Strip properties from object that are not present in the subset. Useful for // printing the diff for toMatchObject() without adding unrelated noise. /* eslint-disable @typescript-eslint/explicit-module-boundary-types</p>"},{"location":"autogenerated/code-summary/#addsegment","title":"addSegment","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts</code></p> <p>Signature: <code>addSegment(   map: GenMapping,   genLine: number,   genColumn: number,   source?: null,   sourceLine?: null,   sourceColumn?: null,   name?: null,   content?: null, )</code></p> <p>JSDoc:</p> <p>Provides the state to generate a sourcemap. / export class GenMapping {   declare private _names: SetArray;   declare private _sources: SetArray;   declare private _sourcesContent: (string | null)[];   declare private _mappings: SourceMapSegment[][];   // private declare _originalScopes: OriginalScope[][];   // private declare _generatedRanges: GeneratedRange[];   declare private _ignoreList: SetArray;   declare file: string | null | undefined;   declare sourceRoot: string | null | undefined; <p>constructor({ file, sourceRoot }: Options = {}) {     this._names = new SetArray();     this._sources = new SetArray();     this._sourcesContent = [];     this._mappings = [];     // this._originalScopes = [];     // this._generatedRanges = [];     this.file = file;     this.sourceRoot = sourceRoot;     this._ignoreList = new SetArray();   } }</p> <p>interface PublicMap {   _names: GenMapping['_names'];   _sources: GenMapping['_sources'];   _sourcesContent: GenMapping['_sourcesContent'];   _mappings: GenMapping['_mappings'];   // _originalScopes: GenMapping['_originalScopes'];   // _generatedRanges: GenMapping['_generatedRanges'];   _ignoreList: GenMapping['_ignoreList']; }</p> <p>/** Typescript doesn't allow friend access to private fields, so this just casts the map into a type with public access modifiers. / function cast(map: unknown): PublicMap {   return map as any; }</p> <p>/** A low-level API to associate a generated position with an original source position. Line and column here are 0-based, unlike <code>addMapping</code>.</p>"},{"location":"autogenerated/code-summary/#addmapping","title":"addMapping","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts</code></p> <p>Signature: <code>addMapping(   map: GenMapping,   mapping: {     generated: Pos;     source?: null;     original?: null;     name?: null;     content?: null;   }, )</code></p> <p>JSDoc:</p> <p>A high-level API to associate a generated position with an original source position. Line is 1-based, but column is 0-based, due to legacy behavior in <code>source-map</code> library.</p>"},{"location":"autogenerated/code-summary/#setsourcecontent","title":"setSourceContent","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts</code></p> <p>Signature: <code>setSourceContent(map: GenMapping, source: string, content: string | null)</code></p> <p>JSDoc:</p> <p>Same as <code>addSegment</code>, but will only add the segment if it generates useful information in the resulting map. This only works correctly if segments are added in order, meaning you should not add a segment with a lower generated line/column than one that came before. / export const maybeAddSegment: typeof addSegment = (   map,   genLine,   genColumn,   source,   sourceLine,   sourceColumn,   name,   content, ) =&gt; {   return addSegmentInternal(     true,     map,     genLine,     genColumn,     source,     sourceLine,     sourceColumn,     name,     content,   ); };</p> <p>/ Same as <code>addMapping</code>, but will only add the mapping if it generates useful information in the resulting map. This only works correctly if mappings are added in order**, meaning you should not add a mapping with a lower generated line/column than one that came before. / export const maybeAddMapping: typeof addMapping = (map, mapping) =&gt; {   return addMappingInternal(true, map, mapping as Parameters[2]); }; <p>/** Adds/removes the content of the source file to the source map.</p>"},{"location":"autogenerated/code-summary/#todecodedmap","title":"toDecodedMap","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts</code></p> <p>Signature: <code>toDecodedMap(map: GenMapping)</code></p> <p>JSDoc:</p> <p>Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects a sourcemap, or to JSON.stringify.</p>"},{"location":"autogenerated/code-summary/#toencodedmap","title":"toEncodedMap","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts</code></p> <p>Signature: <code>toEncodedMap(map: GenMapping)</code></p> <p>JSDoc:</p> <p>Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects a sourcemap, or to JSON.stringify.</p>"},{"location":"autogenerated/code-summary/#frommap","title":"fromMap","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts</code></p> <p>Signature: <code>fromMap(input: SourceMapInput)</code></p> <p>JSDoc:</p> <p>Constructs a new GenMapping, using the already present mappings of the input.</p>"},{"location":"autogenerated/code-summary/#allmappings","title":"allMappings","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts</code></p> <p>Signature: <code>allMappings(map: GenMapping)</code></p> <p>JSDoc:</p> <p>Returns an array of high-level mapping objects for every recorded segment, which could then be passed to the <code>source-map</code> library.</p>"},{"location":"autogenerated/code-summary/#get","title":"get","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/set-array.ts</code></p> <p>Signature: <code>get(&lt;T extends Key&gt;(setarr: SetArray&lt;T&gt;, key: T)</code></p> <p>JSDoc:</p> <p>SetArray acts like a <code>Set</code> (allowing only one occurrence of a string <code>key</code>), but provides the index of the <code>key</code> in the backing array.</p> <p>This is designed to allow synchronizing a second array with the contents of the backing array, like how in a sourcemap <code>sourcesContent[i]</code> is the source content associated with <code>source[i]</code>, and there are never duplicates. / export class SetArray {   declare private _indexes: Record;   declare array: readonly T[]; <p>constructor() {     this._indexes = { proto: null } as any;     this.array = [];   } }</p> <p>interface PublicSet {   array: T[];   _indexes: SetArray['_indexes']; } <p>/** Typescript doesn't allow friend access to private fields, so this just casts the set into a type with public access modifiers. / function cast(set: SetArray): PublicSet {   return set as any; } <p>/** Gets the index associated with <code>key</code> in the backing array, if it is already present.</p>"},{"location":"autogenerated/code-summary/#put","title":"put","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/set-array.ts</code></p> <p>Signature: <code>put(&lt;T extends Key&gt;(setarr: SetArray&lt;T&gt;, key: T)</code></p> <p>JSDoc:</p> <p>Puts <code>key</code> into the backing array, if it is not already present. Returns the index of the <code>key</code> in the backing array.</p>"},{"location":"autogenerated/code-summary/#pop","title":"pop","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/set-array.ts</code></p> <p>Signature: <code>pop(&lt;T extends Key&gt;(setarr: SetArray&lt;T&gt;)</code></p> <p>JSDoc:</p> <p>Pops the last added item out of the SetArray.</p>"},{"location":"autogenerated/code-summary/#remove","title":"remove","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/gen-mapping/src/set-array.ts</code></p> <p>Signature: <code>remove(&lt;T extends Key&gt;(setarr: SetArray&lt;T&gt;, key: T)</code></p> <p>JSDoc:</p> <p>Removes the key, if it exists in the set.</p>"},{"location":"autogenerated/code-summary/#mapsource","title":"MapSource","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/remapping/src/source-map-tree.ts</code></p> <p>Signature: <code>MapSource(map: TraceMap, sources: Sources[])</code></p> <p>JSDoc:</p> <p>MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes (which may themselves be SourceMapTrees).</p>"},{"location":"autogenerated/code-summary/#originalsource","title":"OriginalSource","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/remapping/src/source-map-tree.ts</code></p> <p>Signature: <code>OriginalSource(   source: string,   content: string | null,   ignore: boolean, )</code></p> <p>JSDoc:</p> <p>A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive segment tracing ends at the <code>OriginalSource</code>.</p>"},{"location":"autogenerated/code-summary/#tracemappings","title":"traceMappings","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/remapping/src/source-map-tree.ts</code></p> <p>Signature: <code>traceMappings(tree: MapSource)</code></p> <p>JSDoc:</p> <p>traceMappings is only called on the root level SourceMapTree, and begins the process of resolving each mapping in terms of the original source files.</p>"},{"location":"autogenerated/code-summary/#originalpositionfor","title":"originalPositionFor","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/remapping/src/source-map-tree.ts</code></p> <p>Signature: <code>originalPositionFor(   source: Sources,   line: number,   column: number,   name: string, )</code></p> <p>JSDoc:</p> <p>originalPositionFor is only called on children SourceMapTrees. It recurses down into its own child SourceMapTrees, until we find the original source map.</p>"},{"location":"autogenerated/code-summary/#binarysearch","title":"binarySearch","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/binary-search.ts</code></p> <p>Signature: <code>binarySearch(   haystack: SourceMapSegment[] | ReverseSegment[],   needle: number,   low: number,   high: number, )</code></p> <p>JSDoc:</p> <p>A binary search implementation that returns the index if a match is found. If no match is found, then the left-index (the index associated with the item that comes just before the desired index) is returned. To maintain proper sort order, a splice would happen at the next index:</p> <pre><code>const array = [1, 3];\nconst needle = 2;\nconst index = binarySearch(array, needle, (item, needle) =&gt; item - needle);\n\nassert.equal(index, 0);\narray.splice(index + 1, 0, needle);\nassert.deepEqual(array, [1, 2, 3]);\n</code></pre>"},{"location":"autogenerated/code-summary/#memoizedbinarysearch","title":"memoizedBinarySearch","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/binary-search.ts</code></p> <p>Signature: <code>memoizedBinarySearch(   haystack: SourceMapSegment[] | ReverseSegment[],   needle: number,   state: MemoState,   key: number, )</code></p> <p>JSDoc:</p> <p>This overly complicated beast is just to record the last tested line/column and the resulting index, allowing us to skip a few tests if mappings are monotonically increasing.</p>"},{"location":"autogenerated/code-summary/#encodedmappings","title":"encodedMappings","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>encodedMappings(map: TraceMap)</code></p> <p>JSDoc:</p> <p>Typescript doesn't allow friend access to private fields, so this just casts the map into a type with public access modifiers. / function cast(map: unknown): PublicMap {   return map as any; }</p> <p>/** Returns the encoded (VLQ string) form of the SourceMap's mappings field.</p>"},{"location":"autogenerated/code-summary/#decodedmappings","title":"decodedMappings","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>decodedMappings(map: TraceMap)</code></p> <p>JSDoc:</p> <p>Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.</p>"},{"location":"autogenerated/code-summary/#tracesegment","title":"traceSegment","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>traceSegment(   map: TraceMap,   line: number,   column: number, )</code></p> <p>JSDoc:</p> <p>A low-level API to find the segment associated with a generated line/column (think, from a stack trace). Line and column here are 0-based, unlike <code>originalPositionFor</code>.</p>"},{"location":"autogenerated/code-summary/#originalpositionfor_1","title":"originalPositionFor","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>originalPositionFor(   map: TraceMap,   needle: Needle, )</code></p> <p>JSDoc:</p> <p>A higher-level API to find the source/line/column associated with a generated line/column (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in <code>source-map</code> library.</p>"},{"location":"autogenerated/code-summary/#generatedpositionfor","title":"generatedPositionFor","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>generatedPositionFor(   map: TraceMap,   needle: SourceNeedle, )</code></p> <p>JSDoc:</p> <p>Finds the generated line/column position of the provided source/line/column source position.</p>"},{"location":"autogenerated/code-summary/#allgeneratedpositionsfor","title":"allGeneratedPositionsFor","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle)</code></p> <p>JSDoc:</p> <p>Finds all generated line/column positions of the provided source/line/column source position.</p>"},{"location":"autogenerated/code-summary/#eachmapping","title":"eachMapping","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>eachMapping(map: TraceMap, cb: (mapping: EachMapping)</code></p> <p>JSDoc:</p> <p>Iterates each mapping in generated position order.</p>"},{"location":"autogenerated/code-summary/#sourcecontentfor","title":"sourceContentFor","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>sourceContentFor(map: TraceMap, source: string)</code></p> <p>JSDoc:</p> <p>Retrieves the source content for a particular source, if its found. Returns null if not.</p>"},{"location":"autogenerated/code-summary/#isignored","title":"isIgnored","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>isIgnored(map: TraceMap, source: string)</code></p> <p>JSDoc:</p> <p>Determines if the source is marked to ignore by the source map.</p>"},{"location":"autogenerated/code-summary/#presorteddecodedmap","title":"presortedDecodedMap","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string)</code></p> <p>JSDoc:</p> <p>A helper that skips sorting of the input map's mappings array, which can be expensive for larger maps.</p>"},{"location":"autogenerated/code-summary/#decodedmap","title":"decodedMap","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>decodedMap(   map: TraceMap, )</code></p> <p>JSDoc:</p> <p>Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects a sourcemap, or to JSON.stringify.</p>"},{"location":"autogenerated/code-summary/#encodedmap","title":"encodedMap","text":"<p>Source: <code>my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts</code></p> <p>Signature: <code>encodedMap(map: TraceMap)</code></p> <p>JSDoc:</p> <p>Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects a sourcemap, or to JSON.stringify.</p>"},{"location":"autogenerated/code-summary/#abytes","title":"abytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/_assert.js</code></p> <p>Signature: <code>abytes(= utils_ts_1.abytes; /** @deprecated Use import from</code>noble/hashes/utils<code>module */ exports.aexists = utils_ts_1.aexists; /** @deprecated Use import from</code>noble/hashes/utils<code>module */ exports.anumber = utils_ts_1.anumber; /** @deprecated Use import from</code>noble/hashes/utils<code>module */ exports.aoutput = utils_ts_1.aoutput; //# sourceMappingURL=_assert.js.map)</code></p> <p>JSDoc:</p> <p>Internal assertion helpers. @module @deprecated / const utils_ts_1 = require(\"./utils.js\"); /** @deprecated Use import from <code>noble/hashes/utils</code> module</p>"},{"location":"autogenerated/code-summary/#sha256_iv","title":"SHA256_IV","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/_md.js</code></p> <p>Signature: <code>SHA256_IV(= Uint32Array.from([     0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19, ])</code></p> <p>JSDoc:</p> <p>Internal Merkle-Damgard hash utils. @module / const utils_ts_1 = require(\"./utils.js\"); / Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {     if (typeof view.setBigUint64 === 'function')         return view.setBigUint64(byteOffset, value, isLE);     const _32n = BigInt(32);     const _u32_max = BigInt(0xffffffff);     const wh = Number((value &gt;&gt; _32n) &amp; _u32_max);     const wl = Number(value &amp; _u32_max);     const h = isLE ? 4 : 0;     const l = isLE ? 0 : 4;     view.setUint32(byteOffset + h, wh, isLE);     view.setUint32(byteOffset + l, wl, isLE); } / Choice: a ? b : c / function Chi(a, b, c) {     return (a &amp; b) ^ (~a &amp; c); } / Majority function, true if any two inputs is true. / function Maj(a, b, c) {     return (a &amp; b) ^ (a &amp; c) ^ (b &amp; c); } / Merkle-Damgard hash construction base class. Could be used to create MD5, RIPEMD, SHA1, SHA2. / class HashMD extends utils_ts_1.Hash {     constructor(blockLen, outputLen, padOffset, isLE) {         super();         this.finished = false;         this.length = 0;         this.pos = 0;         this.destroyed = false;         this.blockLen = blockLen;         this.outputLen = outputLen;         this.padOffset = padOffset;         this.isLE = isLE;         this.buffer = new Uint8Array(blockLen);         this.view = (0, utils_ts_1.createView)(this.buffer);     }     update(data) {         (0, utils_ts_1.aexists)(this);         data = (0, utils_ts_1.toBytes)(data);         (0, utils_ts_1.abytes)(data);         const { view, buffer, blockLen } = this;         const len = data.length;         for (let pos = 0; pos &lt; len;) {             const take = Math.min(blockLen - this.pos, len - pos);             // Fast path: we have at least one block in input, cast it to view and process             if (take === blockLen) {                 const dataView = (0, utils_ts_1.createView)(data);                 for (; blockLen &lt;= len - pos; pos += blockLen)                     this.process(dataView, pos);                 continue;             }             buffer.set(data.subarray(pos, pos + take), this.pos);             this.pos += take;             pos += take;             if (this.pos === blockLen) {                 this.process(view, 0);                 this.pos = 0;             }         }         this.length += data.length;         this.roundClean();         return this;     }     digestInto(out) {         (0, utils_ts_1.aexists)(this);         (0, utils_ts_1.aoutput)(out, this);         this.finished = true;         // Padding         // We can avoid allocation of buffer for padding completely if it         // was previously not allocated here. But it won't change performance.         const { buffer, view, blockLen, isLE } = this;         let { pos } = this;         // append the bit '1' to the message         buffer[pos++] = 0b10000000;         (0, utils_ts_1.clean)(this.buffer.subarray(pos));         // we have less than padOffset left in buffer, so we cannot put length in         // current block, need process it and pad again         if (this.padOffset &gt; blockLen - pos) {             this.process(view, 0);             pos = 0;         }         // Pad until full block byte with zeros         for (let i = pos; i &lt; blockLen; i++)             buffer[i] = 0;         // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that         // You need to write around 2 exabytes (u64_max / 8 / (10246)) for this to happen.         // So we just write lowest 64 bits of that value.         setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);         this.process(view, 0);         const oview = (0, utils_ts_1.createView)(out);         const len = this.outputLen;         // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT         if (len % 4)             throw new Error('_sha2: outputLen should be aligned to 32bit');         const outLen = len / 4;         const state = this.get();         if (outLen &gt; state.length)             throw new Error('_sha2: outputLen bigger than state');         for (let i = 0; i &lt; outLen; i++)             oview.setUint32(4 * i, state[i], isLE);     }     digest() {         const { buffer, outputLen } = this;         this.digestInto(buffer);         const res = buffer.slice(0, outputLen);         this.destroy();         return res;     }     _cloneInto(to) {         to || (to = new this.constructor());         to.set(...this.get());         const { blockLen, buffer, length, finished, destroyed, pos } = this;         to.destroyed = destroyed;         to.finished = finished;         to.length = length;         to.pos = pos;         if (length % blockLen)             to.buffer.set(buffer);         return to;     }     clone() {         return this._cloneInto();     } } exports.HashMD = HashMD; / Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53. Check out <code>test/misc/sha2-gen-iv.js</code> for recomputation guide. / / Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19</p>"},{"location":"autogenerated/code-summary/#sha224_iv","title":"SHA224_IV","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/_md.js</code></p> <p>Signature: <code>SHA224_IV(= Uint32Array.from([     0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4, ])</code></p> <p>JSDoc:</p> <p>Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53</p>"},{"location":"autogenerated/code-summary/#sha384_iv","title":"SHA384_IV","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/_md.js</code></p> <p>Signature: <code>SHA384_IV(= Uint32Array.from([     0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,     0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4, ])</code></p> <p>JSDoc:</p> <p>Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53</p>"},{"location":"autogenerated/code-summary/#sha512_iv","title":"SHA512_IV","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/_md.js</code></p> <p>Signature: <code>SHA512_IV(= Uint32Array.from([     0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,     0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179, ])</code></p> <p>JSDoc:</p> <p>Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19</p>"},{"location":"autogenerated/code-summary/#blake224","title":"blake224","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake1.js</code></p> <p>Signature: <code>blake224(= (0, utils_ts_1.createOptHasher)</code></p> <p>JSDoc:</p> <p>Blake1 legacy hash function, one of SHA3 proposals. Rarely used. Check out blake2 or blake3 instead. https://www.aumasson.jp/blake/blake.pdf</p> <p>In the best case, there are 0 allocations.</p> <p>Differences from blake2:</p> <ul> <li>BE instead of LE</li> <li>Paddings, similar to MD5, RIPEMD, SHA1, SHA2, but:<ul> <li>length flag is located before actual length</li> <li>padding block is compressed differently (no lengths) Instead of msg[sigma[k]], we have <code>msg[sigma[k]] ^ constants[sigma[k-1]]</code> (-1 for g1, g2 without -1)</li> </ul> </li> <li>Salt is XOR-ed into constants instead of state</li> <li>Salt is XOR-ed with output in <code>compress</code></li> <li>Additional rows (+64 bytes) in SIGMA for new rounds</li> <li>Different round count:<ul> <li>14 / 10 rounds in blake256 / blake2s</li> <li>16 / 12 rounds in blake512 / blake2b</li> </ul> </li> <li>blake512: G1b: rotr 24 -&gt; 25, G2b: rotr 63 -&gt; 11 @module / const _blake_ts_1 = require(\"./_blake.js\"); const _md_ts_1 = require(\"./_md.js\"); const u64 = require(\"./_u64.js\"); // prettier-ignore const utils_ts_1 = require(\"./utils.js\"); // Empty zero-filled salt const EMPTY_SALT = / @PURE / new Uint32Array(8); class BLAKE1 extends utils_ts_1.Hash {     constructor(blockLen, outputLen, lengthFlag, counterLen, saltLen, constants, opts = {}) {         super();         this.finished = false;         this.length = 0;         this.pos = 0;         this.destroyed = false;         const { salt } = opts;         this.blockLen = blockLen;         this.outputLen = outputLen;         this.lengthFlag = lengthFlag;         this.counterLen = counterLen;         this.buffer = new Uint8Array(blockLen);         this.view = (0, utils_ts_1.createView)(this.buffer);         if (salt) {             let slt = salt;             slt = (0, utils_ts_1.toBytes)(slt);             (0, utils_ts_1.abytes)(slt);             if (slt.length !== 4 * saltLen)                 throw new Error('wrong salt length');             const salt32 = (this.salt = new Uint32Array(saltLen));             const sv = (0, utils_ts_1.createView)(slt);             this.constants = constants.slice();             for (let i = 0, offset = 0; i &lt; salt32.length; i++, offset += 4) {                 salt32[i] = sv.getUint32(offset, false);                 this.constants[i] ^= salt32[i];             }         }         else {             this.salt = EMPTY_SALT;             this.constants = constants;         }     }     update(data) {         (0, utils_ts_1.aexists)(this);         data = (0, utils_ts_1.toBytes)(data);         (0, utils_ts_1.abytes)(data);         // From _md, but update length before each compress         const { view, buffer, blockLen } = this;         const len = data.length;         let dataView;         for (let pos = 0; pos &lt; len;) {             const take = Math.min(blockLen - this.pos, len - pos);             // Fast path: we have at least one block in input, cast it to view and process             if (take === blockLen) {                 if (!dataView)                     dataView = (0, utils_ts_1.createView)(data);                 for (; blockLen &lt;= len - pos; pos += blockLen) {                     this.length += blockLen;                     this.compress(dataView, pos);                 }                 continue;             }             buffer.set(data.subarray(pos, pos + take), this.pos);             this.pos += take;             pos += take;             if (this.pos === blockLen) {                 this.length += blockLen;                 this.compress(view, 0, true);                 this.pos = 0;             }         }         return this;     }     destroy() {         this.destroyed = true;         if (this.salt !== EMPTY_SALT) {             (0, utils_ts_1.clean)(this.salt, this.constants);         }     }     _cloneInto(to) {         to || (to = new this.constructor());         to.set(...this.get());         const { buffer, length, finished, destroyed, constants, salt, pos } = this;         to.buffer.set(buffer);         to.constants = constants.slice();         to.destroyed = destroyed;         to.finished = finished;         to.length = length;         to.pos = pos;         to.salt = salt.slice();         return to;     }     clone() {         return this._cloneInto();     }     digestInto(out) {         (0, utils_ts_1.aexists)(this);         (0, utils_ts_1.aoutput)(out, this);         this.finished = true;         // Padding         const { buffer, blockLen, counterLen, lengthFlag, view } = this;         (0, utils_ts_1.clean)(buffer.subarray(this.pos)); // clean buf         const counter = BigInt((this.length + this.pos) * 8);         const counterPos = blockLen - counterLen - 1;         buffer[this.pos] |= 128; // End block flag         this.length += this.pos; // add unwritten length         // Not enough in buffer for length: write what we have.         if (this.pos &gt; counterPos) {             this.compress(view, 0);             (0, utils_ts_1.clean)(buffer);             this.pos = 0;         }         // Difference with md: here we have lengthFlag!         buffer[counterPos] |= lengthFlag; // Length flag         // We always set 8 byte length flag. Because length will overflow significantly sooner.         (0, _md_ts_1.setBigUint64)(view, blockLen - 8, counter, false);         this.compress(view, 0, this.pos !== 0); // don't add length if length is not empty block?         // Write output         (0, utils_ts_1.clean)(buffer);         const v = (0, utils_ts_1.createView)(out);         const state = this.get();         for (let i = 0; i &lt; this.outputLen / 4; ++i)             v.setUint32(i * 4, state[i]);     }     digest() {         const { buffer, outputLen } = this;         this.digestInto(buffer);         const res = buffer.slice(0, outputLen);         this.destroy();         return res;     } } // Constants const B64C = / @PURE / Uint32Array.from([     0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,     0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,     0x9216d5d9, 0x8979fb1b, 0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96,     0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, ]); // first half of C512 const B32C = B64C.slice(0, 16); const B256_IV = _md_ts_1.SHA256_IV.slice(); const B224_IV = _md_ts_1.SHA224_IV.slice(); const B384_IV = _md_ts_1.SHA384_IV.slice(); const B512_IV = _md_ts_1.SHA512_IV.slice(); function generateTBL256() {     const TBL = [];     for (let i = 0, j = 0; i &lt; 14; i++, j += 16) {         for (let offset = 1; offset &lt; 16; offset += 2) {             TBL.push(B32C[_blake_ts_1.BSIGMA[j + offset]]);             TBL.push(B32C[_blake_ts_1.BSIGMA[j + offset - 1]]);         }     }     return new Uint32Array(TBL); } const TBL256 = / @PURE / generateTBL256(); // C256[SIGMA[X]] precompute // Reusable temporary buffer const BLAKE256_W = / @PURE / new Uint32Array(16); class Blake1_32 extends BLAKE1 {     constructor(outputLen, IV, lengthFlag, opts = {}) {         super(64, outputLen, lengthFlag, 8, 4, B32C, opts);         this.v0 = IV0 | 0;         this.v1 = IV[1] | 0;         this.v2 = IV[2] | 0;         this.v3 = IV[3] | 0;         this.v4 = IV[4] | 0;         this.v5 = IV[5] | 0;         this.v6 = IV[6] | 0;         this.v7 = IV[7] | 0;     }     get() {         const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;         return [v0, v1, v2, v3, v4, v5, v6, v7];     }     // prettier-ignore     set(v0, v1, v2, v3, v4, v5, v6, v7) {         this.v0 = v0 | 0;         this.v1 = v1 | 0;         this.v2 = v2 | 0;         this.v3 = v3 | 0;         this.v4 = v4 | 0;         this.v5 = v5 | 0;         this.v6 = v6 | 0;         this.v7 = v7 | 0;     }     destroy() {         super.destroy();         this.set(0, 0, 0, 0, 0, 0, 0, 0);     }     compress(view, offset, withLength = true) {         for (let i = 0; i &lt; 16; i++, offset += 4)             BLAKE256_W[i] = view.getUint32(offset, false);         // NOTE: we cannot re-use compress from blake2s, since there is additional xor over u256[SIGMA[e]]         let v00 = this.v0 | 0;         let v01 = this.v1 | 0;         let v02 = this.v2 | 0;         let v03 = this.v3 | 0;         let v04 = this.v4 | 0;         let v05 = this.v5 | 0;         let v06 = this.v6 | 0;         let v07 = this.v7 | 0;         let v08 = this.constants0 | 0;         let v09 = this.constants[1] | 0;         let v10 = this.constants[2] | 0;         let v11 = this.constants[3] | 0;         const { h, l } = u64.fromBig(BigInt(withLength ? this.length * 8 : 0));         let v12 = (this.constants[4] ^ l) &gt;&gt;&gt; 0;         let v13 = (this.constants[5] ^ l) &gt;&gt;&gt; 0;         let v14 = (this.constants[6] ^ h) &gt;&gt;&gt; 0;         let v15 = (this.constants[7] ^ h) &gt;&gt;&gt; 0;         // prettier-ignore         for (let i = 0, k = 0, j = 0; i &lt; 14; i++) {             ({ a: v00, b: v04, c: v08, d: v12 } = (0, _blake_ts_1.G1s)(v00, v04, v08, v12, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v00, b: v04, c: v08, d: v12 } = (0, _blake_ts_1.G2s)(v00, v04, v08, v12, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v01, b: v05, c: v09, d: v13 } = (0, _blake_ts_1.G1s)(v01, v05, v09, v13, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v01, b: v05, c: v09, d: v13 } = (0, _blake_ts_1.G2s)(v01, v05, v09, v13, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v02, b: v06, c: v10, d: v14 } = (0, _blake_ts_1.G1s)(v02, v06, v10, v14, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v02, b: v06, c: v10, d: v14 } = (0, _blake_ts_1.G2s)(v02, v06, v10, v14, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v03, b: v07, c: v11, d: v15 } = (0, _blake_ts_1.G1s)(v03, v07, v11, v15, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v03, b: v07, c: v11, d: v15 } = (0, _blake_ts_1.G2s)(v03, v07, v11, v15, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v00, b: v05, c: v10, d: v15 } = (0, _blake_ts_1.G1s)(v00, v05, v10, v15, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v00, b: v05, c: v10, d: v15 } = (0, _blake_ts_1.G2s)(v00, v05, v10, v15, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v01, b: v06, c: v11, d: v12 } = (0, _blake_ts_1.G1s)(v01, v06, v11, v12, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v01, b: v06, c: v11, d: v12 } = (0, _blake_ts_1.G2s)(v01, v06, v11, v12, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v02, b: v07, c: v08, d: v13 } = (0, _blake_ts_1.G1s)(v02, v07, v08, v13, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v02, b: v07, c: v08, d: v13 } = (0, _blake_ts_1.G2s)(v02, v07, v08, v13, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v03, b: v04, c: v09, d: v14 } = (0, _blake_ts_1.G1s)(v03, v04, v09, v14, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));             ({ a: v03, b: v04, c: v09, d: v14 } = (0, _blake_ts_1.G2s)(v03, v04, v09, v14, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));         }         this.v0 = (this.v0 ^ v00 ^ v08 ^ this.salt0) &gt;&gt;&gt; 0;         this.v1 = (this.v1 ^ v01 ^ v09 ^ this.salt[1]) &gt;&gt;&gt; 0;         this.v2 = (this.v2 ^ v02 ^ v10 ^ this.salt[2]) &gt;&gt;&gt; 0;         this.v3 = (this.v3 ^ v03 ^ v11 ^ this.salt[3]) &gt;&gt;&gt; 0;         this.v4 = (this.v4 ^ v04 ^ v12 ^ this.salt0) &gt;&gt;&gt; 0;         this.v5 = (this.v5 ^ v05 ^ v13 ^ this.salt[1]) &gt;&gt;&gt; 0;         this.v6 = (this.v6 ^ v06 ^ v14 ^ this.salt[2]) &gt;&gt;&gt; 0;         this.v7 = (this.v7 ^ v07 ^ v15 ^ this.salt[3]) &gt;&gt;&gt; 0;         (0, utils_ts_1.clean)(BLAKE256_W);     } } const BBUF = / @PURE / new Uint32Array(32); const BLAKE512_W = / @PURE / new Uint32Array(32); function generateTBL512() {     const TBL = [];     for (let r = 0, k = 0; r &lt; 16; r++, k += 16) {         for (let offset = 1; offset &lt; 16; offset += 2) {             TBL.push(B64C[_blake_ts_1.BSIGMA[k + offset] * 2 + 0]);             TBL.push(B64C[_blake_ts_1.BSIGMA[k + offset] * 2 + 1]);             TBL.push(B64C[_blake_ts_1.BSIGMA[k + offset - 1] * 2 + 0]);             TBL.push(B64C[_blake_ts_1.BSIGMA[k + offset - 1] * 2 + 1]);         }     }     return new Uint32Array(TBL); } const TBL512 = / @PURE / generateTBL512(); // C512[SIGMA[X]] precompute // Mixing function G splitted in two halfs function G1b(a, b, c, d, msg, k) {     const Xpos = 2 * _blake_ts_1.BSIGMA[k];     const Xl = msg[Xpos + 1] ^ TBL512[k * 2 + 1], Xh = msg[Xpos] ^ TBL512[k * 2]; // prettier-ignore     let Al = BBUF[2 * a + 1], Ah = BBUF[2 * a]; // prettier-ignore     let Bl = BBUF[2 * b + 1], Bh = BBUF[2 * b]; // prettier-ignore     let Cl = BBUF[2 * c + 1], Ch = BBUF[2 * c]; // prettier-ignore     let Dl = BBUF[2 * d + 1], Dh = BBUF[2 * d]; // prettier-ignore     // v[a] = (v[a] + v[b] + x) | 0;     let ll = u64.add3L(Al, Bl, Xl);     Ah = u64.add3H(ll, Ah, Bh, Xh) &gt;&gt;&gt; 0;     Al = (ll | 0) &gt;&gt;&gt; 0;     // v[d] = rotr(v[d] ^ v[a], 32)     ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });     ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });     // v[c] = (v[c] + v[d]) | 0;     ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));     // v[b] = rotr(v[b] ^ v[c], 25)     ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });     ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 25), Bl: u64.rotrSL(Bh, Bl, 25) });     (BBUF[2 * a + 1] = Al), (BBUF[2 * a] = Ah);     (BBUF[2 * b + 1] = Bl), (BBUF[2 * b] = Bh);     (BBUF[2 * c + 1] = Cl), (BBUF[2 * c] = Ch);     (BBUF[2 * d + 1] = Dl), (BBUF[2 * d] = Dh); } function G2b(a, b, c, d, msg, k) {     const Xpos = 2 * _blake_ts_1.BSIGMA[k];     const Xl = msg[Xpos + 1] ^ TBL512[k * 2 + 1], Xh = msg[Xpos] ^ TBL512[k * 2]; // prettier-ignore     let Al = BBUF[2 * a + 1], Ah = BBUF[2 * a]; // prettier-ignore     let Bl = BBUF[2 * b + 1], Bh = BBUF[2 * b]; // prettier-ignore     let Cl = BBUF[2 * c + 1], Ch = BBUF[2 * c]; // prettier-ignore     let Dl = BBUF[2 * d + 1], Dh = BBUF[2 * d]; // prettier-ignore     // v[a] = (v[a] + v[b] + x) | 0;     let ll = u64.add3L(Al, Bl, Xl);     Ah = u64.add3H(ll, Ah, Bh, Xh);     Al = ll | 0;     // v[d] = rotr(v[d] ^ v[a], 16)     ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });     ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });     // v[c] = (v[c] + v[d]) | 0;     ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));     // v[b] = rotr(v[b] ^ v[c], 11)     ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });     ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 11), Bl: u64.rotrSL(Bh, Bl, 11) });     (BBUF[2 * a + 1] = Al), (BBUF[2 * a] = Ah);     (BBUF[2 * b + 1] = Bl), (BBUF[2 * b] = Bh);     (BBUF[2 * c + 1] = Cl), (BBUF[2 * c] = Ch);     (BBUF[2 * d + 1] = Dl), (BBUF[2 * d] = Dh); } class Blake1_64 extends BLAKE1 {     constructor(outputLen, IV, lengthFlag, opts = {}) {         super(128, outputLen, lengthFlag, 16, 8, B64C, opts);         this.v0l = IV0 | 0;         this.v0h = IV[1] | 0;         this.v1l = IV[2] | 0;         this.v1h = IV[3] | 0;         this.v2l = IV[4] | 0;         this.v2h = IV[5] | 0;         this.v3l = IV[6] | 0;         this.v3h = IV[7] | 0;         this.v4l = IV[8] | 0;         this.v4h = IV[9] | 0;         this.v5l = IV[10] | 0;         this.v5h = IV[11] | 0;         this.v6l = IV[12] | 0;         this.v6h = IV[13] | 0;         this.v7l = IV[14] | 0;         this.v7h = IV[15] | 0;     }     // prettier-ignore     get() {         let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;         return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];     }     // prettier-ignore     set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {         this.v0l = v0l | 0;         this.v0h = v0h | 0;         this.v1l = v1l | 0;         this.v1h = v1h | 0;         this.v2l = v2l | 0;         this.v2h = v2h | 0;         this.v3l = v3l | 0;         this.v3h = v3h | 0;         this.v4l = v4l | 0;         this.v4h = v4h | 0;         this.v5l = v5l | 0;         this.v5h = v5h | 0;         this.v6l = v6l | 0;         this.v6h = v6h | 0;         this.v7l = v7l | 0;         this.v7h = v7h | 0;     }     destroy() {         super.destroy();         this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);     }     compress(view, offset, withLength = true) {         for (let i = 0; i &lt; 32; i++, offset += 4)             BLAKE512_W[i] = view.getUint32(offset, false);         this.get().forEach((v, i) =&gt; (BBUF[i] = v)); // First half from state.         BBUF.set(this.constants.subarray(0, 16), 16);         if (withLength) {             const { h, l } = u64.fromBig(BigInt(this.length * 8));             BBUF[24] = (BBUF[24] ^ h) &gt;&gt;&gt; 0;             BBUF[25] = (BBUF[25] ^ l) &gt;&gt;&gt; 0;             BBUF[26] = (BBUF[26] ^ h) &gt;&gt;&gt; 0;             BBUF[27] = (BBUF[27] ^ l) &gt;&gt;&gt; 0;         }         for (let i = 0, k = 0; i &lt; 16; i++) {             G1b(0, 4, 8, 12, BLAKE512_W, k++);             G2b(0, 4, 8, 12, BLAKE512_W, k++);             G1b(1, 5, 9, 13, BLAKE512_W, k++);             G2b(1, 5, 9, 13, BLAKE512_W, k++);             G1b(2, 6, 10, 14, BLAKE512_W, k++);             G2b(2, 6, 10, 14, BLAKE512_W, k++);             G1b(3, 7, 11, 15, BLAKE512_W, k++);             G2b(3, 7, 11, 15, BLAKE512_W, k++);             G1b(0, 5, 10, 15, BLAKE512_W, k++);             G2b(0, 5, 10, 15, BLAKE512_W, k++);             G1b(1, 6, 11, 12, BLAKE512_W, k++);             G2b(1, 6, 11, 12, BLAKE512_W, k++);             G1b(2, 7, 8, 13, BLAKE512_W, k++);             G2b(2, 7, 8, 13, BLAKE512_W, k++);             G1b(3, 4, 9, 14, BLAKE512_W, k++);             G2b(3, 4, 9, 14, BLAKE512_W, k++);         }         this.v0l ^= BBUF0 ^ BBUF[16] ^ this.salt0;         this.v0h ^= BBUF[1] ^ BBUF[17] ^ this.salt[1];         this.v1l ^= BBUF[2] ^ BBUF[18] ^ this.salt[2];         this.v1h ^= BBUF[3] ^ BBUF[19] ^ this.salt[3];         this.v2l ^= BBUF[4] ^ BBUF[20] ^ this.salt[4];         this.v2h ^= BBUF[5] ^ BBUF[21] ^ this.salt[5];         this.v3l ^= BBUF[6] ^ BBUF[22] ^ this.salt[6];         this.v3h ^= BBUF[7] ^ BBUF[23] ^ this.salt[7];         this.v4l ^= BBUF[8] ^ BBUF[24] ^ this.salt0;         this.v4h ^= BBUF[9] ^ BBUF[25] ^ this.salt[1];         this.v5l ^= BBUF[10] ^ BBUF[26] ^ this.salt[2];         this.v5h ^= BBUF[11] ^ BBUF[27] ^ this.salt[3];         this.v6l ^= BBUF[12] ^ BBUF[28] ^ this.salt[4];         this.v6h ^= BBUF[13] ^ BBUF[29] ^ this.salt[5];         this.v7l ^= BBUF[14] ^ BBUF[30] ^ this.salt[6];         this.v7h ^= BBUF[15] ^ BBUF[31] ^ this.salt[7];         (0, utils_ts_1.clean)(BBUF, BLAKE512_W);     } } class BLAKE224 extends Blake1_32 {     constructor(opts = {}) {         super(28, B224_IV, 0, opts);     } } exports.BLAKE224 = BLAKE224; class BLAKE256 extends Blake1_32 {     constructor(opts = {}) {         super(32, B256_IV, 1, opts);     } } exports.BLAKE256 = BLAKE256; class BLAKE384 extends Blake1_64 {     constructor(opts = {}) {         super(48, B384_IV, 0, opts);     } } exports.BLAKE384 = BLAKE384; class BLAKE512 extends Blake1_64 {     constructor(opts = {}) {         super(64, B512_IV, 1, opts);     } } exports.BLAKE512 = BLAKE512; /** blake1-224 hash function</li> </ul>"},{"location":"autogenerated/code-summary/#blake256","title":"blake256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake1.js</code></p> <p>Signature: <code>blake256(= (0, utils_ts_1.createOptHasher)</code></p> <p>JSDoc:</p> <p>blake1-256 hash function</p>"},{"location":"autogenerated/code-summary/#blake384","title":"blake384","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake1.js</code></p> <p>Signature: <code>blake384(= (0, utils_ts_1.createOptHasher)</code></p> <p>JSDoc:</p> <p>blake1-384 hash function</p>"},{"location":"autogenerated/code-summary/#blake512","title":"blake512","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake1.js</code></p> <p>Signature: <code>blake512(= (0, utils_ts_1.createOptHasher)</code></p> <p>JSDoc:</p> <p>blake1-512 hash function</p>"},{"location":"autogenerated/code-summary/#blake2b","title":"blake2b","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake2.js</code></p> <p>Signature: <code>blake2b(= (0, utils_ts_1.createOptHasher)</code></p> <p>JSDoc:</p> <p>blake2b (64-bit) &amp; blake2s (8 to 32-bit) hash functions. b could have been faster, but there is no fast u64 in js, so s is 1.5x faster. @module / const _blake_ts_1 = require(\"./_blake.js\"); const _md_ts_1 = require(\"./_md.js\"); const u64 = require(\"./_u64.js\"); // prettier-ignore const utils_ts_1 = require(\"./utils.js\"); // Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv0, etc. const B2B_IV = / @PURE / Uint32Array.from([     0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,     0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19, ]); // Temporary buffer const BBUF = / @PURE / new Uint32Array(32); // Mixing function G splitted in two halfs function G1b(a, b, c, d, msg, x) {     // NOTE: V is LE here     const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore     let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore     let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore     let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore     let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore     // v[a] = (v[a] + v[b] + x) | 0;     let ll = u64.add3L(Al, Bl, Xl);     Ah = u64.add3H(ll, Ah, Bh, Xh);     Al = ll | 0;     // v[d] = rotr(v[d] ^ v[a], 32)     ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });     ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });     // v[c] = (v[c] + v[d]) | 0;     ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));     // v[b] = rotr(v[b] ^ v[c], 24)     ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });     ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });     (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);     (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);     (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);     (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh); } function G2b(a, b, c, d, msg, x) {     // NOTE: V is LE here     const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore     let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore     let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore     let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore     let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore     // v[a] = (v[a] + v[b] + x) | 0;     let ll = u64.add3L(Al, Bl, Xl);     Ah = u64.add3H(ll, Ah, Bh, Xh);     Al = ll | 0;     // v[d] = rotr(v[d] ^ v[a], 16)     ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });     ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });     // v[c] = (v[c] + v[d]) | 0;     ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));     // v[b] = rotr(v[b] ^ v[c], 63)     ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });     ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });     (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);     (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);     (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);     (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh); } function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {     (0, utils_ts_1.anumber)(keyLen);     if (outputLen &lt; 0 || outputLen &gt; keyLen)         throw new Error('outputLen bigger than keyLen');     const { key, salt, personalization } = opts;     if (key !== undefined &amp;&amp; (key.length &lt; 1 || key.length &gt; keyLen))         throw new Error('key length must be undefined or 1..' + keyLen);     if (salt !== undefined &amp;&amp; salt.length !== saltLen)         throw new Error('salt must be undefined or ' + saltLen);     if (personalization !== undefined &amp;&amp; personalization.length !== persLen)         throw new Error('personalization must be undefined or ' + persLen); } / Class, from which others are subclassed. */ class BLAKE2 extends utils_ts_1.Hash {     constructor(blockLen, outputLen) {         super();         this.finished = false;         this.destroyed = false;         this.length = 0;         this.pos = 0;         (0, utils_ts_1.anumber)(blockLen);         (0, utils_ts_1.anumber)(outputLen);         this.blockLen = blockLen;         this.outputLen = outputLen;         this.buffer = new Uint8Array(blockLen);         this.buffer32 = (0, utils_ts_1.u32)(this.buffer);     }     update(data) {         (0, utils_ts_1.aexists)(this);         data = (0, utils_ts_1.toBytes)(data);         (0, utils_ts_1.abytes)(data);         // Main difference with other hashes: there is flag for last block,         // so we cannot process current block before we know that there         // is the next one. This significantly complicates logic and reduces ability         // to do zero-copy processing         const { blockLen, buffer, buffer32 } = this;         const len = data.length;         const offset = data.byteOffset;         const buf = data.buffer;         for (let pos = 0; pos &lt; len;) {             // If buffer is full and we still have input (don't process last block, same as blake2s)             if (this.pos === blockLen) {                 (0, utils_ts_1.swap32IfBE)(buffer32);                 this.compress(buffer32, 0, false);                 (0, utils_ts_1.swap32IfBE)(buffer32);                 this.pos = 0;             }             const take = Math.min(blockLen - this.pos, len - pos);             const dataOffset = offset + pos;             // full block &amp;&amp; aligned to 4 bytes &amp;&amp; not last in input             if (take === blockLen &amp;&amp; !(dataOffset % 4) &amp;&amp; pos + take &lt; len) {                 const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));                 (0, utils_ts_1.swap32IfBE)(data32);                 for (let pos32 = 0; pos + blockLen &lt; len; pos32 += buffer32.length, pos += blockLen) {                     this.length += blockLen;                     this.compress(data32, pos32, false);                 }                 (0, utils_ts_1.swap32IfBE)(data32);                 continue;             }             buffer.set(data.subarray(pos, pos + take), this.pos);             this.pos += take;             this.length += take;             pos += take;         }         return this;     }     digestInto(out) {         (0, utils_ts_1.aexists)(this);         (0, utils_ts_1.aoutput)(out, this);         const { pos, buffer32 } = this;         this.finished = true;         // Padding         (0, utils_ts_1.clean)(this.buffer.subarray(pos));         (0, utils_ts_1.swap32IfBE)(buffer32);         this.compress(buffer32, 0, true);         (0, utils_ts_1.swap32IfBE)(buffer32);         const out32 = (0, utils_ts_1.u32)(out);         this.get().forEach((v, i) =&gt; (out32[i] = (0, utils_ts_1.swap8IfBE)(v)));     }     digest() {         const { buffer, outputLen } = this;         this.digestInto(buffer);         const res = buffer.slice(0, outputLen);         this.destroy();         return res;     }     _cloneInto(to) {         const { buffer, length, finished, destroyed, outputLen, pos } = this;         to || (to = new this.constructor({ dkLen: outputLen }));         to.set(...this.get());         to.buffer.set(buffer);         to.destroyed = destroyed;         to.finished = finished;         to.length = length;         to.pos = pos;         // @ts-ignore         to.outputLen = outputLen;         return to;     }     clone() {         return this._cloneInto();     } } exports.BLAKE2 = BLAKE2; class BLAKE2b extends BLAKE2 {     constructor(opts = {}) {         const olen = opts.dkLen === undefined ? 64 : opts.dkLen;         super(128, olen);         // Same as SHA-512, but LE         this.v0l = B2B_IV0 | 0;         this.v0h = B2B_IV[1] | 0;         this.v1l = B2B_IV[2] | 0;         this.v1h = B2B_IV[3] | 0;         this.v2l = B2B_IV[4] | 0;         this.v2h = B2B_IV[5] | 0;         this.v3l = B2B_IV[6] | 0;         this.v3h = B2B_IV[7] | 0;         this.v4l = B2B_IV[8] | 0;         this.v4h = B2B_IV[9] | 0;         this.v5l = B2B_IV[10] | 0;         this.v5h = B2B_IV[11] | 0;         this.v6l = B2B_IV[12] | 0;         this.v6h = B2B_IV[13] | 0;         this.v7l = B2B_IV[14] | 0;         this.v7h = B2B_IV[15] | 0;         checkBlake2Opts(olen, opts, 64, 16, 16);         let { key, personalization, salt } = opts;         let keyLength = 0;         if (key !== undefined) {             key = (0, utils_ts_1.toBytes)(key);             keyLength = key.length;         }         this.v0l ^= this.outputLen | (keyLength &lt;&lt; 8) | (0x01 &lt;&lt; 16) | (0x01 &lt;&lt; 24);         if (salt !== undefined) {             salt = (0, utils_ts_1.toBytes)(salt);             const slt = (0, utils_ts_1.u32)(salt);             this.v4l ^= (0, utils_ts_1.swap8IfBE)(slt0);             this.v4h ^= (0, utils_ts_1.swap8IfBE)(slt[1]);             this.v5l ^= (0, utils_ts_1.swap8IfBE)(slt[2]);             this.v5h ^= (0, utils_ts_1.swap8IfBE)(slt[3]);         }         if (personalization !== undefined) {             personalization = (0, utils_ts_1.toBytes)(personalization);             const pers = (0, utils_ts_1.u32)(personalization);             this.v6l ^= (0, utils_ts_1.swap8IfBE)(pers0);             this.v6h ^= (0, utils_ts_1.swap8IfBE)(pers[1]);             this.v7l ^= (0, utils_ts_1.swap8IfBE)(pers[2]);             this.v7h ^= (0, utils_ts_1.swap8IfBE)(pers[3]);         }         if (key !== undefined) {             // Pad to blockLen and update             const tmp = new Uint8Array(this.blockLen);             tmp.set(key);             this.update(tmp);         }     }     // prettier-ignore     get() {         let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;         return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];     }     // prettier-ignore     set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {         this.v0l = v0l | 0;         this.v0h = v0h | 0;         this.v1l = v1l | 0;         this.v1h = v1h | 0;         this.v2l = v2l | 0;         this.v2h = v2h | 0;         this.v3l = v3l | 0;         this.v3h = v3h | 0;         this.v4l = v4l | 0;         this.v4h = v4h | 0;         this.v5l = v5l | 0;         this.v5h = v5h | 0;         this.v6l = v6l | 0;         this.v6h = v6h | 0;         this.v7l = v7l | 0;         this.v7h = v7h | 0;     }     compress(msg, offset, isLast) {         this.get().forEach((v, i) =&gt; (BBUF[i] = v)); // First half from state.         BBUF.set(B2B_IV, 16); // Second half from IV.         let { h, l } = u64.fromBig(BigInt(this.length));         BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.         BBUF[25] = B2B_IV[9] ^ h; // High word.         // Invert all bits for last block         if (isLast) {             BBUF[28] = ~BBUF[28];             BBUF[29] = ~BBUF[29];         }         let j = 0;         const s = _blake_ts_1.BSIGMA;         for (let i = 0; i &lt; 12; i++) {             G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);             G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);             G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);             G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);             G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);             G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);             G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);             G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);             G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);             G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);             G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);             G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);             G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);             G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);             G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);             G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);         }         this.v0l ^= BBUF0 ^ BBUF[16];         this.v0h ^= BBUF[1] ^ BBUF[17];         this.v1l ^= BBUF[2] ^ BBUF[18];         this.v1h ^= BBUF[3] ^ BBUF[19];         this.v2l ^= BBUF[4] ^ BBUF[20];         this.v2h ^= BBUF[5] ^ BBUF[21];         this.v3l ^= BBUF[6] ^ BBUF[22];         this.v3h ^= BBUF[7] ^ BBUF[23];         this.v4l ^= BBUF[8] ^ BBUF[24];         this.v4h ^= BBUF[9] ^ BBUF[25];         this.v5l ^= BBUF[10] ^ BBUF[26];         this.v5h ^= BBUF[11] ^ BBUF[27];         this.v6l ^= BBUF[12] ^ BBUF[28];         this.v6h ^= BBUF[13] ^ BBUF[29];         this.v7l ^= BBUF[14] ^ BBUF[30];         this.v7h ^= BBUF[15] ^ BBUF[31];         (0, utils_ts_1.clean)(BBUF);     }     destroy() {         this.destroyed = true;         (0, utils_ts_1.clean)(this.buffer32);         this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);     } } exports.BLAKE2b = BLAKE2b; / Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS. @param msg - message that would be hashed @param opts - dkLen output length, key for MAC mode, salt, personalization</p>"},{"location":"autogenerated/code-summary/#blake2s","title":"blake2s","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake2.js</code></p> <p>Signature: <code>blake2s(= (0, utils_ts_1.createOptHasher)</code></p> <p>JSDoc:</p> <p>Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS. @param msg - message that would be hashed @param opts - dkLen output length, key for MAC mode, salt, personalization</p>"},{"location":"autogenerated/code-summary/#blake2b_1","title":"BLAKE2b","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake2b.js</code></p> <p>Signature: <code>BLAKE2b(= blake2_ts_1.BLAKE2b; /** @deprecated Use import from</code>noble/hashes/blake2<code>module */ exports.blake2b = blake2_ts_1.blake2b; //# sourceMappingURL=blake2b.js.map)</code></p> <p>JSDoc:</p> <p>Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible. @module @deprecated / const blake2_ts_1 = require(\"./blake2.js\"); /** @deprecated Use import from <code>noble/hashes/blake2</code> module</p>"},{"location":"autogenerated/code-summary/#b2s_iv","title":"B2S_IV","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake2s.js</code></p> <p>Signature: <code>B2S_IV(= _md_ts_1.SHA256_IV; /** @deprecated Use import from</code>noble/hashes/blake2<code>module */ exports.G1s = _blake_ts_1.G1s; /** @deprecated Use import from</code>noble/hashes/blake2<code>module */ exports.G2s = _blake_ts_1.G2s; /** @deprecated Use import from</code>noble/hashes/blake2<code>module */ exports.compress = blake2_ts_1.compress; /** @deprecated Use import from</code>noble/hashes/blake2<code>module */ exports.BLAKE2s = blake2_ts_1.BLAKE2s; /** @deprecated Use import from</code>noble/hashes/blake2<code>module */ exports.blake2s = blake2_ts_1.blake2s; //# sourceMappingURL=blake2s.js.map)</code></p> <p>JSDoc:</p> <p>Blake2s hash function. Focuses on 8-bit to 32-bit platforms. blake2b for 64-bit, but in JS it is slower. @module @deprecated / const _blake_ts_1 = require(\"./_blake.js\"); const _md_ts_1 = require(\"./_md.js\"); const blake2_ts_1 = require(\"./blake2.js\"); /** @deprecated Use import from <code>noble/hashes/blake2</code> module</p>"},{"location":"autogenerated/code-summary/#blake3","title":"blake3","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/blake3.js</code></p> <p>Signature: <code>blake3(= (0, utils_ts_1.createXOFer)</code></p> <p>JSDoc:</p> <p>Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC &amp; KDF.</p> <p>It is advertised as \"the fastest cryptographic hash\". However, it isn't true in JS. Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:</p> <ul> <li>There is only 30% reduction in number of rounds from blake2s</li> <li>Speed-up comes from tree structure, which is parallelized using SIMD &amp; threading.   These features are not present in JS, so we only get overhead from trees.</li> <li>Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.</li> <li>It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm @module / const md_ts_1 = require(\"./_md.js\"); const _u64_ts_1 = require(\"./_u64.js\"); const blake2_ts_1 = require(\"./blake2.js\"); // prettier-ignore const utils_ts_1 = require(\"./utils.js\"); // Flag bitset const B3_Flags = {     CHUNK_START: 0b1,     CHUNK_END: 0b10,     PARENT: 0b100,     ROOT: 0b1000,     KEYED_HASH: 0b10000,     DERIVE_KEY_CONTEXT: 0b100000,     DERIVE_KEY_MATERIAL: 0b1000000, }; const B3_IV = _md_ts_1.SHA256_IV.slice(); const B3_SIGMA = / @PURE / (() =&gt; {     const Id = Array.from({ length: 16 }, (, i) =&gt; i);     const permute = (arr) =&gt; [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) =&gt; arr[i]);     const res = [];     for (let i = 0, v = Id; i &lt; 7; i++, v = permute(v))         res.push(...v);     return Uint8Array.from(res); })(); / Blake3 hash. Can be used as MAC and KDF. */ class BLAKE3 extends blake2_ts_1.BLAKE2 {     constructor(opts = {}, flags = 0) {         super(64, opts.dkLen === undefined ? 32 : opts.dkLen);         this.chunkPos = 0; // Position of current block in chunk         this.chunksDone = 0; // How many chunks we already have         this.flags = 0 | 0;         this.stack = [];         // Output         this.posOut = 0;         this.bufferOut32 = new Uint32Array(16);         this.chunkOut = 0; // index of output chunk         this.enableXOF = true;         const { key, context } = opts;         const hasContext = context !== undefined;         if (key !== undefined) {             if (hasContext)                 throw new Error('Only \"key\" or \"context\" can be specified at same time');             const k = (0, utils_ts_1.toBytes)(key).slice();             (0, utils_ts_1.abytes)(k, 32);             this.IV = (0, utils_ts_1.u32)(k);             (0, utils_ts_1.swap32IfBE)(this.IV);             this.flags = flags | B3_Flags.KEYED_HASH;         }         else if (hasContext) {             const ctx = (0, utils_ts_1.toBytes)(context);             const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT)                 .update(ctx)                 .digest();             this.IV = (0, utils_ts_1.u32)(contextKey);             (0, utils_ts_1.swap32IfBE)(this.IV);             this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;         }         else {             this.IV = B3_IV.slice();             this.flags = flags;         }         this.state = this.IV.slice();         this.bufferOut = (0, utils_ts_1.u8)(this.bufferOut32);     }     // Unused     get() {         return [];     }     set() { }     b2Compress(counter, flags, buf, bufPos = 0) {         const { state: s, pos } = this;         const { h, l } = (0, _u64_ts_1.fromBig)(BigInt(counter), true);         // prettier-ignore         const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = (0, blake2_ts_1.compress)(B3_SIGMA, bufPos, buf, 7, s0, s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV0, B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);         s0 = v0 ^ v8;         s[1] = v1 ^ v9;         s[2] = v2 ^ v10;         s[3] = v3 ^ v11;         s[4] = v4 ^ v12;         s[5] = v5 ^ v13;         s[6] = v6 ^ v14;         s[7] = v7 ^ v15;     }     compress(buf, bufPos = 0, isLast = false) {         // Compress last block         let flags = this.flags;         if (!this.chunkPos)             flags |= B3_Flags.CHUNK_START;         if (this.chunkPos === 15 || isLast)             flags |= B3_Flags.CHUNK_END;         if (!isLast)             this.pos = this.blockLen;         this.b2Compress(this.chunksDone, flags, buf, bufPos);         this.chunkPos += 1;         // If current block is last in chunk (16 blocks), then compress chunks         if (this.chunkPos === 16 || isLast) {             let chunk = this.state;             this.state = this.IV.slice();             // If not the last one, compress only when there are trailing zeros in chunk counter             // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.             // 1 (001) - leaf not finished (just push current chunk to stack)             // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)             // 3 (011) - last leaf not finished             // 4 (100) - leafs finished at depth=1 and depth=2             for (let last, chunks = this.chunksDone + 1; isLast || !(chunks &amp; 1); chunks &gt;&gt;= 1) {                 if (!(last = this.stack.pop()))                     break;                 this.buffer32.set(last, 0);                 this.buffer32.set(chunk, 8);                 this.pos = this.blockLen;                 this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);                 chunk = this.state;                 this.state = this.IV.slice();             }             this.chunksDone++;             this.chunkPos = 0;             this.stack.push(chunk);         }         this.pos = 0;     }     _cloneInto(to) {         to = super._cloneInto(to);         const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;         to.state.set(state.slice());         to.stack = stack.map((i) =&gt; Uint32Array.from(i));         to.IV.set(IV);         to.flags = flags;         to.chunkPos = chunkPos;         to.chunksDone = chunksDone;         to.posOut = posOut;         to.chunkOut = chunkOut;         to.enableXOF = this.enableXOF;         to.bufferOut32.set(this.bufferOut32);         return to;     }     destroy() {         this.destroyed = true;         (0, utils_ts_1.clean)(this.state, this.buffer32, this.IV, this.bufferOut32);         (0, utils_ts_1.clean)(...this.stack);     }     // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)     b2CompressOut() {         const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;         const { h, l } = (0, _u64_ts_1.fromBig)(BigInt(this.chunkOut++));         (0, utils_ts_1.swap32IfBE)(buffer32);         // prettier-ignore         const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = (0, blake2_ts_1.compress)(B3_SIGMA, 0, buffer32, 7, s0, s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV0, B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);         out320 = v0 ^ v8;         out32[1] = v1 ^ v9;         out32[2] = v2 ^ v10;         out32[3] = v3 ^ v11;         out32[4] = v4 ^ v12;         out32[5] = v5 ^ v13;         out32[6] = v6 ^ v14;         out32[7] = v7 ^ v15;         out32[8] = s0 ^ v8;         out32[9] = s[1] ^ v9;         out32[10] = s[2] ^ v10;         out32[11] = s[3] ^ v11;         out32[12] = s[4] ^ v12;         out32[13] = s[5] ^ v13;         out32[14] = s[6] ^ v14;         out32[15] = s[7] ^ v15;         (0, utils_ts_1.swap32IfBE)(buffer32);         (0, utils_ts_1.swap32IfBE)(out32);         this.posOut = 0;     }     finish() {         if (this.finished)             return;         this.finished = true;         // Padding         (0, utils_ts_1.clean)(this.buffer.subarray(this.pos));         // Process last chunk         let flags = this.flags | B3_Flags.ROOT;         if (this.stack.length) {             flags |= B3_Flags.PARENT;             (0, utils_ts_1.swap32IfBE)(this.buffer32);             this.compress(this.buffer32, 0, true);             (0, utils_ts_1.swap32IfBE)(this.buffer32);             this.chunksDone = 0;             this.pos = this.blockLen;         }         else {             flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;         }         this.flags = flags;         this.b2CompressOut();     }     writeInto(out) {         (0, utils_ts_1.aexists)(this, false);         (0, utils_ts_1.abytes)(out);         this.finish();         const { blockLen, bufferOut } = this;         for (let pos = 0, len = out.length; pos &lt; len;) {             if (this.posOut &gt;= blockLen)                 this.b2CompressOut();             const take = Math.min(blockLen - this.posOut, len - pos);             out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);             this.posOut += take;             pos += take;         }         return out;     }     xofInto(out) {         if (!this.enableXOF)             throw new Error('XOF is not possible after digest call');         return this.writeInto(out);     }     xof(bytes) {         (0, utils_ts_1.anumber)(bytes);         return this.xofInto(new Uint8Array(bytes));     }     digestInto(out) {         (0, utils_ts_1.aoutput)(out, this);         if (this.finished)             throw new Error('digest() was already called');         this.enableXOF = false;         this.writeInto(out);         this.destroy();         return out;     }     digest() {         return this.digestInto(new Uint8Array(this.outputLen));     } } exports.BLAKE3 = BLAKE3; / BLAKE3 hash function. Can be used as MAC and KDF. @param msg - message that would be hashed @param opts - <code>dkLen</code> for output length, <code>key</code> for MAC mode, <code>context</code> for KDF mode @example const data = new Uint8Array(32); const hash = blake3(data); const mac = blake3(data, { key: new Uint8Array(32) }); const kdf = blake3(data, { context: 'application name' });</li> </ul>"},{"location":"autogenerated/code-summary/#setbiguint64","title":"setBigUint64","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/_md.js</code></p> <p>Signature: <code>setBigUint64(view, byteOffset, value, isLE)</code></p> <p>JSDoc:</p> <p>Internal Merkle-Damgard hash utils. @module / import { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\"; /** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64</p>"},{"location":"autogenerated/code-summary/#chi","title":"Chi","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/_md.js</code></p> <p>Signature: <code>Chi(a, b, c)</code></p> <p>JSDoc:</p> <p>Choice: a ? b : c</p>"},{"location":"autogenerated/code-summary/#maj","title":"Maj","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/_md.js</code></p> <p>Signature: <code>Maj(a, b, c)</code></p> <p>JSDoc:</p> <p>Majority function, true if any two inputs is true.</p>"},{"location":"autogenerated/code-summary/#derivemainseed","title":"deriveMainSeed","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/eskdf.js</code></p> <p>Signature: <code>deriveMainSeed(username, password)</code></p> <p>JSDoc:</p> <p>Experimental KDF for AES. / import { hkdf } from \"./hkdf.js\"; import { pbkdf2 as _pbkdf2 } from \"./pbkdf2.js\"; import { scrypt as _scrypt } from \"./scrypt.js\"; import { sha256 } from \"./sha256.js\"; import { abytes, bytesToHex, clean, createView, hexToBytes, kdfInputToBytes } from \"./utils.js\"; // A tiny KDF for various applications like AES key-gen. // Uses HKDF in a non-standard way, so it's not \"KDF-secure\", only \"PRF-secure\". // Which is good enough: assume sha2-256 retained preimage resistance. const SCRYPT_FACTOR = 2 ** 19; const PBKDF2_FACTOR = 2 ** 17; // Scrypt KDF export function scrypt(password, salt) {     return _scrypt(password, salt, { N: SCRYPT_FACTOR, r: 8, p: 1, dkLen: 32 }); } // PBKDF2-HMAC-SHA256 export function pbkdf2(password, salt) {     return _pbkdf2(sha256, password, salt, { c: PBKDF2_FACTOR, dkLen: 32 }); } // Combines two 32-byte byte arrays function xor32(a, b) {     abytes(a, 32);     abytes(b, 32);     const arr = new Uint8Array(32);     for (let i = 0; i &lt; 32; i++) {         arr[i] = a[i] ^ b[i];     }     return arr; } function strHasLength(str, min, max) {     return typeof str === 'string' &amp;&amp; str.length &gt;= min &amp;&amp; str.length &lt;= max; } /** Derives main seed. Takes a lot of time. Prefer <code>eskdf</code> method instead.</p>"},{"location":"autogenerated/code-summary/#extract","title":"extract","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/hkdf.js</code></p> <p>Signature: <code>extract(hash, ikm, salt)</code></p> <p>JSDoc:</p> <p>HKDF (RFC 5869): extract + expand in one step. See https://soatok.blog/2021/11/17/understanding-hkdf/. @module / import { hmac } from \"./hmac.js\"; import { ahash, anumber, clean, toBytes } from \"./utils.js\"; /** HKDF-extract from spec. Less important part. <code>HKDF-Extract(IKM, salt) -&gt; PRK</code> Arguments position differs from spec (IKM is first one, since it is not optional) @param hash - hash function that would be used (e.g. sha256) @param ikm - input keying material, the initial key @param salt - optional salt value (a non-secret random value)</p>"},{"location":"autogenerated/code-summary/#expand","title":"expand","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/hkdf.js</code></p> <p>Signature: <code>expand(hash, prk, info, length = 32)</code></p> <p>JSDoc:</p> <p>HKDF-expand from the spec. The most important part. <code>HKDF-Expand(PRK, info, L) -&gt; OKM</code> @param hash - hash function that would be used (e.g. sha256) @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step) @param info - optional context and application specific information (can be a zero-length string) @param length - length of output keying material in bytes</p>"},{"location":"autogenerated/code-summary/#pbkdf2","title":"pbkdf2","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/pbkdf2.js</code></p> <p>Signature: <code>pbkdf2(hash, password, salt, opts)</code></p> <p>JSDoc:</p> <p>PBKDF (RFC 2898). Can be used to create a key from password and salt. @module / import { hmac } from \"./hmac.js\"; // prettier-ignore import { ahash, anumber, asyncLoop, checkOpts, clean, createView, Hash, kdfInputToBytes } from \"./utils.js\"; // Common prologue and epilogue for sync/async functions function pbkdf2Init(hash, _password, _salt, _opts) {     ahash(hash);     const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);     const { c, dkLen, asyncTick } = opts;     anumber(c);     anumber(dkLen);     anumber(asyncTick);     if (c &lt; 1)         throw new Error('iterations (c) should be &gt;= 1');     const password = kdfInputToBytes(_password);     const salt = kdfInputToBytes(_salt);     // DK = PBKDF2(PRF, Password, Salt, c, dkLen);     const DK = new Uint8Array(dkLen);     // U1 = PRF(Password, Salt + INT_32_BE(i))     const PRF = hmac.create(hash, password);     const PRFSalt = PRF._cloneInto().update(salt);     return { c, dkLen, asyncTick, DK, PRF, PRFSalt }; } function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {     PRF.destroy();     PRFSalt.destroy();     if (prfW)         prfW.destroy();     clean(u);     return DK; } /** PBKDF2-HMAC: RFC 2898 key derivation function @param hash - hash function that would be used e.g. sha256 @param password - password from which a derived key is generated @param salt - cryptographic salt @param opts - {c, dkLen} where c is work factor and dkLen is output message size @example const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });</p>"},{"location":"autogenerated/code-summary/#scrypt","title":"scrypt","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/scrypt.js</code></p> <p>Signature: <code>scrypt(password, salt, opts)</code></p> <p>JSDoc:</p> <p>RFC 7914 Scrypt KDF. Can be used to create a key from password and salt. @module / import { pbkdf2 } from \"./pbkdf2.js\"; import { sha256 } from \"./sha2.js\"; // prettier-ignore import { anumber, asyncLoop, checkOpts, clean, rotl, swap32IfBE, u32 } from \"./utils.js\"; // The main Scrypt loop: uses Salsa extensively. // Six versions of the function were tried, this is the fastest one. // prettier-ignore function XorAndSalsa(prev, pi, input, ii, out, oi) {     // Based on https://cr.yp.to/salsa20.html     // Xor blocks     let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];     let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];     let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];     let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];     let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];     let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];     let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];     let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];     // Save state to temporary variables (salsa)     let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;     // Main loop (salsa)     for (let i = 0; i &lt; 8; i += 2) {         x04 ^= rotl(x00 + x12 | 0, 7);         x08 ^= rotl(x04 + x00 | 0, 9);         x12 ^= rotl(x08 + x04 | 0, 13);         x00 ^= rotl(x12 + x08 | 0, 18);         x09 ^= rotl(x05 + x01 | 0, 7);         x13 ^= rotl(x09 + x05 | 0, 9);         x01 ^= rotl(x13 + x09 | 0, 13);         x05 ^= rotl(x01 + x13 | 0, 18);         x14 ^= rotl(x10 + x06 | 0, 7);         x02 ^= rotl(x14 + x10 | 0, 9);         x06 ^= rotl(x02 + x14 | 0, 13);         x10 ^= rotl(x06 + x02 | 0, 18);         x03 ^= rotl(x15 + x11 | 0, 7);         x07 ^= rotl(x03 + x15 | 0, 9);         x11 ^= rotl(x07 + x03 | 0, 13);         x15 ^= rotl(x11 + x07 | 0, 18);         x01 ^= rotl(x00 + x03 | 0, 7);         x02 ^= rotl(x01 + x00 | 0, 9);         x03 ^= rotl(x02 + x01 | 0, 13);         x00 ^= rotl(x03 + x02 | 0, 18);         x06 ^= rotl(x05 + x04 | 0, 7);         x07 ^= rotl(x06 + x05 | 0, 9);         x04 ^= rotl(x07 + x06 | 0, 13);         x05 ^= rotl(x04 + x07 | 0, 18);         x11 ^= rotl(x10 + x09 | 0, 7);         x08 ^= rotl(x11 + x10 | 0, 9);         x09 ^= rotl(x08 + x11 | 0, 13);         x10 ^= rotl(x09 + x08 | 0, 18);         x12 ^= rotl(x15 + x14 | 0, 7);         x13 ^= rotl(x12 + x15 | 0, 9);         x14 ^= rotl(x13 + x12 | 0, 13);         x15 ^= rotl(x14 + x13 | 0, 18);     }     // Write output (salsa)     out[oi++] = (y00 + x00) | 0;     out[oi++] = (y01 + x01) | 0;     out[oi++] = (y02 + x02) | 0;     out[oi++] = (y03 + x03) | 0;     out[oi++] = (y04 + x04) | 0;     out[oi++] = (y05 + x05) | 0;     out[oi++] = (y06 + x06) | 0;     out[oi++] = (y07 + x07) | 0;     out[oi++] = (y08 + x08) | 0;     out[oi++] = (y09 + x09) | 0;     out[oi++] = (y10 + x10) | 0;     out[oi++] = (y11 + x11) | 0;     out[oi++] = (y12 + x12) | 0;     out[oi++] = (y13 + x13) | 0;     out[oi++] = (y14 + x14) | 0;     out[oi++] = (y15 + x15) | 0; } function BlockMix(input, ii, out, oi, r) {     // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)     let head = oi + 0;     let tail = oi + 16 * r;     for (let i = 0; i &lt; 16; i++)         out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X \u2190 B[2r\u22121]     for (let i = 0; i &lt; r; i++, head += 16, ii += 16) {         // We write odd &amp; even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1         XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2i] ^ tail[i-1])         if (i &gt; 0)             tail += 16; // First iteration overwrites tmp value in tail         XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2i+1] ^ head[i])     } } // Common prologue and epilogue for sync/async functions function scryptInit(password, salt, _opts) {     // Maxmem - 1GB+1KB by default     const opts = checkOpts({         dkLen: 32,         asyncTick: 10,         maxmem: 1024 ** 3 + 1024,     }, _opts);     const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;     anumber(N);     anumber(r);     anumber(p);     anumber(dkLen);     anumber(asyncTick);     anumber(maxmem);     if (onProgress !== undefined &amp;&amp; typeof onProgress !== 'function')         throw new Error('progressCb should be function');     const blockSize = 128 * r;     const blockSize32 = blockSize / 4;     // Max N is 2^32 (Integrify is 32-bit). Real limit is 2^22: JS engines Uint8Array limit is 4GB in 2024.     // Spec check <code>N &gt;= 2^(blockSize / 8)</code> is not done for compat with popular libs,     // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:     // https://www.rfc-editor.org/errata_search.php?rfc=7914     const pow32 = Math.pow(2, 32);     if (N &lt;= 1 || (N &amp; (N - 1)) !== 0 || N &gt; pow32) {         throw new Error('Scrypt: N must be larger than 1, a power of 2, and less than 2^32');     }     if (p &lt; 0 || p &gt; ((pow32 - 1) * 32) / blockSize) {         throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');     }     if (dkLen &lt; 0 || dkLen &gt; (pow32 - 1) * 32) {         throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');     }     const memUsed = blockSize * (N + p);     if (memUsed &gt; maxmem) {         throw new Error('Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) &gt; maxmem of ' + maxmem);     }     // [B0...Bp\u22121] \u2190 PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSizeParallelizationFactor)     // Since it has only one iteration there is no reason to use async variant     const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });     const B32 = u32(B);     // Re-used between parallel iterations. Array(iterations) of B     const V = u32(new Uint8Array(blockSize * N));     const tmp = u32(new Uint8Array(blockSize));     let blockMixCb = () =&gt; { };     if (onProgress) {         const totalBlockMix = 2 * N * p;         // Invoke callback if progress changes from 10.01 to 10.02         // Allows to draw smooth progress bar on up to 8K screen         const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);         let blockMixCnt = 0;         blockMixCb = () =&gt; {             blockMixCnt++;             if (onProgress &amp;&amp; (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))                 onProgress(blockMixCnt / totalBlockMix);         };     }     return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick }; } function scryptOutput(password, dkLen, B, V, tmp) {     const res = pbkdf2(sha256, password, B, { c: 1, dkLen });     clean(B, V, tmp);     return res; } / Scrypt KDF from RFC 7914. @param password - pass @param salt - salt @param opts - parameters - <code>N</code> is cpu/mem work factor (power of 2 e.g. 218) - <code>r</code> is block size (8 is common), fine-tunes sequential memory read size and performance - <code>p</code> is parallelization factor (1 is common) - <code>dkLen</code> is output key length in bytes e.g. 32. - <code>asyncTick</code> - (default: 10) max time in ms for which async function can block execution - <code>maxmem</code> - (default: <code>1024 ** 3 + 1024</code> aka 1GB+1KB). A limit that the app could use for scrypt - <code>onProgress</code> - callback function that would be executed for progress report @returns Derived key @example scrypt('password', 'salt', { N: 2*18, r: 8, p: 1, dkLen: 32 });</p>"},{"location":"autogenerated/code-summary/#keccakp","title":"keccakP","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/sha3.js</code></p> <p>Signature: <code>keccakP(s, rounds = 24)</code></p> <p>JSDoc:</p> <p>SHA3 (keccak) hash function, based on a new \"Sponge function\" design. Different from older hashes, the internal state is bigger than output size.</p> <p>Check out FIPS-202, Website, the differences between SHA-3 and Keccak.</p> <p>Check out <code>sha3-addons</code> module for cSHAKE, k12, and others. @module / import { rotlBH, rotlBL, rotlSH, rotlSL, split } from \"./_u64.js\"; // prettier-ignore import { abytes, aexists, anumber, aoutput, clean, createHasher, createXOFer, Hash, swap32IfBE, toBytes, u32 } from \"./utils.js\"; // No PURE annotations in sha3 header: // EVERYTHING is in fact used on every export. // Various per round constants calculations const _0n = BigInt(0); const _1n = BigInt(1); const _2n = BigInt(2); const _7n = BigInt(7); const _256n = BigInt(256); const _0x71n = BigInt(0x71); const SHA3_PI = []; const SHA3_ROTL = []; const _SHA3_IOTA = []; for (let round = 0, R = _1n, x = 1, y = 0; round &lt; 24; round++) {     // Pi     [x, y] = [y, (2 * x + 3 * y) % 5];     SHA3_PI.push(2 * (5 * y + x));     // Rotational     SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);     // Iota     let t = _0n;     for (let j = 0; j &lt; 7; j++) {         R = ((R &lt;&lt; _1n) ^ ((R &gt;&gt; _7n) * _0x71n)) % _256n;         if (R &amp; _2n)             t ^= _1n &lt;&lt; ((_1n &lt;&lt; / @PURE / BigInt(j)) - _1n);     }     _SHA3_IOTA.push(t); } const IOTAS = split(_SHA3_IOTA, true); const SHA3_IOTA_H = IOTAS0; const SHA3_IOTA_L = IOTAS[1]; // Left rotation (without 0, 32, 64) const rotlH = (h, l, s) =&gt; (s &gt; 32 ? rotlBH(h, l, s) : rotlSH(h, l, s)); const rotlL = (h, l, s) =&gt; (s &gt; 32 ? rotlBL(h, l, s) : rotlSL(h, l, s)); /** <code>keccakf1600</code> internal function, additionally allows to adjust round count.</p>"},{"location":"autogenerated/code-summary/#isbytes","title":"isBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>isBytes(a)</code></p> <p>JSDoc:</p> <p>Utilities for hex, bytes, CSPRNG. @module / /! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) / // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+. // node.js versions earlier than v19 don't declare it in global scope. // For node.js, package.json#exports field mapping rewrites import // from <code>crypto</code> to <code>cryptoNode</code>, which imports native module. // Makes the utils un-importable in browsers without a bundler. // Once node.js 18 is deprecated (2025-04-30), we can just drop the import. import { crypto } from '@noble/hashes/crypto'; /** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true.</p>"},{"location":"autogenerated/code-summary/#anumber","title":"anumber","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>anumber(n)</code></p> <p>JSDoc:</p> <p>Asserts something is positive integer.</p>"},{"location":"autogenerated/code-summary/#abytes_1","title":"abytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>abytes(b, ...lengths)</code></p> <p>JSDoc:</p> <p>Asserts something is Uint8Array.</p>"},{"location":"autogenerated/code-summary/#ahash","title":"ahash","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>ahash(h)</code></p> <p>JSDoc:</p> <p>Asserts something is hash</p>"},{"location":"autogenerated/code-summary/#aexists","title":"aexists","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>aexists(instance, checkFinished = true)</code></p> <p>JSDoc:</p> <p>Asserts a hash instance has not been destroyed / finished</p>"},{"location":"autogenerated/code-summary/#aoutput","title":"aoutput","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>aoutput(out, instance)</code></p> <p>JSDoc:</p> <p>Asserts output is properly-sized byte array</p>"},{"location":"autogenerated/code-summary/#u8","title":"u8","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>u8(arr)</code></p> <p>JSDoc:</p> <p>Cast u8 / u16 / u32 to u8.</p>"},{"location":"autogenerated/code-summary/#u32","title":"u32","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>u32(arr)</code></p> <p>JSDoc:</p> <p>Cast u8 / u16 / u32 to u32.</p>"},{"location":"autogenerated/code-summary/#clean","title":"clean","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>clean(...arrays)</code></p> <p>JSDoc:</p> <p>Zeroize a byte array. Warning: JS provides no guarantees.</p>"},{"location":"autogenerated/code-summary/#createview","title":"createView","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>createView(arr)</code></p> <p>JSDoc:</p> <p>Create DataView of an array for easy byte-level manipulation.</p>"},{"location":"autogenerated/code-summary/#rotr","title":"rotr","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>rotr(word, shift)</code></p> <p>JSDoc:</p> <p>The rotate right (circular right shift) operation for uint32</p>"},{"location":"autogenerated/code-summary/#rotl","title":"rotl","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>rotl(word, shift)</code></p> <p>JSDoc:</p> <p>The rotate left (circular left shift) operation for uint32</p>"},{"location":"autogenerated/code-summary/#byteswap","title":"byteSwap","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>byteSwap(word)</code></p> <p>JSDoc:</p> <p>Is current platform little-endian? Most are. Big-Endian platform: IBM / export const isLE = / @PURE / (() =&gt; new Uint8Array(new Uint32Array([0x11223344]).buffer)0 === 0x44)(); /* The byte swap operation for uint32</p>"},{"location":"autogenerated/code-summary/#byteswap32","title":"byteSwap32","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>byteSwap32(arr)</code></p> <p>JSDoc:</p> <p>Conditionally byte swap if on a big-endian platform / export const swap8IfBE = isLE     ? (n) =&gt; n     : (n) =&gt; byteSwap(n); / @deprecated / export const byteSwapIfBE = swap8IfBE; /** In place byte swap for Uint32Array</p>"},{"location":"autogenerated/code-summary/#bytestohex","title":"bytesToHex","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>bytesToHex(bytes)</code></p> <p>JSDoc:</p> <p>Convert byte array to hex string. Uses built-in function, when available. @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'</p>"},{"location":"autogenerated/code-summary/#hextobytes","title":"hexToBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>hexToBytes(hex)</code></p> <p>JSDoc:</p> <p>Convert hex string to byte array. Uses built-in function, when available. @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])</p>"},{"location":"autogenerated/code-summary/#utf8tobytes","title":"utf8ToBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>utf8ToBytes(str)</code></p> <p>JSDoc:</p> <p>There is no setImmediate in browser and setTimeout is slow. Call of async fn will return Promise, which will be fullfiled only on next scheduler queue processing step and this is exactly what we need. / export const nextTick = async () =&gt; { }; / Returns control to thread each 'tick' ms to avoid blocking. */ export async function asyncLoop(iters, tick, cb) {     let ts = Date.now();     for (let i = 0; i &lt; iters; i++) {         cb(i);         // Date.now() is not monotonic, so in case if clock goes backwards we return return control too         const diff = Date.now() - ts;         if (diff &gt;= 0 &amp;&amp; diff &lt; tick)             continue;         await nextTick();         ts += diff;     } } / Converts string to bytes using UTF8 encoding. @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])</p>"},{"location":"autogenerated/code-summary/#bytestoutf8","title":"bytesToUtf8","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>bytesToUtf8(bytes)</code></p> <p>JSDoc:</p> <p>Converts bytes to string using UTF8 encoding. @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'</p>"},{"location":"autogenerated/code-summary/#tobytes","title":"toBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>toBytes(data)</code></p> <p>JSDoc:</p> <p>Normalizes (non-hex) string or Uint8Array to Uint8Array. Warning: when Uint8Array is passed, it would NOT get copied. Keep in mind for future mutable operations.</p>"},{"location":"autogenerated/code-summary/#kdfinputtobytes","title":"kdfInputToBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>kdfInputToBytes(data)</code></p> <p>JSDoc:</p> <p>Helper for KDFs: consumes uint8array or string. When string is passed, does utf8 decoding, using TextDecoder.</p>"},{"location":"autogenerated/code-summary/#concatbytes","title":"concatBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>concatBytes(...arrays)</code></p> <p>JSDoc:</p> <p>Copies several Uint8Arrays into one.</p>"},{"location":"autogenerated/code-summary/#createhasher","title":"createHasher","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>createHasher(hashCons)</code></p> <p>JSDoc:</p> <p>For runtime check if class implements interface / export class Hash { } /* Wraps hash function, creating an interface on top of it</p>"},{"location":"autogenerated/code-summary/#randombytes","title":"randomBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/esm/utils.js</code></p> <p>Signature: <code>randomBytes(bytesLength = 32)</code></p> <p>JSDoc:</p> <p>Cryptographically secure PRNG. Uses internal OS-level <code>crypto.getRandomValues</code>.</p>"},{"location":"autogenerated/code-summary/#sha1","title":"sha1","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/legacy.js</code></p> <p>Signature: <code>sha1(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>SHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions. Don't use them in a new protocol. What \"weak\" means:</p> <ul> <li>Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.</li> <li>No practical pre-image attacks (only theoretical, 2^123.4)</li> <li>HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151 @module / const _md_ts_1 = require(\"./_md.js\"); const utils_ts_1 = require(\"./utils.js\"); / Initial SHA1 state / const SHA1_IV = / @PURE / Uint32Array.from([     0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0, ]); // Reusable temporary buffer const SHA1_W = / @PURE */ new Uint32Array(80); / SHA1 legacy hash class. / class SHA1 extends _md_ts_1.HashMD {     constructor() {         super(64, 20, 8, false);         this.A = SHA1_IV0 | 0;         this.B = SHA1_IV[1] | 0;         this.C = SHA1_IV[2] | 0;         this.D = SHA1_IV[3] | 0;         this.E = SHA1_IV[4] | 0;     }     get() {         const { A, B, C, D, E } = this;         return [A, B, C, D, E];     }     set(A, B, C, D, E) {         this.A = A | 0;         this.B = B | 0;         this.C = C | 0;         this.D = D | 0;         this.E = E | 0;     }     process(view, offset) {         for (let i = 0; i &lt; 16; i++, offset += 4)             SHA1_W[i] = view.getUint32(offset, false);         for (let i = 16; i &lt; 80; i++)             SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);         // Compression function main loop, 80 rounds         let { A, B, C, D, E } = this;         for (let i = 0; i &lt; 80; i++) {             let F, K;             if (i &lt; 20) {                 F = (0, _md_ts_1.Chi)(B, C, D);                 K = 0x5a827999;             }             else if (i &lt; 40) {                 F = B ^ C ^ D;                 K = 0x6ed9eba1;             }             else if (i &lt; 60) {                 F = (0, _md_ts_1.Maj)(B, C, D);                 K = 0x8f1bbcdc;             }             else {                 F = B ^ C ^ D;                 K = 0xca62c1d6;             }             const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;             E = D;             D = C;             C = (0, utils_ts_1.rotl)(B, 30);             B = A;             A = T;         }         // Add the compressed chunk to the current hash value         A = (A + this.A) | 0;         B = (B + this.B) | 0;         C = (C + this.C) | 0;         D = (D + this.D) | 0;         E = (E + this.E) | 0;         this.set(A, B, C, D, E);     }     roundClean() {         (0, utils_ts_1.clean)(SHA1_W);     }     destroy() {         this.set(0, 0, 0, 0, 0);         (0, utils_ts_1.clean)(this.buffer);     } } exports.SHA1 = SHA1; /* SHA1 (RFC 3174) legacy hash function. It was cryptographically broken.</li> </ul>"},{"location":"autogenerated/code-summary/#md5","title":"md5","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/legacy.js</code></p> <p>Signature: <code>md5(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>Per-round constants / const p32 = / @PURE / Math.pow(2, 32); const K = / @PURE / Array.from({ length: 64 }, (_, i) =&gt; Math.floor(p32 * Math.abs(Math.sin(i + 1)))); / md5 initial state: same as sha1, but 4 u32 instead of 5. / const MD5_IV = / @PURE / SHA1_IV.slice(0, 4); // Reusable temporary buffer const MD5_W = / @PURE / new Uint32Array(16); / MD5 legacy hash class. */ class MD5 extends _md_ts_1.HashMD {     constructor() {         super(64, 16, 8, true);         this.A = MD5_IV0 | 0;         this.B = MD5_IV[1] | 0;         this.C = MD5_IV[2] | 0;         this.D = MD5_IV[3] | 0;     }     get() {         const { A, B, C, D } = this;         return [A, B, C, D];     }     set(A, B, C, D) {         this.A = A | 0;         this.B = B | 0;         this.C = C | 0;         this.D = D | 0;     }     process(view, offset) {         for (let i = 0; i &lt; 16; i++, offset += 4)             MD5_W[i] = view.getUint32(offset, true);         // Compression function main loop, 64 rounds         let { A, B, C, D } = this;         for (let i = 0; i &lt; 64; i++) {             let F, g, s;             if (i &lt; 16) {                 F = (0, _md_ts_1.Chi)(B, C, D);                 g = i;                 s = [7, 12, 17, 22];             }             else if (i &lt; 32) {                 F = (0, _md_ts_1.Chi)(D, B, C);                 g = (5 * i + 1) % 16;                 s = [5, 9, 14, 20];             }             else if (i &lt; 48) {                 F = B ^ C ^ D;                 g = (3 * i + 5) % 16;                 s = [4, 11, 16, 23];             }             else {                 F = C ^ (B | ~D);                 g = (7 * i) % 16;                 s = [6, 10, 15, 21];             }             F = F + A + K[i] + MD5_W[g];             A = D;             D = C;             C = B;             B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);         }         // Add the compressed chunk to the current hash value         A = (A + this.A) | 0;         B = (B + this.B) | 0;         C = (C + this.C) | 0;         D = (D + this.D) | 0;         this.set(A, B, C, D);     }     roundClean() {         (0, utils_ts_1.clean)(MD5_W);     }     destroy() {         this.set(0, 0, 0, 0);         (0, utils_ts_1.clean)(this.buffer);     } } exports.MD5 = MD5; / MD5 (RFC 1321) legacy hash function. It was cryptographically broken. MD5 architecture is similar to SHA1, with some differences: - Reduced output length: 16 bytes (128 bit) instead of 20 - 64 rounds, instead of 80 - Little-endian: could be faster, but will require more code - Non-linear index selection: huge speed-up for unroll - Per round constants: more memory accesses, additional speed-up for unroll</p>"},{"location":"autogenerated/code-summary/#ripemd160","title":"ripemd160","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/legacy.js</code></p> <p>Signature: <code>ripemd160(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>RIPEMD-160 - a legacy hash function from 1990s. * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf</p>"},{"location":"autogenerated/code-summary/#ripemd160_1","title":"RIPEMD160","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/ripemd160.js</code></p> <p>Signature: <code>RIPEMD160(= legacy_ts_1.RIPEMD160; /** @deprecated Use import from</code>noble/hashes/legacy<code>module */ exports.ripemd160 = legacy_ts_1.ripemd160; //# sourceMappingURL=ripemd160.js.map)</code></p> <p>JSDoc:</p> <p>RIPEMD-160 legacy hash function. https://homes.esat.kuleuven.be/~bosselae/ripemd160.html https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf @module @deprecated / const legacy_ts_1 = require(\"./legacy.js\"); /** @deprecated Use import from <code>noble/hashes/legacy</code> module</p>"},{"location":"autogenerated/code-summary/#sha1_1","title":"SHA1","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha1.js</code></p> <p>Signature: <code>SHA1(= legacy_ts_1.SHA1; /** @deprecated Use import from</code>noble/hashes/legacy<code>module */ exports.sha1 = legacy_ts_1.sha1; //# sourceMappingURL=sha1.js.map)</code></p> <p>JSDoc:</p> <p>SHA1 (RFC 3174) legacy hash function. @module @deprecated / const legacy_ts_1 = require(\"./legacy.js\"); /** @deprecated Use import from <code>noble/hashes/legacy</code> module</p>"},{"location":"autogenerated/code-summary/#sha256","title":"sha256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha2.js</code></p> <p>Signature: <code>sha256(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256. SHA256 is the fastest hash implementable in JS, even faster than Blake3. Check out RFC 4634 and FIPS 180-4. @module / const _md_ts_1 = require(\"./_md.js\"); const u64 = require(\"./_u64.js\"); const utils_ts_1 = require(\"./utils.js\"); / Round constants: First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311) / // prettier-ignore const SHA256_K = / @PURE / Uint32Array.from([     0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 ]); / Reusable temporary buffer. \"W\" comes straight from spec. / const SHA256_W = / @PURE / new Uint32Array(64); class SHA256 extends _md_ts_1.HashMD {     constructor(outputLen = 32) {         super(64, outputLen, 8, false);         // We cannot use array here since array allows indexing by variable         // which means optimizer/compiler cannot use registers.         this.A = _md_ts_1.SHA256_IV0 | 0;         this.B = _md_ts_1.SHA256_IV[1] | 0;         this.C = _md_ts_1.SHA256_IV[2] | 0;         this.D = _md_ts_1.SHA256_IV[3] | 0;         this.E = _md_ts_1.SHA256_IV[4] | 0;         this.F = _md_ts_1.SHA256_IV[5] | 0;         this.G = _md_ts_1.SHA256_IV[6] | 0;         this.H = _md_ts_1.SHA256_IV[7] | 0;     }     get() {         const { A, B, C, D, E, F, G, H } = this;         return [A, B, C, D, E, F, G, H];     }     // prettier-ignore     set(A, B, C, D, E, F, G, H) {         this.A = A | 0;         this.B = B | 0;         this.C = C | 0;         this.D = D | 0;         this.E = E | 0;         this.F = F | 0;         this.G = G | 0;         this.H = H | 0;     }     process(view, offset) {         // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array         for (let i = 0; i &lt; 16; i++, offset += 4)             SHA256_W[i] = view.getUint32(offset, false);         for (let i = 16; i &lt; 64; i++) {             const W15 = SHA256_W[i - 15];             const W2 = SHA256_W[i - 2];             const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 &gt;&gt;&gt; 3);             const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 &gt;&gt;&gt; 10);             SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;         }         // Compression function main loop, 64 rounds         let { A, B, C, D, E, F, G, H } = this;         for (let i = 0; i &lt; 64; i++) {             const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);             const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;             const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);             const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;             H = G;             G = F;             F = E;             E = (D + T1) | 0;             D = C;             C = B;             B = A;             A = (T1 + T2) | 0;         }         // Add the compressed chunk to the current hash value         A = (A + this.A) | 0;         B = (B + this.B) | 0;         C = (C + this.C) | 0;         D = (D + this.D) | 0;         E = (E + this.E) | 0;         F = (F + this.F) | 0;         G = (G + this.G) | 0;         H = (H + this.H) | 0;         this.set(A, B, C, D, E, F, G, H);     }     roundClean() {         (0, utils_ts_1.clean)(SHA256_W);     }     destroy() {         this.set(0, 0, 0, 0, 0, 0, 0, 0);         (0, utils_ts_1.clean)(this.buffer);     } } exports.SHA256 = SHA256; class SHA224 extends SHA256 {     constructor() {         super(28);         this.A = _md_ts_1.SHA224_IV0 | 0;         this.B = _md_ts_1.SHA224_IV[1] | 0;         this.C = _md_ts_1.SHA224_IV[2] | 0;         this.D = _md_ts_1.SHA224_IV[3] | 0;         this.E = _md_ts_1.SHA224_IV[4] | 0;         this.F = _md_ts_1.SHA224_IV[5] | 0;         this.G = _md_ts_1.SHA224_IV[6] | 0;         this.H = _md_ts_1.SHA224_IV[7] | 0;     } } exports.SHA224 = SHA224; // SHA2-512 is slower than sha256 in js because u64 operations are slow. // Round contants // First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409 // prettier-ignore const K512 = / @PURE / (() =&gt; u64.split([     '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',     '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',     '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',     '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',     '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',     '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',     '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',     '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',     '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',     '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',     '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',     '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',     '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',     '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',     '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',     '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',     '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',     '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',     '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',     '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817' ].map(n =&gt; BigInt(n))))(); const SHA512_Kh = / @PURE / (() =&gt; K5120)(); const SHA512_Kl = / @PURE / (() =&gt; K512[1])(); // Reusable temporary buffers const SHA512_W_H = / @PURE / new Uint32Array(80); const SHA512_W_L = / @PURE / new Uint32Array(80); class SHA512 extends _md_ts_1.HashMD {     constructor(outputLen = 64) {         super(128, outputLen, 16, false);         // We cannot use array here since array allows indexing by variable         // which means optimizer/compiler cannot use registers.         // h -- high 32 bits, l -- low 32 bits         this.Ah = _md_ts_1.SHA512_IV0 | 0;         this.Al = _md_ts_1.SHA512_IV[1] | 0;         this.Bh = _md_ts_1.SHA512_IV[2] | 0;         this.Bl = _md_ts_1.SHA512_IV[3] | 0;         this.Ch = _md_ts_1.SHA512_IV[4] | 0;         this.Cl = _md_ts_1.SHA512_IV[5] | 0;         this.Dh = _md_ts_1.SHA512_IV[6] | 0;         this.Dl = _md_ts_1.SHA512_IV[7] | 0;         this.Eh = _md_ts_1.SHA512_IV[8] | 0;         this.El = _md_ts_1.SHA512_IV[9] | 0;         this.Fh = _md_ts_1.SHA512_IV[10] | 0;         this.Fl = _md_ts_1.SHA512_IV[11] | 0;         this.Gh = _md_ts_1.SHA512_IV[12] | 0;         this.Gl = _md_ts_1.SHA512_IV[13] | 0;         this.Hh = _md_ts_1.SHA512_IV[14] | 0;         this.Hl = _md_ts_1.SHA512_IV[15] | 0;     }     // prettier-ignore     get() {         const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;         return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];     }     // prettier-ignore     set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {         this.Ah = Ah | 0;         this.Al = Al | 0;         this.Bh = Bh | 0;         this.Bl = Bl | 0;         this.Ch = Ch | 0;         this.Cl = Cl | 0;         this.Dh = Dh | 0;         this.Dl = Dl | 0;         this.Eh = Eh | 0;         this.El = El | 0;         this.Fh = Fh | 0;         this.Fl = Fl | 0;         this.Gh = Gh | 0;         this.Gl = Gl | 0;         this.Hh = Hh | 0;         this.Hl = Hl | 0;     }     process(view, offset) {         // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array         for (let i = 0; i &lt; 16; i++, offset += 4) {             SHA512_W_H[i] = view.getUint32(offset);             SHA512_W_L[i] = view.getUint32((offset += 4));         }         for (let i = 16; i &lt; 80; i++) {             // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)             const W15h = SHA512_W_H[i - 15] | 0;             const W15l = SHA512_W_L[i - 15] | 0;             const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);             const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);             // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)             const W2h = SHA512_W_H[i - 2] | 0;             const W2l = SHA512_W_L[i - 2] | 0;             const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);             const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);             // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];             const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);             const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);             SHA512_W_H[i] = SUMh | 0;             SHA512_W_L[i] = SUMl | 0;         }         let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;         // Compression function main loop, 80 rounds         for (let i = 0; i &lt; 80; i++) {             // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)             const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);             const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);             //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;             const CHIh = (Eh &amp; Fh) ^ (~Eh &amp; Gh);             const CHIl = (El &amp; Fl) ^ (~El &amp; Gl);             // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]             // prettier-ignore             const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);             const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);             const T1l = T1ll | 0;             // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)             const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);             const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);             const MAJh = (Ah &amp; Bh) ^ (Ah &amp; Ch) ^ (Bh &amp; Ch);             const MAJl = (Al &amp; Bl) ^ (Al &amp; Cl) ^ (Bl &amp; Cl);             Hh = Gh | 0;             Hl = Gl | 0;             Gh = Fh | 0;             Gl = Fl | 0;             Fh = Eh | 0;             Fl = El | 0;             ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));             Dh = Ch | 0;             Dl = Cl | 0;             Ch = Bh | 0;             Cl = Bl | 0;             Bh = Ah | 0;             Bl = Al | 0;             const All = u64.add3L(T1l, sigma0l, MAJl);             Ah = u64.add3H(All, T1h, sigma0h, MAJh);             Al = All | 0;         }         // Add the compressed chunk to the current hash value         ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));         ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));         ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));         ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));         ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));         ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));         ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));         ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));         this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);     }     roundClean() {         (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);     }     destroy() {         (0, utils_ts_1.clean)(this.buffer);         this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);     } } exports.SHA512 = SHA512; class SHA384 extends SHA512 {     constructor() {         super(48);         this.Ah = _md_ts_1.SHA384_IV0 | 0;         this.Al = _md_ts_1.SHA384_IV[1] | 0;         this.Bh = _md_ts_1.SHA384_IV[2] | 0;         this.Bl = _md_ts_1.SHA384_IV[3] | 0;         this.Ch = _md_ts_1.SHA384_IV[4] | 0;         this.Cl = _md_ts_1.SHA384_IV[5] | 0;         this.Dh = _md_ts_1.SHA384_IV[6] | 0;         this.Dl = _md_ts_1.SHA384_IV[7] | 0;         this.Eh = _md_ts_1.SHA384_IV[8] | 0;         this.El = _md_ts_1.SHA384_IV[9] | 0;         this.Fh = _md_ts_1.SHA384_IV[10] | 0;         this.Fl = _md_ts_1.SHA384_IV[11] | 0;         this.Gh = _md_ts_1.SHA384_IV[12] | 0;         this.Gl = _md_ts_1.SHA384_IV[13] | 0;         this.Hh = _md_ts_1.SHA384_IV[14] | 0;         this.Hl = _md_ts_1.SHA384_IV[15] | 0;     } } exports.SHA384 = SHA384; / Truncated SHA512/256 and SHA512/224. SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t. Then t hashes string to produce result IV. See <code>test/misc/sha2-gen-iv.js</code>. / / SHA512/224 IV / const T224_IV = / @PURE / Uint32Array.from([     0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,     0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1, ]); / SHA512/256 IV / const T256_IV = / @PURE */ Uint32Array.from([     0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,     0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2, ]); class SHA512_224 extends SHA512 {     constructor() {         super(28);         this.Ah = T224_IV0 | 0;         this.Al = T224_IV[1] | 0;         this.Bh = T224_IV[2] | 0;         this.Bl = T224_IV[3] | 0;         this.Ch = T224_IV[4] | 0;         this.Cl = T224_IV[5] | 0;         this.Dh = T224_IV[6] | 0;         this.Dl = T224_IV[7] | 0;         this.Eh = T224_IV[8] | 0;         this.El = T224_IV[9] | 0;         this.Fh = T224_IV[10] | 0;         this.Fl = T224_IV[11] | 0;         this.Gh = T224_IV[12] | 0;         this.Gl = T224_IV[13] | 0;         this.Hh = T224_IV[14] | 0;         this.Hl = T224_IV[15] | 0;     } } exports.SHA512_224 = SHA512_224; class SHA512_256 extends SHA512 {     constructor() {         super(32);         this.Ah = T256_IV0 | 0;         this.Al = T256_IV[1] | 0;         this.Bh = T256_IV[2] | 0;         this.Bl = T256_IV[3] | 0;         this.Ch = T256_IV[4] | 0;         this.Cl = T256_IV[5] | 0;         this.Dh = T256_IV[6] | 0;         this.Dl = T256_IV[7] | 0;         this.Eh = T256_IV[8] | 0;         this.El = T256_IV[9] | 0;         this.Fh = T256_IV[10] | 0;         this.Fl = T256_IV[11] | 0;         this.Gh = T256_IV[12] | 0;         this.Gl = T256_IV[13] | 0;         this.Hh = T256_IV[14] | 0;         this.Hl = T256_IV[15] | 0;     } } exports.SHA512_256 = SHA512_256; / SHA2-256 hash function from RFC 4634.</p> <p>It is the fastest JS hash, even faster than Blake3. To break sha256 using birthday attack, attackers need to try 2^128 hashes. BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.</p>"},{"location":"autogenerated/code-summary/#sha224","title":"sha224","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha2.js</code></p> <p>Signature: <code>sha224(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>SHA2-224 hash function from RFC 4634</p>"},{"location":"autogenerated/code-summary/#sha512","title":"sha512","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha2.js</code></p> <p>Signature: <code>sha512(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>SHA2-512 hash function from RFC 4634.</p>"},{"location":"autogenerated/code-summary/#sha384","title":"sha384","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha2.js</code></p> <p>Signature: <code>sha384(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>SHA2-384 hash function from RFC 4634.</p>"},{"location":"autogenerated/code-summary/#sha512_256","title":"sha512_256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha2.js</code></p> <p>Signature: <code>sha512_256(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks. See the paper on truncated SHA512.</p>"},{"location":"autogenerated/code-summary/#sha512_224","title":"sha512_224","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha2.js</code></p> <p>Signature: <code>sha512_224(= (0, utils_ts_1.createHasher)</code></p> <p>JSDoc:</p> <p>SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks. See the paper on truncated SHA512.</p>"},{"location":"autogenerated/code-summary/#sha256_1","title":"SHA256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha256.js</code></p> <p>Signature: <code>SHA256(= sha2_ts_1.SHA256; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.sha256 = sha2_ts_1.sha256; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.SHA224 = sha2_ts_1.SHA224; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.sha224 = sha2_ts_1.sha224; //# sourceMappingURL=sha256.js.map)</code></p> <p>JSDoc:</p> <p>SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.</p> <p>To break sha256 using birthday attack, attackers need to try 2^128 hashes. BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.</p> <p>Check out FIPS 180-4. @module @deprecated / const sha2_ts_1 = require(\"./sha2.js\"); /** @deprecated Use import from <code>noble/hashes/sha2</code> module</p>"},{"location":"autogenerated/code-summary/#tuplehash128","title":"tuplehash128","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>tuplehash128(= (()</code></p> <p>JSDoc:</p> <p>SHA3 (keccak) addons.</p> <ul> <li>Full NIST SP 800-185:   cSHAKE, KMAC, TupleHash, ParallelHash + XOF variants</li> <li>Reduced-round Keccak (draft):<ul> <li>\ud83e\udd98 K12 aka KangarooTwelve</li> <li>M14 aka MarsupilamiFourteen</li> <li>TurboSHAKE</li> </ul> </li> <li>KeccakPRG: Pseudo-random generator based on Keccak (pdf) @module / const sha3_ts_1 = require(\"./sha3.js\"); const utils_ts_1 = require(\"./utils.js\"); // cSHAKE &amp;&amp; KMAC (NIST SP800-185) const _8n = BigInt(8); const _ffn = BigInt(0xff); // NOTE: it is safe to use bigints here, since they used only for length encoding (not actual data). // We use bigints in sha256 for lengths too. function leftEncode(n) {     n = BigInt(n);     const res = [Number(n &amp; _ffn)];     n &gt;&gt;= _8n;     for (; n &gt; 0; n &gt;&gt;= _8n)         res.unshift(Number(n &amp; _ffn));     res.unshift(res.length);     return new Uint8Array(res); } function rightEncode(n) {     n = BigInt(n);     const res = [Number(n &amp; _ffn)];     n &gt;&gt;= _8n;     for (; n &gt; 0; n &gt;&gt;= _8n)         res.unshift(Number(n &amp; _ffn));     res.push(res.length);     return new Uint8Array(res); } function chooseLen(opts, outputLen) {     return opts.dkLen === undefined ? outputLen : opts.dkLen; } const abytesOrZero = (buf) =&gt; {     if (buf === undefined)         return Uint8Array.of();     return (0, utils_ts_1.toBytes)(buf); }; // NOTE: second modulo is necessary since we don't need to add padding if current element takes whole block const getPadding = (len, block) =&gt; new Uint8Array((block - (len % block)) % block); // Personalization function cshakePers(hash, opts = {}) {     if (!opts || (!opts.personalization &amp;&amp; !opts.NISTfn))         return hash;     // Encode and pad inplace to avoid unneccesary memory copies/slices (so we don't need to zero them later)     // bytepad(encode_string(N) || encode_string(S), 168)     const blockLenBytes = leftEncode(hash.blockLen);     const fn = abytesOrZero(opts.NISTfn);     const fnLen = leftEncode(_8n * BigInt(fn.length)); // length in bits     const pers = abytesOrZero(opts.personalization);     const persLen = leftEncode(_8n * BigInt(pers.length)); // length in bits     if (!fn.length &amp;&amp; !pers.length)         return hash;     hash.suffix = 0x04;     hash.update(blockLenBytes).update(fnLen).update(fn).update(persLen).update(pers);     let totalLen = blockLenBytes.length + fnLen.length + fn.length + persLen.length + pers.length;     hash.update(getPadding(totalLen, hash.blockLen));     return hash; } const gencShake = (suffix, blockLen, outputLen) =&gt; (0, utils_ts_1.createXOFer)((opts = {}) =&gt; cshakePers(new sha3_ts_1.Keccak(blockLen, suffix, chooseLen(opts, outputLen), true), opts)); exports.cshake128 = (() =&gt; gencShake(0x1f, 168, 128 / 8))(); exports.cshake256 = (() =&gt; gencShake(0x1f, 136, 256 / 8))(); class KMAC extends sha3_ts_1.Keccak {     constructor(blockLen, outputLen, enableXOF, key, opts = {}) {         super(blockLen, 0x1f, outputLen, enableXOF);         cshakePers(this, { NISTfn: 'KMAC', personalization: opts.personalization });         key = (0, utils_ts_1.toBytes)(key);         (0, utils_ts_1.abytes)(key);         // 1. newX = bytepad(encode_string(K), 168) || X || right_encode(L).         const blockLenBytes = leftEncode(this.blockLen);         const keyLen = leftEncode(_8n * BigInt(key.length));         this.update(blockLenBytes).update(keyLen).update(key);         const totalLen = blockLenBytes.length + keyLen.length + key.length;         this.update(getPadding(totalLen, this.blockLen));     }     finish() {         if (!this.finished)             this.update(rightEncode(this.enableXOF ? 0 : _8n * BigInt(this.outputLen))); // outputLen in bits         super.finish();     }     _cloneInto(to) {         // Create new instance without calling constructor since key already in state and we don't know it.         // Force \"to\" to be instance of KMAC instead of Sha3.         if (!to) {             to = Object.create(Object.getPrototypeOf(this), {});             to.state = this.state.slice();             to.blockLen = this.blockLen;             to.state32 = (0, utils_ts_1.u32)(to.state);         }         return super._cloneInto(to);     }     clone() {         return this._cloneInto();     } } exports.KMAC = KMAC; function genKmac(blockLen, outputLen, xof = false) {     const kmac = (key, message, opts) =&gt; kmac.create(key, opts).update(message).digest();     kmac.create = (key, opts = {}) =&gt; new KMAC(blockLen, chooseLen(opts, outputLen), xof, key, opts);     return kmac; } exports.kmac128 = (() =&gt; genKmac(168, 128 / 8))(); exports.kmac256 = (() =&gt; genKmac(136, 256 / 8))(); exports.kmac128xof = (() =&gt; genKmac(168, 128 / 8, true))(); exports.kmac256xof = (() =&gt; genKmac(136, 256 / 8, true))(); // TupleHash // Usage: tuple(['ab', 'cd']) != tuple(['a', 'bcd']) class TupleHash extends sha3_ts_1.Keccak {     constructor(blockLen, outputLen, enableXOF, opts = {}) {         super(blockLen, 0x1f, outputLen, enableXOF);         cshakePers(this, { NISTfn: 'TupleHash', personalization: opts.personalization });         // Change update after cshake processed         this.update = (data) =&gt; {             data = (0, utils_ts_1.toBytes)(data);             (0, utils_ts_1.abytes)(data);             super.update(leftEncode(_8n * BigInt(data.length)));             super.update(data);             return this;         };     }     finish() {         if (!this.finished)             super.update(rightEncode(this.enableXOF ? 0 : _8n * BigInt(this.outputLen))); // outputLen in bits         super.finish();     }     _cloneInto(to) {         to || (to = new TupleHash(this.blockLen, this.outputLen, this.enableXOF));         return super._cloneInto(to);     }     clone() {         return this._cloneInto();     } } exports.TupleHash = TupleHash; function genTuple(blockLen, outputLen, xof = false) {     const tuple = (messages, opts) =&gt; {         const h = tuple.create(opts);         for (const msg of messages)             h.update(msg);         return h.digest();     };     tuple.create = (opts = {}) =&gt; new TupleHash(blockLen, chooseLen(opts, outputLen), xof, opts);     return tuple; } /** 128-bit TupleHASH.</li> </ul>"},{"location":"autogenerated/code-summary/#tuplehash256","title":"tuplehash256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>tuplehash256(= (()</code></p> <p>JSDoc:</p> <p>256-bit TupleHASH.</p>"},{"location":"autogenerated/code-summary/#tuplehash128xof","title":"tuplehash128xof","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>tuplehash128xof(= (()</code></p> <p>JSDoc:</p> <p>128-bit TupleHASH XOF.</p>"},{"location":"autogenerated/code-summary/#tuplehash256xof","title":"tuplehash256xof","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>tuplehash256xof(= (()</code></p> <p>JSDoc:</p> <p>256-bit TupleHASH XOF.</p>"},{"location":"autogenerated/code-summary/#parallelhash128","title":"parallelhash128","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>parallelhash128(= (()</code></p> <p>JSDoc:</p> <p>128-bit ParallelHash. In JS, it is not parallel.</p>"},{"location":"autogenerated/code-summary/#parallelhash256","title":"parallelhash256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>parallelhash256(= (()</code></p> <p>JSDoc:</p> <p>256-bit ParallelHash. In JS, it is not parallel.</p>"},{"location":"autogenerated/code-summary/#parallelhash128xof","title":"parallelhash128xof","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>parallelhash128xof(= (()</code></p> <p>JSDoc:</p> <p>128-bit ParallelHash XOF. In JS, it is not parallel.</p>"},{"location":"autogenerated/code-summary/#parallelhash256xof","title":"parallelhash256xof","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>parallelhash256xof(= (()</code></p> <p>JSDoc:</p> <p>256-bit ParallelHash. In JS, it is not parallel.</p>"},{"location":"autogenerated/code-summary/#turboshake128","title":"turboshake128","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>turboshake128(= genTurboshake(168, 256 / 8)</code></p> <p>JSDoc:</p> <p>TurboSHAKE 128-bit: reduced 12-round keccak.</p>"},{"location":"autogenerated/code-summary/#turboshake256","title":"turboshake256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>turboshake256(= genTurboshake(136, 512 / 8)</code></p> <p>JSDoc:</p> <p>TurboSHAKE 256-bit: reduced 12-round keccak.</p>"},{"location":"autogenerated/code-summary/#k12","title":"k12","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>k12(= (()</code></p> <p>JSDoc:</p> <p>KangarooTwelve: reduced 12-round keccak.</p>"},{"location":"autogenerated/code-summary/#m14","title":"m14","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3-addons.js</code></p> <p>Signature: <code>m14(= (()</code></p> <p>JSDoc:</p> <p>MarsupilamiFourteen: reduced 14-round keccak.</p>"},{"location":"autogenerated/code-summary/#sha3_224","title":"sha3_224","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>sha3_224(= (()</code></p> <p>JSDoc:</p> <p>SHA3 (keccak) hash function, based on a new \"Sponge function\" design. Different from older hashes, the internal state is bigger than output size.</p> <p>Check out FIPS-202, Website, the differences between SHA-3 and Keccak.</p> <p>Check out <code>sha3-addons</code> module for cSHAKE, k12, and others. @module / const _u64_ts_1 = require(\"./_u64.js\"); // prettier-ignore const utils_ts_1 = require(\"./utils.js\"); // No PURE annotations in sha3 header: // EVERYTHING is in fact used on every export. // Various per round constants calculations const _0n = BigInt(0); const _1n = BigInt(1); const _2n = BigInt(2); const _7n = BigInt(7); const _256n = BigInt(256); const _0x71n = BigInt(0x71); const SHA3_PI = []; const SHA3_ROTL = []; const _SHA3_IOTA = []; for (let round = 0, R = _1n, x = 1, y = 0; round &lt; 24; round++) {     // Pi     [x, y] = [y, (2 * x + 3 * y) % 5];     SHA3_PI.push(2 * (5 * y + x));     // Rotational     SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);     // Iota     let t = _0n;     for (let j = 0; j &lt; 7; j++) {         R = ((R &lt;&lt; _1n) ^ ((R &gt;&gt; _7n) * _0x71n)) % _256n;         if (R &amp; _2n)             t ^= _1n &lt;&lt; ((_1n &lt;&lt; / @PURE / BigInt(j)) - _1n);     }     _SHA3_IOTA.push(t); } const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true); const SHA3_IOTA_H = IOTAS0; const SHA3_IOTA_L = IOTAS[1]; // Left rotation (without 0, 32, 64) const rotlH = (h, l, s) =&gt; (s &gt; 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s)); const rotlL = (h, l, s) =&gt; (s &gt; 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s)); / <code>keccakf1600</code> internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {     const B = new Uint32Array(5 * 2);     // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)     for (let round = 24 - rounds; round &lt; 24; round++) {         // Theta \u03b8         for (let x = 0; x &lt; 10; x++)             B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];         for (let x = 0; x &lt; 10; x += 2) {             const idx1 = (x + 8) % 10;             const idx0 = (x + 2) % 10;             const B0 = B[idx0];             const B1 = B[idx0 + 1];             const Th = rotlH(B0, B1, 1) ^ B[idx1];             const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];             for (let y = 0; y &lt; 50; y += 10) {                 s[x + y] ^= Th;                 s[x + y + 1] ^= Tl;             }         }         // Rho (\u03c1) and Pi (\u03c0)         let curH = s[2];         let curL = s[3];         for (let t = 0; t &lt; 24; t++) {             const shift = SHA3_ROTL[t];             const Th = rotlH(curH, curL, shift);             const Tl = rotlL(curH, curL, shift);             const PI = SHA3_PI[t];             curH = s[PI];             curL = s[PI + 1];             s[PI] = Th;             s[PI + 1] = Tl;         }         // Chi (\u03c7)         for (let y = 0; y &lt; 50; y += 10) {             for (let x = 0; x &lt; 10; x++)                 B[x] = s[y + x];             for (let x = 0; x &lt; 10; x++)                 s[y + x] ^= ~B[(x + 2) % 10] &amp; B[(x + 4) % 10];         }         // Iota (\u03b9)         s0 ^= SHA3_IOTA_H[round];         s[1] ^= SHA3_IOTA_L[round];     }     (0, utils_ts_1.clean)(B); } / Keccak sponge function. / class Keccak extends utils_ts_1.Hash {     // NOTE: we accept arguments in bytes instead of bits here.     constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {         super();         this.pos = 0;         this.posOut = 0;         this.finished = false;         this.destroyed = false;         this.enableXOF = false;         this.blockLen = blockLen;         this.suffix = suffix;         this.outputLen = outputLen;         this.enableXOF = enableXOF;         this.rounds = rounds;         // Can be passed from user as dkLen         (0, utils_ts_1.anumber)(outputLen);         // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes         // 0 &lt; blockLen &lt; 200         if (!(0 &lt; blockLen &amp;&amp; blockLen &lt; 200))             throw new Error('only keccak-f1600 function is supported');         this.state = new Uint8Array(200);         this.state32 = (0, utils_ts_1.u32)(this.state);     }     clone() {         return this._cloneInto();     }     keccak() {         (0, utils_ts_1.swap32IfBE)(this.state32);         keccakP(this.state32, this.rounds);         (0, utils_ts_1.swap32IfBE)(this.state32);         this.posOut = 0;         this.pos = 0;     }     update(data) {         (0, utils_ts_1.aexists)(this);         data = (0, utils_ts_1.toBytes)(data);         (0, utils_ts_1.abytes)(data);         const { blockLen, state } = this;         const len = data.length;         for (let pos = 0; pos &lt; len;) {             const take = Math.min(blockLen - this.pos, len - pos);             for (let i = 0; i &lt; take; i++)                 state[this.pos++] ^= data[pos++];             if (this.pos === blockLen)                 this.keccak();         }         return this;     }     finish() {         if (this.finished)             return;         this.finished = true;         const { state, suffix, pos, blockLen } = this;         // Do the padding         state[pos] ^= suffix;         if ((suffix &amp; 0x80) !== 0 &amp;&amp; pos === blockLen - 1)             this.keccak();         state[blockLen - 1] ^= 0x80;         this.keccak();     }     writeInto(out) {         (0, utils_ts_1.aexists)(this, false);         (0, utils_ts_1.abytes)(out);         this.finish();         const bufferOut = this.state;         const { blockLen } = this;         for (let pos = 0, len = out.length; pos &lt; len;) {             if (this.posOut &gt;= blockLen)                 this.keccak();             const take = Math.min(blockLen - this.posOut, len - pos);             out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);             this.posOut += take;             pos += take;         }         return out;     }     xofInto(out) {         // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF         if (!this.enableXOF)             throw new Error('XOF is not possible for this instance');         return this.writeInto(out);     }     xof(bytes) {         (0, utils_ts_1.anumber)(bytes);         return this.xofInto(new Uint8Array(bytes));     }     digestInto(out) {         (0, utils_ts_1.aoutput)(out, this);         if (this.finished)             throw new Error('digest() was already called');         this.writeInto(out);         this.destroy();         return out;     }     digest() {         return this.digestInto(new Uint8Array(this.outputLen));     }     destroy() {         this.destroyed = true;         (0, utils_ts_1.clean)(this.state);     }     _cloneInto(to) {         const { blockLen, suffix, outputLen, rounds, enableXOF } = this;         to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));         to.state32.set(this.state32);         to.pos = this.pos;         to.posOut = this.posOut;         to.finished = this.finished;         to.rounds = rounds;         // Suffix can change in cSHAKE         to.suffix = suffix;         to.outputLen = outputLen;         to.enableXOF = enableXOF;         to.destroyed = this.destroyed;         return to;     } } exports.Keccak = Keccak; const gen = (suffix, blockLen, outputLen) =&gt; (0, utils_ts_1.createHasher)(() =&gt; new Keccak(blockLen, suffix, outputLen)); /* SHA3-224 hash function.</p>"},{"location":"autogenerated/code-summary/#sha3_256","title":"sha3_256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>sha3_256(= (()</code></p> <p>JSDoc:</p> <p>SHA3-256 hash function. Different from keccak-256.</p>"},{"location":"autogenerated/code-summary/#sha3_384","title":"sha3_384","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>sha3_384(= (()</code></p> <p>JSDoc:</p> <p>SHA3-384 hash function.</p>"},{"location":"autogenerated/code-summary/#sha3_512","title":"sha3_512","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>sha3_512(= (()</code></p> <p>JSDoc:</p> <p>SHA3-512 hash function.</p>"},{"location":"autogenerated/code-summary/#keccak_224","title":"keccak_224","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>keccak_224(= (()</code></p> <p>JSDoc:</p> <p>keccak-224 hash function.</p>"},{"location":"autogenerated/code-summary/#keccak_256","title":"keccak_256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>keccak_256(= (()</code></p> <p>JSDoc:</p> <p>keccak-256 hash function. Different from SHA3-256.</p>"},{"location":"autogenerated/code-summary/#keccak_384","title":"keccak_384","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>keccak_384(= (()</code></p> <p>JSDoc:</p> <p>keccak-384 hash function.</p>"},{"location":"autogenerated/code-summary/#keccak_512","title":"keccak_512","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>keccak_512(= (()</code></p> <p>JSDoc:</p> <p>keccak-512 hash function.</p>"},{"location":"autogenerated/code-summary/#shake128","title":"shake128","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>shake128(= (()</code></p> <p>JSDoc:</p> <p>SHAKE128 XOF with 128-bit security.</p>"},{"location":"autogenerated/code-summary/#shake256","title":"shake256","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha3.js</code></p> <p>Signature: <code>shake256(= (()</code></p> <p>JSDoc:</p> <p>SHAKE256 XOF with 256-bit security.</p>"},{"location":"autogenerated/code-summary/#sha512_1","title":"SHA512","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/sha512.js</code></p> <p>Signature: <code>SHA512(= sha2_ts_1.SHA512; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.sha512 = sha2_ts_1.sha512; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.SHA384 = sha2_ts_1.SHA384; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.sha384 = sha2_ts_1.sha384; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.SHA512_224 = sha2_ts_1.SHA512_224; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.sha512_224 = sha2_ts_1.sha512_224; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.SHA512_256 = sha2_ts_1.SHA512_256; /** @deprecated Use import from</code>noble/hashes/sha2<code>module */ exports.sha512_256 = sha2_ts_1.sha512_256; //# sourceMappingURL=sha512.js.map)</code></p> <p>JSDoc:</p> <p>SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.</p> <p>Check out RFC 4634 and the paper on truncated SHA512/256. @module @deprecated / const sha2_ts_1 = require(\"./sha2.js\"); /** @deprecated Use import from <code>noble/hashes/sha2</code> module</p>"},{"location":"autogenerated/code-summary/#setbiguint64_1","title":"setBigUint64","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/_md.ts</code></p> <p>Signature: <code>setBigUint64(   view: DataView,   byteOffset: number,   value: bigint,   isLE: boolean )</code></p> <p>JSDoc:</p> <p>Internal Merkle-Damgard hash utils. @module / import { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';</p> <p>/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64</p>"},{"location":"autogenerated/code-summary/#chi_1","title":"Chi","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/_md.ts</code></p> <p>Signature: <code>Chi(a: number, b: number, c: number)</code></p> <p>JSDoc:</p> <p>Choice: a ? b : c</p>"},{"location":"autogenerated/code-summary/#maj_1","title":"Maj","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/_md.ts</code></p> <p>Signature: <code>Maj(a: number, b: number, c: number)</code></p> <p>JSDoc:</p> <p>Majority function, true if any two inputs is true.</p>"},{"location":"autogenerated/code-summary/#derivemainseed_1","title":"deriveMainSeed","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/eskdf.ts</code></p> <p>Signature: <code>deriveMainSeed(username: string, password: string)</code></p> <p>JSDoc:</p> <p>Experimental KDF for AES. / import { hkdf } from './hkdf.ts'; import { pbkdf2 as _pbkdf2 } from './pbkdf2.ts'; import { scrypt as _scrypt } from './scrypt.ts'; import { sha256 } from './sha256.ts'; import { abytes, bytesToHex, clean, createView, hexToBytes, kdfInputToBytes } from './utils.ts';</p> <p>// A tiny KDF for various applications like AES key-gen. // Uses HKDF in a non-standard way, so it's not \"KDF-secure\", only \"PRF-secure\". // Which is good enough: assume sha2-256 retained preimage resistance.</p> <p>const SCRYPT_FACTOR = 2 ** 19; const PBKDF2_FACTOR = 2 ** 17;</p> <p>// Scrypt KDF export function scrypt(password: string, salt: string): Uint8Array {   return _scrypt(password, salt, { N: SCRYPT_FACTOR, r: 8, p: 1, dkLen: 32 }); }</p> <p>// PBKDF2-HMAC-SHA256 export function pbkdf2(password: string, salt: string): Uint8Array {   return _pbkdf2(sha256, password, salt, { c: PBKDF2_FACTOR, dkLen: 32 }); }</p> <p>// Combines two 32-byte byte arrays function xor32(a: Uint8Array, b: Uint8Array): Uint8Array {   abytes(a, 32);   abytes(b, 32);   const arr = new Uint8Array(32);   for (let i = 0; i &lt; 32; i++) {     arr[i] = a[i] ^ b[i];   }   return arr; }</p> <p>function strHasLength(str: string, min: number, max: number): boolean {   return typeof str === 'string' &amp;&amp; str.length &gt;= min &amp;&amp; str.length &lt;= max; }</p> <p>/** Derives main seed. Takes a lot of time. Prefer <code>eskdf</code> method instead.</p>"},{"location":"autogenerated/code-summary/#extract_1","title":"extract","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/hkdf.ts</code></p> <p>Signature: <code>extract(hash: CHash, ikm: Input, salt?: Input)</code></p> <p>JSDoc:</p> <p>HKDF (RFC 5869): extract + expand in one step. See https://soatok.blog/2021/11/17/understanding-hkdf/. @module / import { hmac } from './hmac.ts'; import { ahash, anumber, type CHash, clean, type Input, toBytes } from './utils.ts';</p> <p>/** HKDF-extract from spec. Less important part. <code>HKDF-Extract(IKM, salt) -&gt; PRK</code> Arguments position differs from spec (IKM is first one, since it is not optional) @param hash - hash function that would be used (e.g. sha256) @param ikm - input keying material, the initial key @param salt - optional salt value (a non-secret random value)</p>"},{"location":"autogenerated/code-summary/#expand_1","title":"expand","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/hkdf.ts</code></p> <p>Signature: <code>expand(hash: CHash, prk: Input, info?: Input, length: number = 32)</code></p> <p>JSDoc:</p> <p>HKDF-expand from the spec. The most important part. <code>HKDF-Expand(PRK, info, L) -&gt; OKM</code> @param hash - hash function that would be used (e.g. sha256) @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step) @param info - optional context and application specific information (can be a zero-length string) @param length - length of output keying material in bytes</p>"},{"location":"autogenerated/code-summary/#pbkdf2_1","title":"pbkdf2","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/pbkdf2.ts</code></p> <p>Signature: <code>pbkdf2(   hash: CHash,   password: KDFInput,   salt: KDFInput,   opts: Pbkdf2Opt )</code></p> <p>JSDoc:</p> <p>PBKDF (RFC 2898). Can be used to create a key from password and salt. @module / import { hmac } from './hmac.ts'; // prettier-ignore import {   ahash, anumber,   asyncLoop, checkOpts, clean, createView, Hash, kdfInputToBytes,   type CHash,   type KDFInput } from './utils.ts';</p> <p>export type Pbkdf2Opt = {   c: number; // Iterations   dkLen?: number; // Desired key length in bytes (Intended output length in octets of the derived key   asyncTick?: number; // Maximum time in ms for which async function can block execution }; // Common prologue and epilogue for sync/async functions function pbkdf2Init(hash: CHash, _password: KDFInput, _salt: KDFInput, _opts: Pbkdf2Opt) {   ahash(hash);   const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);   const { c, dkLen, asyncTick } = opts;   anumber(c);   anumber(dkLen);   anumber(asyncTick);   if (c &lt; 1) throw new Error('iterations (c) should be &gt;= 1');   const password = kdfInputToBytes(_password);   const salt = kdfInputToBytes(_salt);   // DK = PBKDF2(PRF, Password, Salt, c, dkLen);   const DK = new Uint8Array(dkLen);   // U1 = PRF(Password, Salt + INT_32_BE(i))   const PRF = hmac.create(hash, password);   const PRFSalt = PRF._cloneInto().update(salt);   return { c, dkLen, asyncTick, DK, PRF, PRFSalt }; }</p> <p>function pbkdf2Output&gt;(   PRF: Hash,   PRFSalt: Hash,   DK: Uint8Array,   prfW: Hash,   u: Uint8Array ) {   PRF.destroy();   PRFSalt.destroy();   if (prfW) prfW.destroy();   clean(u);   return DK; } <p>/** PBKDF2-HMAC: RFC 2898 key derivation function @param hash - hash function that would be used e.g. sha256 @param password - password from which a derived key is generated @param salt - cryptographic salt @param opts - {c, dkLen} where c is work factor and dkLen is output message size @example const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });</p>"},{"location":"autogenerated/code-summary/#scrypt_1","title":"scrypt","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/scrypt.ts</code></p> <p>Signature: <code>scrypt(password: KDFInput, salt: KDFInput, opts: ScryptOpts)</code></p> <p>JSDoc:</p> <p>RFC 7914 Scrypt KDF. Can be used to create a key from password and salt. @module / import { pbkdf2 } from './pbkdf2.ts'; import { sha256 } from './sha2.ts'; // prettier-ignore import {   anumber, asyncLoop,   checkOpts, clean,   type KDFInput, rotl,   swap32IfBE,   u32 } from './utils.ts';</p> <p>// The main Scrypt loop: uses Salsa extensively. // Six versions of the function were tried, this is the fastest one. // prettier-ignore function XorAndSalsa(   prev: Uint32Array,   pi: number,   input: Uint32Array,   ii: number,   out: Uint32Array,   oi: number ) {   // Based on https://cr.yp.to/salsa20.html   // Xor blocks   let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];   let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];   let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];   let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];   let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];   let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];   let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];   let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];   // Save state to temporary variables (salsa)   let x00 = y00, x01 = y01, x02 = y02, x03 = y03,       x04 = y04, x05 = y05, x06 = y06, x07 = y07,       x08 = y08, x09 = y09, x10 = y10, x11 = y11,       x12 = y12, x13 = y13, x14 = y14, x15 = y15;   // Main loop (salsa)   for (let i = 0; i &lt; 8; i += 2) {     x04 ^= rotl(x00 + x12 | 0,  7); x08 ^= rotl(x04 + x00 | 0,  9);     x12 ^= rotl(x08 + x04 | 0, 13); x00 ^= rotl(x12 + x08 | 0, 18);     x09 ^= rotl(x05 + x01 | 0,  7); x13 ^= rotl(x09 + x05 | 0,  9);     x01 ^= rotl(x13 + x09 | 0, 13); x05 ^= rotl(x01 + x13 | 0, 18);     x14 ^= rotl(x10 + x06 | 0,  7); x02 ^= rotl(x14 + x10 | 0,  9);     x06 ^= rotl(x02 + x14 | 0, 13); x10 ^= rotl(x06 + x02 | 0, 18);     x03 ^= rotl(x15 + x11 | 0,  7); x07 ^= rotl(x03 + x15 | 0,  9);     x11 ^= rotl(x07 + x03 | 0, 13); x15 ^= rotl(x11 + x07 | 0, 18);     x01 ^= rotl(x00 + x03 | 0,  7); x02 ^= rotl(x01 + x00 | 0,  9);     x03 ^= rotl(x02 + x01 | 0, 13); x00 ^= rotl(x03 + x02 | 0, 18);     x06 ^= rotl(x05 + x04 | 0,  7); x07 ^= rotl(x06 + x05 | 0,  9);     x04 ^= rotl(x07 + x06 | 0, 13); x05 ^= rotl(x04 + x07 | 0, 18);     x11 ^= rotl(x10 + x09 | 0,  7); x08 ^= rotl(x11 + x10 | 0,  9);     x09 ^= rotl(x08 + x11 | 0, 13); x10 ^= rotl(x09 + x08 | 0, 18);     x12 ^= rotl(x15 + x14 | 0,  7); x13 ^= rotl(x12 + x15 | 0,  9);     x14 ^= rotl(x13 + x12 | 0, 13); x15 ^= rotl(x14 + x13 | 0, 18);   }   // Write output (salsa)   out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;   out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;   out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;   out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;   out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;   out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;   out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;   out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0; }</p> <p>function BlockMix(input: Uint32Array, ii: number, out: Uint32Array, oi: number, r: number) {   // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)   let head = oi + 0;   let tail = oi + 16 * r;   for (let i = 0; i &lt; 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X \u2190 B[2r\u22121]   for (let i = 0; i &lt; r; i++, head += 16, ii += 16) {     // We write odd &amp; even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1     XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2i] ^ tail[i-1])     if (i &gt; 0) tail += 16; // First iteration overwrites tmp value in tail     XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2i+1] ^ head[i])   } }</p> <p>export type ScryptOpts = {   N: number; // cost factor   r: number; // block size   p: number; // parallelization   dkLen?: number; // key length   asyncTick?: number; // block execution max time   maxmem?: number;   onProgress?: (progress: number) =&gt; void; };</p> <p>// Common prologue and epilogue for sync/async functions function scryptInit(password: KDFInput, salt: KDFInput, _opts?: ScryptOpts) {   // Maxmem - 1GB+1KB by default   const opts = checkOpts(     {       dkLen: 32,       asyncTick: 10,       maxmem: 1024 ** 3 + 1024,     },     _opts   );   const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;   anumber(N);   anumber(r);   anumber(p);   anumber(dkLen);   anumber(asyncTick);   anumber(maxmem);   if (onProgress !== undefined &amp;&amp; typeof onProgress !== 'function')     throw new Error('progressCb should be function');   const blockSize = 128 * r;   const blockSize32 = blockSize / 4;</p> <p>// Max N is 2^32 (Integrify is 32-bit). Real limit is 2^22: JS engines Uint8Array limit is 4GB in 2024.   // Spec check <code>N &gt;= 2^(blockSize / 8)</code> is not done for compat with popular libs,   // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:   // https://www.rfc-editor.org/errata_search.php?rfc=7914   const pow32 = Math.pow(2, 32);   if (N &lt;= 1 || (N &amp; (N - 1)) !== 0 || N &gt; pow32) {     throw new Error('Scrypt: N must be larger than 1, a power of 2, and less than 2^32');   }   if (p &lt; 0 || p &gt; ((pow32 - 1) * 32) / blockSize) {     throw new Error(       'Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)'     );   }   if (dkLen &lt; 0 || dkLen &gt; (pow32 - 1) * 32) {     throw new Error(       'Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32'     );   }   const memUsed = blockSize * (N + p);   if (memUsed &gt; maxmem) {     throw new Error(       'Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) &gt; maxmem of ' + maxmem     );   }   // [B0...Bp\u22121] \u2190 PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)   // Since it has only one iteration there is no reason to use async variant   const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });   const B32 = u32(B);   // Re-used between parallel iterations. Array(iterations) of B   const V = u32(new Uint8Array(blockSize * N));   const tmp = u32(new Uint8Array(blockSize));   let blockMixCb = () =&gt; {};   if (onProgress) {     const totalBlockMix = 2 * N * p;     // Invoke callback if progress changes from 10.01 to 10.02     // Allows to draw smooth progress bar on up to 8K screen     const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);     let blockMixCnt = 0;     blockMixCb = () =&gt; {       blockMixCnt++;       if (onProgress &amp;&amp; (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))         onProgress(blockMixCnt / totalBlockMix);     };   }   return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick }; }</p> <p>function scryptOutput(   password: KDFInput,   dkLen: number,   B: Uint8Array,   V: Uint32Array,   tmp: Uint32Array ) {   const res = pbkdf2(sha256, password, B, { c: 1, dkLen });   clean(B, V, tmp);   return res; }</p> <p>/ Scrypt KDF from RFC 7914. @param password - pass @param salt - salt @param opts - parameters - <code>N</code> is cpu/mem work factor (power of 2 e.g. 218) - <code>r</code> is block size (8 is common), fine-tunes sequential memory read size and performance - <code>p</code> is parallelization factor (1 is common) - <code>dkLen</code> is output key length in bytes e.g. 32. - <code>asyncTick</code> - (default: 10) max time in ms for which async function can block execution - <code>maxmem</code> - (default: <code>1024 ** 3 + 1024</code> aka 1GB+1KB). A limit that the app could use for scrypt - <code>onProgress</code> - callback function that would be executed for progress report @returns Derived key @example scrypt('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });</p>"},{"location":"autogenerated/code-summary/#keccakp_1","title":"keccakP","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/sha3.ts</code></p> <p>Signature: <code>keccakP(s: Uint32Array, rounds: number = 24)</code></p> <p>JSDoc:</p> <p>SHA3 (keccak) hash function, based on a new \"Sponge function\" design. Different from older hashes, the internal state is bigger than output size.</p> <p>Check out FIPS-202, Website, the differences between SHA-3 and Keccak.</p> <p>Check out <code>sha3-addons</code> module for cSHAKE, k12, and others. @module / import { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts'; // prettier-ignore import {   abytes, aexists, anumber, aoutput,   clean, createHasher, createXOFer, Hash,   swap32IfBE,   toBytes, u32,   type CHash, type CHashXO, type HashXOF, type Input } from './utils.ts';</p> <p>// No PURE annotations in sha3 header: // EVERYTHING is in fact used on every export. // Various per round constants calculations const _0n = BigInt(0); const _1n = BigInt(1); const _2n = BigInt(2); const _7n = BigInt(7); const _256n = BigInt(256); const _0x71n = BigInt(0x71); const SHA3_PI: number[] = []; const SHA3_ROTL: number[] = []; const _SHA3_IOTA: bigint[] = []; for (let round = 0, R = _1n, x = 1, y = 0; round &lt; 24; round++) {   // Pi   [x, y] = [y, (2 * x + 3 * y) % 5];   SHA3_PI.push(2 * (5 * y + x));   // Rotational   SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);   // Iota   let t = _0n;   for (let j = 0; j &lt; 7; j++) {     R = ((R &lt;&lt; _1n) ^ ((R &gt;&gt; _7n) * _0x71n)) % _256n;     if (R &amp; _2n) t ^= _1n &lt;&lt; ((_1n &lt;&lt; / @PURE / BigInt(j)) - _1n);   }   _SHA3_IOTA.push(t); } const IOTAS = split(_SHA3_IOTA, true); const SHA3_IOTA_H = IOTAS0; const SHA3_IOTA_L = IOTAS[1];</p> <p>// Left rotation (without 0, 32, 64) const rotlH = (h: number, l: number, s: number) =&gt; (s &gt; 32 ? rotlBH(h, l, s) : rotlSH(h, l, s)); const rotlL = (h: number, l: number, s: number) =&gt; (s &gt; 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));</p> <p>/** <code>keccakf1600</code> internal function, additionally allows to adjust round count.</p>"},{"location":"autogenerated/code-summary/#isbytes_1","title":"isBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>isBytes(a: unknown)</code></p> <p>JSDoc:</p> <p>Utilities for hex, bytes, CSPRNG. @module / /! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) /</p> <p>// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+. // node.js versions earlier than v19 don't declare it in global scope. // For node.js, package.json#exports field mapping rewrites import // from <code>crypto</code> to <code>cryptoNode</code>, which imports native module. // Makes the utils un-importable in browsers without a bundler. // Once node.js 18 is deprecated (2025-04-30), we can just drop the import. import { crypto } from '@noble/hashes/crypto';</p> <p>/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true.</p>"},{"location":"autogenerated/code-summary/#anumber_1","title":"anumber","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>anumber(n: number)</code></p> <p>JSDoc:</p> <p>Asserts something is positive integer.</p>"},{"location":"autogenerated/code-summary/#abytes_2","title":"abytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>abytes(b: Uint8Array | undefined, ...lengths: number[])</code></p> <p>JSDoc:</p> <p>Asserts something is Uint8Array.</p>"},{"location":"autogenerated/code-summary/#ahash_1","title":"ahash","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>ahash(h: IHash)</code></p> <p>JSDoc:</p> <p>Asserts something is hash</p>"},{"location":"autogenerated/code-summary/#aexists_1","title":"aexists","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>aexists(instance: any, checkFinished = true)</code></p> <p>JSDoc:</p> <p>Asserts a hash instance has not been destroyed / finished</p>"},{"location":"autogenerated/code-summary/#aoutput_1","title":"aoutput","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>aoutput(out: any, instance: any)</code></p> <p>JSDoc:</p> <p>Asserts output is properly-sized byte array</p>"},{"location":"autogenerated/code-summary/#u8_1","title":"u8","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>u8(arr: TypedArray)</code></p> <p>JSDoc:</p> <p>Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */ // prettier-ignore export type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |   Uint16Array | Int16Array | Uint32Array | Int32Array;</p> <p>/** Cast u8 / u16 / u32 to u8.</p>"},{"location":"autogenerated/code-summary/#u32_1","title":"u32","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>u32(arr: TypedArray)</code></p> <p>JSDoc:</p> <p>Cast u8 / u16 / u32 to u32.</p>"},{"location":"autogenerated/code-summary/#clean_1","title":"clean","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>clean(...arrays: TypedArray[])</code></p> <p>JSDoc:</p> <p>Zeroize a byte array. Warning: JS provides no guarantees.</p>"},{"location":"autogenerated/code-summary/#createview_1","title":"createView","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>createView(arr: TypedArray)</code></p> <p>JSDoc:</p> <p>Create DataView of an array for easy byte-level manipulation.</p>"},{"location":"autogenerated/code-summary/#rotr_1","title":"rotr","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>rotr(word: number, shift: number)</code></p> <p>JSDoc:</p> <p>The rotate right (circular right shift) operation for uint32</p>"},{"location":"autogenerated/code-summary/#rotl_1","title":"rotl","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>rotl(word: number, shift: number)</code></p> <p>JSDoc:</p> <p>The rotate left (circular left shift) operation for uint32</p>"},{"location":"autogenerated/code-summary/#byteswap_1","title":"byteSwap","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>byteSwap(word: number)</code></p> <p>JSDoc:</p> <p>Is current platform little-endian? Most are. Big-Endian platform: IBM / export const isLE: boolean = / @PURE */ (() =&gt;   new Uint8Array(new Uint32Array([0x11223344]).buffer)0 === 0x44)();</p> <p>/** The byte swap operation for uint32</p>"},{"location":"autogenerated/code-summary/#byteswap32_1","title":"byteSwap32","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>byteSwap32(arr: Uint32Array)</code></p> <p>JSDoc:</p> <p>Conditionally byte swap if on a big-endian platform */ export const swap8IfBE: (n: number) =&gt; number = isLE   ? (n: number) =&gt; n   : (n: number) =&gt; byteSwap(n);</p> <p>/ @deprecated */ export const byteSwapIfBE: typeof swap8IfBE = swap8IfBE; / In place byte swap for Uint32Array</p>"},{"location":"autogenerated/code-summary/#bytestohex_1","title":"bytesToHex","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>bytesToHex(bytes: Uint8Array)</code></p> <p>JSDoc:</p> <p>Convert byte array to hex string. Uses built-in function, when available. @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'</p>"},{"location":"autogenerated/code-summary/#hextobytes_1","title":"hexToBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>hexToBytes(hex: string)</code></p> <p>JSDoc:</p> <p>Convert hex string to byte array. Uses built-in function, when available. @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])</p>"},{"location":"autogenerated/code-summary/#utf8tobytes_1","title":"utf8ToBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>utf8ToBytes(str: string)</code></p> <p>JSDoc:</p> <p>There is no setImmediate in browser and setTimeout is slow. Call of async fn will return Promise, which will be fullfiled only on next scheduler queue processing step and this is exactly what we need. / export const nextTick = async (): Promise =&gt; {}; <p>/* Returns control to thread each 'tick' ms to avoid blocking. / export async function asyncLoop(   iters: number,   tick: number,   cb: (i: number) =&gt; void ): Promise {   let ts = Date.now();   for (let i = 0; i &lt; iters; i++) {     cb(i);     // Date.now() is not monotonic, so in case if clock goes backwards we return return control too     const diff = Date.now() - ts;     if (diff &gt;= 0 &amp;&amp; diff &lt; tick) continue;     await nextTick();     ts += diff;   } } <p>// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535 declare const TextEncoder: any; declare const TextDecoder: any;</p> <p>/** Converts string to bytes using UTF8 encoding. @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])</p>"},{"location":"autogenerated/code-summary/#bytestoutf8_1","title":"bytesToUtf8","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>bytesToUtf8(bytes: Uint8Array)</code></p> <p>JSDoc:</p> <p>Converts bytes to string using UTF8 encoding. @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'</p>"},{"location":"autogenerated/code-summary/#tobytes_1","title":"toBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>toBytes(data: Input)</code></p> <p>JSDoc:</p> <p>Accepted input of hash functions. Strings are converted to byte arrays. / export type Input = string | Uint8Array; /* Normalizes (non-hex) string or Uint8Array to Uint8Array. Warning: when Uint8Array is passed, it would NOT get copied. Keep in mind for future mutable operations.</p>"},{"location":"autogenerated/code-summary/#kdfinputtobytes_1","title":"kdfInputToBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>kdfInputToBytes(data: KDFInput)</code></p> <p>JSDoc:</p> <p>KDFs can accept string or Uint8Array for user convenience. / export type KDFInput = string | Uint8Array; /* Helper for KDFs: consumes uint8array or string. When string is passed, does utf8 decoding, using TextDecoder.</p>"},{"location":"autogenerated/code-summary/#concatbytes_1","title":"concatBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>concatBytes(...arrays: Uint8Array[])</code></p> <p>JSDoc:</p> <p>Copies several Uint8Arrays into one.</p>"},{"location":"autogenerated/code-summary/#createhasher_1","title":"createHasher","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>createHasher(&lt;T extends Hash&lt;T&gt;&gt;(   hashCons: ()</code></p> <p>JSDoc:</p> <p>Hash interface. */ export type IHash = {   (data: Uint8Array): Uint8Array;   blockLen: number;   outputLen: number;   create: any; };</p> <p>/ For runtime check if class implements interface */ export abstract class Hash&gt; {   abstract blockLen: number; // Bytes per block   abstract outputLen: number; // Bytes in output   abstract update(buf: Input): this;   // Writes digest into buf   abstract digestInto(buf: Uint8Array): void;   abstract digest(): Uint8Array;   / Resets internal state. Makes Hash instance unusable. Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed by user, they will need to manually call <code>destroy()</code> when zeroing is necessary. /   abstract destroy(): void;   /** Clones hash instance. Unsafe: doesn't check whether <code>to</code> is valid. Can be used as <code>clone()</code> when no options are passed. Reasons to use <code>_cloneInto</code> instead of clone: 1) performance 2) reuse instance =&gt; all internal buffers are overwritten =&gt; causes buffer overwrite which is used for digest in some cases. There are no guarantees for clean-up because it's impossible in JS. /   abstract _cloneInto(to?: T): T;   // Safe version that clones internal state   abstract clone(): T; } <p>/** XOF: streaming API to read digest in chunks. Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name. When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot destroy state, next call can require more bytes. / export type HashXOF&gt; = Hash &amp; {   xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream   xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf }; <p>/ Hash function */ export type CHash = ReturnType; / Hash function with output / export type CHashO = ReturnType; / XOF with output / export type CHashXO = ReturnType; <p>/** Wraps hash function, creating an interface on top of it</p>"},{"location":"autogenerated/code-summary/#randombytes_1","title":"randomBytes","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/src/utils.ts</code></p> <p>Signature: <code>randomBytes(bytesLength = 32)</code></p> <p>JSDoc:</p> <p>Cryptographically secure PRNG. Uses internal OS-level <code>crypto.getRandomValues</code>.</p>"},{"location":"autogenerated/code-summary/#isle","title":"isLE","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/utils.js</code></p> <p>Signature: <code>isLE(= (()</code></p> <p>JSDoc:</p> <p>Utilities for hex, bytes, CSPRNG. @module / /! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) / Object.defineProperty(exports, \"__esModule\", { value: true }); exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0; exports.isBytes = isBytes; exports.anumber = anumber; exports.abytes = abytes; exports.ahash = ahash; exports.aexists = aexists; exports.aoutput = aoutput; exports.u8 = u8; exports.u32 = u32; exports.clean = clean; exports.createView = createView; exports.rotr = rotr; exports.rotl = rotl; exports.byteSwap = byteSwap; exports.byteSwap32 = byteSwap32; exports.bytesToHex = bytesToHex; exports.hexToBytes = hexToBytes; exports.asyncLoop = asyncLoop; exports.utf8ToBytes = utf8ToBytes; exports.bytesToUtf8 = bytesToUtf8; exports.toBytes = toBytes; exports.kdfInputToBytes = kdfInputToBytes; exports.concatBytes = concatBytes; exports.checkOpts = checkOpts; exports.createHasher = createHasher; exports.createOptHasher = createOptHasher; exports.createXOFer = createXOFer; exports.randomBytes = randomBytes; // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+. // node.js versions earlier than v19 don't declare it in global scope. // For node.js, package.json#exports field mapping rewrites import // from <code>crypto</code> to <code>cryptoNode</code>, which imports native module. // Makes the utils un-importable in browsers without a bundler. // Once node.js 18 is deprecated (2025-04-30), we can just drop the import. const crypto_1 = require(\"@noble/hashes/crypto\"); / Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {     return a instanceof Uint8Array || (ArrayBuffer.isView(a) &amp;&amp; a.constructor.name === 'Uint8Array'); } / Asserts something is positive integer. / function anumber(n) {     if (!Number.isSafeInteger(n) || n &lt; 0)         throw new Error('positive integer expected, got ' + n); } / Asserts something is Uint8Array. / function abytes(b, ...lengths) {     if (!isBytes(b))         throw new Error('Uint8Array expected');     if (lengths.length &gt; 0 &amp;&amp; !lengths.includes(b.length))         throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length); } / Asserts something is hash */ function ahash(h) {     if (typeof h !== 'function' || typeof h.create !== 'function')         throw new Error('Hash should be wrapped by utils.createHasher');     anumber(h.outputLen);     anumber(h.blockLen); } / Asserts a hash instance has not been destroyed / finished / function aexists(instance, checkFinished = true) {     if (instance.destroyed)         throw new Error('Hash instance has been destroyed');     if (checkFinished &amp;&amp; instance.finished)         throw new Error('Hash#digest() has already been called'); } / Asserts output is properly-sized byte array / function aoutput(out, instance) {     abytes(out);     const min = instance.outputLen;     if (out.length &lt; min) {         throw new Error('digestInto() expects output buffer of length at least ' + min);     } } / Cast u8 / u16 / u32 to u8. */ function u8(arr) {     return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength); } / Cast u8 / u16 / u32 to u32. / function u32(arr) {     return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4)); } / Zeroize a byte array. Warning: JS provides no guarantees. / function clean(...arrays) {     for (let i = 0; i &lt; arrays.length; i++) {         arrays[i].fill(0);     } } / Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {     return new DataView(arr.buffer, arr.byteOffset, arr.byteLength); } / The rotate right (circular right shift) operation for uint32 / function rotr(word, shift) {     return (word &lt;&lt; (32 - shift)) | (word &gt;&gt;&gt; shift); } / The rotate left (circular left shift) operation for uint32 / function rotl(word, shift) {     return (word &lt;&lt; shift) | ((word &gt;&gt;&gt; (32 - shift)) &gt;&gt;&gt; 0); } /** Is current platform little-endian? Most are. Big-Endian platform: IBM</p>"},{"location":"autogenerated/code-summary/#swap8ifbe","title":"swap8IfBE","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/utils.js</code></p> <p>Signature: <code>swap8IfBE(= exports.isLE     ? (n)</code></p> <p>JSDoc:</p> <p>The byte swap operation for uint32 / function byteSwap(word) {     return (((word &lt;&lt; 24) &amp; 0xff000000) |         ((word &lt;&lt; 8) &amp; 0xff0000) |         ((word &gt;&gt;&gt; 8) &amp; 0xff00) |         ((word &gt;&gt;&gt; 24) &amp; 0xff)); } /* Conditionally byte swap if on a big-endian platform</p>"},{"location":"autogenerated/code-summary/#byteswapifbe","title":"byteSwapIfBE","text":"<p>Source: <code>my-backend/node_modules/@noble/hashes/utils.js</code></p> <p>Signature: <code>byteSwapIfBE(= exports.swap8IfBE; /** In place byte swap for Uint32Array */ function byteSwap32(arr)</code></p> <p>JSDoc:</p> <p>@deprecated</p>"},{"location":"autogenerated/code-summary/#standardtype","title":"StandardType","text":"<p>Source: <code>my-backend/node_modules/@sinclair/typebox/typebox.js</code></p> <p>Signature: <code>StandardType(= new StandardTypeBuilder()</code></p> <p>JSDoc:</p> <p>A registry for user defined types / var TypeRegistry; (function (TypeRegistry) {     const map = new Map();     / Returns the entries in this registry /     function Entries() {         return new Map(map);     }     TypeRegistry.Entries = Entries;     / Clears all user defined types */     function Clear() {         return map.clear();     }     TypeRegistry.Clear = Clear;     / Returns true if this registry contains this kind /     function Has(kind) {         return map.has(kind);     }     TypeRegistry.Has = Has;     / Sets a validation function for a user defined type /     function Set(kind, func) {         map.set(kind, func);     }     TypeRegistry.Set = Set;     / Gets a custom validation function for a user defined type */     function Get(kind) {         return map.get(kind);     }     TypeRegistry.Get = Get; })(TypeRegistry = exports.TypeRegistry || (exports.TypeRegistry = {})); / A registry for user defined string formats / var FormatRegistry; (function (FormatRegistry) {     const map = new Map();     / Returns the entries in this registry /     function Entries() {         return new Map(map);     }     FormatRegistry.Entries = Entries;     / Clears all user defined string formats */     function Clear() {         return map.clear();     }     FormatRegistry.Clear = Clear;     / Returns true if the user defined string format exists /     function Has(format) {         return map.has(format);     }     FormatRegistry.Has = Has;     / Sets a validation function for a user defined string format /     function Set(format, func) {         map.set(format, func);     }     FormatRegistry.Set = Set;     / Gets a validation function for a user defined string format */     function Get(format) {         return map.get(format);     }     FormatRegistry.Get = Get; })(FormatRegistry = exports.FormatRegistry || (exports.FormatRegistry = {})); // -------------------------------------------------------------------------- // TypeGuard // -------------------------------------------------------------------------- class TypeGuardUnknownTypeError extends Error {     constructor(schema) {         super('TypeGuard: Unknown type');         this.schema = schema;     } } exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError; / Provides functions to test if JavaScript values are TypeBox types / var TypeGuard; (function (TypeGuard) {     function IsObject(value) {         return typeof value === 'object' &amp;&amp; value !== null &amp;&amp; !Array.isArray(value);     }     function IsArray(value) {         return typeof value === 'object' &amp;&amp; value !== null &amp;&amp; Array.isArray(value);     }     function IsPattern(value) {         try {             new RegExp(value);             return true;         }         catch {             return false;         }     }     function IsControlCharacterFree(value) {         if (typeof value !== 'string')             return false;         for (let i = 0; i &lt; value.length; i++) {             const code = value.charCodeAt(i);             if ((code &gt;= 7 &amp;&amp; code &lt;= 13) || code === 27 || code === 127) {                 return false;             }         }         return true;     }     function IsBigInt(value) {         return typeof value === 'bigint';     }     function IsString(value) {         return typeof value === 'string';     }     function IsNumber(value) {         return typeof value === 'number' &amp;&amp; globalThis.Number.isFinite(value);     }     function IsBoolean(value) {         return typeof value === 'boolean';     }     function IsOptionalBigInt(value) {         return value === undefined || (value !== undefined &amp;&amp; IsBigInt(value));     }     function IsOptionalNumber(value) {         return value === undefined || (value !== undefined &amp;&amp; IsNumber(value));     }     function IsOptionalBoolean(value) {         return value === undefined || (value !== undefined &amp;&amp; IsBoolean(value));     }     function IsOptionalString(value) {         return value === undefined || (value !== undefined &amp;&amp; IsString(value));     }     function IsOptionalPattern(value) {         return value === undefined || (value !== undefined &amp;&amp; IsString(value) &amp;&amp; IsControlCharacterFree(value) &amp;&amp; IsPattern(value));     }     function IsOptionalFormat(value) {         return value === undefined || (value !== undefined &amp;&amp; IsString(value) &amp;&amp; IsControlCharacterFree(value));     }     function IsOptionalSchema(value) {         return value === undefined || TSchema(value);     }     / Returns true if the given schema is TAny /     function TAny(schema) {         return TKind(schema) &amp;&amp; schema[exports.Kind] === 'Any' &amp;&amp; IsOptionalString(schema.$id);     }     TypeGuard.TAny = TAny;     / Returns true if the given schema is TArray */     function TArray(schema) {         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Array' &amp;&amp;             schema.type === 'array' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             TSchema(schema.items) &amp;&amp;             IsOptionalNumber(schema.minItems) &amp;&amp;             IsOptionalNumber(schema.maxItems) &amp;&amp;             IsOptionalBoolean(schema.uniqueItems));     }     TypeGuard.TArray = TArray;     / Returns true if the given schema is TBigInt /     function TBigInt(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'BigInt' &amp;&amp;             schema.type === 'null' &amp;&amp;             schema.typeOf === 'BigInt' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsOptionalBigInt(schema.multipleOf) &amp;&amp;             IsOptionalBigInt(schema.minimum) &amp;&amp;             IsOptionalBigInt(schema.maximum) &amp;&amp;             IsOptionalBigInt(schema.exclusiveMinimum) &amp;&amp;             IsOptionalBigInt(schema.exclusiveMaximum));     }     TypeGuard.TBigInt = TBigInt;     / Returns true if the given schema is TBoolean /     function TBoolean(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Boolean' &amp;&amp;             schema.type === 'boolean' &amp;&amp;             IsOptionalString(schema.$id));     }     TypeGuard.TBoolean = TBoolean;     / Returns true if the given schema is TConstructor */     function TConstructor(schema) {         // prettier-ignore         if (!(TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Constructor' &amp;&amp;             schema.type === 'object' &amp;&amp;             schema.instanceOf === 'Constructor' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsArray(schema.parameters) &amp;&amp;             TSchema(schema.returns))) {             return false;         }         for (const parameter of schema.parameters) {             if (!TSchema(parameter))                 return false;         }         return true;     }     TypeGuard.TConstructor = TConstructor;     / Returns true if the given schema is TDate /     function TDate(schema) {         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Date' &amp;&amp;             schema.type === 'object' &amp;&amp;             schema.instanceOf === 'Date' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsOptionalNumber(schema.minimumTimestamp) &amp;&amp;             IsOptionalNumber(schema.maximumTimestamp) &amp;&amp;             IsOptionalNumber(schema.exclusiveMinimumTimestamp) &amp;&amp;             IsOptionalNumber(schema.exclusiveMaximumTimestamp));     }     TypeGuard.TDate = TDate;     / Returns true if the given schema is TFunction /     function TFunction(schema) {         // prettier-ignore         if (!(TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Function' &amp;&amp;             schema.type === 'object' &amp;&amp;             schema.instanceOf === 'Function' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsArray(schema.parameters) &amp;&amp;             TSchema(schema.returns))) {             return false;         }         for (const parameter of schema.parameters) {             if (!TSchema(parameter))                 return false;         }         return true;     }     TypeGuard.TFunction = TFunction;     / Returns true if the given schema is TInteger */     function TInteger(schema) {         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Integer' &amp;&amp;             schema.type === 'integer' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsOptionalNumber(schema.multipleOf) &amp;&amp;             IsOptionalNumber(schema.minimum) &amp;&amp;             IsOptionalNumber(schema.maximum) &amp;&amp;             IsOptionalNumber(schema.exclusiveMinimum) &amp;&amp;             IsOptionalNumber(schema.exclusiveMaximum));     }     TypeGuard.TInteger = TInteger;     / Returns true if the given schema is TIntersect /     function TIntersect(schema) {         // prettier-ignore         if (!(TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Intersect' &amp;&amp;             IsArray(schema.allOf) &amp;&amp;             IsOptionalString(schema.type) &amp;&amp;             (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &amp;&amp;             IsOptionalString(schema.$id))) {             return false;         }         if ('type' in schema &amp;&amp; schema.type !== 'object') {             return false;         }         for (const inner of schema.allOf) {             if (!TSchema(inner))                 return false;         }         return true;     }     TypeGuard.TIntersect = TIntersect;     / Returns true if the given schema is TKind /     function TKind(schema) {         return IsObject(schema) &amp;&amp; exports.Kind in schema &amp;&amp; typeof schema[exports.Kind] === 'string'; // TS 4.1.5: any required for symbol indexer     }     TypeGuard.TKind = TKind;     / Returns true if the given schema is TLiteral */     function TLiteral(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Literal' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             (IsString(schema.const) ||                 IsNumber(schema.const) ||                 IsBoolean(schema.const) ||                 IsBigInt(schema.const)));     }     TypeGuard.TLiteral = TLiteral;     / Returns true if the given schema is TNever /     function TNever(schema) {         return TKind(schema) &amp;&amp; schema[exports.Kind] === 'Never' &amp;&amp; IsObject(schema.not) &amp;&amp; globalThis.Object.getOwnPropertyNames(schema.not).length === 0;     }     TypeGuard.TNever = TNever;     / Returns true if the given schema is TNot /     function TNot(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Not' &amp;&amp;             IsArray(schema.allOf) &amp;&amp;             schema.allOf.length === 2 &amp;&amp;             IsObject(schema.allOf0) &amp;&amp;             TSchema(schema.allOf0.not) &amp;&amp;             TSchema(schema.allOf[1]));     }     TypeGuard.TNot = TNot;     / Returns true if the given schema is TNull */     function TNull(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Null' &amp;&amp;             schema.type === 'null' &amp;&amp;             IsOptionalString(schema.$id));     }     TypeGuard.TNull = TNull;     / Returns true if the given schema is TNumber /     function TNumber(schema) {         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Number' &amp;&amp;             schema.type === 'number' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsOptionalNumber(schema.multipleOf) &amp;&amp;             IsOptionalNumber(schema.minimum) &amp;&amp;             IsOptionalNumber(schema.maximum) &amp;&amp;             IsOptionalNumber(schema.exclusiveMinimum) &amp;&amp;             IsOptionalNumber(schema.exclusiveMaximum));     }     TypeGuard.TNumber = TNumber;     / Returns true if the given schema is TObject /     function TObject(schema) {         if (!(TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Object' &amp;&amp;             schema.type === 'object' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsObject(schema.properties) &amp;&amp;             (IsOptionalBoolean(schema.additionalProperties) || IsOptionalSchema(schema.additionalProperties)) &amp;&amp;             IsOptionalNumber(schema.minProperties) &amp;&amp;             IsOptionalNumber(schema.maxProperties))) {             return false;         }         for (const [key, value] of Object.entries(schema.properties)) {             if (!IsControlCharacterFree(key))                 return false;             if (!TSchema(value))                 return false;         }         return true;     }     TypeGuard.TObject = TObject;     / Returns true if the given schema is TPromise */     function TPromise(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Promise' &amp;&amp;             schema.type === 'object' &amp;&amp;             schema.instanceOf === 'Promise' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             TSchema(schema.item));     }     TypeGuard.TPromise = TPromise;     / Returns true if the given schema is TRecord /     function TRecord(schema) {         // prettier-ignore         if (!(TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Record' &amp;&amp;             schema.type === 'object' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             schema.additionalProperties === false &amp;&amp;             IsObject(schema.patternProperties))) {             return false;         }         const keys = Object.keys(schema.patternProperties);         if (keys.length !== 1) {             return false;         }         if (!IsPattern(keys0)) {             return false;         }         if (!TSchema(schema.patternProperties[keys[0]])) {             return false;         }         return true;     }     TypeGuard.TRecord = TRecord;     / Returns true if the given schema is TRef /     function TRef(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Ref' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsString(schema.$ref));     }     TypeGuard.TRef = TRef;     / Returns true if the given schema is TString */     function TString(schema) {         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'String' &amp;&amp;             schema.type === 'string' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsOptionalNumber(schema.minLength) &amp;&amp;             IsOptionalNumber(schema.maxLength) &amp;&amp;             IsOptionalPattern(schema.pattern) &amp;&amp;             IsOptionalFormat(schema.format));     }     TypeGuard.TString = TString;     / Returns true if the given schema is TSymbol /     function TSymbol(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Symbol' &amp;&amp;             schema.type === 'null' &amp;&amp;             schema.typeOf === 'Symbol' &amp;&amp;             IsOptionalString(schema.$id));     }     TypeGuard.TSymbol = TSymbol;     / Returns true if the given schema is TTemplateLiteral /     function TTemplateLiteral(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'TemplateLiteral' &amp;&amp;             schema.type === 'string' &amp;&amp;             IsString(schema.pattern) &amp;&amp;             schema.pattern0 === '^' &amp;&amp;             schema.pattern[schema.pattern.length - 1] === '$');     }     TypeGuard.TTemplateLiteral = TTemplateLiteral;     / Returns true if the given schema is TThis */     function TThis(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'This' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsString(schema.$ref));     }     TypeGuard.TThis = TThis;     / Returns true if the given schema is TTuple /     function TTuple(schema) {         // prettier-ignore         if (!(TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Tuple' &amp;&amp;             schema.type === 'array' &amp;&amp;             IsOptionalString(schema.$id) &amp;&amp;             IsNumber(schema.minItems) &amp;&amp;             IsNumber(schema.maxItems) &amp;&amp;             schema.minItems === schema.maxItems)) {             return false;         }         if (schema.items === undefined &amp;&amp; schema.additionalItems === undefined &amp;&amp; schema.minItems === 0) {             return true;         }         if (!IsArray(schema.items)) {             return false;         }         for (const inner of schema.items) {             if (!TSchema(inner))                 return false;         }         return true;     }     TypeGuard.TTuple = TTuple;     / Returns true if the given schema is TUndefined /     function TUndefined(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Undefined' &amp;&amp;             schema.type === 'null' &amp;&amp;             schema.typeOf === 'Undefined' &amp;&amp;             IsOptionalString(schema.$id));     }     TypeGuard.TUndefined = TUndefined;     / Returns true if the given schema is TUnion */     function TUnion(schema) {         // prettier-ignore         if (!(TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Union' &amp;&amp;             IsArray(schema.anyOf) &amp;&amp;             IsOptionalString(schema.$id))) {             return false;         }         for (const inner of schema.anyOf) {             if (!TSchema(inner))                 return false;         }         return true;     }     TypeGuard.TUnion = TUnion;     / Returns true if the given schema is TUnion[]&gt; /     function TUnionLiteral(schema) {         return TUnion(schema) &amp;&amp; schema.anyOf.every((schema) =&gt; TLiteral(schema) &amp;&amp; typeof schema.const === 'string');     }     TypeGuard.TUnionLiteral = TUnionLiteral;     / Returns true if the given schema is TUint8Array /     function TUint8Array(schema) {         return TKind(schema) &amp;&amp; schema[exports.Kind] === 'Uint8Array' &amp;&amp; schema.type === 'object' &amp;&amp; IsOptionalString(schema.$id) &amp;&amp; schema.instanceOf === 'Uint8Array' &amp;&amp; IsOptionalNumber(schema.minByteLength) &amp;&amp; IsOptionalNumber(schema.maxByteLength);     }     TypeGuard.TUint8Array = TUint8Array;     / Returns true if the given schema is TUnknown */     function TUnknown(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Unknown' &amp;&amp;             IsOptionalString(schema.$id));     }     TypeGuard.TUnknown = TUnknown;     / Returns true if the given schema is a raw TUnsafe /     function TUnsafe(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Unsafe');     }     TypeGuard.TUnsafe = TUnsafe;     / Returns true if the given schema is TVoid /     function TVoid(schema) {         // prettier-ignore         return (TKind(schema) &amp;&amp;             schema[exports.Kind] === 'Void' &amp;&amp;             schema.type === 'null' &amp;&amp;             schema.typeOf === 'Void' &amp;&amp;             IsOptionalString(schema.$id));     }     TypeGuard.TVoid = TVoid;     / Returns true if this schema has the ReadonlyOptional modifier */     function TReadonlyOptional(schema) {         return IsObject(schema) &amp;&amp; schema[exports.Modifier] === 'ReadonlyOptional';     }     TypeGuard.TReadonlyOptional = TReadonlyOptional;     / Returns true if this schema has the Readonly modifier /     function TReadonly(schema) {         return IsObject(schema) &amp;&amp; schema[exports.Modifier] === 'Readonly';     }     TypeGuard.TReadonly = TReadonly;     / Returns true if this schema has the Optional modifier /     function TOptional(schema) {         return IsObject(schema) &amp;&amp; schema[exports.Modifier] === 'Optional';     }     TypeGuard.TOptional = TOptional;     / Returns true if the given schema is TSchema */     function TSchema(schema) {         return (typeof schema === 'object' &amp;&amp;             (TAny(schema) ||                 TArray(schema) ||                 TBoolean(schema) ||                 TBigInt(schema) ||                 TConstructor(schema) ||                 TDate(schema) ||                 TFunction(schema) ||                 TInteger(schema) ||                 TIntersect(schema) ||                 TLiteral(schema) ||                 TNever(schema) ||                 TNot(schema) ||                 TNull(schema) ||                 TNumber(schema) ||                 TObject(schema) ||                 TPromise(schema) ||                 TRecord(schema) ||                 TRef(schema) ||                 TString(schema) ||                 TSymbol(schema) ||                 TTemplateLiteral(schema) ||                 TThis(schema) ||                 TTuple(schema) ||                 TUndefined(schema) ||                 TUnion(schema) ||                 TUint8Array(schema) ||                 TUnknown(schema) ||                 TUnsafe(schema) ||                 TVoid(schema) ||                 (TKind(schema) &amp;&amp; TypeRegistry.Has(schema[exports.Kind]))));     }     TypeGuard.TSchema = TSchema; })(TypeGuard = exports.TypeGuard || (exports.TypeGuard = {})); // -------------------------------------------------------------------------- // ExtendsUndefined // -------------------------------------------------------------------------- / Fast undefined check used for properties of type undefined / var ExtendsUndefined; (function (ExtendsUndefined) {     function Check(schema) {         if (schema[exports.Kind] === 'Undefined')             return true;         if (schema[exports.Kind] === 'Union') {             const union = schema;             return union.anyOf.some((schema) =&gt; Check(schema));         }         return false;     }     ExtendsUndefined.Check = Check; })(ExtendsUndefined = exports.ExtendsUndefined || (exports.ExtendsUndefined = {})); // -------------------------------------------------------------------------- // TypeExtends // -------------------------------------------------------------------------- var TypeExtendsResult; (function (TypeExtendsResult) {     TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";     TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";     TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\"; })(TypeExtendsResult = exports.TypeExtendsResult || (exports.TypeExtendsResult = {})); var TypeExtends; (function (TypeExtends) {     // --------------------------------------------------------------------------     // IntoBooleanResult     // --------------------------------------------------------------------------     function IntoBooleanResult(result) {         return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;     }     // --------------------------------------------------------------------------     // Any     // --------------------------------------------------------------------------     function AnyRight(left, right) {         return TypeExtendsResult.True;     }     function Any(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right) &amp;&amp; right.anyOf.some((schema) =&gt; TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))             return TypeExtendsResult.True;         if (TypeGuard.TUnion(right))             return TypeExtendsResult.Union;         if (TypeGuard.TUnknown(right))             return TypeExtendsResult.True;         if (TypeGuard.TAny(right))             return TypeExtendsResult.True;         return TypeExtendsResult.Union;     }     // --------------------------------------------------------------------------     // Array     // --------------------------------------------------------------------------     function ArrayRight(left, right) {         if (TypeGuard.TUnknown(left))             return TypeExtendsResult.False;         if (TypeGuard.TAny(left))             return TypeExtendsResult.Union;         if (TypeGuard.TNever(left))             return TypeExtendsResult.True;         return TypeExtendsResult.False;     }     function Array(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right) &amp;&amp; IsObjectArrayLike(right))             return TypeExtendsResult.True;         if (!TypeGuard.TArray(right))             return TypeExtendsResult.False;         return IntoBooleanResult(Visit(left.items, right.items));     }     // --------------------------------------------------------------------------     // BigInt     // --------------------------------------------------------------------------     function BigInt(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Boolean     // --------------------------------------------------------------------------     function BooleanRight(left, right) {         if (TypeGuard.TLiteral(left) &amp;&amp; typeof left.const === 'boolean')             return TypeExtendsResult.True;         return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     function Boolean(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Constructor     // --------------------------------------------------------------------------     function Constructor(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (!TypeGuard.TConstructor(right))             return TypeExtendsResult.False;         if (left.parameters.length &gt; right.parameters.length)             return TypeExtendsResult.False;         if (!left.parameters.every((schema, index) =&gt; IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {             return TypeExtendsResult.False;         }         return IntoBooleanResult(Visit(left.returns, right.returns));     }     // --------------------------------------------------------------------------     // Date     // --------------------------------------------------------------------------     function Date(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Function     // --------------------------------------------------------------------------     function Function(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (!TypeGuard.TFunction(right))             return TypeExtendsResult.False;         if (left.parameters.length &gt; right.parameters.length)             return TypeExtendsResult.False;         if (!left.parameters.every((schema, index) =&gt; IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {             return TypeExtendsResult.False;         }         return IntoBooleanResult(Visit(left.returns, right.returns));     }     // --------------------------------------------------------------------------     // Integer     // --------------------------------------------------------------------------     function IntegerRight(left, right) {         if (TypeGuard.TLiteral(left) &amp;&amp; typeof left.const === 'number')             return TypeExtendsResult.True;         return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     function Integer(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Intersect     // --------------------------------------------------------------------------     function IntersectRight(left, right) {         return right.allOf.every((schema) =&gt; Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     function Intersect(left, right) {         return left.allOf.some((schema) =&gt; Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Literal     // --------------------------------------------------------------------------     function IsLiteralString(schema) {         return typeof schema.const === 'string';     }     function IsLiteralNumber(schema) {         return typeof schema.const === 'number';     }     function IsLiteralBoolean(schema) {         return typeof schema.const === 'boolean';     }     function Literal(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         if (TypeGuard.TString(right))             return StringRight(left, right);         if (TypeGuard.TNumber(right))             return NumberRight(left, right);         if (TypeGuard.TInteger(right))             return IntegerRight(left, right);         if (TypeGuard.TBoolean(right))             return BooleanRight(left, right);         return TypeGuard.TLiteral(right) &amp;&amp; right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Never     // --------------------------------------------------------------------------     function NeverRight(left, right) {         return TypeExtendsResult.False;     }     function Never(left, right) {         return TypeExtendsResult.True;     }     // --------------------------------------------------------------------------     // Null     // --------------------------------------------------------------------------     function Null(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Number     // --------------------------------------------------------------------------     function NumberRight(left, right) {         if (TypeGuard.TLiteral(left) &amp;&amp; IsLiteralNumber(left))             return TypeExtendsResult.True;         return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     function Number(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Object     // --------------------------------------------------------------------------     function IsObjectPropertyCount(schema, count) {         return globalThis.Object.keys(schema.properties).length === count;     }     function IsObjectStringLike(schema) {         return IsObjectArrayLike(schema);     }     function IsObjectSymbolLike(schema) {         // prettier-ignore         return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) &amp;&amp; 'description' in schema.properties &amp;&amp; TypeGuard.TUnion(schema.properties.description) &amp;&amp; schema.properties.description.anyOf.length === 2 &amp;&amp; ((TypeGuard.TString(schema.properties.description.anyOf0) &amp;&amp;             TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &amp;&amp;             TypeGuard.TUndefined(schema.properties.description.anyOf0))));     }     function IsObjectNumberLike(schema) {         return IsObjectPropertyCount(schema, 0);     }     function IsObjectBooleanLike(schema) {         return IsObjectPropertyCount(schema, 0);     }     function IsObjectBigIntLike(schema) {         return IsObjectPropertyCount(schema, 0);     }     function IsObjectDateLike(schema) {         return IsObjectPropertyCount(schema, 0);     }     function IsObjectUint8ArrayLike(schema) {         return IsObjectArrayLike(schema);     }     function IsObjectFunctionLike(schema) {         const length = exports.Type.Number();         return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) &amp;&amp; 'length' in schema.properties &amp;&amp; IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);     }     function IsObjectConstructorLike(schema) {         return IsObjectPropertyCount(schema, 0);     }     function IsObjectArrayLike(schema) {         const length = exports.Type.Number();         return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) &amp;&amp; 'length' in schema.properties &amp;&amp; IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);     }     function IsObjectPromiseLike(schema) {         const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());         return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) &amp;&amp; 'then' in schema.properties &amp;&amp; IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);     }     // --------------------------------------------------------------------------     // Property     // --------------------------------------------------------------------------     function Property(left, right) {         if (Visit(left, right) === TypeExtendsResult.False)             return TypeExtendsResult.False;         if (TypeGuard.TOptional(left) &amp;&amp; !TypeGuard.TOptional(right))             return TypeExtendsResult.False;         return TypeExtendsResult.True;     }     function ObjectRight(left, right) {         if (TypeGuard.TUnknown(left))             return TypeExtendsResult.False;         if (TypeGuard.TAny(left))             return TypeExtendsResult.Union;         if (TypeGuard.TNever(left))             return TypeExtendsResult.True;         if (TypeGuard.TLiteral(left) &amp;&amp; IsLiteralString(left) &amp;&amp; IsObjectStringLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TLiteral(left) &amp;&amp; IsLiteralNumber(left) &amp;&amp; IsObjectNumberLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TLiteral(left) &amp;&amp; IsLiteralBoolean(left) &amp;&amp; IsObjectBooleanLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TSymbol(left) &amp;&amp; IsObjectSymbolLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TBigInt(left) &amp;&amp; IsObjectBigIntLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TString(left) &amp;&amp; IsObjectStringLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TSymbol(left) &amp;&amp; IsObjectSymbolLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TNumber(left) &amp;&amp; IsObjectNumberLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TInteger(left) &amp;&amp; IsObjectNumberLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TBoolean(left) &amp;&amp; IsObjectBooleanLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TUint8Array(left) &amp;&amp; IsObjectUint8ArrayLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TDate(left) &amp;&amp; IsObjectDateLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TConstructor(left) &amp;&amp; IsObjectConstructorLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TFunction(left) &amp;&amp; IsObjectFunctionLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TRecord(left) &amp;&amp; TypeGuard.TString(RecordKey(left))) {             // When expressing a Record with literal key values, the Record is converted into a Object with             // the Hint assigned as <code>Record</code>. This is used to invert the extends logic.             return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;         }         if (TypeGuard.TRecord(left) &amp;&amp; TypeGuard.TNumber(RecordKey(left))) {             return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;         }         return TypeExtendsResult.False;     }     function Object(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         if (!TypeGuard.TObject(right))             return TypeExtendsResult.False;         for (const key of globalThis.Object.keys(right.properties)) {             if (!(key in left.properties))                 return TypeExtendsResult.False;             if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {                 return TypeExtendsResult.False;             }         }         return TypeExtendsResult.True;     }     // --------------------------------------------------------------------------     // Promise     // --------------------------------------------------------------------------     function Promise(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right) &amp;&amp; IsObjectPromiseLike(right))             return TypeExtendsResult.True;         if (!TypeGuard.TPromise(right))             return TypeExtendsResult.False;         return IntoBooleanResult(Visit(left.item, right.item));     }     // --------------------------------------------------------------------------     // Record     // --------------------------------------------------------------------------     function RecordKey(schema) {         if (exports.PatternNumberExact in schema.patternProperties)             return exports.Type.Number();         if (exports.PatternStringExact in schema.patternProperties)             return exports.Type.String();         throw Error('TypeExtends: Cannot get record key');     }     function RecordValue(schema) {         if (exports.PatternNumberExact in schema.patternProperties)             return schema.patternProperties[exports.PatternNumberExact];         if (exports.PatternStringExact in schema.patternProperties)             return schema.patternProperties[exports.PatternStringExact];         throw Error('TypeExtends: Cannot get record value');     }     function RecordRight(left, right) {         const Key = RecordKey(right);         const Value = RecordValue(right);         if (TypeGuard.TLiteral(left) &amp;&amp; IsLiteralString(left) &amp;&amp; TypeGuard.TNumber(Key) &amp;&amp; IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)             return TypeExtendsResult.True;         if (TypeGuard.TUint8Array(left) &amp;&amp; TypeGuard.TNumber(Key))             return Visit(left, Value);         if (TypeGuard.TString(left) &amp;&amp; TypeGuard.TNumber(Key))             return Visit(left, Value);         if (TypeGuard.TArray(left) &amp;&amp; TypeGuard.TNumber(Key))             return Visit(left, Value);         if (TypeGuard.TObject(left)) {             for (const key of globalThis.Object.keys(left.properties)) {                 if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {                     return TypeExtendsResult.False;                 }             }             return TypeExtendsResult.True;         }         return TypeExtendsResult.False;     }     function Record(left, right) {         const Value = RecordValue(left);         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (!TypeGuard.TRecord(right))             return TypeExtendsResult.False;         return Visit(Value, RecordValue(right));     }     // --------------------------------------------------------------------------     // String     // --------------------------------------------------------------------------     function StringRight(left, right) {         if (TypeGuard.TLiteral(left) &amp;&amp; typeof left.const === 'string')             return TypeExtendsResult.True;         return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     function String(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Symbol     // --------------------------------------------------------------------------     function Symbol(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Tuple     // --------------------------------------------------------------------------     function TupleRight(left, right) {         if (TypeGuard.TUnknown(left))             return TypeExtendsResult.False;         if (TypeGuard.TAny(left))             return TypeExtendsResult.Union;         if (TypeGuard.TNever(left))             return TypeExtendsResult.True;         return TypeExtendsResult.False;     }     function IsArrayOfTuple(left, right) {         return TypeGuard.TArray(right) &amp;&amp; left.items !== undefined &amp;&amp; left.items.every((schema) =&gt; Visit(schema, right.items) === TypeExtendsResult.True);     }     function Tuple(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right) &amp;&amp; IsObjectArrayLike(right))             return TypeExtendsResult.True;         if (TypeGuard.TArray(right) &amp;&amp; IsArrayOfTuple(left, right))             return TypeExtendsResult.True;         if (!TypeGuard.TTuple(right))             return TypeExtendsResult.False;         if ((left.items === undefined &amp;&amp; right.items !== undefined) || (left.items !== undefined &amp;&amp; right.items === undefined))             return TypeExtendsResult.False;         if (left.items === undefined &amp;&amp; right.items === undefined)             return TypeExtendsResult.True;         return left.items.every((schema, index) =&gt; Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Uint8Array     // --------------------------------------------------------------------------     function Uint8Array(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Undefined     // --------------------------------------------------------------------------     function Undefined(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TNever(right))             return NeverRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         if (TypeGuard.TRecord(right))             return RecordRight(left, right);         if (TypeGuard.TVoid(right))             return VoidRight(left, right);         return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Union     // --------------------------------------------------------------------------     function UnionRight(left, right) {         return right.anyOf.some((schema) =&gt; Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     function Union(left, right) {         return left.anyOf.every((schema) =&gt; Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Unknown     // --------------------------------------------------------------------------     function UnknownRight(left, right) {         return TypeExtendsResult.True;     }     function Unknown(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TString(right))             return StringRight(left, right);         if (TypeGuard.TNumber(right))             return NumberRight(left, right);         if (TypeGuard.TInteger(right))             return IntegerRight(left, right);         if (TypeGuard.TBoolean(right))             return BooleanRight(left, right);         if (TypeGuard.TArray(right))             return ArrayRight(left, right);         if (TypeGuard.TTuple(right))             return TupleRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     // --------------------------------------------------------------------------     // Void     // --------------------------------------------------------------------------     function VoidRight(left, right) {         if (TypeGuard.TUndefined(left))             return TypeExtendsResult.True;         return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     function Void(left, right) {         if (TypeGuard.TIntersect(right))             return IntersectRight(left, right);         if (TypeGuard.TUnion(right))             return UnionRight(left, right);         if (TypeGuard.TUnknown(right))             return UnknownRight(left, right);         if (TypeGuard.TAny(right))             return AnyRight(left, right);         if (TypeGuard.TObject(right))             return ObjectRight(left, right);         return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;     }     function Visit(left, right) {         // template union remap         if (TypeGuard.TTemplateLiteral(left))             return Visit(TemplateLiteralResolver.Resolve(left), right);         if (TypeGuard.TTemplateLiteral(right))             return Visit(left, TemplateLiteralResolver.Resolve(right));         // standard extends         if (TypeGuard.TAny(left))             return Any(left, right);         if (TypeGuard.TArray(left))             return Array(left, right);         if (TypeGuard.TBigInt(left))             return BigInt(left, right);         if (TypeGuard.TBoolean(left))             return Boolean(left, right);         if (TypeGuard.TConstructor(left))             return Constructor(left, right);         if (TypeGuard.TDate(left))             return Date(left, right);         if (TypeGuard.TFunction(left))             return Function(left, right);         if (TypeGuard.TInteger(left))             return Integer(left, right);         if (TypeGuard.TIntersect(left))             return Intersect(left, right);         if (TypeGuard.TLiteral(left))             return Literal(left, right);         if (TypeGuard.TNever(left))             return Never(left, right);         if (TypeGuard.TNull(left))             return Null(left, right);         if (TypeGuard.TNumber(left))             return Number(left, right);         if (TypeGuard.TObject(left))             return Object(left, right);         if (TypeGuard.TRecord(left))             return Record(left, right);         if (TypeGuard.TString(left))             return String(left, right);         if (TypeGuard.TSymbol(left))             return Symbol(left, right);         if (TypeGuard.TTuple(left))             return Tuple(left, right);         if (TypeGuard.TPromise(left))             return Promise(left, right);         if (TypeGuard.TUint8Array(left))             return Uint8Array(left, right);         if (TypeGuard.TUndefined(left))             return Undefined(left, right);         if (TypeGuard.TUnion(left))             return Union(left, right);         if (TypeGuard.TUnknown(left))             return Unknown(left, right);         if (TypeGuard.TVoid(left))             return Void(left, right);         throw Error(<code>TypeExtends: Unknown left type operand '${left[exports.Kind]}'</code>);     }     function Extends(left, right) {         return Visit(left, right);     }     TypeExtends.Extends = Extends; })(TypeExtends = exports.TypeExtends || (exports.TypeExtends = {})); // -------------------------------------------------------------------------- // TypeClone // -------------------------------------------------------------------------- / Specialized Clone for Types / var TypeClone; (function (TypeClone) {     function IsObject(value) {         return typeof value === 'object' &amp;&amp; value !== null;     }     function IsArray(value) {         return globalThis.Array.isArray(value);     }     function Array(value) {         return value.map((value) =&gt; Visit(value));     }     function Object(value) {         const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) =&gt; {             return { ...acc, [key]: Visit(value[key]) };         }, {});         const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) =&gt; {             return { ...acc, [key]: Visit(value[key]) };         }, {});         return { ...clonedProperties, ...clonedSymbols };     }     function Visit(value) {         if (IsArray(value))             return Array(value);         if (IsObject(value))             return Object(value);         return value;     }     / Clones a type. /     function Clone(schema, options) {         return { ...Visit(schema), ...options };     }     TypeClone.Clone = Clone; })(TypeClone = exports.TypeClone || (exports.TypeClone = {})); // -------------------------------------------------------------------------- // ObjectMap // -------------------------------------------------------------------------- var ObjectMap; (function (ObjectMap) {     function Intersect(schema, callback) {         // prettier-ignore         return exports.Type.Intersect(schema.allOf.map((inner) =&gt; Visit(inner, callback)), { ...schema });     }     function Union(schema, callback) {         // prettier-ignore         return exports.Type.Union(schema.anyOf.map((inner) =&gt; Visit(inner, callback)), { ...schema });     }     function Object(schema, callback) {         return callback(schema);     }     function Visit(schema, callback) {         // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would         // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the         // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only         // used for composition, we use explicit checks instead.         if (schema[exports.Kind] === 'Intersect')             return Intersect(schema, callback);         if (schema[exports.Kind] === 'Union')             return Union(schema, callback);         if (schema[exports.Kind] === 'Object')             return Object(schema, callback);         return schema;     }     function Map(schema, callback, options) {         return { ...Visit(TypeClone.Clone(schema, {}), callback), ...options };     }     ObjectMap.Map = Map; })(ObjectMap = exports.ObjectMap || (exports.ObjectMap = {})); // -------------------------------------------------------------------------- // KeyResolver // -------------------------------------------------------------------------- var KeyResolver; (function (KeyResolver) {     function IsKeyable(schema) {         return TypeGuard.TIntersect(schema) || TypeGuard.TUnion(schema) || (TypeGuard.TObject(schema) &amp;&amp; globalThis.Object.getOwnPropertyNames(schema.properties).length &gt; 0);     }     function Intersect(schema) {         return [...schema.allOf.filter((schema) =&gt; IsKeyable(schema)).reduce((set, schema) =&gt; Visit(schema).map((key) =&gt; set.add(key))[0], new Set())];     }     function Union(schema) {         const sets = schema.anyOf.filter((schema) =&gt; IsKeyable(schema)).map((inner) =&gt; Visit(inner));         return [...sets.reduce((set, outer) =&gt; outer.map((key) =&gt; (sets.every((inner) =&gt; inner.includes(key)) ? set.add(key) : set))[0], new Set())];     }     function Object(schema) {         return globalThis.Object.keys(schema.properties);     }     function Visit(schema) {         if (TypeGuard.TIntersect(schema))             return Intersect(schema);         if (TypeGuard.TUnion(schema))             return Union(schema);         if (TypeGuard.TObject(schema))             return Object(schema);         return [];     }     function Resolve(schema) {         return Visit(schema);     }     KeyResolver.Resolve = Resolve; })(KeyResolver = exports.KeyResolver || (exports.KeyResolver = {})); // -------------------------------------------------------------------------- // TemplateLiteralPattern // -------------------------------------------------------------------------- var TemplateLiteralPattern; (function (TemplateLiteralPattern) {     function Escape(value) {         return value.replace(/[.+?^${}()|[]\\]/g, '\\$&amp;');     }     function Visit(schema, acc) {         if (TypeGuard.TTemplateLiteral(schema)) {             const pattern = schema.pattern.slice(1, schema.pattern.length - 1);             return pattern;         }         else if (TypeGuard.TUnion(schema)) {             const tokens = schema.anyOf.map((schema) =&gt; Visit(schema, acc)).join('|');             return <code>(${tokens})</code>;         }         else if (TypeGuard.TNumber(schema)) {             return <code>${acc}${exports.PatternNumber}</code>;         }         else if (TypeGuard.TInteger(schema)) {             return <code>${acc}${exports.PatternNumber}</code>;         }         else if (TypeGuard.TBigInt(schema)) {             return <code>${acc}${exports.PatternNumber}</code>;         }         else if (TypeGuard.TString(schema)) {             return <code>${acc}${exports.PatternString}</code>;         }         else if (TypeGuard.TLiteral(schema)) {             return <code>${acc}${Escape(schema.const.toString())}</code>;         }         else if (TypeGuard.TBoolean(schema)) {             return <code>${acc}${exports.PatternBoolean}</code>;         }         else if (TypeGuard.TNever(schema)) {             throw Error('TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever');         }         else {             throw Error(<code>TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'</code>);         }     }     function Create(kinds) {         return <code>^${kinds.map((schema) =&gt; Visit(schema, '')).join('')}\\$</code>;     }     TemplateLiteralPattern.Create = Create; })(TemplateLiteralPattern = exports.TemplateLiteralPattern || (exports.TemplateLiteralPattern = {})); // -------------------------------------------------------------------------------------- // TemplateLiteralResolver // -------------------------------------------------------------------------------------- var TemplateLiteralResolver; (function (TemplateLiteralResolver) {     function Resolve(template) {         const expression = TemplateLiteralParser.ParseExact(template.pattern);         if (!TemplateLiteralFinite.Check(expression))             return exports.Type.String();         const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) =&gt; exports.Type.Literal(value));         return exports.Type.Union(literals);     }     TemplateLiteralResolver.Resolve = Resolve; })(TemplateLiteralResolver = exports.TemplateLiteralResolver || (exports.TemplateLiteralResolver = {})); // -------------------------------------------------------------------------------------- // TemplateLiteralParser // -------------------------------------------------------------------------------------- class TemplateLiteralParserError extends Error {     constructor(message) {         super(message);     } } exports.TemplateLiteralParserError = TemplateLiteralParserError; var TemplateLiteralParser; (function (TemplateLiteralParser) {     function IsNonEscaped(pattern, index, char) {         return pattern[index] === char &amp;&amp; pattern.charCodeAt(index - 1) !== 92;     }     function IsOpenParen(pattern, index) {         return IsNonEscaped(pattern, index, '(');     }     function IsCloseParen(pattern, index) {         return IsNonEscaped(pattern, index, ')');     }     function IsSeparator(pattern, index) {         return IsNonEscaped(pattern, index, '|');     }     function IsGroup(pattern) {         if (!(IsOpenParen(pattern, 0) &amp;&amp; IsCloseParen(pattern, pattern.length - 1)))             return false;         let count = 0;         for (let index = 0; index &lt; pattern.length; index++) {             if (IsOpenParen(pattern, index))                 count += 1;             if (IsCloseParen(pattern, index))                 count -= 1;             if (count === 0 &amp;&amp; index !== pattern.length - 1)                 return false;         }         return true;     }     function InGroup(pattern) {         return pattern.slice(1, pattern.length - 1);     }     function IsPrecedenceOr(pattern) {         let count = 0;         for (let index = 0; index &lt; pattern.length; index++) {             if (IsOpenParen(pattern, index))                 count += 1;             if (IsCloseParen(pattern, index))                 count -= 1;             if (IsSeparator(pattern, index) &amp;&amp; count === 0)                 return true;         }         return false;     }     function IsPrecedenceAnd(pattern) {         for (let index = 0; index &lt; pattern.length; index++) {             if (IsOpenParen(pattern, index))                 return true;         }         return false;     }     function Or(pattern) {         let [count, start] = [0, 0];         const expressions = [];         for (let index = 0; index &lt; pattern.length; index++) {             if (IsOpenParen(pattern, index))                 count += 1;             if (IsCloseParen(pattern, index))                 count -= 1;             if (IsSeparator(pattern, index) &amp;&amp; count === 0) {                 const range = pattern.slice(start, index);                 if (range.length &gt; 0)                     expressions.push(Parse(range));                 start = index + 1;             }         }         const range = pattern.slice(start);         if (range.length &gt; 0)             expressions.push(Parse(range));         if (expressions.length === 0)             return { type: 'const', const: '' };         if (expressions.length === 1)             return expressions0;         return { type: 'or', expr: expressions };     }     function And(pattern) {         function Group(value, index) {             if (!IsOpenParen(value, index))                 throw new TemplateLiteralParserError(<code>TemplateLiteralParser: Index must point to open parens</code>);             let count = 0;             for (let scan = index; scan &lt; value.length; scan++) {                 if (IsOpenParen(value, scan))                     count += 1;                 if (IsCloseParen(value, scan))                     count -= 1;                 if (count === 0)                     return [index, scan];             }             throw new TemplateLiteralParserError(<code>TemplateLiteralParser: Unclosed group parens in expression</code>);         }         function Range(pattern, index) {             for (let scan = index; scan &lt; pattern.length; scan++) {                 if (IsOpenParen(pattern, scan))                     return [index, scan];             }             return [index, pattern.length];         }         const expressions = [];         for (let index = 0; index &lt; pattern.length; index++) {             if (IsOpenParen(pattern, index)) {                 const [start, end] = Group(pattern, index);                 const range = pattern.slice(start, end + 1);                 expressions.push(Parse(range));                 index = end;             }             else {                 const [start, end] = Range(pattern, index);                 const range = pattern.slice(start, end);                 if (range.length &gt; 0)                     expressions.push(Parse(range));                 index = end - 1;             }         }         if (expressions.length === 0)             return { type: 'const', const: '' };         if (expressions.length === 1)             return expressions0;         return { type: 'and', expr: expressions };     }     / Parses a pattern and returns an expression tree /     function Parse(pattern) {         if (IsGroup(pattern))             return Parse(InGroup(pattern));         if (IsPrecedenceOr(pattern))             return Or(pattern);         if (IsPrecedenceAnd(pattern))             return And(pattern);         return { type: 'const', const: pattern };     }     TemplateLiteralParser.Parse = Parse;     / Parses a pattern and strips forward and trailing ^ and $ /     function ParseExact(pattern) {         return Parse(pattern.slice(1, pattern.length - 1));     }     TemplateLiteralParser.ParseExact = ParseExact; })(TemplateLiteralParser = exports.TemplateLiteralParser || (exports.TemplateLiteralParser = {})); // -------------------------------------------------------------------------------------- // TemplateLiteralFinite // -------------------------------------------------------------------------------------- var TemplateLiteralFinite; (function (TemplateLiteralFinite) {     function IsNumber(expression) {         // prettier-ignore         return (expression.type === 'or' &amp;&amp;             expression.expr.length === 2 &amp;&amp;             expression.expr0.type === 'const' &amp;&amp;             expression.expr0.const === '0' &amp;&amp;             expression.expr[1].type === 'const' &amp;&amp;             expression.expr[1].const === '[1-9][0-9]');     }     function IsBoolean(expression) {         // prettier-ignore         return (expression.type === 'or' &amp;&amp;             expression.expr.length === 2 &amp;&amp;             expression.expr0.type === 'const' &amp;&amp;             expression.expr0.const === 'true' &amp;&amp;             expression.expr[1].type === 'const' &amp;&amp;             expression.expr[1].const === 'false');     }     function IsString(expression) {         return expression.type === 'const' &amp;&amp; expression.const === '.';     }     function Check(expression) {         if (IsBoolean(expression))             return true;         if (IsNumber(expression) || IsString(expression))             return false;         if (expression.type === 'and')             return expression.expr.every((expr) =&gt; Check(expr));         if (expression.type === 'or')             return expression.expr.every((expr) =&gt; Check(expr));         if (expression.type === 'const')             return true;         throw Error(<code>TemplateLiteralFinite: Unknown expression type</code>);     }     TemplateLiteralFinite.Check = Check; })(TemplateLiteralFinite = exports.TemplateLiteralFinite || (exports.TemplateLiteralFinite = {})); // -------------------------------------------------------------------------------------- // TemplateLiteralGenerator // -------------------------------------------------------------------------------------- var TemplateLiteralGenerator; (function (TemplateLiteralGenerator) {     function Reduce(buffer) {         if (buffer.length === 1)             return yield buffer0;         for (const left of buffer0) {             for (const right of Reduce(buffer.slice(1))) {                 yield <code>${left}${right}</code>;             }         }     }     function And(expression) {         return yield Reduce(expression.expr.map((expr) =&gt; [...Generate(expr)]));     }     function Or(expression) {         for (const expr of expression.expr)             yield Generate(expr);     }     function Const(expression) {         return yield expression.const;     }     function Generate(expression) {         if (expression.type === 'and')             return yield And(expression);         if (expression.type === 'or')             return yield Or(expression);         if (expression.type === 'const')             return yield Const(expression);         throw Error('TemplateLiteralGenerator: Unknown expression');     }     TemplateLiteralGenerator.Generate = Generate; })(TemplateLiteralGenerator = exports.TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = {})); // -------------------------------------------------------------------------- // TypeOrdinal: Used for auto $id generation // -------------------------------------------------------------------------- let TypeOrdinal = 0; // -------------------------------------------------------------------------- // TypeBuilder // -------------------------------------------------------------------------- class TypeBuilder {     / <code>[Utility]</code> Creates a schema without <code>static</code> and <code>params</code> types /     Create(schema) {         return schema;     }     / <code>[Standard]</code> Omits compositing symbols from this schema */     Strict(schema) {         return JSON.parse(JSON.stringify(schema));     } } exports.TypeBuilder = TypeBuilder; // -------------------------------------------------------------------------- // StandardTypeBuilder // -------------------------------------------------------------------------- class StandardTypeBuilder extends TypeBuilder {     // ------------------------------------------------------------------------     // Modifiers     // ------------------------------------------------------------------------     / <code>[Modifier]</code> Creates a Optional property /     Optional(schema) {         return { [exports.Modifier]: 'Optional', ...TypeClone.Clone(schema, {}) };     }     / <code>[Modifier]</code> Creates a ReadonlyOptional property /     ReadonlyOptional(schema) {         return { [exports.Modifier]: 'ReadonlyOptional', ...TypeClone.Clone(schema, {}) };     }     / <code>[Modifier]</code> Creates a Readonly object or property */     Readonly(schema) {         return { [exports.Modifier]: 'Readonly', ...schema };     }     // ------------------------------------------------------------------------     // Types     // ------------------------------------------------------------------------     / <code>[Standard]</code> Creates an Any type /     Any(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Any' });     }     / <code>[Standard]</code> Creates an Array type /     Array(items, options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Clone(items, {}) });     }     / <code>[Standard]</code> Creates a Boolean type */     Boolean(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });     }     / <code>[Standard]</code> Creates a Composite object type. /     Composite(objects, options) {         const isOptionalAll = (objects, key) =&gt; objects.every((object) =&gt; !(key in object.properties) || IsOptional(object.properties[key]));         const IsOptional = (schema) =&gt; TypeGuard.TOptional(schema) || TypeGuard.TReadonlyOptional(schema);         const [required, optional] = [new Set(), new Set()];         for (const object of objects) {             for (const key of globalThis.Object.getOwnPropertyNames(object.properties)) {                 if (isOptionalAll(objects, key))                     optional.add(key);             }         }         for (const object of objects) {             for (const key of globalThis.Object.getOwnPropertyNames(object.properties)) {                 if (!optional.has(key))                     required.add(key);             }         }         const properties = {};         for (const object of objects) {             for (const [key, schema] of Object.entries(object.properties)) {                 const property = TypeClone.Clone(schema, {});                 if (!optional.has(key))                     delete property[exports.Modifier];                 if (key in properties) {                     const left = TypeExtends.Extends(properties[key], property) !== TypeExtendsResult.False;                     const right = TypeExtends.Extends(property, properties[key]) !== TypeExtendsResult.False;                     if (!left &amp;&amp; !right)                         properties[key] = exports.Type.Never();                     if (!left &amp;&amp; right)                         properties[key] = property;                 }                 else {                     properties[key] = property;                 }             }         }         if (required.size &gt; 0) {             return this.Create({ ...options, [exports.Kind]: 'Object', [exports.Hint]: 'Composite', type: 'object', properties, required: [...required] });         }         else {             return this.Create({ ...options, [exports.Kind]: 'Object', [exports.Hint]: 'Composite', type: 'object', properties });         }     }     / <code>[Standard]</code> Creates a Enum type /     Enum(item, options = {}) {         // prettier-ignore         const values = globalThis.Object.keys(item).filter((key) =&gt; isNaN(key)).map((key) =&gt; item[key]);         const anyOf = values.map((value) =&gt; (typeof value === 'string' ? { [exports.Kind]: 'Literal', type: 'string', const: value } : { [exports.Kind]: 'Literal', type: 'number', const: value }));         return this.Create({ ...options, [exports.Kind]: 'Union', anyOf });     }     / <code>[Standard]</code> A conditional type expression that will return the true type if the left type extends the right */     Extends(left, right, trueType, falseType, options = {}) {         switch (TypeExtends.Extends(left, right)) {             case TypeExtendsResult.Union:                 return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);             case TypeExtendsResult.True:                 return TypeClone.Clone(trueType, options);             case TypeExtendsResult.False:                 return TypeClone.Clone(falseType, options);         }     }     / <code>[Standard]</code> Excludes from the left type any type that is not assignable to the right /     Exclude(left, right, options = {}) {         if (TypeGuard.TTemplateLiteral(left))             return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);         if (TypeGuard.TTemplateLiteral(right))             return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);         if (TypeGuard.TUnion(left)) {             const narrowed = left.anyOf.filter((inner) =&gt; TypeExtends.Extends(inner, right) === TypeExtendsResult.False);             return (narrowed.length === 1 ? TypeClone.Clone(narrowed0, options) : this.Union(narrowed, options));         }         else {             return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options));         }     }     / <code>[Standard]</code> Extracts from the left type any type that is assignable to the right /     Extract(left, right, options = {}) {         if (TypeGuard.TTemplateLiteral(left))             return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);         if (TypeGuard.TTemplateLiteral(right))             return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);         if (TypeGuard.TUnion(left)) {             const narrowed = left.anyOf.filter((inner) =&gt; TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);             return (narrowed.length === 1 ? TypeClone.Clone(narrowed0, options) : this.Union(narrowed, options));         }         else {             return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options));         }     }     / <code>[Standard]</code> Creates an Integer type */     Integer(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });     }     Intersect(allOf, options = {}) {         if (allOf.length === 0)             return exports.Type.Never();         if (allOf.length === 1)             return TypeClone.Clone(allOf0, options);         const objects = allOf.every((schema) =&gt; TypeGuard.TObject(schema));         const cloned = allOf.map((schema) =&gt; TypeClone.Clone(schema, {}));         const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};         if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {             return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned });         }         else {             return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });         }     }     / <code>[Standard]</code> Creates a KeyOf type /     KeyOf(schema, options = {}) {         if (TypeGuard.TRecord(schema)) {             const pattern = Object.getOwnPropertyNames(schema.patternProperties)0;             if (pattern === exports.PatternNumberExact)                 return this.Number(options);             if (pattern === exports.PatternStringExact)                 return this.String(options);             throw Error('StandardTypeBuilder: Unable to resolve key type from Record key pattern');         }         else {             const resolved = KeyResolver.Resolve(schema);             if (resolved.length === 0)                 return this.Never(options);             const literals = resolved.map((key) =&gt; this.Literal(key));             return this.Union(literals, options);         }     }     / <code>[Standard]</code> Creates a Literal type /     Literal(value, options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });     }     / <code>[Standard]</code> Creates a Never type */     Never(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });     }     / <code>[Standard]</code> Creates a Not type. The first argument is the disallowed type, the second is the allowed. /     Not(not, schema, options) {         return this.Create({ ...options, [exports.Kind]: 'Not', allOf: [{ not: TypeClone.Clone(not, {}) }, TypeClone.Clone(schema, {})] });     }     / <code>[Standard]</code> Creates a Null type /     Null(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });     }     / <code>[Standard]</code> Creates a Number type */     Number(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });     }     / <code>[Standard]</code> Creates an Object type /     Object(properties, options = {}) {         const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);         const optionalKeys = propertyKeys.filter((key) =&gt; TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));         const requiredKeys = propertyKeys.filter((name) =&gt; !optionalKeys.includes(name));         const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};         const clonedProperties = propertyKeys.reduce((acc, key) =&gt; ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});         if (requiredKeys.length &gt; 0) {             return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys });         }         else {             return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });         }     }     Omit(schema, unresolved, options = {}) {         // prettier-ignore         const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map((schema) =&gt; schema.const) :             TypeGuard.TLiteral(unresolved) ? [unresolved.const] :                 TypeGuard.TNever(unresolved) ? [] :                     unresolved;         // prettier-ignore         return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) =&gt; {             if (schema.required) {                 schema.required = schema.required.filter((key) =&gt; !keys.includes(key));                 if (schema.required.length === 0)                     delete schema.required;             }             for (const key of globalThis.Object.keys(schema.properties)) {                 if (keys.includes(key))                     delete schema.properties[key];             }             return this.Create(schema);         }, options);     }     / <code>[Standard]</code> Creates a mapped type where all properties are Optional /     Partial(schema, options = {}) {         function Apply(schema) {             // prettier-ignore             switch (schema[exports.Modifier]) {                 case 'ReadonlyOptional':                     schema[exports.Modifier] = 'ReadonlyOptional';                     break;                 case 'Readonly':                     schema[exports.Modifier] = 'ReadonlyOptional';                     break;                 case 'Optional':                     schema[exports.Modifier] = 'Optional';                     break;                 default:                     schema[exports.Modifier] = 'Optional';                     break;             }         }         // prettier-ignore         return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) =&gt; {             delete schema.required;             globalThis.Object.keys(schema.properties).forEach(key =&gt; Apply(schema.properties[key]));             return schema;         }, options);     }     Pick(schema, unresolved, options = {}) {         // prettier-ignore         const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map((schema) =&gt; schema.const) :             TypeGuard.TLiteral(unresolved) ? [unresolved.const] :                 TypeGuard.TNever(unresolved) ? [] :                     unresolved;         // prettier-ignore         return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) =&gt; {             if (schema.required) {                 schema.required = schema.required.filter((key) =&gt; keys.includes(key));                 if (schema.required.length === 0)                     delete schema.required;             }             for (const key of globalThis.Object.keys(schema.properties)) {                 if (!keys.includes(key))                     delete schema.properties[key];             }             return this.Create(schema);         }, options);     }     / <code>[Standard]</code> Creates a Record type */     Record(key, schema, options = {}) {         if (TypeGuard.TTemplateLiteral(key)) {             const expression = TemplateLiteralParser.ParseExact(key.pattern);             // prettier-ignore             return TemplateLiteralFinite.Check(expression)                 ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) =&gt; ({ ...acc, [key]: TypeClone.Clone(schema, {}) }), {}), options))                 : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });         }         else if (TypeGuard.TUnionLiteral(key)) {             if (key.anyOf.every((schema) =&gt; TypeGuard.TLiteral(schema) &amp;&amp; (typeof schema.const === 'string' || typeof schema.const === 'number'))) {                 const properties = key.anyOf.reduce((acc, literal) =&gt; ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});                 return this.Object(properties, { ...options, [exports.Hint]: 'Record' });             }             else                 throw Error('TypeBuilder: Record key can only be derived from union literal of number or string');         }         else if (TypeGuard.TLiteral(key)) {             if (typeof key.const === 'string' || typeof key.const === 'number') {                 return this.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);             }             else                 throw Error('TypeBuilder: Record key can only be derived from literals of number or string');         }         else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {             const pattern = exports.PatternNumberExact;             return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });         }         else if (TypeGuard.TString(key)) {             const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;             return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });         }         else {             throw Error(<code>StandardTypeBuilder: Invalid Record Key</code>);         }     }     / <code>[Standard]</code> Creates a Recursive type /     Recursive(callback, options = {}) {         if (options.$id === undefined)             options.$id = <code>T${TypeOrdinal++}</code>;         const thisType = callback({ [exports.Kind]: 'This', $ref: <code>${options.$id}</code> });         thisType.$id = options.$id;         return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });     }     / <code>[Standard]</code> Creates a Ref type. The referenced type must contain a $id /     Ref(schema, options = {}) {         if (schema.$id === undefined)             throw Error('StandardTypeBuilder.Ref: Target type must specify an $id');         return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: schema.$id });     }     / <code>[Standard]</code> Creates a mapped type where all properties are Required */     Required(schema, options = {}) {         function Apply(schema) {             // prettier-ignore             switch (schema[exports.Modifier]) {                 case 'ReadonlyOptional':                     schema[exports.Modifier] = 'Readonly';                     break;                 case 'Readonly':                     schema[exports.Modifier] = 'Readonly';                     break;                 case 'Optional':                     delete schema[exports.Modifier];                     break;                 default:                     delete schema[exports.Modifier];                     break;             }         }         // prettier-ignore         return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) =&gt; {             schema.required = globalThis.Object.keys(schema.properties);             globalThis.Object.keys(schema.properties).forEach(key =&gt; Apply(schema.properties[key]));             return schema;         }, options);     }     / <code>[Standard]</code> Creates a String type /     String(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });     }     / <code>[Standard]</code> Creates a template literal type /     TemplateLiteral(kinds, options = {}) {         const pattern = TemplateLiteralPattern.Create(kinds);         return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });     }     / <code>[Standard]</code> Creates a Tuple type */     Tuple(items, options = {}) {         const [additionalItems, minItems, maxItems] = [false, items.length, items.length];         const clonedItems = items.map((item) =&gt; TypeClone.Clone(item, {}));         // prettier-ignore         const schema = (items.length &gt; 0 ?             { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :             { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });         return this.Create(schema);     }     Union(union, options = {}) {         if (TypeGuard.TTemplateLiteral(union)) {             return TemplateLiteralResolver.Resolve(union);         }         else {             const anyOf = union;             if (anyOf.length === 0)                 return this.Never(options);             if (anyOf.length === 1)                 return this.Create(TypeClone.Clone(anyOf0, options));             const clonedAnyOf = anyOf.map((schema) =&gt; TypeClone.Clone(schema, {}));             return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });         }     }     / <code>[Standard]</code> Creates an Unknown type /     Unknown(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Unknown' });     }     / <code>[Standard]</code> Creates a Unsafe type that infers for the generic argument /     Unsafe(options = {}) {         return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });     } } exports.StandardTypeBuilder = StandardTypeBuilder; // -------------------------------------------------------------------------- // ExtendedTypeBuilder // -------------------------------------------------------------------------- class ExtendedTypeBuilder extends StandardTypeBuilder {     / <code>[Extended]</code> Creates a BigInt type */     BigInt(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'null', typeOf: 'BigInt' });     }     / <code>[Extended]</code> Extracts the ConstructorParameters from the given Constructor type /     ConstructorParameters(schema, options = {}) {         return this.Tuple([...schema.parameters], { ...options });     }     Constructor(parameters, returns, options = {}) {         const clonedReturns = TypeClone.Clone(returns, {});         if (TypeGuard.TTuple(parameters)) {             const clonedParameters = parameters.items === undefined ? [] : parameters.items.map((parameter) =&gt; TypeClone.Clone(parameter, {}));             return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'object', instanceOf: 'Constructor', parameters: clonedParameters, returns: clonedReturns });         }         else if (globalThis.Array.isArray(parameters)) {             const clonedParameters = parameters.map((parameter) =&gt; TypeClone.Clone(parameter, {}));             return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'object', instanceOf: 'Constructor', parameters: clonedParameters, returns: clonedReturns });         }         else {             throw new Error('ExtendedTypeBuilder.Constructor: Invalid parameters');         }     }     / <code>[Extended]</code> Creates a Date type /     Date(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Date', type: 'object', instanceOf: 'Date' });     }     Function(parameters, returns, options = {}) {         const clonedReturns = TypeClone.Clone(returns, {});         if (TypeGuard.TTuple(parameters)) {             const clonedParameters = parameters.items === undefined ? [] : parameters.items.map((parameter) =&gt; TypeClone.Clone(parameter, {}));             return this.Create({ ...options, [exports.Kind]: 'Function', type: 'object', instanceOf: 'Function', parameters: clonedParameters, returns: clonedReturns });         }         else if (globalThis.Array.isArray(parameters)) {             const clonedParameters = parameters.map((parameter) =&gt; TypeClone.Clone(parameter, {}));             return this.Create({ ...options, [exports.Kind]: 'Function', type: 'object', instanceOf: 'Function', parameters: clonedParameters, returns: clonedReturns });         }         else {             throw new Error('ExtendedTypeBuilder.Function: Invalid parameters');         }     }     / <code>[Extended]</code> Extracts the InstanceType from the given Constructor */     InstanceType(schema, options = {}) {         return TypeClone.Clone(schema.returns, options);     }     / <code>[Extended]</code> Extracts the Parameters from the given Function type /     Parameters(schema, options = {}) {         return this.Tuple(schema.parameters, { ...options });     }     / <code>[Extended]</code> Creates a Promise type /     Promise(item, options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'object', instanceOf: 'Promise', item: TypeClone.Clone(item, {}) });     }     / <code>[Extended]</code> Creates a regular expression type */     RegEx(regex, options = {}) {         return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern: regex.source });     }     / <code>[Extended]</code> Extracts the ReturnType from the given Function /     ReturnType(schema, options = {}) {         return TypeClone.Clone(schema.returns, options);     }     / <code>[Extended]</code> Creates a Symbol type /     Symbol(options) {         return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'null', typeOf: 'Symbol' });     }     / <code>[Extended]</code> Creates a Undefined type */     Undefined(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'null', typeOf: 'Undefined' });     }     / <code>[Extended]</code> Creates a Uint8Array type /     Uint8Array(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'object', instanceOf: 'Uint8Array' });     }     / <code>[Extended]</code> Creates a Void type /     Void(options = {}) {         return this.Create({ ...options, [exports.Kind]: 'Void', type: 'null', typeOf: 'Void' });     } } exports.ExtendedTypeBuilder = ExtendedTypeBuilder; /** JSON Schema TypeBuilder with Static Resolution for TypeScript"},{"location":"autogenerated/code-summary/#type","title":"Type","text":"<p>Source: <code>my-backend/node_modules/@sinclair/typebox/typebox.js</code></p> <p>Signature: <code>Type(= new ExtendedTypeBuilder()</code></p> <p>JSDoc:</p> <p>JSON Schema TypeBuilder with Static Resolution for TypeScript</p>"},{"location":"autogenerated/code-summary/#wrap","title":"wrap","text":"<p>Source: <code>my-backend/node_modules/@sinonjs/commons/lib/deprecated.js</code></p> <p>Signature: <code>wrap(= function (func, msg)</code></p> <p>JSDoc:</p> <p>Returns a function that will invoke the supplied function and print a deprecation warning to the console each time it is called. @param  {Function} func @param  {string} msg @returns {Function}</p>"},{"location":"autogenerated/code-summary/#defaultmsg","title":"defaultMsg","text":"<p>Source: <code>my-backend/node_modules/@sinonjs/commons/lib/deprecated.js</code></p> <p>Signature: <code>defaultMsg(= function (packageName, funcName)</code></p> <p>JSDoc:</p> <p>Returns a string which can be supplied to <code>wrap()</code> to notify the user that a particular part of the sinon API has been deprecated. @param  {string} packageName @param  {string} funcName @returns {string}</p>"},{"location":"autogenerated/code-summary/#printwarning","title":"printWarning","text":"<p>Source: <code>my-backend/node_modules/@sinonjs/commons/lib/deprecated.js</code></p> <p>Signature: <code>printWarning(= function (msg)</code></p> <p>JSDoc:</p> <p>Prints a warning on the console, when it exists @param  {string} msg @returns {undefined}</p>"},{"location":"autogenerated/code-summary/#transform","title":"transform","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transform(code: string, callback: FileResultCallback)</code></p> <p>JSDoc:</p> <p>Source map standard format as to revision 3 @see {@link https://sourcemaps.info/spec.html} @see {@link https://github.com/mozilla/source-map/blob/HEAD/source-map.d.ts} / interface InputSourceMap {     version: number;     sources: string[];     names: string[];     sourceRoot?: string | undefined;     sourcesContent?: string[] | undefined;     mappings: string;     file: string; }</p> <p>export interface TransformOptions {     / Specify which assumptions it can make about your code, to better optimize the compilation result. NOTE**: This replaces the various <code>loose</code> options in plugins in favor of top-level options that can apply to multiple plugins</p> <p>@see https://babeljs.io/docs/en/assumptions /     assumptions?: { name: string: boolean } | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Include the AST in the returned object</p> <p>Default: <code>false</code> /     ast?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Attach a comment after all non-user injected code</p> <p>Default: <code>null</code> /     auxiliaryCommentAfter?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Attach a comment before all non-user injected code</p> <p>Default: <code>null</code> /     auxiliaryCommentBefore?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Specify the \"root\" folder that defines the location to search for \"babel.config.js\", and the default folder to allow <code>.babelrc</code> files inside of.</p> <p>Default: <code>\".\"</code> /     root?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>This option, combined with the \"root\" value, defines how Babel chooses its project root. The different modes define different ways that Babel can process the \"root\" value to get the final project root.</p> <p>@see https://babeljs.io/docs/en/next/options#rootmode /     rootMode?: \"root\" | \"upward\" | \"upward-optional\" | undefined;</p> <pre><code>/**\n</code></pre> <p>The config file to load Babel's config from. Defaults to searching for \"babel.config.js\" inside the \"root\" folder. <code>false</code> will disable searching for config files.</p> <p>Default: <code>undefined</code> /     configFile?: string | boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Specify whether or not to use .babelrc and .babelignore files.</p> <p>Default: <code>true</code> /     babelrc?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Specify which packages should be search for .babelrc files when they are being compiled. <code>true</code> to always search, or a path string or an array of paths to packages to search inside of. Defaults to only searching the \"root\" package.</p> <p>Default: <code>(root)</code> /     babelrcRoots?: boolean | MatchPattern | MatchPattern[] | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Toggles whether or not browserslist config sources are used, which includes searching for any browserslist files or referencing the browserslist key inside package.json. This is useful for projects that use a browserslist config for files that won't be compiled with Babel.</p> <p>If a string is specified, it must represent the path of a browserslist configuration file. Relative paths are resolved relative to the configuration file which specifies this option, or to <code>cwd</code> when it's passed as part of the programmatic options.</p> <p>Default: <code>true</code> /     browserslistConfigFile?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>The Browserslist environment to use.</p> <p>Default: <code>undefined</code> /     browserslistEnv?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>By default <code>babel.transformFromAst</code> will clone the input AST to avoid mutations. Specifying <code>cloneInputAst: false</code> can improve parsing performance if the input AST is not used elsewhere.</p> <p>Default: <code>true</code> /     cloneInputAst?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Defaults to environment variable <code>BABEL_ENV</code> if set, or else <code>NODE_ENV</code> if set, or else it defaults to <code>\"development\"</code></p> <p>Default: env vars /     envName?: string | undefined;</p> <pre><code>/**\n</code></pre> <p>If any of patterns match, the current configuration object is considered inactive and is ignored during config processing. /     exclude?: MatchPattern | MatchPattern[] | undefined;</p> <pre><code>/**\n</code></pre> <p>Enable code generation</p> <p>Default: <code>true</code> /     code?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Output comments in generated output</p> <p>Default: <code>true</code> /     comments?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Do not include superfluous whitespace characters and line terminators. When set to <code>\"auto\"</code> compact is set to <code>true</code> on input sizes of &gt;500KB</p> <p>Default: <code>\"auto\"</code> /     compact?: boolean | \"auto\" | null | undefined;</p> <pre><code>/**\n</code></pre> <p>The working directory that Babel's programmatic options are loaded relative to.</p> <p>Default: <code>\".\"</code> /     cwd?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Utilities may pass a caller object to identify themselves to Babel and pass capability-related flags for use by configs, presets and plugins.</p> <p>@see https://babeljs.io/docs/en/next/options#caller /     caller?: TransformCaller | undefined;</p> <pre><code>/**\n</code></pre> <p>This is an object of keys that represent different environments. For example, you may have: <code>{ env: { production: { \\/* specific options *\\/ } } }</code> which will use those options when the <code>envName</code> is <code>production</code></p> <p>Default: <code>{}</code> /     env?: { [index: string]: TransformOptions | null | undefined } | null | undefined;</p> <pre><code>/**\n</code></pre> <p>A path to a <code>.babelrc</code> file to extend</p> <p>Default: <code>null</code> /     extends?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Filename for use in errors etc</p> <p>Default: <code>\"unknown\"</code> /     filename?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Filename relative to <code>sourceRoot</code></p> <p>Default: <code>(filename)</code> /     filenameRelative?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>An object containing the options to be passed down to the babel code generator, @babel/generator</p> <p>Default: <code>{}</code> /     generatorOpts?: GeneratorOptions | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Specify a custom callback to generate a module id with. Called as <code>getModuleId(moduleName)</code>. If falsy value is returned then the generated module id is used</p> <p>Default: <code>null</code> /     getModuleId?: ((moduleName: string) =&gt; string | null | undefined) | null | undefined;</p> <pre><code>/**\n</code></pre> <p>ANSI highlight syntax error code frames</p> <p>Default: <code>true</code> /     highlightCode?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Opposite to the <code>only</code> option. <code>ignore</code> is disregarded if <code>only</code> is specified</p> <p>Default: <code>null</code> /     ignore?: MatchPattern[] | null | undefined;</p> <pre><code>/**\n</code></pre> <p>This option is a synonym for \"test\" /     include?: MatchPattern | MatchPattern[] | undefined;</p> <pre><code>/**\n</code></pre> <p>A source map object that the output source map will be based on</p> <p>Default: <code>null</code> /     inputSourceMap?: InputSourceMap | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Should the output be minified (not printing last semicolons in blocks, printing literal string values instead of escaped ones, stripping <code>()</code> from <code>new</code> when safe)</p> <p>Default: <code>false</code> /     minified?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Specify a custom name for module ids</p> <p>Default: <code>null</code> /     moduleId?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>If truthy, insert an explicit id for modules. By default, all modules are anonymous. (Not available for <code>common</code> modules)</p> <p>Default: <code>false</code> /     moduleIds?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Optional prefix for the AMD module formatter that will be prepend to the filename on module definitions</p> <p>Default: <code>(sourceRoot)</code> /     moduleRoot?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>A glob, regex, or mixed array of both, matching paths to only compile. Can also be an array of arrays containing paths to explicitly match. When attempting to compile a non-matching file it's returned verbatim</p> <p>Default: <code>null</code> /     only?: MatchPattern[] | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Allows users to provide an array of options that will be merged into the current configuration one at a time. This feature is best used alongside the \"test\"/\"include\"/\"exclude\" options to provide conditions for which an override should apply /     overrides?: TransformOptions[] | undefined;</p> <pre><code>/**\n</code></pre> <p>An object containing the options to be passed down to the babel parser, @babel/parser</p> <p>Default: <code>{}</code> /     parserOpts?: ParserOptions | null | undefined;</p> <pre><code>/**\n</code></pre> <p>List of plugins to load and use</p> <p>Default: <code>[]</code> /     plugins?: PluginItem[] | null | undefined;</p> <pre><code>/**\n</code></pre> <p>List of presets (a set of plugins) to load and use</p> <p>Default: <code>[]</code> /     presets?: PluginItem[] | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Retain line numbers. This will lead to wacky code but is handy for scenarios where you can't use source maps. (NOTE: This will not retain the columns)</p> <p>Default: <code>false</code> /     retainLines?: boolean | null | undefined;</p> <pre><code>/**\n</code></pre> <p>An optional callback that controls whether a comment should be output or not. Called as <code>shouldPrintComment(commentContents)</code>. NOTE: This overrides the <code>comment</code> option when used</p> <p>Default: <code>null</code> /     shouldPrintComment?: ((commentContents: string) =&gt; boolean) | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Set <code>sources[0]</code> on returned source map</p> <p>Default: <code>(filenameRelative)</code> /     sourceFileName?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>If truthy, adds a <code>map</code> property to returned output. If set to <code>\"inline\"</code>, a comment with a sourceMappingURL directive is added to the bottom of the returned code. If set to <code>\"both\"</code> then a <code>map</code> property is returned as well as a source map comment appended. This does not emit sourcemap files by itself!</p> <p>Default: <code>false</code> /     sourceMaps?: boolean | \"inline\" | \"both\" | null | undefined;</p> <pre><code>/**\n</code></pre> <p>The root from which all sources are relative</p> <p>Default: <code>(moduleRoot)</code> /     sourceRoot?: string | null | undefined;</p> <pre><code>/**\n</code></pre> <p>Indicate the mode the code should be parsed in. Can be one of \"script\", \"module\", or \"unambiguous\". <code>\"unambiguous\"</code> will make Babel attempt to guess, based on the presence of ES6 <code>import</code> or <code>export</code> statements. Files with ES6 <code>import</code>s and <code>export</code>s are considered <code>\"module\"</code> and are otherwise <code>\"script\"</code>.</p> <p>Default: <code>(\"module\")</code> /     sourceType?: \"script\" | \"module\" | \"unambiguous\" | null | undefined;</p> <pre><code>/**\n</code></pre> <p>If all patterns fail to match, the current configuration object is considered inactive and is ignored during config processing. /     test?: MatchPattern | MatchPattern[] | undefined;</p> <pre><code>/**\n</code></pre> <p>Describes the environments you support/target for your project. This can either be a browserslist-compatible query (with caveats)</p> <p>Default: <code>{}</code> /     targets?:         | string         | string[]         | {             esmodules?: boolean;             node?: Omit | \"current\" | true;             safari?: Omit | \"tp\";             browsers?: string | string[];             android?: string;             chrome?: string;             deno?: string;             edge?: string;             electron?: string;             firefox?: string;             ie?: string;             ios?: string;             opera?: string;             rhino?: string;             samsung?: string;         }; <pre><code>/**\n</code></pre> <p>An optional callback that can be used to wrap visitor methods. NOTE: This is useful for things like introspection, and not really needed for implementing anything. Called as <code>wrapPluginVisitorMethod(pluginAlias, visitorType, callback)</code>. /     wrapPluginVisitorMethod?:         | ((             pluginAlias: string,             visitorType: \"enter\" | \"exit\",             callback: (path: NodePath, state: any) =&gt; void,         ) =&gt; (path: NodePath, state: any) =&gt; void)         | null         | undefined; }</p> <p>export interface TransformCaller {     // the only required property     name: string;     // e.g. set to true by <code>babel-loader</code> and false by <code>babel-jest</code>     supportsStaticESM?: boolean | undefined;     supportsDynamicImport?: boolean | undefined;     supportsExportNamespaceFrom?: boolean | undefined;     supportsTopLevelAwait?: boolean | undefined;     // augment this with a \"declare module '@babel/core' { ... }\" if you need more keys }</p> <p>export type FileResultCallback = (err: Error | null, result: BabelFileResult | null) =&gt; any;</p> <p>export interface MatchPatternContext {     envName: string;     dirname: string;     caller: TransformCaller | undefined; } export type MatchPattern = string | RegExp | ((filename: string | undefined, context: MatchPatternContext) =&gt; boolean);</p> <p>/** Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.</p>"},{"location":"autogenerated/code-summary/#transform_1","title":"transform","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transform(code: string, opts: TransformOptions | undefined, callback: FileResultCallback)</code></p> <p>JSDoc:</p> <p>Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.</p>"},{"location":"autogenerated/code-summary/#transform_2","title":"transform","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transform(code: string, opts?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Here for backward-compatibility. Ideally use <code>transformSync</code> if you want a synchronous API.</p>"},{"location":"autogenerated/code-summary/#transformsync","title":"transformSync","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformSync(code: string, opts?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Transforms the passed in code. Returning an object with the generated code, source map, and AST.</p>"},{"location":"autogenerated/code-summary/#transformasync","title":"transformAsync","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformAsync(code: string, opts?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.</p>"},{"location":"autogenerated/code-summary/#transformfile","title":"transformFile","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformFile(filename: string, callback: FileResultCallback)</code></p> <p>JSDoc:</p> <p>Asynchronously transforms the entire contents of a file.</p>"},{"location":"autogenerated/code-summary/#transformfile_1","title":"transformFile","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformFile(filename: string, opts: TransformOptions | undefined, callback: FileResultCallback)</code></p> <p>JSDoc:</p> <p>Asynchronously transforms the entire contents of a file.</p>"},{"location":"autogenerated/code-summary/#transformfilesync","title":"transformFileSync","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformFileSync(filename: string, opts?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Synchronous version of <code>babel.transformFile</code>. Returns the transformed contents of the <code>filename</code>.</p>"},{"location":"autogenerated/code-summary/#transformfileasync","title":"transformFileAsync","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformFileAsync(filename: string, opts?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Asynchronously transforms the entire contents of a file.</p>"},{"location":"autogenerated/code-summary/#transformfromast","title":"transformFromAst","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformFromAst(ast: Node, code: string | undefined, callback: FileResultCallback)</code></p> <p>JSDoc:</p> <p>Given an AST, transform it.</p>"},{"location":"autogenerated/code-summary/#transformfromast_1","title":"transformFromAst","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformFromAst(     ast: Node,     code: string | undefined,     opts: TransformOptions | undefined,     callback: FileResultCallback, )</code></p> <p>JSDoc:</p> <p>Given an AST, transform it.</p>"},{"location":"autogenerated/code-summary/#transformfromastsync","title":"transformFromAstSync","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformFromAstSync(ast: Node, code?: string, opts?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Here for backward-compatibility. Ideally use \".transformSync\" if you want a synchronous API.</p>"},{"location":"autogenerated/code-summary/#transformfromastasync","title":"transformFromAstAsync","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>transformFromAstAsync(     ast: Node,     code?: string,     opts?: TransformOptions, )</code></p> <p>JSDoc:</p> <p>Given an AST, transform it.</p>"},{"location":"autogenerated/code-summary/#parse","title":"parse","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>parse(code: string, callback: FileParseCallback)</code></p> <p>JSDoc:</p> <p>Given some code, parse it using Babel's standard behavior. Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.</p>"},{"location":"autogenerated/code-summary/#parse_1","title":"parse","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>parse(code: string, options: TransformOptions | undefined, callback: FileParseCallback)</code></p> <p>JSDoc:</p> <p>Given some code, parse it using Babel's standard behavior. Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.</p>"},{"location":"autogenerated/code-summary/#parse_2","title":"parse","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>parse(code: string, options?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Given some code, parse it using Babel's standard behavior. Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.</p>"},{"location":"autogenerated/code-summary/#parsesync","title":"parseSync","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>parseSync(code: string, options?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Given some code, parse it using Babel's standard behavior. Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.</p>"},{"location":"autogenerated/code-summary/#parseasync","title":"parseAsync","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>parseAsync(code: string, options?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Given some code, parse it using Babel's standard behavior. Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.</p>"},{"location":"autogenerated/code-summary/#loadoptions","title":"loadOptions","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>loadOptions(options?: TransformOptions)</code></p> <p>JSDoc:</p> <p>Resolve Babel's options fully, resulting in an options object where:</p> <ul> <li>opts.plugins is a full list of Plugin instances.</li> <li>opts.presets is empty and all presets are flattened into opts.</li> <li>It can be safely passed back to Babel. Fields like babelrc have been set to false so that later calls to Babel will not make a second attempt to load config files.</li> </ul> <p>Plugin instances aren't meant to be manipulated directly, but often callers will serialize this opts to JSON to use it as a cache key representing the options Babel has received. Caching on this isn't 100% guaranteed to invalidate properly, but it is the best we have at the moment.</p>"},{"location":"autogenerated/code-summary/#loadpartialconfig","title":"loadPartialConfig","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>loadPartialConfig(options?: TransformOptions)</code></p> <p>JSDoc:</p> <p>To allow systems to easily manipulate and validate a user's config, this function resolves the plugins and presets and proceeds no further. The expectation is that callers will take the config's .options, manipulate it as then see fit and pass it back to Babel again.</p> <ul> <li><code>babelrc: string | void</code> - The path of the <code>.babelrc</code> file, if there was one.</li> <li><code>babelignore: string | void</code> - The path of the <code>.babelignore</code> file, if there was one.</li> <li><code>options: ValidatedOptions</code> - The partially resolved options, which can be manipulated and passed back to Babel again.</li> <li><code>plugins: Array&lt;ConfigItem&gt;</code> - See below.</li> <li><code>presets: Array&lt;ConfigItem&gt;</code> - See below.</li> <li>It can be safely passed back to Babel. Fields like <code>babelrc</code> have been set to false so that later calls to Babel will not make a second attempt to load config files.</li> </ul> <p><code>ConfigItem</code> instances expose properties to introspect the values, but each item should be treated as immutable. If changes are desired, the item should be removed from the list and replaced with either a normal Babel config value, or with a replacement item created by <code>babel.createConfigItem</code>. See that function for information about <code>ConfigItem</code> fields.</p>"},{"location":"autogenerated/code-summary/#createconfigitem","title":"createConfigItem","text":"<p>Source: <code>my-backend/node_modules/@types/babel__core/index.d.ts</code></p> <p>Signature: <code>createConfigItem(     value: PluginTarget | [PluginTarget, PluginOptions] | [PluginTarget, PluginOptions, string | undefined],     options?: CreateConfigItemOptions, )</code></p> <p>JSDoc:</p> <p>The name that the user gave the plugin instance, e.g. <code>plugins: [ ['env', {}, 'my-env'] ]</code> /     name?: string | undefined;</p> <pre><code>/**\n</code></pre> <p>The resolved value of the plugin. /     value: object | ((...args: any[]) =&gt; any);</p> <pre><code>/**\n</code></pre> <p>The options object passed to the plugin. /     options?: object | false | undefined;</p> <pre><code>/**\n</code></pre> <p>The path that the options are relative to. /     dirname: string;</p> <pre><code>/**\n</code></pre> <p>Information about the plugin's file, if Babel knows it.  * /     file?:         | {             /** The file that the user requested, e.g. <code>\"@babel/env\"</code> /             request: string;</p> <pre><code>        /**\n</code></pre> <p>The full path of the resolved file, e.g. <code>\"/tmp/node_modules/@babel/preset-env/lib/index.js\"</code> /             resolved: string;         }         | null         | undefined; }</p> <p>export type PluginOptions = object | undefined | false;</p> <p>export type PluginTarget = string | object | ((...args: any[]) =&gt; any);</p> <p>export type PluginItem =     | ConfigItem     | PluginObj     | PluginTarget     | [PluginTarget, PluginOptions]     | [PluginTarget, PluginOptions, string | undefined]; <p>export function resolvePlugin(name: string, dirname: string): string | null; export function resolvePreset(name: string, dirname: string): string | null;</p> <p>export interface CreateConfigItemOptions {     dirname?: string | undefined;     type?: \"preset\" | \"plugin\" | undefined; }</p> <p>/** Allows build tooling to create and cache config items up front. If this function is called multiple times for a given plugin, Babel will call the plugin's function itself multiple times. If you have a clear set of expected plugins and presets to inject, pre-constructing the config items would be recommended.</p>"},{"location":"autogenerated/code-summary/#generate","title":"generate","text":"<p>Source: <code>my-backend/node_modules/@types/babel__generator/index.d.ts</code></p> <p>Signature: <code>generate(     ast: t.Node,     opts?: GeneratorOptions,     code?: string | { [filename: string]: string }, )</code></p> <p>JSDoc:</p> <p>Optional string to add as a block comment at the start of the output file. /     auxiliaryCommentBefore?: string | undefined;</p> <pre><code>/**\n</code></pre> <p>Optional string to add as a block comment at the end of the output file. /     auxiliaryCommentAfter?: string | undefined;</p> <pre><code>/**\n</code></pre> <p>Function that takes a comment (as a string) and returns true if the comment should be included in the output. By default, comments are included if <code>opts.comments</code> is <code>true</code> or if <code>opts.minifed</code> is <code>false</code> and the comment contains <code>@preserve</code> or <code>@license</code>. /     shouldPrintComment?(comment: string): boolean;</p> <pre><code>/**\n</code></pre> <p>Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces). Defaults to <code>false</code>. /     retainLines?: boolean | undefined;</p> <pre><code>/**\n</code></pre> <p>Retain parens around function expressions (could be used to change engine parsing behavior) Defaults to <code>false</code>. /     retainFunctionParens?: boolean | undefined;</p> <pre><code>/**\n</code></pre> <p>Should comments be included in output? Defaults to <code>true</code>. /     comments?: boolean | undefined;</p> <pre><code>/**\n</code></pre> <p>Set to true to avoid adding whitespace for formatting. Defaults to the value of <code>opts.minified</code>. /     compact?: boolean | \"auto\" | undefined;</p> <pre><code>/**\n</code></pre> <p>Should the output be minified. Defaults to <code>false</code>. /     minified?: boolean | undefined;</p> <pre><code>/**\n</code></pre> <p>Set to true to reduce whitespace (but not as much as opts.compact). Defaults to <code>false</code>. /     concise?: boolean | undefined;</p> <pre><code>/**\n</code></pre> <p>Used in warning messages /     filename?: string | undefined;</p> <pre><code>/**\n</code></pre> <p>Enable generating source maps. Defaults to <code>false</code>. /     sourceMaps?: boolean | undefined;</p> <pre><code>/**\n</code></pre> <p>A root for all relative URLs in the source map. /     sourceRoot?: string | undefined;</p> <pre><code>/**\n</code></pre> <p>The filename for the source code (i.e. the code in the <code>code</code> argument). This will only be used if <code>code</code> is a string. /     sourceFileName?: string | undefined;</p> <pre><code>/**\n</code></pre> <p>Set to true to run jsesc with \"json\": true to print \"\\u00A9\" vs. \"\u00a9\"; /     jsonCompatibleStrings?: boolean | undefined;</p> <pre><code>/**\n</code></pre> <p>Set to true to enable support for experimental decorators syntax before module exports. Defaults to <code>false</code>. /     decoratorsBeforeExport?: boolean | undefined;</p> <pre><code>/**\n</code></pre> <p>The import attributes/assertions syntax to use. When not specified, @babel/generator will try to match the style in the input code based on the AST shape. /     importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";</p> <pre><code>/**\n</code></pre> <p>Options for outputting jsesc representation. /     jsescOption?: {         /** The default value for the quotes option is 'single'. This means that any occurrences of ' in the input string are escaped as \\', so that the output can be used in a string literal wrapped in single quotes. /         quotes?: \"single\" | \"double\" | \"backtick\" | undefined;</p> <pre><code>    /**\n</code></pre> <p>The default value for the numbers option is 'decimal'. This means that any numeric values are represented using decimal integer literals. Other valid options are binary, octal, and hexadecimal, which result in binary integer literals, octal integer literals, and hexadecimal integer literals, respectively. /         numbers?: \"binary\" | \"octal\" | \"decimal\" | \"hexadecimal\" | undefined;</p> <pre><code>    /**\n</code></pre> <p>The wrap option takes a boolean value (true or false), and defaults to false (disabled). When enabled, the output is a valid JavaScript string literal wrapped in quotes. The type of quotes can be specified through the quotes setting. /         wrap?: boolean | undefined;</p> <pre><code>    /**\n</code></pre> <p>The es6 option takes a boolean value (true or false), and defaults to false (disabled). When enabled, any astral Unicode symbols in the input are escaped using ECMAScript 6 Unicode code point escape sequences instead of using separate escape sequences for each surrogate half. If backwards compatibility with ES5 environments is a concern, don\u2019t enable this setting. If the json setting is enabled, the value for the es6 setting is ignored (as if it was false). /         es6?: boolean | undefined;</p> <pre><code>    /**\n</code></pre> <p>The escapeEverything option takes a boolean value (true or false), and defaults to false (disabled). When enabled, all the symbols in the output are escaped \u2014 even printable ASCII symbols. /         escapeEverything?: boolean | undefined;</p> <pre><code>    /**\n</code></pre> <p>The minimal option takes a boolean value (true or false), and defaults to false (disabled). When enabled, only a limited set of symbols in the output are escaped: \\0, \\b, \\t, \\n, \\f, \\r, \\, \\u2028, \\u2029. /         minimal?: boolean | undefined;</p> <pre><code>    /**\n</code></pre> <p>The isScriptContext option takes a boolean value (true or false), and defaults to false (disabled). When enabled, occurrences of &lt;/script and &lt;/style in the output are escaped as &lt;\\/script and &lt;\\/style, and &lt;!-- is escaped as \\x3C!-- (or \\u003C!-- when the json option is enabled). This setting is useful when jsesc\u2019s output ends up as part of a"},{"location":"schema/ENUM/","title":"Table: ENUM","text":"<p>Columns:</p> <ul> <li>'pending_kyc'</li> <li>'kyc_submitted'</li> <li>'expired'</li> <li>'cancelled'</li> </ul>"},{"location":"schema/EXISTS/","title":"Table: EXISTS","text":"<p>Columns:</p> <ul> <li>SELECT 1 FROM pg_roles WHERE rolname = 'erp_app'</li> </ul>"},{"location":"schema/FROM/","title":"Table: FROM","text":"<p>Columns:</p> <ul> <li>'2025-01-01'</li> </ul>"},{"location":"schema/actions/","title":"Table: actions","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>name VARCHAR</li> </ul>"},{"location":"schema/approval_logs/","title":"Table: approval_logs","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/audit_logs/","title":"Table: audit_logs","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/audit_logs_new/","title":"Table: audit_logs_new","text":"<p>Columns:</p> <ul> <li>id UUID DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/branches/","title":"Table: branches","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/chart_of_accounts/","title":"Table: chart_of_accounts","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/currency/","title":"Table: currency","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/customers/","title":"Table: customers","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/exchange_rates/","title":"Table: exchange_rates","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/features/","title":"Table: features","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT gen_random_uuid</li> </ul>"},{"location":"schema/file_objects/","title":"Table: file_objects","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/format/","title":"Table: format","text":"<p>Columns:</p> <ul> <li>'DROP TRIGGER IF EXISTS %I ON erp.%I'</li> <li>trigger_record.trigger_name</li> <li>trigger_record.event_object_table</li> </ul>"},{"location":"schema/inventory_movements/","title":"Table: inventory_movements","text":"<p>Columns:</p> <ul> <li>id UUID DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/invitations/","title":"Table: invitations","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/kyc_submissions/","title":"Table: kyc_submissions","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/panel/","title":"Table: panel","text":"<p>Columns:</p> <ul> <li>standalone</li> </ul>"},{"location":"schema/permissions/","title":"Table: permissions","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>role_id INTEGER NOT NULL</li> <li>route_id INTEGER NOT NULL</li> <li>action_id INTEGER NOT NULL</li> <li>is_granted BOOLEAN DEFAULT true</li> <li>created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</li> <li>updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</li> <li>FOREIGN KEY</li> </ul>"},{"location":"schema/product_categories/","title":"Table: product_categories","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/products/","title":"Table: products","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/purchase_order_details/","title":"Table: purchase_order_details","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/purchase_orders/","title":"Table: purchase_orders","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/rate_limits/","title":"Table: rate_limits","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/rbac_actions/","title":"Table: rbac_actions","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>name VARCHAR</li> </ul>"},{"location":"schema/rbac_permissions/","title":"Table: rbac_permissions","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>role_id INTEGER REFERENCES rbac_roles</li> </ul>"},{"location":"schema/rbac_roles/","title":"Table: rbac_roles","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>name VARCHAR</li> </ul>"},{"location":"schema/rbac_routes/","title":"Table: rbac_routes","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>path VARCHAR</li> </ul>"},{"location":"schema/rbac_user_roles/","title":"Table: rbac_user_roles","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>user_id INTEGER NOT NULL</li> <li>role_id INTEGER REFERENCES rbac_roles</li> </ul>"},{"location":"schema/recent_activity/","title":"Table: recent_activity","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT gen_random_uuid</li> </ul>"},{"location":"schema/role_inheritance/","title":"Table: role_inheritance","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>parent_role_id INTEGER NOT NULL</li> <li>child_role_id INTEGER NOT NULL</li> <li>created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</li> <li>FOREIGN KEY</li> </ul>"},{"location":"schema/role_privileges/","title":"Table: role_privileges","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT gen_random_uuid</li> </ul>"},{"location":"schema/roles/","title":"Table: roles","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/routes/","title":"Table: routes","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>path VARCHAR</li> </ul>"},{"location":"schema/sales_order_details/","title":"Table: sales_order_details","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/sales_orders/","title":"Table: sales_orders","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/tables/","title":"Table: tables","text":"<p>Columns:</p> <ul> <li>only if they were enabled by our migration</li> </ul>"},{"location":"schema/user_privileges/","title":"Table: user_privileges","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT gen_random_uuid</li> </ul>"},{"location":"schema/user_roles/","title":"Table: user_roles","text":"<p>Columns:</p> <ul> <li>id SERIAL PRIMARY KEY</li> <li>user_id INTEGER NOT NULL</li> <li>role_id INTEGER NOT NULL</li> <li>assigned_by INTEGER</li> <li>assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</li> <li>is_active BOOLEAN DEFAULT true</li> <li>FOREIGN KEY</li> </ul>"},{"location":"schema/user_sessions/","title":"Table: user_sessions","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/users/","title":"Table: users","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"},{"location":"schema/vendors/","title":"Table: vendors","text":"<p>Columns:</p> <ul> <li>id UUID PRIMARY KEY DEFAULT uuid_generate_v4</li> </ul>"}]}