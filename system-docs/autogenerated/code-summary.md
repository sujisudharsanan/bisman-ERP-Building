# Code Summary

## Prisma

Source: `my-backend/node_modules/.prisma/client/edge.js`

Signature: `Prisma(.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
})`

JSDoc:

Prisma Client JS version: 6.16.3
Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
/
Prisma.prismaVersion = {
  client: "6.16.3",
  engine: "bb420e667c1820a8c05a38023385f6cc7ef8e83a"
}

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError
Prisma.PrismaClientInitializationError = PrismaClientInitializationError
Prisma.PrismaClientValidationError = PrismaClientValidationError
Prisma.Decimal = Decimal

/**
Re-export of sql-template-tag
/
Prisma.sql = sqltag
Prisma.empty = empty
Prisma.join = join
Prisma.raw = raw
Prisma.validator = Public.validator

/**
Extensions
/
Prisma.getExtensionContext = Extensions.getExtensionContext
Prisma.defineExtension = Extensions.defineExtension

/**
Shorthand utilities for JSON filtering
/
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}





/**
Enums

## Prisma

Source: `my-backend/node_modules/.prisma/client/index-browser.js`

Signature: `Prisma(.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
})`

JSDoc:

Prisma Client JS version: 6.16.3
Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
/
Prisma.prismaVersion = {
  client: "6.16.3",
  engine: "bb420e667c1820a8c05a38023385f6cc7ef8e83a"
}

Prisma.PrismaClientKnownRequestError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientKnownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)};
Prisma.PrismaClientUnknownRequestError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientUnknownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientRustPanicError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientRustPanicError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientInitializationError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientInitializationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.PrismaClientValidationError = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`PrismaClientValidationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.Decimal = Decimal

/**
Re-export of sql-template-tag
/
Prisma.sql = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`sqltag is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.empty = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`empty is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.join = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`join is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.raw = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`raw is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.validator = Public.validator

/**
Extensions
/
Prisma.getExtensionContext = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`Extensions.getExtensionContext is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}
Prisma.defineExtension = () => {
  const runtimeName = getRuntime().prettyName;
  throw new Error(`Extensions.defineExtension is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`,
)}

/**
Shorthand utilities for JSON filtering
/
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}



/**
Enums

## Prisma

Source: `my-backend/node_modules/.prisma/client/index.js`

Signature: `Prisma(.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
})`

JSDoc:

Prisma Client JS version: 6.16.3
Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
/
Prisma.prismaVersion = {
  client: "6.16.3",
  engine: "bb420e667c1820a8c05a38023385f6cc7ef8e83a"
}

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError
Prisma.PrismaClientInitializationError = PrismaClientInitializationError
Prisma.PrismaClientValidationError = PrismaClientValidationError
Prisma.Decimal = Decimal

/**
Re-export of sql-template-tag
/
Prisma.sql = sqltag
Prisma.empty = empty
Prisma.join = join
Prisma.raw = raw
Prisma.validator = Public.validator

/**
Extensions
/
Prisma.getExtensionContext = Extensions.getExtensionContext
Prisma.defineExtension = Extensions.defineExtension

/**
Shorthand utilities for JSON filtering
/
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}




  const path = require('path')

/**
Enums

## Prisma

Source: `my-backend/node_modules/.prisma/client/wasm.js`

Signature: `Prisma(.TransactionIsolationLevel = makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
})`

JSDoc:

Prisma Client JS version: 6.16.3
Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
/
Prisma.prismaVersion = {
  client: "6.16.3",
  engine: "bb420e667c1820a8c05a38023385f6cc7ef8e83a"
}

Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError;
Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError
Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError
Prisma.PrismaClientInitializationError = PrismaClientInitializationError
Prisma.PrismaClientValidationError = PrismaClientValidationError
Prisma.Decimal = Decimal

/**
Re-export of sql-template-tag
/
Prisma.sql = sqltag
Prisma.empty = empty
Prisma.join = join
Prisma.raw = raw
Prisma.validator = Public.validator

/**
Extensions
/
Prisma.getExtensionContext = Extensions.getExtensionContext
Prisma.defineExtension = Extensions.defineExtension

/**
Shorthand utilities for JSON filtering
/
Prisma.DbNull = objectEnumValues.instances.DbNull
Prisma.JsonNull = objectEnumValues.instances.JsonNull
Prisma.AnyNull = objectEnumValues.instances.AnyNull

Prisma.NullTypes = {
  DbNull: objectEnumValues.classes.DbNull,
  JsonNull: objectEnumValues.classes.JsonNull,
  AnyNull: objectEnumValues.classes.AnyNull
}





/**
Enums

## formatArgs

Source: `my-backend/node_modules/@babel/core/node_modules/debug/src/browser.js`

Signature: `formatArgs(= formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage()`

JSDoc:

This is the web browser implementation of `debug()`.

## colors

Source: `my-backend/node_modules/@babel/core/node_modules/debug/src/browser.js`

Signature: `colors(= [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version)`

JSDoc:

Colors.

## log

Source: `my-backend/node_modules/@babel/core/node_modules/debug/src/browser.js`

Signature: `log(= console.debug || console.log || (()`

JSDoc:

Colorize log arguments if enabled.

@api public
/

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
Invokes `console.debug()` when available.
No-op when `console.debug` is not a "function".
If `console.debug` is not available, falls back
to `console.log`.

@api public

## init

Source: `my-backend/node_modules/@babel/core/node_modules/debug/src/node.js`

Signature: `init(= init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	()`

JSDoc:

Module dependencies.
/

const tty = require('tty');
const util = require('util');

/**
This is the Node.js implementation of `debug()`.

## colors

Source: `my-backend/node_modules/@babel/core/node_modules/debug/src/node.js`

Signature: `colors(= [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)`

JSDoc:

Colors.

## inspectOpts

Source: `my-backend/node_modules/@babel/core/node_modules/debug/src/node.js`

Signature: `inspectOpts(= Object.keys(process.env)`

JSDoc:

Build up the default `inspectOpts` object from the environment variables.

  $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js

## formatArgs

Source: `my-backend/node_modules/@babel/traverse/node_modules/debug/src/browser.js`

Signature: `formatArgs(= formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage()`

JSDoc:

This is the web browser implementation of `debug()`.

## colors

Source: `my-backend/node_modules/@babel/traverse/node_modules/debug/src/browser.js`

Signature: `colors(= [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version)`

JSDoc:

Colors.

## log

Source: `my-backend/node_modules/@babel/traverse/node_modules/debug/src/browser.js`

Signature: `log(= console.debug || console.log || (()`

JSDoc:

Colorize log arguments if enabled.

@api public
/

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
Invokes `console.debug()` when available.
No-op when `console.debug` is not a "function".
If `console.debug` is not available, falls back
to `console.log`.

@api public

## init

Source: `my-backend/node_modules/@babel/traverse/node_modules/debug/src/node.js`

Signature: `init(= init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	()`

JSDoc:

Module dependencies.
/

const tty = require('tty');
const util = require('util');

/**
This is the Node.js implementation of `debug()`.

## colors

Source: `my-backend/node_modules/@babel/traverse/node_modules/debug/src/node.js`

Signature: `colors(= [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)`

JSDoc:

Colors.

## inspectOpts

Source: `my-backend/node_modules/@babel/traverse/node_modules/debug/src/node.js`

Signature: `inspectOpts(= Object.keys(process.env)`

JSDoc:

Build up the default `inspectOpts` object from the environment variables.

  $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js

## isNumberLiteral

Source: `my-backend/node_modules/@babel/types/lib/index-legacy.d.ts`

Signature: `isNumberLiteral(node: object | null | undefined, opts?: object | null)`

JSDoc:

@deprecated Use `NumericLiteral`
/
export type NumberLiteral = NumericLiteral;

/**
@deprecated Use `RegExpLiteral`
/
export type RegexLiteral = RegExpLiteral;

/**
@deprecated Use `RestElement`
/
export type RestProperty = RestElement;

/**
@deprecated Use `SpreadElement`
/
export type SpreadProperty = SpreadElement;

export type Standardized = ArrayExpression | AssignmentExpression | BinaryExpression | InterpreterDirective | Directive | DirectiveLiteral | BlockStatement | BreakStatement | CallExpression | CatchClause | ConditionalExpression | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | File | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Identifier | IfStatement | LabeledStatement | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | Program | ObjectExpression | ObjectMethod | ObjectProperty | RestElement | ReturnStatement | SequenceExpression | ParenthesizedExpression | SwitchCase | SwitchStatement | ThisExpression | ThrowStatement | TryStatement | UnaryExpression | UpdateExpression | VariableDeclaration | VariableDeclarator | WhileStatement | WithStatement | AssignmentPattern | ArrayPattern | ArrowFunctionExpression | ClassBody | ClassExpression | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ExportSpecifier | ForOfStatement | ImportDeclaration | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ImportExpression | MetaProperty | ClassMethod | ObjectPattern | SpreadElement | Super | TaggedTemplateExpression | TemplateElement | TemplateLiteral | YieldExpression | AwaitExpression | Import | BigIntLiteral | ExportNamespaceSpecifier | OptionalMemberExpression | OptionalCallExpression | ClassProperty | ClassAccessorProperty | ClassPrivateProperty | ClassPrivateMethod | PrivateName | StaticBlock | ImportAttribute;
export type Expression = ArrayExpression | AssignmentExpression | BinaryExpression | CallExpression | ConditionalExpression | FunctionExpression | Identifier | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | LogicalExpression | MemberExpression | NewExpression | ObjectExpression | SequenceExpression | ParenthesizedExpression | ThisExpression | UnaryExpression | UpdateExpression | ArrowFunctionExpression | ClassExpression | ImportExpression | MetaProperty | Super | TaggedTemplateExpression | TemplateLiteral | YieldExpression | AwaitExpression | Import | BigIntLiteral | OptionalMemberExpression | OptionalCallExpression | TypeCastExpression | JSXElement | JSXFragment | BindExpression | DoExpression | RecordExpression | TupleExpression | DecimalLiteral | ModuleExpression | TopicReference | PipelineTopicExpression | PipelineBareFunction | PipelinePrimaryTopicReference | TSInstantiationExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression;
export type Binary = BinaryExpression | LogicalExpression;
export type Scopable = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ClassExpression | ClassDeclaration | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
export type BlockParent = BlockStatement | CatchClause | DoWhileStatement | ForInStatement | ForStatement | FunctionDeclaration | FunctionExpression | Program | ObjectMethod | SwitchStatement | WhileStatement | ArrowFunctionExpression | ForOfStatement | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
export type Block = BlockStatement | Program | TSModuleBlock;
export type Statement = BlockStatement | BreakStatement | ContinueStatement | DebuggerStatement | DoWhileStatement | EmptyStatement | ExpressionStatement | ForInStatement | ForStatement | FunctionDeclaration | IfStatement | LabeledStatement | ReturnStatement | SwitchStatement | ThrowStatement | TryStatement | VariableDeclaration | WhileStatement | WithStatement | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ForOfStatement | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration | TSExportAssignment | TSNamespaceExportDeclaration;
export type Terminatorless = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement | YieldExpression | AwaitExpression;
export type CompletionStatement = BreakStatement | ContinueStatement | ReturnStatement | ThrowStatement;
export type Conditional = ConditionalExpression | IfStatement;
export type Loop = DoWhileStatement | ForInStatement | ForStatement | WhileStatement | ForOfStatement;
export type While = DoWhileStatement | WhileStatement;
export type ExpressionWrapper = ExpressionStatement | ParenthesizedExpression | TypeCastExpression;
export type For = ForInStatement | ForStatement | ForOfStatement;
export type ForXStatement = ForInStatement | ForOfStatement;
export type Function = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod;
export type FunctionParent = FunctionDeclaration | FunctionExpression | ObjectMethod | ArrowFunctionExpression | ClassMethod | ClassPrivateMethod | StaticBlock | TSModuleBlock;
export type Pureish = FunctionDeclaration | FunctionExpression | StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | ArrowFunctionExpression | BigIntLiteral | DecimalLiteral;
export type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration | ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias | EnumDeclaration | TSDeclareFunction | TSInterfaceDeclaration | TSTypeAliasDeclaration | TSEnumDeclaration | TSModuleDeclaration | TSImportEqualsDeclaration;
export type FunctionParameter = Identifier | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | VoidPattern;
export type PatternLike = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | VoidPattern | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression;
export type LVal = Identifier | MemberExpression | RestElement | AssignmentPattern | ArrayPattern | ObjectPattern | TSParameterProperty | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression;
export type TSEntityName = Identifier | TSQualifiedName;
export type Literal = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | RegExpLiteral | TemplateLiteral | BigIntLiteral | DecimalLiteral;
export type Immutable = StringLiteral | NumericLiteral | NullLiteral | BooleanLiteral | BigIntLiteral | JSXAttribute | JSXClosingElement | JSXElement | JSXExpressionContainer | JSXSpreadChild | JSXOpeningElement | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment | DecimalLiteral;
export type UserWhitespacable = ObjectMethod | ObjectProperty | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty;
export type Method = ObjectMethod | ClassMethod | ClassPrivateMethod;
export type ObjectMember = ObjectMethod | ObjectProperty;
export type Property = ObjectProperty | ClassProperty | ClassAccessorProperty | ClassPrivateProperty;
export type UnaryLike = UnaryExpression | SpreadElement;
export type Pattern = AssignmentPattern | ArrayPattern | ObjectPattern | VoidPattern;
export type Class = ClassExpression | ClassDeclaration;
export type ImportOrExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;
export type ExportDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration;
export type ModuleSpecifier = ExportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier | ExportNamespaceSpecifier | ExportDefaultSpecifier;
export type Accessor = ClassAccessorProperty;
export type Private = ClassPrivateProperty | ClassPrivateMethod | PrivateName;
export type Flow = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ClassImplements | DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | DeclaredPredicate | ExistsTypeAnnotation | FunctionTypeAnnotation | FunctionTypeParam | GenericTypeAnnotation | InferredPredicate | InterfaceExtends | InterfaceDeclaration | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | ObjectTypeInternalSlot | ObjectTypeCallProperty | ObjectTypeIndexer | ObjectTypeProperty | ObjectTypeSpreadProperty | OpaqueType | QualifiedTypeIdentifier | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | TypeAlias | TypeAnnotation | TypeCastExpression | TypeParameter | TypeParameterDeclaration | TypeParameterInstantiation | UnionTypeAnnotation | Variance | VoidTypeAnnotation | EnumDeclaration | EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody | EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember | IndexedAccessType | OptionalIndexedAccessType;
export type FlowType = AnyTypeAnnotation | ArrayTypeAnnotation | BooleanTypeAnnotation | BooleanLiteralTypeAnnotation | NullLiteralTypeAnnotation | ExistsTypeAnnotation | FunctionTypeAnnotation | GenericTypeAnnotation | InterfaceTypeAnnotation | IntersectionTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NullableTypeAnnotation | NumberLiteralTypeAnnotation | NumberTypeAnnotation | ObjectTypeAnnotation | StringLiteralTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | TupleTypeAnnotation | TypeofTypeAnnotation | UnionTypeAnnotation | VoidTypeAnnotation | IndexedAccessType | OptionalIndexedAccessType;
export type FlowBaseAnnotation = AnyTypeAnnotation | BooleanTypeAnnotation | NullLiteralTypeAnnotation | MixedTypeAnnotation | EmptyTypeAnnotation | NumberTypeAnnotation | StringTypeAnnotation | SymbolTypeAnnotation | ThisTypeAnnotation | VoidTypeAnnotation;
export type FlowDeclaration = DeclareClass | DeclareFunction | DeclareInterface | DeclareModule | DeclareModuleExports | DeclareTypeAlias | DeclareOpaqueType | DeclareVariable | DeclareExportDeclaration | DeclareExportAllDeclaration | InterfaceDeclaration | OpaqueType | TypeAlias;
export type FlowPredicate = DeclaredPredicate | InferredPredicate;
export type EnumBody = EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody;
export type EnumMember = EnumBooleanMember | EnumNumberMember | EnumStringMember | EnumDefaultedMember;
export type JSX = JSXAttribute | JSXClosingElement | JSXElement | JSXEmptyExpression | JSXExpressionContainer | JSXSpreadChild | JSXIdentifier | JSXMemberExpression | JSXNamespacedName | JSXOpeningElement | JSXSpreadAttribute | JSXText | JSXFragment | JSXOpeningFragment | JSXClosingFragment;
export type Miscellaneous = Noop | Placeholder | V8IntrinsicIdentifier;
export type TypeScript = TSParameterProperty | TSDeclareFunction | TSDeclareMethod | TSQualifiedName | TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature | TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSOptionalType | TSRestType | TSNamedTupleMember | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSTemplateLiteralType | TSLiteralType | TSExpressionWithTypeArguments | TSInterfaceDeclaration | TSInterfaceBody | TSTypeAliasDeclaration | TSInstantiationExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSEnumBody | TSEnumDeclaration | TSEnumMember | TSModuleDeclaration | TSModuleBlock | TSImportType | TSImportEqualsDeclaration | TSExternalModuleReference | TSNonNullExpression | TSExportAssignment | TSNamespaceExportDeclaration | TSTypeAnnotation | TSTypeParameterInstantiation | TSTypeParameterDeclaration | TSTypeParameter;
export type TSTypeElement = TSCallSignatureDeclaration | TSConstructSignatureDeclaration | TSPropertySignature | TSMethodSignature | TSIndexSignature;
export type TSType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSFunctionType | TSConstructorType | TSTypeReference | TSTypePredicate | TSTypeQuery | TSTypeLiteral | TSArrayType | TSTupleType | TSOptionalType | TSRestType | TSUnionType | TSIntersectionType | TSConditionalType | TSInferType | TSParenthesizedType | TSTypeOperator | TSIndexedAccessType | TSMappedType | TSTemplateLiteralType | TSLiteralType | TSExpressionWithTypeArguments | TSImportType;
export type TSBaseType = TSAnyKeyword | TSBooleanKeyword | TSBigIntKeyword | TSIntrinsicKeyword | TSNeverKeyword | TSNullKeyword | TSNumberKeyword | TSObjectKeyword | TSStringKeyword | TSSymbolKeyword | TSUndefinedKeyword | TSUnknownKeyword | TSVoidKeyword | TSThisType | TSTemplateLiteralType | TSLiteralType;
export type ModuleDeclaration = ExportAllDeclaration | ExportDefaultDeclaration | ExportNamedDeclaration | ImportDeclaration;

export interface Aliases {
  Standardized: Standardized;
  Expression: Expression;
  Binary: Binary;
  Scopable: Scopable;
  BlockParent: BlockParent;
  Block: Block;
  Statement: Statement;
  Terminatorless: Terminatorless;
  CompletionStatement: CompletionStatement;
  Conditional: Conditional;
  Loop: Loop;
  While: While;
  ExpressionWrapper: ExpressionWrapper;
  For: For;
  ForXStatement: ForXStatement;
  Function: Function;
  FunctionParent: FunctionParent;
  Pureish: Pureish;
  Declaration: Declaration;
  FunctionParameter: FunctionParameter;
  PatternLike: PatternLike;
  LVal: LVal;
  TSEntityName: TSEntityName;
  Literal: Literal;
  Immutable: Immutable;
  UserWhitespacable: UserWhitespacable;
  Method: Method;
  ObjectMember: ObjectMember;
  Property: Property;
  UnaryLike: UnaryLike;
  Pattern: Pattern;
  Class: Class;
  ImportOrExportDeclaration: ImportOrExportDeclaration;
  ExportDeclaration: ExportDeclaration;
  ModuleSpecifier: ModuleSpecifier;
  Accessor: Accessor;
  Private: Private;
  Flow: Flow;
  FlowType: FlowType;
  FlowBaseAnnotation: FlowBaseAnnotation;
  FlowDeclaration: FlowDeclaration;
  FlowPredicate: FlowPredicate;
  EnumBody: EnumBody;
  EnumMember: EnumMember;
  JSX: JSX;
  Miscellaneous: Miscellaneous;
  TypeScript: TypeScript;
  TSTypeElement: TSTypeElement;
  TSType: TSType;
  TSBaseType: TSBaseType;
  ModuleDeclaration: ModuleDeclaration;
}

export function arrayExpression(elements?: Array<null | Expression | SpreadElement>): ArrayExpression;
export function assignmentExpression(operator: string, left: LVal | OptionalMemberExpression, right: Expression): AssignmentExpression;
export function binaryExpression(operator: "+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=" | "|>", left: Expression | PrivateName, right: Expression): BinaryExpression;
export function interpreterDirective(value: string): InterpreterDirective;
export function directive(value: DirectiveLiteral): Directive;
export function directiveLiteral(value: string): DirectiveLiteral;
export function blockStatement(body: Array<Statement>, directives?: Array<Directive>): BlockStatement;
export function breakStatement(label?: Identifier | null): BreakStatement;
export function callExpression(callee: Expression | Super | V8IntrinsicIdentifier, _arguments: Array<Expression | SpreadElement | ArgumentPlaceholder>): CallExpression;
export function catchClause(param: Identifier | ArrayPattern | ObjectPattern | null | undefined, body: BlockStatement): CatchClause;
export function conditionalExpression(test: Expression, consequent: Expression, alternate: Expression): ConditionalExpression;
export function continueStatement(label?: Identifier | null): ContinueStatement;
export function debuggerStatement(): DebuggerStatement;
export function doWhileStatement(test: Expression, body: Statement): DoWhileStatement;
export function emptyStatement(): EmptyStatement;
export function expressionStatement(expression: Expression): ExpressionStatement;
export function file(program: Program, comments?: Array<CommentBlock | CommentLine> | null, tokens?: Array<any> | null): File;
export function forInStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement): ForInStatement;
export function forStatement(init: VariableDeclaration | Expression | null | undefined, test: Expression | null | undefined, update: Expression | null | undefined, body: Statement): ForStatement;
export function functionDeclaration(id: Identifier | null | undefined, params: Array<FunctionParameter>, body: BlockStatement, generator?: boolean, async?: boolean): FunctionDeclaration;
export function functionExpression(id: Identifier | null | undefined, params: Array<FunctionParameter>, body: BlockStatement, generator?: boolean, async?: boolean): FunctionExpression;
export function identifier(name: string): Identifier;
export function ifStatement(test: Expression, consequent: Statement, alternate?: Statement | null): IfStatement;
export function labeledStatement(label: Identifier, body: Statement): LabeledStatement;
export function stringLiteral(value: string): StringLiteral;
export function numericLiteral(value: number): NumericLiteral;
export function nullLiteral(): NullLiteral;
export function booleanLiteral(value: boolean): BooleanLiteral;
export function regExpLiteral(pattern: string, flags?: string): RegExpLiteral;
export function logicalExpression(operator: "||" | "&&" | "??", left: Expression, right: Expression): LogicalExpression;
export function memberExpression(object: Expression | Super, property: Expression | Identifier | PrivateName, computed?: boolean, optional?: boolean | null): MemberExpression;
export function newExpression(callee: Expression | Super | V8IntrinsicIdentifier, _arguments: Array<Expression | SpreadElement | ArgumentPlaceholder>): NewExpression;
export function program(body: Array<Statement>, directives?: Array<Directive>, sourceType?: "script" | "module", interpreter?: InterpreterDirective | null): Program;
export function objectExpression(properties: Array<ObjectMethod | ObjectProperty | SpreadElement>): ObjectExpression;
export function objectMethod(kind: "method" | "get" | "set" | undefined, key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral, params: Array<FunctionParameter>, body: BlockStatement, computed?: boolean, generator?: boolean, async?: boolean): ObjectMethod;
export function objectProperty(key: Expression | Identifier | StringLiteral | NumericLiteral | BigIntLiteral | DecimalLiteral | PrivateName, value: Expression | PatternLike, computed?: boolean, shorthand?: boolean, decorators?: Array<Decorator> | null): ObjectProperty;
export function restElement(argument: Identifier | ArrayPattern | ObjectPattern | MemberExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression | RestElement | AssignmentPattern): RestElement;
export function returnStatement(argument?: Expression | null): ReturnStatement;
export function sequenceExpression(expressions: Array<Expression>): SequenceExpression;
export function parenthesizedExpression(expression: Expression): ParenthesizedExpression;
export function switchCase(test: Expression | null | undefined, consequent: Array<Statement>): SwitchCase;
export function switchStatement(discriminant: Expression, cases: Array<SwitchCase>): SwitchStatement;
export function thisExpression(): ThisExpression;
export function throwStatement(argument: Expression): ThrowStatement;
export function tryStatement(block: BlockStatement, handler?: CatchClause | null, finalizer?: BlockStatement | null): TryStatement;
export function unaryExpression(operator: "void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof", argument: Expression, prefix?: boolean): UnaryExpression;
export function updateExpression(operator: "++" | "--", argument: Expression, prefix?: boolean): UpdateExpression;
export function variableDeclaration(kind: "var" | "let" | "const" | "using" | "await using", declarations: Array<VariableDeclarator>): VariableDeclaration;
export function variableDeclarator(id: LVal | VoidPattern, init?: Expression | null): VariableDeclarator;
export function whileStatement(test: Expression, body: Statement): WhileStatement;
export function withStatement(object: Expression, body: Statement): WithStatement;
export function assignmentPattern(left: Identifier | ObjectPattern | ArrayPattern | MemberExpression | TSAsExpression | TSSatisfiesExpression | TSTypeAssertion | TSNonNullExpression, right: Expression): AssignmentPattern;
export function arrayPattern(elements: Array<null | PatternLike>): ArrayPattern;
export function arrowFunctionExpression(params: Array<FunctionParameter>, body: BlockStatement | Expression, async?: boolean): ArrowFunctionExpression;
export function classBody(body: Array<ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty | ClassAccessorProperty | TSDeclareMethod | TSIndexSignature | StaticBlock>): ClassBody;
export function classExpression(id: Identifier | null | undefined, superClass: Expression | null | undefined, body: ClassBody, decorators?: Array<Decorator> | null): ClassExpression;
export function classDeclaration(id: Identifier | null | undefined, superClass: Expression | null | undefined, body: ClassBody, decorators?: Array<Decorator> | null): ClassDeclaration;
export function exportAllDeclaration(source: StringLiteral): ExportAllDeclaration;
export function exportDefaultDeclaration(declaration: TSDeclareFunction | FunctionDeclaration | ClassDeclaration | Expression): ExportDefaultDeclaration;
export function exportNamedDeclaration(declaration?: Declaration | null, specifiers?: Array<ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier>, source?: StringLiteral | null): ExportNamedDeclaration;
export function exportSpecifier(local: Identifier, exported: Identifier | StringLiteral): ExportSpecifier;
export function forOfStatement(left: VariableDeclaration | LVal, right: Expression, body: Statement, _await?: boolean): ForOfStatement;
export function importDeclaration(specifiers: Array<ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier>, source: StringLiteral): ImportDeclaration;
export function importDefaultSpecifier(local: Identifier): ImportDefaultSpecifier;
export function importNamespaceSpecifier(local: Identifier): ImportNamespaceSpecifier;
export function importSpecifier(local: Identifier, imported: Identifier | StringLiteral): ImportSpecifier;
export function importExpression(source: Expression, options?: Expression | null): ImportExpression;
export function metaProperty(meta: Identifier, property: Identifier): MetaProperty;
export function classMethod(kind: "get" | "set" | "method" | "constructor" | undefined, key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, params: Array<FunctionParameter | TSParameterProperty>, body: BlockStatement, computed?: boolean, _static?: boolean, generator?: boolean, async?: boolean): ClassMethod;
export function objectPattern(properties: Array<RestElement | ObjectProperty>): ObjectPattern;
export function spreadElement(argument: Expression): SpreadElement;
declare function _super(): Super;
export { _super as super}
export function taggedTemplateExpression(tag: Expression, quasi: TemplateLiteral): TaggedTemplateExpression;
export function templateElement(value: { raw: string, cooked?: string }, tail?: boolean): TemplateElement;
export function templateLiteral(quasis: Array<TemplateElement>, expressions: Array<Expression | TSType>): TemplateLiteral;
export function yieldExpression(argument?: Expression | null, delegate?: boolean): YieldExpression;
export function awaitExpression(argument: Expression): AwaitExpression;
declare function _import(): Import;
export { _import as import}
export function bigIntLiteral(value: string): BigIntLiteral;
export function exportNamespaceSpecifier(exported: Identifier): ExportNamespaceSpecifier;
export function optionalMemberExpression(object: Expression, property: Expression | Identifier, computed: boolean | undefined, optional: boolean): OptionalMemberExpression;
export function optionalCallExpression(callee: Expression, _arguments: Array<Expression | SpreadElement | ArgumentPlaceholder>, optional: boolean): OptionalCallExpression;
export function classProperty(key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, value?: Expression | null, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null, decorators?: Array<Decorator> | null, computed?: boolean, _static?: boolean): ClassProperty;
export function classAccessorProperty(key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression | PrivateName, value?: Expression | null, typeAnnotation?: TypeAnnotation | TSTypeAnnotation | Noop | null, decorators?: Array<Decorator> | null, computed?: boolean, _static?: boolean): ClassAccessorProperty;
export function classPrivateProperty(key: PrivateName, value?: Expression | null, decorators?: Array<Decorator> | null, _static?: boolean): ClassPrivateProperty;
export function classPrivateMethod(kind: "get" | "set" | "method" | undefined, key: PrivateName, params: Array<FunctionParameter | TSParameterProperty>, body: BlockStatement, _static?: boolean): ClassPrivateMethod;
export function privateName(id: Identifier): PrivateName;
export function staticBlock(body: Array<Statement>): StaticBlock;
export function importAttribute(key: Identifier | StringLiteral, value: StringLiteral): ImportAttribute;
export function anyTypeAnnotation(): AnyTypeAnnotation;
export function arrayTypeAnnotation(elementType: FlowType): ArrayTypeAnnotation;
export function booleanTypeAnnotation(): BooleanTypeAnnotation;
export function booleanLiteralTypeAnnotation(value: boolean): BooleanLiteralTypeAnnotation;
export function nullLiteralTypeAnnotation(): NullLiteralTypeAnnotation;
export function classImplements(id: Identifier, typeParameters?: TypeParameterInstantiation | null): ClassImplements;
export function declareClass(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): DeclareClass;
export function declareFunction(id: Identifier): DeclareFunction;
export function declareInterface(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): DeclareInterface;
export function declareModule(id: Identifier | StringLiteral, body: BlockStatement, kind?: "CommonJS" | "ES" | null): DeclareModule;
export function declareModuleExports(typeAnnotation: TypeAnnotation): DeclareModuleExports;
export function declareTypeAlias(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, right: FlowType): DeclareTypeAlias;
export function declareOpaqueType(id: Identifier, typeParameters?: TypeParameterDeclaration | null, supertype?: FlowType | null): DeclareOpaqueType;
export function declareVariable(id: Identifier): DeclareVariable;
export function declareExportDeclaration(declaration?: Flow | null, specifiers?: Array<ExportSpecifier | ExportNamespaceSpecifier> | null, source?: StringLiteral | null, attributes?: Array<ImportAttribute> | null): DeclareExportDeclaration;
export function declareExportAllDeclaration(source: StringLiteral, attributes?: Array<ImportAttribute> | null): DeclareExportAllDeclaration;
export function declaredPredicate(value: Flow): DeclaredPredicate;
export function existsTypeAnnotation(): ExistsTypeAnnotation;
export function functionTypeAnnotation(typeParameters: TypeParameterDeclaration | null | undefined, params: Array<FunctionTypeParam>, rest: FunctionTypeParam | null | undefined, returnType: FlowType): FunctionTypeAnnotation;
export function functionTypeParam(name: Identifier | null | undefined, typeAnnotation: FlowType): FunctionTypeParam;
export function genericTypeAnnotation(id: Identifier | QualifiedTypeIdentifier, typeParameters?: TypeParameterInstantiation | null): GenericTypeAnnotation;
export function inferredPredicate(): InferredPredicate;
export function interfaceExtends(id: Identifier | QualifiedTypeIdentifier, typeParameters?: TypeParameterInstantiation | null): InterfaceExtends;
export function interfaceDeclaration(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, _extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): InterfaceDeclaration;
export function interfaceTypeAnnotation(_extends: Array<InterfaceExtends> | null | undefined, body: ObjectTypeAnnotation): InterfaceTypeAnnotation;
export function intersectionTypeAnnotation(types: Array<FlowType>): IntersectionTypeAnnotation;
export function mixedTypeAnnotation(): MixedTypeAnnotation;
export function emptyTypeAnnotation(): EmptyTypeAnnotation;
export function nullableTypeAnnotation(typeAnnotation: FlowType): NullableTypeAnnotation;
export function numberLiteralTypeAnnotation(value: number): NumberLiteralTypeAnnotation;
export function numberTypeAnnotation(): NumberTypeAnnotation;
export function objectTypeAnnotation(properties: Array<ObjectTypeProperty | ObjectTypeSpreadProperty>, indexers?: Array<ObjectTypeIndexer>, callProperties?: Array<ObjectTypeCallProperty>, internalSlots?: Array<ObjectTypeInternalSlot>, exact?: boolean): ObjectTypeAnnotation;
export function objectTypeInternalSlot(id: Identifier, value: FlowType, optional: boolean, _static: boolean, method: boolean): ObjectTypeInternalSlot;
export function objectTypeCallProperty(value: FlowType): ObjectTypeCallProperty;
export function objectTypeIndexer(id: Identifier | null | undefined, key: FlowType, value: FlowType, variance?: Variance | null): ObjectTypeIndexer;
export function objectTypeProperty(key: Identifier | StringLiteral, value: FlowType, variance?: Variance | null): ObjectTypeProperty;
export function objectTypeSpreadProperty(argument: FlowType): ObjectTypeSpreadProperty;
export function opaqueType(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, supertype: FlowType | null | undefined, impltype: FlowType): OpaqueType;
export function qualifiedTypeIdentifier(id: Identifier, qualification: Identifier | QualifiedTypeIdentifier): QualifiedTypeIdentifier;
export function stringLiteralTypeAnnotation(value: string): StringLiteralTypeAnnotation;
export function stringTypeAnnotation(): StringTypeAnnotation;
export function symbolTypeAnnotation(): SymbolTypeAnnotation;
export function thisTypeAnnotation(): ThisTypeAnnotation;
export function tupleTypeAnnotation(types: Array<FlowType>): TupleTypeAnnotation;
export function typeofTypeAnnotation(argument: FlowType): TypeofTypeAnnotation;
export function typeAlias(id: Identifier, typeParameters: TypeParameterDeclaration | null | undefined, right: FlowType): TypeAlias;
export function typeAnnotation(typeAnnotation: FlowType): TypeAnnotation;
export function typeCastExpression(expression: Expression, typeAnnotation: TypeAnnotation): TypeCastExpression;
export function typeParameter(bound?: TypeAnnotation | null, _default?: FlowType | null, variance?: Variance | null): TypeParameter;
export function typeParameterDeclaration(params: Array<TypeParameter>): TypeParameterDeclaration;
export function typeParameterInstantiation(params: Array<FlowType>): TypeParameterInstantiation;
export function unionTypeAnnotation(types: Array<FlowType>): UnionTypeAnnotation;
export function variance(kind: "minus" | "plus"): Variance;
export function voidTypeAnnotation(): VoidTypeAnnotation;
export function enumDeclaration(id: Identifier, body: EnumBooleanBody | EnumNumberBody | EnumStringBody | EnumSymbolBody): EnumDeclaration;
export function enumBooleanBody(members: Array<EnumBooleanMember>): EnumBooleanBody;
export function enumNumberBody(members: Array<EnumNumberMember>): EnumNumberBody;
export function enumStringBody(members: Array<EnumStringMember | EnumDefaultedMember>): EnumStringBody;
export function enumSymbolBody(members: Array<EnumDefaultedMember>): EnumSymbolBody;
export function enumBooleanMember(id: Identifier): EnumBooleanMember;
export function enumNumberMember(id: Identifier, init: NumericLiteral): EnumNumberMember;
export function enumStringMember(id: Identifier, init: StringLiteral): EnumStringMember;
export function enumDefaultedMember(id: Identifier): EnumDefaultedMember;
export function indexedAccessType(objectType: FlowType, indexType: FlowType): IndexedAccessType;
export function optionalIndexedAccessType(objectType: FlowType, indexType: FlowType): OptionalIndexedAccessType;
export function jsxAttribute(name: JSXIdentifier | JSXNamespacedName, value?: JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer | null): JSXAttribute;
export function jsxClosingElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName): JSXClosingElement;
export function jsxElement(openingElement: JSXOpeningElement, closingElement: JSXClosingElement | null | undefined, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>, selfClosing?: boolean | null): JSXElement;
export function jsxEmptyExpression(): JSXEmptyExpression;
export function jsxExpressionContainer(expression: Expression | JSXEmptyExpression): JSXExpressionContainer;
export function jsxSpreadChild(expression: Expression): JSXSpreadChild;
export function jsxIdentifier(name: string): JSXIdentifier;
export function jsxMemberExpression(object: JSXMemberExpression | JSXIdentifier, property: JSXIdentifier): JSXMemberExpression;
export function jsxNamespacedName(namespace: JSXIdentifier, name: JSXIdentifier): JSXNamespacedName;
export function jsxOpeningElement(name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName, attributes: Array<JSXAttribute | JSXSpreadAttribute>, selfClosing?: boolean): JSXOpeningElement;
export function jsxSpreadAttribute(argument: Expression): JSXSpreadAttribute;
export function jsxText(value: string): JSXText;
export function jsxFragment(openingFragment: JSXOpeningFragment, closingFragment: JSXClosingFragment, children: Array<JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment>): JSXFragment;
export function jsxOpeningFragment(): JSXOpeningFragment;
export function jsxClosingFragment(): JSXClosingFragment;
export function noop(): Noop;
export function placeholder(expectedNode: "Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern", name: Identifier): Placeholder;
export function v8IntrinsicIdentifier(name: string): V8IntrinsicIdentifier;
export function argumentPlaceholder(): ArgumentPlaceholder;
export function bindExpression(object: Expression, callee: Expression): BindExpression;
export function decorator(expression: Expression): Decorator;
export function doExpression(body: BlockStatement, async?: boolean): DoExpression;
export function exportDefaultSpecifier(exported: Identifier): ExportDefaultSpecifier;
export function recordExpression(properties: Array<ObjectProperty | SpreadElement>): RecordExpression;
export function tupleExpression(elements?: Array<Expression | SpreadElement>): TupleExpression;
export function decimalLiteral(value: string): DecimalLiteral;
export function moduleExpression(body: Program): ModuleExpression;
export function topicReference(): TopicReference;
export function pipelineTopicExpression(expression: Expression): PipelineTopicExpression;
export function pipelineBareFunction(callee: Expression): PipelineBareFunction;
export function pipelinePrimaryTopicReference(): PipelinePrimaryTopicReference;
export function voidPattern(): VoidPattern;
export function tsParameterProperty(parameter: Identifier | AssignmentPattern): TSParameterProperty;
export function tsDeclareFunction(id: Identifier | null | undefined, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array<FunctionParameter>, returnType?: TSTypeAnnotation | Noop | null): TSDeclareFunction;
export function tsDeclareMethod(decorators: Array<Decorator> | null | undefined, key: Identifier | StringLiteral | NumericLiteral | BigIntLiteral | Expression, typeParameters: TSTypeParameterDeclaration | Noop | null | undefined, params: Array<FunctionParameter | TSParameterProperty>, returnType?: TSTypeAnnotation | Noop | null): TSDeclareMethod;
export function tsQualifiedName(left: TSEntityName, right: Identifier): TSQualifiedName;
export function tsCallSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<ArrayPattern | Identifier | ObjectPattern | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSCallSignatureDeclaration;
export function tsConstructSignatureDeclaration(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<ArrayPattern | Identifier | ObjectPattern | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSConstructSignatureDeclaration;
export function tsPropertySignature(key: Expression, typeAnnotation?: TSTypeAnnotation | null): TSPropertySignature;
export function tsMethodSignature(key: Expression, typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<ArrayPattern | Identifier | ObjectPattern | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSMethodSignature;
export function tsIndexSignature(parameters: Array<Identifier>, typeAnnotation?: TSTypeAnnotation | null): TSIndexSignature;
export function tsAnyKeyword(): TSAnyKeyword;
export function tsBooleanKeyword(): TSBooleanKeyword;
export function tsBigIntKeyword(): TSBigIntKeyword;
export function tsIntrinsicKeyword(): TSIntrinsicKeyword;
export function tsNeverKeyword(): TSNeverKeyword;
export function tsNullKeyword(): TSNullKeyword;
export function tsNumberKeyword(): TSNumberKeyword;
export function tsObjectKeyword(): TSObjectKeyword;
export function tsStringKeyword(): TSStringKeyword;
export function tsSymbolKeyword(): TSSymbolKeyword;
export function tsUndefinedKeyword(): TSUndefinedKeyword;
export function tsUnknownKeyword(): TSUnknownKeyword;
export function tsVoidKeyword(): TSVoidKeyword;
export function tsThisType(): TSThisType;
export function tsFunctionType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<ArrayPattern | Identifier | ObjectPattern | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSFunctionType;
export function tsConstructorType(typeParameters: TSTypeParameterDeclaration | null | undefined, parameters: Array<ArrayPattern | Identifier | ObjectPattern | RestElement>, typeAnnotation?: TSTypeAnnotation | null): TSConstructorType;
export function tsTypeReference(typeName: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSTypeReference;
export function tsTypePredicate(parameterName: Identifier | TSThisType, typeAnnotation?: TSTypeAnnotation | null, asserts?: boolean | null): TSTypePredicate;
export function tsTypeQuery(exprName: TSEntityName | TSImportType, typeParameters?: TSTypeParameterInstantiation | null): TSTypeQuery;
export function tsTypeLiteral(members: Array<TSTypeElement>): TSTypeLiteral;
export function tsArrayType(elementType: TSType): TSArrayType;
export function tsTupleType(elementTypes: Array<TSType | TSNamedTupleMember>): TSTupleType;
export function tsOptionalType(typeAnnotation: TSType): TSOptionalType;
export function tsRestType(typeAnnotation: TSType): TSRestType;
export function tsNamedTupleMember(label: Identifier, elementType: TSType, optional?: boolean): TSNamedTupleMember;
export function tsUnionType(types: Array<TSType>): TSUnionType;
export function tsIntersectionType(types: Array<TSType>): TSIntersectionType;
export function tsConditionalType(checkType: TSType, extendsType: TSType, trueType: TSType, falseType: TSType): TSConditionalType;
export function tsInferType(typeParameter: TSTypeParameter): TSInferType;
export function tsParenthesizedType(typeAnnotation: TSType): TSParenthesizedType;
export function tsTypeOperator(typeAnnotation: TSType, operator?: string): TSTypeOperator;
export function tsIndexedAccessType(objectType: TSType, indexType: TSType): TSIndexedAccessType;
export function tsMappedType(typeParameter: TSTypeParameter, typeAnnotation?: TSType | null, nameType?: TSType | null): TSMappedType;
export function tsTemplateLiteralType(quasis: Array<TemplateElement>, types: Array<TSType>): TSTemplateLiteralType;
export function tsLiteralType(literal: NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral | TemplateLiteral | UnaryExpression): TSLiteralType;
export function tsExpressionWithTypeArguments(expression: TSEntityName, typeParameters?: TSTypeParameterInstantiation | null): TSExpressionWithTypeArguments;
export function tsInterfaceDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, _extends: Array<TSExpressionWithTypeArguments> | null | undefined, body: TSInterfaceBody): TSInterfaceDeclaration;
export function tsInterfaceBody(body: Array<TSTypeElement>): TSInterfaceBody;
export function tsTypeAliasDeclaration(id: Identifier, typeParameters: TSTypeParameterDeclaration | null | undefined, typeAnnotation: TSType): TSTypeAliasDeclaration;
export function tsInstantiationExpression(expression: Expression, typeParameters?: TSTypeParameterInstantiation | null): TSInstantiationExpression;
export function tsAsExpression(expression: Expression, typeAnnotation: TSType): TSAsExpression;
export function tsSatisfiesExpression(expression: Expression, typeAnnotation: TSType): TSSatisfiesExpression;
export function tsTypeAssertion(typeAnnotation: TSType, expression: Expression): TSTypeAssertion;
export function tsEnumBody(members: Array<TSEnumMember>): TSEnumBody;
export function tsEnumDeclaration(id: Identifier, members: Array<TSEnumMember>): TSEnumDeclaration;
export function tsEnumMember(id: Identifier | StringLiteral, initializer?: Expression | null): TSEnumMember;
export function tsModuleDeclaration(id: Identifier | StringLiteral, body: TSModuleBlock | TSModuleDeclaration): TSModuleDeclaration;
export function tsModuleBlock(body: Array<Statement>): TSModuleBlock;
export function tsImportType(argument: StringLiteral, qualifier?: TSEntityName | null, typeParameters?: TSTypeParameterInstantiation | null): TSImportType;
export function tsImportEqualsDeclaration(id: Identifier, moduleReference: TSEntityName | TSExternalModuleReference): TSImportEqualsDeclaration;
export function tsExternalModuleReference(expression: StringLiteral): TSExternalModuleReference;
export function tsNonNullExpression(expression: Expression): TSNonNullExpression;
export function tsExportAssignment(expression: Expression): TSExportAssignment;
export function tsNamespaceExportDeclaration(id: Identifier): TSNamespaceExportDeclaration;
export function tsTypeAnnotation(typeAnnotation: TSType): TSTypeAnnotation;
export function tsTypeParameterInstantiation(params: Array<TSType>): TSTypeParameterInstantiation;
export function tsTypeParameterDeclaration(params: Array<TSTypeParameter>): TSTypeParameterDeclaration;
export function tsTypeParameter(constraint: TSType | null | undefined, _default: TSType | null | undefined, name: string): TSTypeParameter;
export function isAccessor(node: object | null | undefined, opts?: object | null): node is Accessor;
export function assertAccessor(node: object | null | undefined, opts?: object | null): void;
export function isAnyTypeAnnotation(node: object | null | undefined, opts?: object | null): node is AnyTypeAnnotation;
export function assertAnyTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isArgumentPlaceholder(node: object | null | undefined, opts?: object | null): node is ArgumentPlaceholder;
export function assertArgumentPlaceholder(node: object | null | undefined, opts?: object | null): void;
export function isArrayExpression(node: object | null | undefined, opts?: object | null): node is ArrayExpression;
export function assertArrayExpression(node: object | null | undefined, opts?: object | null): void;
export function isArrayPattern(node: object | null | undefined, opts?: object | null): node is ArrayPattern;
export function assertArrayPattern(node: object | null | undefined, opts?: object | null): void;
export function isArrayTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ArrayTypeAnnotation;
export function assertArrayTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isArrowFunctionExpression(node: object | null | undefined, opts?: object | null): node is ArrowFunctionExpression;
export function assertArrowFunctionExpression(node: object | null | undefined, opts?: object | null): void;
export function isAssignmentExpression(node: object | null | undefined, opts?: object | null): node is AssignmentExpression;
export function assertAssignmentExpression(node: object | null | undefined, opts?: object | null): void;
export function isAssignmentPattern(node: object | null | undefined, opts?: object | null): node is AssignmentPattern;
export function assertAssignmentPattern(node: object | null | undefined, opts?: object | null): void;
export function isAwaitExpression(node: object | null | undefined, opts?: object | null): node is AwaitExpression;
export function assertAwaitExpression(node: object | null | undefined, opts?: object | null): void;
export function isBigIntLiteral(node: object | null | undefined, opts?: object | null): node is BigIntLiteral;
export function assertBigIntLiteral(node: object | null | undefined, opts?: object | null): void;
export function isBinary(node: object | null | undefined, opts?: object | null): node is Binary;
export function assertBinary(node: object | null | undefined, opts?: object | null): void;
export function isBinaryExpression(node: object | null | undefined, opts?: object | null): node is BinaryExpression;
export function assertBinaryExpression(node: object | null | undefined, opts?: object | null): void;
export function isBindExpression(node: object | null | undefined, opts?: object | null): node is BindExpression;
export function assertBindExpression(node: object | null | undefined, opts?: object | null): void;
export function isBlock(node: object | null | undefined, opts?: object | null): node is Block;
export function assertBlock(node: object | null | undefined, opts?: object | null): void;
export function isBlockParent(node: object | null | undefined, opts?: object | null): node is BlockParent;
export function assertBlockParent(node: object | null | undefined, opts?: object | null): void;
export function isBlockStatement(node: object | null | undefined, opts?: object | null): node is BlockStatement;
export function assertBlockStatement(node: object | null | undefined, opts?: object | null): void;
export function isBooleanLiteral(node: object | null | undefined, opts?: object | null): node is BooleanLiteral;
export function assertBooleanLiteral(node: object | null | undefined, opts?: object | null): void;
export function isBooleanLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): node is BooleanLiteralTypeAnnotation;
export function assertBooleanLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isBooleanTypeAnnotation(node: object | null | undefined, opts?: object | null): node is BooleanTypeAnnotation;
export function assertBooleanTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isBreakStatement(node: object | null | undefined, opts?: object | null): node is BreakStatement;
export function assertBreakStatement(node: object | null | undefined, opts?: object | null): void;
export function isCallExpression(node: object | null | undefined, opts?: object | null): node is CallExpression;
export function assertCallExpression(node: object | null | undefined, opts?: object | null): void;
export function isCatchClause(node: object | null | undefined, opts?: object | null): node is CatchClause;
export function assertCatchClause(node: object | null | undefined, opts?: object | null): void;
export function isClass(node: object | null | undefined, opts?: object | null): node is Class;
export function assertClass(node: object | null | undefined, opts?: object | null): void;
export function isClassAccessorProperty(node: object | null | undefined, opts?: object | null): node is ClassAccessorProperty;
export function assertClassAccessorProperty(node: object | null | undefined, opts?: object | null): void;
export function isClassBody(node: object | null | undefined, opts?: object | null): node is ClassBody;
export function assertClassBody(node: object | null | undefined, opts?: object | null): void;
export function isClassDeclaration(node: object | null | undefined, opts?: object | null): node is ClassDeclaration;
export function assertClassDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isClassExpression(node: object | null | undefined, opts?: object | null): node is ClassExpression;
export function assertClassExpression(node: object | null | undefined, opts?: object | null): void;
export function isClassImplements(node: object | null | undefined, opts?: object | null): node is ClassImplements;
export function assertClassImplements(node: object | null | undefined, opts?: object | null): void;
export function isClassMethod(node: object | null | undefined, opts?: object | null): node is ClassMethod;
export function assertClassMethod(node: object | null | undefined, opts?: object | null): void;
export function isClassPrivateMethod(node: object | null | undefined, opts?: object | null): node is ClassPrivateMethod;
export function assertClassPrivateMethod(node: object | null | undefined, opts?: object | null): void;
export function isClassPrivateProperty(node: object | null | undefined, opts?: object | null): node is ClassPrivateProperty;
export function assertClassPrivateProperty(node: object | null | undefined, opts?: object | null): void;
export function isClassProperty(node: object | null | undefined, opts?: object | null): node is ClassProperty;
export function assertClassProperty(node: object | null | undefined, opts?: object | null): void;
export function isCompletionStatement(node: object | null | undefined, opts?: object | null): node is CompletionStatement;
export function assertCompletionStatement(node: object | null | undefined, opts?: object | null): void;
export function isConditional(node: object | null | undefined, opts?: object | null): node is Conditional;
export function assertConditional(node: object | null | undefined, opts?: object | null): void;
export function isConditionalExpression(node: object | null | undefined, opts?: object | null): node is ConditionalExpression;
export function assertConditionalExpression(node: object | null | undefined, opts?: object | null): void;
export function isContinueStatement(node: object | null | undefined, opts?: object | null): node is ContinueStatement;
export function assertContinueStatement(node: object | null | undefined, opts?: object | null): void;
export function isDebuggerStatement(node: object | null | undefined, opts?: object | null): node is DebuggerStatement;
export function assertDebuggerStatement(node: object | null | undefined, opts?: object | null): void;
export function isDecimalLiteral(node: object | null | undefined, opts?: object | null): node is DecimalLiteral;
export function assertDecimalLiteral(node: object | null | undefined, opts?: object | null): void;
export function isDeclaration(node: object | null | undefined, opts?: object | null): node is Declaration;
export function assertDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isDeclareClass(node: object | null | undefined, opts?: object | null): node is DeclareClass;
export function assertDeclareClass(node: object | null | undefined, opts?: object | null): void;
export function isDeclareExportAllDeclaration(node: object | null | undefined, opts?: object | null): node is DeclareExportAllDeclaration;
export function assertDeclareExportAllDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isDeclareExportDeclaration(node: object | null | undefined, opts?: object | null): node is DeclareExportDeclaration;
export function assertDeclareExportDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isDeclareFunction(node: object | null | undefined, opts?: object | null): node is DeclareFunction;
export function assertDeclareFunction(node: object | null | undefined, opts?: object | null): void;
export function isDeclareInterface(node: object | null | undefined, opts?: object | null): node is DeclareInterface;
export function assertDeclareInterface(node: object | null | undefined, opts?: object | null): void;
export function isDeclareModule(node: object | null | undefined, opts?: object | null): node is DeclareModule;
export function assertDeclareModule(node: object | null | undefined, opts?: object | null): void;
export function isDeclareModuleExports(node: object | null | undefined, opts?: object | null): node is DeclareModuleExports;
export function assertDeclareModuleExports(node: object | null | undefined, opts?: object | null): void;
export function isDeclareOpaqueType(node: object | null | undefined, opts?: object | null): node is DeclareOpaqueType;
export function assertDeclareOpaqueType(node: object | null | undefined, opts?: object | null): void;
export function isDeclareTypeAlias(node: object | null | undefined, opts?: object | null): node is DeclareTypeAlias;
export function assertDeclareTypeAlias(node: object | null | undefined, opts?: object | null): void;
export function isDeclareVariable(node: object | null | undefined, opts?: object | null): node is DeclareVariable;
export function assertDeclareVariable(node: object | null | undefined, opts?: object | null): void;
export function isDeclaredPredicate(node: object | null | undefined, opts?: object | null): node is DeclaredPredicate;
export function assertDeclaredPredicate(node: object | null | undefined, opts?: object | null): void;
export function isDecorator(node: object | null | undefined, opts?: object | null): node is Decorator;
export function assertDecorator(node: object | null | undefined, opts?: object | null): void;
export function isDirective(node: object | null | undefined, opts?: object | null): node is Directive;
export function assertDirective(node: object | null | undefined, opts?: object | null): void;
export function isDirectiveLiteral(node: object | null | undefined, opts?: object | null): node is DirectiveLiteral;
export function assertDirectiveLiteral(node: object | null | undefined, opts?: object | null): void;
export function isDoExpression(node: object | null | undefined, opts?: object | null): node is DoExpression;
export function assertDoExpression(node: object | null | undefined, opts?: object | null): void;
export function isDoWhileStatement(node: object | null | undefined, opts?: object | null): node is DoWhileStatement;
export function assertDoWhileStatement(node: object | null | undefined, opts?: object | null): void;
export function isEmptyStatement(node: object | null | undefined, opts?: object | null): node is EmptyStatement;
export function assertEmptyStatement(node: object | null | undefined, opts?: object | null): void;
export function isEmptyTypeAnnotation(node: object | null | undefined, opts?: object | null): node is EmptyTypeAnnotation;
export function assertEmptyTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isEnumBody(node: object | null | undefined, opts?: object | null): node is EnumBody;
export function assertEnumBody(node: object | null | undefined, opts?: object | null): void;
export function isEnumBooleanBody(node: object | null | undefined, opts?: object | null): node is EnumBooleanBody;
export function assertEnumBooleanBody(node: object | null | undefined, opts?: object | null): void;
export function isEnumBooleanMember(node: object | null | undefined, opts?: object | null): node is EnumBooleanMember;
export function assertEnumBooleanMember(node: object | null | undefined, opts?: object | null): void;
export function isEnumDeclaration(node: object | null | undefined, opts?: object | null): node is EnumDeclaration;
export function assertEnumDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isEnumDefaultedMember(node: object | null | undefined, opts?: object | null): node is EnumDefaultedMember;
export function assertEnumDefaultedMember(node: object | null | undefined, opts?: object | null): void;
export function isEnumMember(node: object | null | undefined, opts?: object | null): node is EnumMember;
export function assertEnumMember(node: object | null | undefined, opts?: object | null): void;
export function isEnumNumberBody(node: object | null | undefined, opts?: object | null): node is EnumNumberBody;
export function assertEnumNumberBody(node: object | null | undefined, opts?: object | null): void;
export function isEnumNumberMember(node: object | null | undefined, opts?: object | null): node is EnumNumberMember;
export function assertEnumNumberMember(node: object | null | undefined, opts?: object | null): void;
export function isEnumStringBody(node: object | null | undefined, opts?: object | null): node is EnumStringBody;
export function assertEnumStringBody(node: object | null | undefined, opts?: object | null): void;
export function isEnumStringMember(node: object | null | undefined, opts?: object | null): node is EnumStringMember;
export function assertEnumStringMember(node: object | null | undefined, opts?: object | null): void;
export function isEnumSymbolBody(node: object | null | undefined, opts?: object | null): node is EnumSymbolBody;
export function assertEnumSymbolBody(node: object | null | undefined, opts?: object | null): void;
export function isExistsTypeAnnotation(node: object | null | undefined, opts?: object | null): node is ExistsTypeAnnotation;
export function assertExistsTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isExportAllDeclaration(node: object | null | undefined, opts?: object | null): node is ExportAllDeclaration;
export function assertExportAllDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isExportDeclaration(node: object | null | undefined, opts?: object | null): node is ExportDeclaration;
export function assertExportDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isExportDefaultDeclaration(node: object | null | undefined, opts?: object | null): node is ExportDefaultDeclaration;
export function assertExportDefaultDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isExportDefaultSpecifier(node: object | null | undefined, opts?: object | null): node is ExportDefaultSpecifier;
export function assertExportDefaultSpecifier(node: object | null | undefined, opts?: object | null): void;
export function isExportNamedDeclaration(node: object | null | undefined, opts?: object | null): node is ExportNamedDeclaration;
export function assertExportNamedDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isExportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): node is ExportNamespaceSpecifier;
export function assertExportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): void;
export function isExportSpecifier(node: object | null | undefined, opts?: object | null): node is ExportSpecifier;
export function assertExportSpecifier(node: object | null | undefined, opts?: object | null): void;
export function isExpression(node: object | null | undefined, opts?: object | null): node is Expression;
export function assertExpression(node: object | null | undefined, opts?: object | null): void;
export function isExpressionStatement(node: object | null | undefined, opts?: object | null): node is ExpressionStatement;
export function assertExpressionStatement(node: object | null | undefined, opts?: object | null): void;
export function isExpressionWrapper(node: object | null | undefined, opts?: object | null): node is ExpressionWrapper;
export function assertExpressionWrapper(node: object | null | undefined, opts?: object | null): void;
export function isFile(node: object | null | undefined, opts?: object | null): node is File;
export function assertFile(node: object | null | undefined, opts?: object | null): void;
export function isFlow(node: object | null | undefined, opts?: object | null): node is Flow;
export function assertFlow(node: object | null | undefined, opts?: object | null): void;
export function isFlowBaseAnnotation(node: object | null | undefined, opts?: object | null): node is FlowBaseAnnotation;
export function assertFlowBaseAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isFlowDeclaration(node: object | null | undefined, opts?: object | null): node is FlowDeclaration;
export function assertFlowDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isFlowPredicate(node: object | null | undefined, opts?: object | null): node is FlowPredicate;
export function assertFlowPredicate(node: object | null | undefined, opts?: object | null): void;
export function isFlowType(node: object | null | undefined, opts?: object | null): node is FlowType;
export function assertFlowType(node: object | null | undefined, opts?: object | null): void;
export function isFor(node: object | null | undefined, opts?: object | null): node is For;
export function assertFor(node: object | null | undefined, opts?: object | null): void;
export function isForInStatement(node: object | null | undefined, opts?: object | null): node is ForInStatement;
export function assertForInStatement(node: object | null | undefined, opts?: object | null): void;
export function isForOfStatement(node: object | null | undefined, opts?: object | null): node is ForOfStatement;
export function assertForOfStatement(node: object | null | undefined, opts?: object | null): void;
export function isForStatement(node: object | null | undefined, opts?: object | null): node is ForStatement;
export function assertForStatement(node: object | null | undefined, opts?: object | null): void;
export function isForXStatement(node: object | null | undefined, opts?: object | null): node is ForXStatement;
export function assertForXStatement(node: object | null | undefined, opts?: object | null): void;
export function isFunction(node: object | null | undefined, opts?: object | null): node is Function;
export function assertFunction(node: object | null | undefined, opts?: object | null): void;
export function isFunctionDeclaration(node: object | null | undefined, opts?: object | null): node is FunctionDeclaration;
export function assertFunctionDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isFunctionExpression(node: object | null | undefined, opts?: object | null): node is FunctionExpression;
export function assertFunctionExpression(node: object | null | undefined, opts?: object | null): void;
export function isFunctionParameter(node: object | null | undefined, opts?: object | null): node is FunctionParameter;
export function assertFunctionParameter(node: object | null | undefined, opts?: object | null): void;
export function isFunctionParent(node: object | null | undefined, opts?: object | null): node is FunctionParent;
export function assertFunctionParent(node: object | null | undefined, opts?: object | null): void;
export function isFunctionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is FunctionTypeAnnotation;
export function assertFunctionTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isFunctionTypeParam(node: object | null | undefined, opts?: object | null): node is FunctionTypeParam;
export function assertFunctionTypeParam(node: object | null | undefined, opts?: object | null): void;
export function isGenericTypeAnnotation(node: object | null | undefined, opts?: object | null): node is GenericTypeAnnotation;
export function assertGenericTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isIdentifier(node: object | null | undefined, opts?: object | null): node is Identifier;
export function assertIdentifier(node: object | null | undefined, opts?: object | null): void;
export function isIfStatement(node: object | null | undefined, opts?: object | null): node is IfStatement;
export function assertIfStatement(node: object | null | undefined, opts?: object | null): void;
export function isImmutable(node: object | null | undefined, opts?: object | null): node is Immutable;
export function assertImmutable(node: object | null | undefined, opts?: object | null): void;
export function isImport(node: object | null | undefined, opts?: object | null): node is Import;
export function assertImport(node: object | null | undefined, opts?: object | null): void;
export function isImportAttribute(node: object | null | undefined, opts?: object | null): node is ImportAttribute;
export function assertImportAttribute(node: object | null | undefined, opts?: object | null): void;
export function isImportDeclaration(node: object | null | undefined, opts?: object | null): node is ImportDeclaration;
export function assertImportDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isImportDefaultSpecifier(node: object | null | undefined, opts?: object | null): node is ImportDefaultSpecifier;
export function assertImportDefaultSpecifier(node: object | null | undefined, opts?: object | null): void;
export function isImportExpression(node: object | null | undefined, opts?: object | null): node is ImportExpression;
export function assertImportExpression(node: object | null | undefined, opts?: object | null): void;
export function isImportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): node is ImportNamespaceSpecifier;
export function assertImportNamespaceSpecifier(node: object | null | undefined, opts?: object | null): void;
export function isImportOrExportDeclaration(node: object | null | undefined, opts?: object | null): node is ImportOrExportDeclaration;
export function assertImportOrExportDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isImportSpecifier(node: object | null | undefined, opts?: object | null): node is ImportSpecifier;
export function assertImportSpecifier(node: object | null | undefined, opts?: object | null): void;
export function isIndexedAccessType(node: object | null | undefined, opts?: object | null): node is IndexedAccessType;
export function assertIndexedAccessType(node: object | null | undefined, opts?: object | null): void;
export function isInferredPredicate(node: object | null | undefined, opts?: object | null): node is InferredPredicate;
export function assertInferredPredicate(node: object | null | undefined, opts?: object | null): void;
export function isInterfaceDeclaration(node: object | null | undefined, opts?: object | null): node is InterfaceDeclaration;
export function assertInterfaceDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isInterfaceExtends(node: object | null | undefined, opts?: object | null): node is InterfaceExtends;
export function assertInterfaceExtends(node: object | null | undefined, opts?: object | null): void;
export function isInterfaceTypeAnnotation(node: object | null | undefined, opts?: object | null): node is InterfaceTypeAnnotation;
export function assertInterfaceTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isInterpreterDirective(node: object | null | undefined, opts?: object | null): node is InterpreterDirective;
export function assertInterpreterDirective(node: object | null | undefined, opts?: object | null): void;
export function isIntersectionTypeAnnotation(node: object | null | undefined, opts?: object | null): node is IntersectionTypeAnnotation;
export function assertIntersectionTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isJSX(node: object | null | undefined, opts?: object | null): node is JSX;
export function assertJSX(node: object | null | undefined, opts?: object | null): void;
export function isJSXAttribute(node: object | null | undefined, opts?: object | null): node is JSXAttribute;
export function assertJSXAttribute(node: object | null | undefined, opts?: object | null): void;
export function isJSXClosingElement(node: object | null | undefined, opts?: object | null): node is JSXClosingElement;
export function assertJSXClosingElement(node: object | null | undefined, opts?: object | null): void;
export function isJSXClosingFragment(node: object | null | undefined, opts?: object | null): node is JSXClosingFragment;
export function assertJSXClosingFragment(node: object | null | undefined, opts?: object | null): void;
export function isJSXElement(node: object | null | undefined, opts?: object | null): node is JSXElement;
export function assertJSXElement(node: object | null | undefined, opts?: object | null): void;
export function isJSXEmptyExpression(node: object | null | undefined, opts?: object | null): node is JSXEmptyExpression;
export function assertJSXEmptyExpression(node: object | null | undefined, opts?: object | null): void;
export function isJSXExpressionContainer(node: object | null | undefined, opts?: object | null): node is JSXExpressionContainer;
export function assertJSXExpressionContainer(node: object | null | undefined, opts?: object | null): void;
export function isJSXFragment(node: object | null | undefined, opts?: object | null): node is JSXFragment;
export function assertJSXFragment(node: object | null | undefined, opts?: object | null): void;
export function isJSXIdentifier(node: object | null | undefined, opts?: object | null): node is JSXIdentifier;
export function assertJSXIdentifier(node: object | null | undefined, opts?: object | null): void;
export function isJSXMemberExpression(node: object | null | undefined, opts?: object | null): node is JSXMemberExpression;
export function assertJSXMemberExpression(node: object | null | undefined, opts?: object | null): void;
export function isJSXNamespacedName(node: object | null | undefined, opts?: object | null): node is JSXNamespacedName;
export function assertJSXNamespacedName(node: object | null | undefined, opts?: object | null): void;
export function isJSXOpeningElement(node: object | null | undefined, opts?: object | null): node is JSXOpeningElement;
export function assertJSXOpeningElement(node: object | null | undefined, opts?: object | null): void;
export function isJSXOpeningFragment(node: object | null | undefined, opts?: object | null): node is JSXOpeningFragment;
export function assertJSXOpeningFragment(node: object | null | undefined, opts?: object | null): void;
export function isJSXSpreadAttribute(node: object | null | undefined, opts?: object | null): node is JSXSpreadAttribute;
export function assertJSXSpreadAttribute(node: object | null | undefined, opts?: object | null): void;
export function isJSXSpreadChild(node: object | null | undefined, opts?: object | null): node is JSXSpreadChild;
export function assertJSXSpreadChild(node: object | null | undefined, opts?: object | null): void;
export function isJSXText(node: object | null | undefined, opts?: object | null): node is JSXText;
export function assertJSXText(node: object | null | undefined, opts?: object | null): void;
export function isLVal(node: object | null | undefined, opts?: object | null): node is LVal;
export function assertLVal(node: object | null | undefined, opts?: object | null): void;
export function isLabeledStatement(node: object | null | undefined, opts?: object | null): node is LabeledStatement;
export function assertLabeledStatement(node: object | null | undefined, opts?: object | null): void;
export function isLiteral(node: object | null | undefined, opts?: object | null): node is Literal;
export function assertLiteral(node: object | null | undefined, opts?: object | null): void;
export function isLogicalExpression(node: object | null | undefined, opts?: object | null): node is LogicalExpression;
export function assertLogicalExpression(node: object | null | undefined, opts?: object | null): void;
export function isLoop(node: object | null | undefined, opts?: object | null): node is Loop;
export function assertLoop(node: object | null | undefined, opts?: object | null): void;
export function isMemberExpression(node: object | null | undefined, opts?: object | null): node is MemberExpression;
export function assertMemberExpression(node: object | null | undefined, opts?: object | null): void;
export function isMetaProperty(node: object | null | undefined, opts?: object | null): node is MetaProperty;
export function assertMetaProperty(node: object | null | undefined, opts?: object | null): void;
export function isMethod(node: object | null | undefined, opts?: object | null): node is Method;
export function assertMethod(node: object | null | undefined, opts?: object | null): void;
export function isMiscellaneous(node: object | null | undefined, opts?: object | null): node is Miscellaneous;
export function assertMiscellaneous(node: object | null | undefined, opts?: object | null): void;
export function isMixedTypeAnnotation(node: object | null | undefined, opts?: object | null): node is MixedTypeAnnotation;
export function assertMixedTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isModuleDeclaration(node: object | null | undefined, opts?: object | null): node is ModuleDeclaration;
export function assertModuleDeclaration(node: object | null | undefined, opts?: object | null): void;
export function isModuleExpression(node: object | null | undefined, opts?: object | null): node is ModuleExpression;
export function assertModuleExpression(node: object | null | undefined, opts?: object | null): void;
export function isModuleSpecifier(node: object | null | undefined, opts?: object | null): node is ModuleSpecifier;
export function assertModuleSpecifier(node: object | null | undefined, opts?: object | null): void;
export function isNewExpression(node: object | null | undefined, opts?: object | null): node is NewExpression;
export function assertNewExpression(node: object | null | undefined, opts?: object | null): void;
export function isNoop(node: object | null | undefined, opts?: object | null): node is Noop;
export function assertNoop(node: object | null | undefined, opts?: object | null): void;
export function isNullLiteral(node: object | null | undefined, opts?: object | null): node is NullLiteral;
export function assertNullLiteral(node: object | null | undefined, opts?: object | null): void;
export function isNullLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): node is NullLiteralTypeAnnotation;
export function assertNullLiteralTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
export function isNullableTypeAnnotation(node: object | null | undefined, opts?: object | null): node is NullableTypeAnnotation;
export function assertNullableTypeAnnotation(node: object | null | undefined, opts?: object | null): void;
/** @deprecated Use `isNumericLiteral`

## assertNumberLiteral

Source: `my-backend/node_modules/@babel/types/lib/index-legacy.d.ts`

Signature: `assertNumberLiteral(node: object | null | undefined, opts?: object | null)`

JSDoc:

@deprecated Use `assertNumericLiteral`

## isRegexLiteral

Source: `my-backend/node_modules/@babel/types/lib/index-legacy.d.ts`

Signature: `isRegexLiteral(node: object | null | undefined, opts?: object | null)`

JSDoc:

@deprecated Use `isRegExpLiteral`

## assertRegexLiteral

Source: `my-backend/node_modules/@babel/types/lib/index-legacy.d.ts`

Signature: `assertRegexLiteral(node: object | null | undefined, opts?: object | null)`

JSDoc:

@deprecated Use `assertRegExpLiteral`

## isRestProperty

Source: `my-backend/node_modules/@babel/types/lib/index-legacy.d.ts`

Signature: `isRestProperty(node: object | null | undefined, opts?: object | null)`

JSDoc:

@deprecated Use `isRestElement`

## assertRestProperty

Source: `my-backend/node_modules/@babel/types/lib/index-legacy.d.ts`

Signature: `assertRestProperty(node: object | null | undefined, opts?: object | null)`

JSDoc:

@deprecated Use `assertRestElement`

## isSpreadProperty

Source: `my-backend/node_modules/@babel/types/lib/index-legacy.d.ts`

Signature: `isSpreadProperty(node: object | null | undefined, opts?: object | null)`

JSDoc:

@deprecated Use `isSpreadElement`

## assertSpreadProperty

Source: `my-backend/node_modules/@babel/types/lib/index-legacy.d.ts`

Signature: `assertSpreadProperty(node: object | null | undefined, opts?: object | null)`

JSDoc:

@deprecated Use `assertSpreadElement`

## cloneProcessCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/clone.ts`

Signature: `cloneProcessCov(processCov: Readonly<ProcessCov>)`

JSDoc:

Creates a deep copy of a process coverage.

@param processCov Process coverage to clone.
@return Cloned process coverage.

## cloneScriptCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/clone.ts`

Signature: `cloneScriptCov(scriptCov: Readonly<ScriptCov>)`

JSDoc:

Creates a deep copy of a script coverage.

@param scriptCov Script coverage to clone.
@return Cloned script coverage.

## cloneFunctionCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/clone.ts`

Signature: `cloneFunctionCov(functionCov: Readonly<FunctionCov>)`

JSDoc:

Creates a deep copy of a function coverage.

@param functionCov Function coverage to clone.
@return Cloned function coverage.

## cloneRangeCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/clone.ts`

Signature: `cloneRangeCov(rangeCov: Readonly<RangeCov>)`

JSDoc:

Creates a deep copy of a function coverage.

@param rangeCov Range coverage to clone.
@return Cloned range coverage.

## compareScriptCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/compare.ts`

Signature: `compareScriptCovs(a: Readonly<ScriptCov>, b: Readonly<ScriptCov>)`

JSDoc:

Compares two script coverages.

The result corresponds to the comparison of their `url` value (alphabetical sort).

## compareFunctionCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/compare.ts`

Signature: `compareFunctionCovs(a: Readonly<FunctionCov>, b: Readonly<FunctionCov>)`

JSDoc:

Compares two function coverages.

The result corresponds to the comparison of the root ranges.

## compareRangeCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/compare.ts`

Signature: `compareRangeCovs(a: Readonly<RangeCov>, b: Readonly<RangeCov>)`

JSDoc:

Compares two range coverages.

The ranges are first ordered by ascending `startOffset` and then by
descending `endOffset`.
This corresponds to a pre-order tree traversal.

## mergeProcessCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/merge.ts`

Signature: `mergeProcessCovs(processCovs: ReadonlyArray<ProcessCov>)`

JSDoc:

Merges a list of process coverages.

The result is normalized.
The input values may be mutated, it is not safe to use them after passing
them to this function.
The computation is synchronous.

@param processCovs Process coverages to merge.
@return Merged process coverage.

## mergeScriptCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/merge.ts`

Signature: `mergeScriptCovs(scriptCovs: ReadonlyArray<ScriptCov>)`

JSDoc:

Merges a list of matching script coverages.

Scripts are matching if they have the same `url`.
The result is normalized.
The input values may be mutated, it is not safe to use them after passing
them to this function.
The computation is synchronous.

@param scriptCovs Process coverages to merge.
@return Merged script coverage, or `undefined` if the input list was empty.

## mergeFunctionCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/merge.ts`

Signature: `mergeFunctionCovs(funcCovs: ReadonlyArray<FunctionCov>)`

JSDoc:

Returns a string representation of the root range of the function.

This string can be used to match function with same root range.
The string is derived from the start and end offsets of the root range of
the function.
This assumes that `ranges` is non-empty (true for valid function coverages).

@param funcCov Function coverage with the range to stringify
@internal
/
function stringifyFunctionRootRange(funcCov: Readonly<FunctionCov>): string {
  const rootRange: RangeCov = funcCov.ranges[0];
  return `${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}`;
}

/**
Merges a list of matching function coverages.

Functions are matching if their root ranges have the same span.
The result is normalized.
The input values may be mutated, it is not safe to use them after passing
them to this function.
The computation is synchronous.

@param funcCovs Function coverages to merge.
@return Merged function coverage, or `undefined` if the input list was empty.

## normalizeProcessCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts`

Signature: `normalizeProcessCov(processCov: ProcessCov)`

JSDoc:

Normalizes a process coverage.

Sorts the scripts alphabetically by `url`.
Reassigns script ids: the script at index `0` receives `"0"`, the script at
index `1` receives `"1"` etc.
This does not normalize the script coverages.

@param processCov Process coverage to normalize.

## deepNormalizeProcessCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts`

Signature: `deepNormalizeProcessCov(processCov: ProcessCov)`

JSDoc:

Normalizes a process coverage deeply.

Normalizes the script coverages deeply, then normalizes the process coverage
itself.

@param processCov Process coverage to normalize.

## normalizeScriptCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts`

Signature: `normalizeScriptCov(scriptCov: ScriptCov)`

JSDoc:

Normalizes a script coverage.

Sorts the function by root range (pre-order sort).
This does not normalize the function coverages.

@param scriptCov Script coverage to normalize.

## deepNormalizeScriptCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts`

Signature: `deepNormalizeScriptCov(scriptCov: ScriptCov)`

JSDoc:

Normalizes a script coverage deeply.

Normalizes the function coverages deeply, then normalizes the script coverage
itself.

@param scriptCov Script coverage to normalize.

## normalizeFunctionCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts`

Signature: `normalizeFunctionCov(funcCov: FunctionCov)`

JSDoc:

Normalizes a function coverage.

Sorts the ranges (pre-order sort).
TODO: Tree-based normalization of the ranges.

@param funcCov Function coverage to normalize.

## normalizeRangeTree

Source: `my-backend/node_modules/@bcoe/v8-coverage/dist/lib/_src/normalize.ts`

Signature: `normalizeRangeTree(tree: RangeTree)`

JSDoc:

@internal

## cloneProcessCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/clone.ts`

Signature: `cloneProcessCov(processCov: Readonly<ProcessCov>)`

JSDoc:

Creates a deep copy of a process coverage.

@param processCov Process coverage to clone.
@return Cloned process coverage.

## cloneScriptCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/clone.ts`

Signature: `cloneScriptCov(scriptCov: Readonly<ScriptCov>)`

JSDoc:

Creates a deep copy of a script coverage.

@param scriptCov Script coverage to clone.
@return Cloned script coverage.

## cloneFunctionCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/clone.ts`

Signature: `cloneFunctionCov(functionCov: Readonly<FunctionCov>)`

JSDoc:

Creates a deep copy of a function coverage.

@param functionCov Function coverage to clone.
@return Cloned function coverage.

## cloneRangeCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/clone.ts`

Signature: `cloneRangeCov(rangeCov: Readonly<RangeCov>)`

JSDoc:

Creates a deep copy of a function coverage.

@param rangeCov Range coverage to clone.
@return Cloned range coverage.

## compareScriptCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/compare.ts`

Signature: `compareScriptCovs(a: Readonly<ScriptCov>, b: Readonly<ScriptCov>)`

JSDoc:

Compares two script coverages.

The result corresponds to the comparison of their `url` value (alphabetical sort).

## compareFunctionCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/compare.ts`

Signature: `compareFunctionCovs(a: Readonly<FunctionCov>, b: Readonly<FunctionCov>)`

JSDoc:

Compares two function coverages.

The result corresponds to the comparison of the root ranges.

## compareRangeCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/compare.ts`

Signature: `compareRangeCovs(a: Readonly<RangeCov>, b: Readonly<RangeCov>)`

JSDoc:

Compares two range coverages.

The ranges are first ordered by ascending `startOffset` and then by
descending `endOffset`.
This corresponds to a pre-order tree traversal.

## mergeProcessCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/merge.ts`

Signature: `mergeProcessCovs(processCovs: ReadonlyArray<ProcessCov>)`

JSDoc:

Merges a list of process coverages.

The result is normalized.
The input values may be mutated, it is not safe to use them after passing
them to this function.
The computation is synchronous.

@param processCovs Process coverages to merge.
@return Merged process coverage.

## mergeScriptCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/merge.ts`

Signature: `mergeScriptCovs(scriptCovs: ReadonlyArray<ScriptCov>)`

JSDoc:

Merges a list of matching script coverages.

Scripts are matching if they have the same `url`.
The result is normalized.
The input values may be mutated, it is not safe to use them after passing
them to this function.
The computation is synchronous.

@param scriptCovs Process coverages to merge.
@return Merged script coverage, or `undefined` if the input list was empty.

## mergeFunctionCovs

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/merge.ts`

Signature: `mergeFunctionCovs(funcCovs: ReadonlyArray<FunctionCov>)`

JSDoc:

Returns a string representation of the root range of the function.

This string can be used to match function with same root range.
The string is derived from the start and end offsets of the root range of
the function.
This assumes that `ranges` is non-empty (true for valid function coverages).

@param funcCov Function coverage with the range to stringify
@internal
/
function stringifyFunctionRootRange(funcCov: Readonly<FunctionCov>): string {
  const rootRange: RangeCov = funcCov.ranges[0];
  return `${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}`;
}

/**
Merges a list of matching function coverages.

Functions are matching if their root ranges have the same span.
The result is normalized.
The input values may be mutated, it is not safe to use them after passing
them to this function.
The computation is synchronous.

@param funcCovs Function coverages to merge.
@return Merged function coverage, or `undefined` if the input list was empty.

## normalizeProcessCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts`

Signature: `normalizeProcessCov(processCov: ProcessCov)`

JSDoc:

Normalizes a process coverage.

Sorts the scripts alphabetically by `url`.
Reassigns script ids: the script at index `0` receives `"0"`, the script at
index `1` receives `"1"` etc.
This does not normalize the script coverages.

@param processCov Process coverage to normalize.

## deepNormalizeProcessCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts`

Signature: `deepNormalizeProcessCov(processCov: ProcessCov)`

JSDoc:

Normalizes a process coverage deeply.

Normalizes the script coverages deeply, then normalizes the process coverage
itself.

@param processCov Process coverage to normalize.

## normalizeScriptCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts`

Signature: `normalizeScriptCov(scriptCov: ScriptCov)`

JSDoc:

Normalizes a script coverage.

Sorts the function by root range (pre-order sort).
This does not normalize the function coverages.

@param scriptCov Script coverage to normalize.

## deepNormalizeScriptCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts`

Signature: `deepNormalizeScriptCov(scriptCov: ScriptCov)`

JSDoc:

Normalizes a script coverage deeply.

Normalizes the function coverages deeply, then normalizes the script coverage
itself.

@param scriptCov Script coverage to normalize.

## normalizeFunctionCov

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts`

Signature: `normalizeFunctionCov(funcCov: FunctionCov)`

JSDoc:

Normalizes a function coverage.

Sorts the ranges (pre-order sort).
TODO: Tree-based normalization of the ranges.

@param funcCov Function coverage to normalize.

## normalizeRangeTree

Source: `my-backend/node_modules/@bcoe/v8-coverage/src/lib/normalize.ts`

Signature: `normalizeRangeTree(tree: RangeTree)`

JSDoc:

@internal

## getPath

Source: `my-backend/node_modules/@jest/expect-utils/build/utils.js`

Signature: `getPath(= getPath;
const getObjectSubset = (
  object,
  subset,
  customTesters = [],
  seenReferences = new WeakMap()`

JSDoc:

Copyright (c) Meta Platforms, Inc. and affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.

/
/**
Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.
/
const hasPropertyInObject = (object, key) => {
  const shouldTerminate =
    !object || typeof object !== 'object' || object === Object.prototype;
  if (shouldTerminate) {
    return false;
  }
  return (
    Object.prototype.hasOwnProperty.call(object, key) ||
    hasPropertyInObject(Object.getPrototypeOf(object), key)
  );
};

// Retrieves an object's keys for evaluation by getObjectSubset.  This evaluates
// the prototype chain for string keys but not for symbols.  (Otherwise, it
// could find values such as a Set or Map's Symbol.toStringTag, with unexpected
// results.)
const getObjectKeys = object => [
  ...Object.keys(object),
  ...Object.getOwnPropertySymbols(object)
];
exports.getObjectKeys = getObjectKeys;
const getPath = (object, propertyPath) => {
  if (!Array.isArray(propertyPath)) {
    propertyPath = pathAsArray(propertyPath);
  }
  if (propertyPath.length) {
    const lastProp = propertyPath.length === 1;
    const prop = propertyPath[0];
    const newObject = object[prop];
    if (!lastProp && (newObject === null || newObject === undefined)) {
      // This is not the last prop in the chain. If we keep recursing it will
      // hit a `can't access property X of undefined | null`. At this point we
      // know that the chain has broken and we can return right away.
      return {
        hasEndProp: false,
        lastTraversedObject: object,
        traversedPath: []
      };
    }
    const result = getPath(newObject, propertyPath.slice(1));
    if (result.lastTraversedObject === null) {
      result.lastTraversedObject = object;
    }
    result.traversedPath.unshift(prop);
    if (lastProp) {
      // Does object have the property with an undefined value?
      // Although primitive values support bracket notation (above)
      // they would throw TypeError for in operator (below).
      result.endPropIsDefined =
        !(0, _jestGetType.isPrimitive)(object) && prop in object;
      result.hasEndProp = newObject !== undefined || result.endPropIsDefined;
      if (!result.hasEndProp) {
        result.traversedPath.shift();
      }
    }
    return result;
  }
  return {
    lastTraversedObject: null,
    traversedPath: [],
    value: object
  };
};

// Strip properties from object that are not present in the subset. Useful for
// printing the diff for toMatchObject() without adding unrelated noise.
/* eslint-disable @typescript-eslint/explicit-module-boundary-types

## addSegment

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts`

Signature: `addSegment(
  map: GenMapping,
  genLine: number,
  genColumn: number,
  source?: null,
  sourceLine?: null,
  sourceColumn?: null,
  name?: null,
  content?: null,
)`

JSDoc:

Provides the state to generate a sourcemap.
/
export class GenMapping {
  declare private _names: SetArray<string>;
  declare private _sources: SetArray<string>;
  declare private _sourcesContent: (string | null)[];
  declare private _mappings: SourceMapSegment[][];
  // private declare _originalScopes: OriginalScope[][];
  // private declare _generatedRanges: GeneratedRange[];
  declare private _ignoreList: SetArray<number>;
  declare file: string | null | undefined;
  declare sourceRoot: string | null | undefined;

  constructor({ file, sourceRoot }: Options = {}) {
    this._names = new SetArray();
    this._sources = new SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    // this._originalScopes = [];
    // this._generatedRanges = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
    this._ignoreList = new SetArray();
  }
}

interface PublicMap {
  _names: GenMapping['_names'];
  _sources: GenMapping['_sources'];
  _sourcesContent: GenMapping['_sourcesContent'];
  _mappings: GenMapping['_mappings'];
  // _originalScopes: GenMapping['_originalScopes'];
  // _generatedRanges: GenMapping['_generatedRanges'];
  _ignoreList: GenMapping['_ignoreList'];
}

/**
Typescript doesn't allow friend access to private fields, so this just casts the map into a type
with public access modifiers.
/
function cast(map: unknown): PublicMap {
  return map as any;
}

/**
A low-level API to associate a generated position with an original source position. Line and
column here are 0-based, unlike `addMapping`.

## addMapping

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts`

Signature: `addMapping(
  map: GenMapping,
  mapping: {
    generated: Pos;
    source?: null;
    original?: null;
    name?: null;
    content?: null;
  },
)`

JSDoc:

A high-level API to associate a generated position with an original source position. Line is
1-based, but column is 0-based, due to legacy behavior in `source-map` library.

## setSourceContent

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts`

Signature: `setSourceContent(map: GenMapping, source: string, content: string | null)`

JSDoc:

Same as `addSegment`, but will only add the segment if it generates useful information in the
resulting map. This only works correctly if segments are added **in order**, meaning you should
not add a segment with a lower generated line/column than one that came before.
/
export const maybeAddSegment: typeof addSegment = (
  map,
  genLine,
  genColumn,
  source,
  sourceLine,
  sourceColumn,
  name,
  content,
) => {
  return addSegmentInternal(
    true,
    map,
    genLine,
    genColumn,
    source,
    sourceLine,
    sourceColumn,
    name,
    content,
  );
};

/**
Same as `addMapping`, but will only add the mapping if it generates useful information in the
resulting map. This only works correctly if mappings are added **in order**, meaning you should
not add a mapping with a lower generated line/column than one that came before.
/
export const maybeAddMapping: typeof addMapping = (map, mapping) => {
  return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);
};

/**
Adds/removes the content of the source file to the source map.

## toDecodedMap

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts`

Signature: `toDecodedMap(map: GenMapping)`

JSDoc:

Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
a sourcemap, or to JSON.stringify.

## toEncodedMap

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts`

Signature: `toEncodedMap(map: GenMapping)`

JSDoc:

Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
a sourcemap, or to JSON.stringify.

## fromMap

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts`

Signature: `fromMap(input: SourceMapInput)`

JSDoc:

Constructs a new GenMapping, using the already present mappings of the input.

## allMappings

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts`

Signature: `allMappings(map: GenMapping)`

JSDoc:

Returns an array of high-level mapping objects for every recorded segment, which could then be
passed to the `source-map` library.

## get

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/set-array.ts`

Signature: `get(<T extends Key>(setarr: SetArray<T>, key: T)`

JSDoc:

SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
index of the `key` in the backing array.

This is designed to allow synchronizing a second array with the contents of the backing array,
like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
and there are never duplicates.
/
export class SetArray<T extends Key = Key> {
  declare private _indexes: Record<T, number | undefined>;
  declare array: readonly T[];

  constructor() {
    this._indexes = { __proto__: null } as any;
    this.array = [];
  }
}

interface PublicSet<T extends Key> {
  array: T[];
  _indexes: SetArray<T>['_indexes'];
}

/**
Typescript doesn't allow friend access to private fields, so this just casts the set into a type
with public access modifiers.
/
function cast<T extends Key>(set: SetArray<T>): PublicSet<T> {
  return set as any;
}

/**
Gets the index associated with `key` in the backing array, if it is already present.

## put

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/set-array.ts`

Signature: `put(<T extends Key>(setarr: SetArray<T>, key: T)`

JSDoc:

Puts `key` into the backing array, if it is not already present. Returns
the index of the `key` in the backing array.

## pop

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/set-array.ts`

Signature: `pop(<T extends Key>(setarr: SetArray<T>)`

JSDoc:

Pops the last added item out of the SetArray.

## remove

Source: `my-backend/node_modules/@jridgewell/gen-mapping/src/set-array.ts`

Signature: `remove(<T extends Key>(setarr: SetArray<T>, key: T)`

JSDoc:

Removes the key, if it exists in the set.

## MapSource

Source: `my-backend/node_modules/@jridgewell/remapping/src/source-map-tree.ts`

Signature: `MapSource(map: TraceMap, sources: Sources[])`

JSDoc:

MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes
(which may themselves be SourceMapTrees).

## OriginalSource

Source: `my-backend/node_modules/@jridgewell/remapping/src/source-map-tree.ts`

Signature: `OriginalSource(
  source: string,
  content: string | null,
  ignore: boolean,
)`

JSDoc:

A "leaf" node in the sourcemap tree, representing an original, unmodified source file. Recursive
segment tracing ends at the `OriginalSource`.

## traceMappings

Source: `my-backend/node_modules/@jridgewell/remapping/src/source-map-tree.ts`

Signature: `traceMappings(tree: MapSource)`

JSDoc:

traceMappings is only called on the root level SourceMapTree, and begins the process of
resolving each mapping in terms of the original source files.

## originalPositionFor

Source: `my-backend/node_modules/@jridgewell/remapping/src/source-map-tree.ts`

Signature: `originalPositionFor(
  source: Sources,
  line: number,
  column: number,
  name: string,
)`

JSDoc:

originalPositionFor is only called on children SourceMapTrees. It recurses down into its own
child SourceMapTrees, until we find the original source map.

## binarySearch

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/binary-search.ts`

Signature: `binarySearch(
  haystack: SourceMapSegment[] | ReverseSegment[],
  needle: number,
  low: number,
  high: number,
)`

JSDoc:

A binary search implementation that returns the index if a match is found.
If no match is found, then the left-index (the index associated with the item that comes just
before the desired index) is returned. To maintain proper sort order, a splice would happen at
the next index:

```js
const array = [1, 3];
const needle = 2;
const index = binarySearch(array, needle, (item, needle) => item - needle);

assert.equal(index, 0);
array.splice(index + 1, 0, needle);
assert.deepEqual(array, [1, 2, 3]);
```

## memoizedBinarySearch

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/binary-search.ts`

Signature: `memoizedBinarySearch(
  haystack: SourceMapSegment[] | ReverseSegment[],
  needle: number,
  state: MemoState,
  key: number,
)`

JSDoc:

This overly complicated beast is just to record the last tested line/column and the resulting
index, allowing us to skip a few tests if mappings are monotonically increasing.

## encodedMappings

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `encodedMappings(map: TraceMap)`

JSDoc:

Typescript doesn't allow friend access to private fields, so this just casts the map into a type
with public access modifiers.
/
function cast(map: unknown): PublicMap {
  return map as any;
}

/**
Returns the encoded (VLQ string) form of the SourceMap's mappings field.

## decodedMappings

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `decodedMappings(map: TraceMap)`

JSDoc:

Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.

## traceSegment

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `traceSegment(
  map: TraceMap,
  line: number,
  column: number,
)`

JSDoc:

A low-level API to find the segment associated with a generated line/column (think, from a
stack trace). Line and column here are 0-based, unlike `originalPositionFor`.

## originalPositionFor

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `originalPositionFor(
  map: TraceMap,
  needle: Needle,
)`

JSDoc:

A higher-level API to find the source/line/column associated with a generated line/column
(think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
`source-map` library.

## generatedPositionFor

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `generatedPositionFor(
  map: TraceMap,
  needle: SourceNeedle,
)`

JSDoc:

Finds the generated line/column position of the provided source/line/column source position.

## allGeneratedPositionsFor

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `allGeneratedPositionsFor(map: TraceMap, needle: SourceNeedle)`

JSDoc:

Finds all generated line/column positions of the provided source/line/column source position.

## eachMapping

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `eachMapping(map: TraceMap, cb: (mapping: EachMapping)`

JSDoc:

Iterates each mapping in generated position order.

## sourceContentFor

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `sourceContentFor(map: TraceMap, source: string)`

JSDoc:

Retrieves the source content for a particular source, if its found. Returns null if not.

## isIgnored

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `isIgnored(map: TraceMap, source: string)`

JSDoc:

Determines if the source is marked to ignore by the source map.

## presortedDecodedMap

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `presortedDecodedMap(map: DecodedSourceMap, mapUrl?: string)`

JSDoc:

A helper that skips sorting of the input map's mappings array, which can be expensive for larger
maps.

## decodedMap

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `decodedMap(
  map: TraceMap,
)`

JSDoc:

Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
a sourcemap, or to JSON.stringify.

## encodedMap

Source: `my-backend/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts`

Signature: `encodedMap(map: TraceMap)`

JSDoc:

Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
a sourcemap, or to JSON.stringify.

## abytes

Source: `my-backend/node_modules/@noble/hashes/_assert.js`

Signature: `abytes(= utils_ts_1.abytes;
/** @deprecated Use import from `noble/hashes/utils` module */
exports.aexists = utils_ts_1.aexists;
/** @deprecated Use import from `noble/hashes/utils` module */
exports.anumber = utils_ts_1.anumber;
/** @deprecated Use import from `noble/hashes/utils` module */
exports.aoutput = utils_ts_1.aoutput;
//# sourceMappingURL=_assert.js.map)`

JSDoc:

Internal assertion helpers.
@module
@deprecated
/
const utils_ts_1 = require("./utils.js");
/** @deprecated Use import from `noble/hashes/utils` module

## SHA256_IV

Source: `my-backend/node_modules/@noble/hashes/_md.js`

Signature: `SHA256_IV(= Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
])`

JSDoc:

Internal Merkle-Damgard hash utils.
@module
/
const utils_ts_1 = require("./utils.js");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
    return (a & b) ^ (~a & c);
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
    return (a & b) ^ (a & c) ^ (b & c);
}
/**
Merkle-Damgard hash construction base class.
Could be used to create MD5, RIPEMD, SHA1, SHA2.
/
class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
/
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19

## SHA224_IV

Source: `my-backend/node_modules/@noble/hashes/_md.js`

Signature: `SHA224_IV(= Uint32Array.from([
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
])`

JSDoc:

Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53

## SHA384_IV

Source: `my-backend/node_modules/@noble/hashes/_md.js`

Signature: `SHA384_IV(= Uint32Array.from([
    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,
])`

JSDoc:

Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53

## SHA512_IV

Source: `my-backend/node_modules/@noble/hashes/_md.js`

Signature: `SHA512_IV(= Uint32Array.from([
    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,
])`

JSDoc:

Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19

## blake224

Source: `my-backend/node_modules/@noble/hashes/blake1.js`

Signature: `blake224(= (0, utils_ts_1.createOptHasher)`

JSDoc:

Blake1 legacy hash function, one of SHA3 proposals.
Rarely used. Check out blake2 or blake3 instead.
https://www.aumasson.jp/blake/blake.pdf

In the best case, there are 0 allocations.

Differences from blake2:

- BE instead of LE
- Paddings, similar to MD5, RIPEMD, SHA1, SHA2, but:
    - length flag is located before actual length
    - padding block is compressed differently (no lengths)
Instead of msg[sigma[k]], we have `msg[sigma[k]] ^ constants[sigma[k-1]]`
(-1 for g1, g2 without -1)
- Salt is XOR-ed into constants instead of state
- Salt is XOR-ed with output in `compress`
- Additional rows (+64 bytes) in SIGMA for new rounds
- Different round count:
    - 14 / 10 rounds in blake256 / blake2s
    - 16 / 12 rounds in blake512 / blake2b
- blake512: G1b: rotr 24 -> 25, G2b: rotr 63 -> 11
@module
/
const _blake_ts_1 = require("./_blake.js");
const _md_ts_1 = require("./_md.js");
const u64 = require("./_u64.js");
// prettier-ignore
const utils_ts_1 = require("./utils.js");
// Empty zero-filled salt
const EMPTY_SALT = /* @__PURE__ */ new Uint32Array(8);
class BLAKE1 extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, lengthFlag, counterLen, saltLen, constants, opts = {}) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        const { salt } = opts;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.lengthFlag = lengthFlag;
        this.counterLen = counterLen;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
        if (salt) {
            let slt = salt;
            slt = (0, utils_ts_1.toBytes)(slt);
            (0, utils_ts_1.abytes)(slt);
            if (slt.length !== 4 * saltLen)
                throw new Error('wrong salt length');
            const salt32 = (this.salt = new Uint32Array(saltLen));
            const sv = (0, utils_ts_1.createView)(slt);
            this.constants = constants.slice();
            for (let i = 0, offset = 0; i < salt32.length; i++, offset += 4) {
                salt32[i] = sv.getUint32(offset, false);
                this.constants[i] ^= salt32[i];
            }
        }
        else {
            this.salt = EMPTY_SALT;
            this.constants = constants;
        }
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        // From _md, but update length before each compress
        const { view, buffer, blockLen } = this;
        const len = data.length;
        let dataView;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                if (!dataView)
                    dataView = (0, utils_ts_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen) {
                    this.length += blockLen;
                    this.compress(dataView, pos);
                }
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.length += blockLen;
                this.compress(view, 0, true);
                this.pos = 0;
            }
        }
        return this;
    }
    destroy() {
        this.destroyed = true;
        if (this.salt !== EMPTY_SALT) {
            (0, utils_ts_1.clean)(this.salt, this.constants);
        }
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { buffer, length, finished, destroyed, constants, salt, pos } = this;
        to.buffer.set(buffer);
        to.constants = constants.slice();
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        to.salt = salt.slice();
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        const { buffer, blockLen, counterLen, lengthFlag, view } = this;
        (0, utils_ts_1.clean)(buffer.subarray(this.pos)); // clean buf
        const counter = BigInt((this.length + this.pos) * 8);
        const counterPos = blockLen - counterLen - 1;
        buffer[this.pos] |= 128; // End block flag
        this.length += this.pos; // add unwritten length
        // Not enough in buffer for length: write what we have.
        if (this.pos > counterPos) {
            this.compress(view, 0);
            (0, utils_ts_1.clean)(buffer);
            this.pos = 0;
        }
        // Difference with md: here we have lengthFlag!
        buffer[counterPos] |= lengthFlag; // Length flag
        // We always set 8 byte length flag. Because length will overflow significantly sooner.
        (0, _md_ts_1.setBigUint64)(view, blockLen - 8, counter, false);
        this.compress(view, 0, this.pos !== 0); // don't add length if length is not empty block?
        // Write output
        (0, utils_ts_1.clean)(buffer);
        const v = (0, utils_ts_1.createView)(out);
        const state = this.get();
        for (let i = 0; i < this.outputLen / 4; ++i)
            v.setUint32(i * 4, state[i]);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
}
// Constants
const B64C = /* @__PURE__ */ Uint32Array.from([
    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
    0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
    0x9216d5d9, 0x8979fb1b, 0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96,
    0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69,
]);
// first half of C512
const B32C = B64C.slice(0, 16);
const B256_IV = _md_ts_1.SHA256_IV.slice();
const B224_IV = _md_ts_1.SHA224_IV.slice();
const B384_IV = _md_ts_1.SHA384_IV.slice();
const B512_IV = _md_ts_1.SHA512_IV.slice();
function generateTBL256() {
    const TBL = [];
    for (let i = 0, j = 0; i < 14; i++, j += 16) {
        for (let offset = 1; offset < 16; offset += 2) {
            TBL.push(B32C[_blake_ts_1.BSIGMA[j + offset]]);
            TBL.push(B32C[_blake_ts_1.BSIGMA[j + offset - 1]]);
        }
    }
    return new Uint32Array(TBL);
}
const TBL256 = /* @__PURE__ */ generateTBL256(); // C256[SIGMA[X]] precompute
// Reusable temporary buffer
const BLAKE256_W = /* @__PURE__ */ new Uint32Array(16);
class Blake1_32 extends BLAKE1 {
    constructor(outputLen, IV, lengthFlag, opts = {}) {
        super(64, outputLen, lengthFlag, 8, 4, B32C, opts);
        this.v0 = IV[0] | 0;
        this.v1 = IV[1] | 0;
        this.v2 = IV[2] | 0;
        this.v3 = IV[3] | 0;
        this.v4 = IV[4] | 0;
        this.v5 = IV[5] | 0;
        this.v6 = IV[6] | 0;
        this.v7 = IV[7] | 0;
    }
    get() {
        const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;
        return [v0, v1, v2, v3, v4, v5, v6, v7];
    }
    // prettier-ignore
    set(v0, v1, v2, v3, v4, v5, v6, v7) {
        this.v0 = v0 | 0;
        this.v1 = v1 | 0;
        this.v2 = v2 | 0;
        this.v3 = v3 | 0;
        this.v4 = v4 | 0;
        this.v5 = v5 | 0;
        this.v6 = v6 | 0;
        this.v7 = v7 | 0;
    }
    destroy() {
        super.destroy();
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
    }
    compress(view, offset, withLength = true) {
        for (let i = 0; i < 16; i++, offset += 4)
            BLAKE256_W[i] = view.getUint32(offset, false);
        // NOTE: we cannot re-use compress from blake2s, since there is additional xor over u256[SIGMA[e]]
        let v00 = this.v0 | 0;
        let v01 = this.v1 | 0;
        let v02 = this.v2 | 0;
        let v03 = this.v3 | 0;
        let v04 = this.v4 | 0;
        let v05 = this.v5 | 0;
        let v06 = this.v6 | 0;
        let v07 = this.v7 | 0;
        let v08 = this.constants[0] | 0;
        let v09 = this.constants[1] | 0;
        let v10 = this.constants[2] | 0;
        let v11 = this.constants[3] | 0;
        const { h, l } = u64.fromBig(BigInt(withLength ? this.length * 8 : 0));
        let v12 = (this.constants[4] ^ l) >>> 0;
        let v13 = (this.constants[5] ^ l) >>> 0;
        let v14 = (this.constants[6] ^ h) >>> 0;
        let v15 = (this.constants[7] ^ h) >>> 0;
        // prettier-ignore
        for (let i = 0, k = 0, j = 0; i < 14; i++) {
            ({ a: v00, b: v04, c: v08, d: v12 } = (0, _blake_ts_1.G1s)(v00, v04, v08, v12, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v00, b: v04, c: v08, d: v12 } = (0, _blake_ts_1.G2s)(v00, v04, v08, v12, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v01, b: v05, c: v09, d: v13 } = (0, _blake_ts_1.G1s)(v01, v05, v09, v13, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v01, b: v05, c: v09, d: v13 } = (0, _blake_ts_1.G2s)(v01, v05, v09, v13, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v02, b: v06, c: v10, d: v14 } = (0, _blake_ts_1.G1s)(v02, v06, v10, v14, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v02, b: v06, c: v10, d: v14 } = (0, _blake_ts_1.G2s)(v02, v06, v10, v14, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v03, b: v07, c: v11, d: v15 } = (0, _blake_ts_1.G1s)(v03, v07, v11, v15, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v03, b: v07, c: v11, d: v15 } = (0, _blake_ts_1.G2s)(v03, v07, v11, v15, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v00, b: v05, c: v10, d: v15 } = (0, _blake_ts_1.G1s)(v00, v05, v10, v15, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v00, b: v05, c: v10, d: v15 } = (0, _blake_ts_1.G2s)(v00, v05, v10, v15, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v01, b: v06, c: v11, d: v12 } = (0, _blake_ts_1.G1s)(v01, v06, v11, v12, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v01, b: v06, c: v11, d: v12 } = (0, _blake_ts_1.G2s)(v01, v06, v11, v12, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v02, b: v07, c: v08, d: v13 } = (0, _blake_ts_1.G1s)(v02, v07, v08, v13, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v02, b: v07, c: v08, d: v13 } = (0, _blake_ts_1.G2s)(v02, v07, v08, v13, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v03, b: v04, c: v09, d: v14 } = (0, _blake_ts_1.G1s)(v03, v04, v09, v14, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
            ({ a: v03, b: v04, c: v09, d: v14 } = (0, _blake_ts_1.G2s)(v03, v04, v09, v14, BLAKE256_W[_blake_ts_1.BSIGMA[k++]] ^ TBL256[j++]));
        }
        this.v0 = (this.v0 ^ v00 ^ v08 ^ this.salt[0]) >>> 0;
        this.v1 = (this.v1 ^ v01 ^ v09 ^ this.salt[1]) >>> 0;
        this.v2 = (this.v2 ^ v02 ^ v10 ^ this.salt[2]) >>> 0;
        this.v3 = (this.v3 ^ v03 ^ v11 ^ this.salt[3]) >>> 0;
        this.v4 = (this.v4 ^ v04 ^ v12 ^ this.salt[0]) >>> 0;
        this.v5 = (this.v5 ^ v05 ^ v13 ^ this.salt[1]) >>> 0;
        this.v6 = (this.v6 ^ v06 ^ v14 ^ this.salt[2]) >>> 0;
        this.v7 = (this.v7 ^ v07 ^ v15 ^ this.salt[3]) >>> 0;
        (0, utils_ts_1.clean)(BLAKE256_W);
    }
}
const BBUF = /* @__PURE__ */ new Uint32Array(32);
const BLAKE512_W = /* @__PURE__ */ new Uint32Array(32);
function generateTBL512() {
    const TBL = [];
    for (let r = 0, k = 0; r < 16; r++, k += 16) {
        for (let offset = 1; offset < 16; offset += 2) {
            TBL.push(B64C[_blake_ts_1.BSIGMA[k + offset] * 2 + 0]);
            TBL.push(B64C[_blake_ts_1.BSIGMA[k + offset] * 2 + 1]);
            TBL.push(B64C[_blake_ts_1.BSIGMA[k + offset - 1] * 2 + 0]);
            TBL.push(B64C[_blake_ts_1.BSIGMA[k + offset - 1] * 2 + 1]);
        }
    }
    return new Uint32Array(TBL);
}
const TBL512 = /* @__PURE__ */ generateTBL512(); // C512[SIGMA[X]] precompute
// Mixing function G splitted in two halfs
function G1b(a, b, c, d, msg, k) {
    const Xpos = 2 * _blake_ts_1.BSIGMA[k];
    const Xl = msg[Xpos + 1] ^ TBL512[k * 2 + 1], Xh = msg[Xpos] ^ TBL512[k * 2]; // prettier-ignore
    let Al = BBUF[2 * a + 1], Ah = BBUF[2 * a]; // prettier-ignore
    let Bl = BBUF[2 * b + 1], Bh = BBUF[2 * b]; // prettier-ignore
    let Cl = BBUF[2 * c + 1], Ch = BBUF[2 * c]; // prettier-ignore
    let Dl = BBUF[2 * d + 1], Dh = BBUF[2 * d]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = u64.add3L(Al, Bl, Xl);
    Ah = u64.add3H(ll, Ah, Bh, Xh) >>> 0;
    Al = (ll | 0) >>> 0;
    // v[d] = rotr(v[d] ^ v[a], 32)
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });
    // v[c] = (v[c] + v[d]) | 0;
    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));
    // v[b] = rotr(v[b] ^ v[c], 25)
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 25), Bl: u64.rotrSL(Bh, Bl, 25) });
    (BBUF[2 * a + 1] = Al), (BBUF[2 * a] = Ah);
    (BBUF[2 * b + 1] = Bl), (BBUF[2 * b] = Bh);
    (BBUF[2 * c + 1] = Cl), (BBUF[2 * c] = Ch);
    (BBUF[2 * d + 1] = Dl), (BBUF[2 * d] = Dh);
}
function G2b(a, b, c, d, msg, k) {
    const Xpos = 2 * _blake_ts_1.BSIGMA[k];
    const Xl = msg[Xpos + 1] ^ TBL512[k * 2 + 1], Xh = msg[Xpos] ^ TBL512[k * 2]; // prettier-ignore
    let Al = BBUF[2 * a + 1], Ah = BBUF[2 * a]; // prettier-ignore
    let Bl = BBUF[2 * b + 1], Bh = BBUF[2 * b]; // prettier-ignore
    let Cl = BBUF[2 * c + 1], Ch = BBUF[2 * c]; // prettier-ignore
    let Dl = BBUF[2 * d + 1], Dh = BBUF[2 * d]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = u64.add3L(Al, Bl, Xl);
    Ah = u64.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    // v[d] = rotr(v[d] ^ v[a], 16)
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });
    // v[c] = (v[c] + v[d]) | 0;
    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));
    // v[b] = rotr(v[b] ^ v[c], 11)
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 11), Bl: u64.rotrSL(Bh, Bl, 11) });
    (BBUF[2 * a + 1] = Al), (BBUF[2 * a] = Ah);
    (BBUF[2 * b + 1] = Bl), (BBUF[2 * b] = Bh);
    (BBUF[2 * c + 1] = Cl), (BBUF[2 * c] = Ch);
    (BBUF[2 * d + 1] = Dl), (BBUF[2 * d] = Dh);
}
class Blake1_64 extends BLAKE1 {
    constructor(outputLen, IV, lengthFlag, opts = {}) {
        super(128, outputLen, lengthFlag, 16, 8, B64C, opts);
        this.v0l = IV[0] | 0;
        this.v0h = IV[1] | 0;
        this.v1l = IV[2] | 0;
        this.v1h = IV[3] | 0;
        this.v2l = IV[4] | 0;
        this.v2h = IV[5] | 0;
        this.v3l = IV[6] | 0;
        this.v3h = IV[7] | 0;
        this.v4l = IV[8] | 0;
        this.v4h = IV[9] | 0;
        this.v5l = IV[10] | 0;
        this.v5h = IV[11] | 0;
        this.v6l = IV[12] | 0;
        this.v6h = IV[13] | 0;
        this.v7l = IV[14] | 0;
        this.v7h = IV[15] | 0;
    }
    // prettier-ignore
    get() {
        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
    }
    // prettier-ignore
    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
        this.v0l = v0l | 0;
        this.v0h = v0h | 0;
        this.v1l = v1l | 0;
        this.v1h = v1h | 0;
        this.v2l = v2l | 0;
        this.v2h = v2h | 0;
        this.v3l = v3l | 0;
        this.v3h = v3h | 0;
        this.v4l = v4l | 0;
        this.v4h = v4h | 0;
        this.v5l = v5l | 0;
        this.v5h = v5h | 0;
        this.v6l = v6l | 0;
        this.v6h = v6h | 0;
        this.v7l = v7l | 0;
        this.v7h = v7h | 0;
    }
    destroy() {
        super.destroy();
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    compress(view, offset, withLength = true) {
        for (let i = 0; i < 32; i++, offset += 4)
            BLAKE512_W[i] = view.getUint32(offset, false);
        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.
        BBUF.set(this.constants.subarray(0, 16), 16);
        if (withLength) {
            const { h, l } = u64.fromBig(BigInt(this.length * 8));
            BBUF[24] = (BBUF[24] ^ h) >>> 0;
            BBUF[25] = (BBUF[25] ^ l) >>> 0;
            BBUF[26] = (BBUF[26] ^ h) >>> 0;
            BBUF[27] = (BBUF[27] ^ l) >>> 0;
        }
        for (let i = 0, k = 0; i < 16; i++) {
            G1b(0, 4, 8, 12, BLAKE512_W, k++);
            G2b(0, 4, 8, 12, BLAKE512_W, k++);
            G1b(1, 5, 9, 13, BLAKE512_W, k++);
            G2b(1, 5, 9, 13, BLAKE512_W, k++);
            G1b(2, 6, 10, 14, BLAKE512_W, k++);
            G2b(2, 6, 10, 14, BLAKE512_W, k++);
            G1b(3, 7, 11, 15, BLAKE512_W, k++);
            G2b(3, 7, 11, 15, BLAKE512_W, k++);
            G1b(0, 5, 10, 15, BLAKE512_W, k++);
            G2b(0, 5, 10, 15, BLAKE512_W, k++);
            G1b(1, 6, 11, 12, BLAKE512_W, k++);
            G2b(1, 6, 11, 12, BLAKE512_W, k++);
            G1b(2, 7, 8, 13, BLAKE512_W, k++);
            G2b(2, 7, 8, 13, BLAKE512_W, k++);
            G1b(3, 4, 9, 14, BLAKE512_W, k++);
            G2b(3, 4, 9, 14, BLAKE512_W, k++);
        }
        this.v0l ^= BBUF[0] ^ BBUF[16] ^ this.salt[0];
        this.v0h ^= BBUF[1] ^ BBUF[17] ^ this.salt[1];
        this.v1l ^= BBUF[2] ^ BBUF[18] ^ this.salt[2];
        this.v1h ^= BBUF[3] ^ BBUF[19] ^ this.salt[3];
        this.v2l ^= BBUF[4] ^ BBUF[20] ^ this.salt[4];
        this.v2h ^= BBUF[5] ^ BBUF[21] ^ this.salt[5];
        this.v3l ^= BBUF[6] ^ BBUF[22] ^ this.salt[6];
        this.v3h ^= BBUF[7] ^ BBUF[23] ^ this.salt[7];
        this.v4l ^= BBUF[8] ^ BBUF[24] ^ this.salt[0];
        this.v4h ^= BBUF[9] ^ BBUF[25] ^ this.salt[1];
        this.v5l ^= BBUF[10] ^ BBUF[26] ^ this.salt[2];
        this.v5h ^= BBUF[11] ^ BBUF[27] ^ this.salt[3];
        this.v6l ^= BBUF[12] ^ BBUF[28] ^ this.salt[4];
        this.v6h ^= BBUF[13] ^ BBUF[29] ^ this.salt[5];
        this.v7l ^= BBUF[14] ^ BBUF[30] ^ this.salt[6];
        this.v7h ^= BBUF[15] ^ BBUF[31] ^ this.salt[7];
        (0, utils_ts_1.clean)(BBUF, BLAKE512_W);
    }
}
class BLAKE224 extends Blake1_32 {
    constructor(opts = {}) {
        super(28, B224_IV, 0, opts);
    }
}
exports.BLAKE224 = BLAKE224;
class BLAKE256 extends Blake1_32 {
    constructor(opts = {}) {
        super(32, B256_IV, 1, opts);
    }
}
exports.BLAKE256 = BLAKE256;
class BLAKE384 extends Blake1_64 {
    constructor(opts = {}) {
        super(48, B384_IV, 0, opts);
    }
}
exports.BLAKE384 = BLAKE384;
class BLAKE512 extends Blake1_64 {
    constructor(opts = {}) {
        super(64, B512_IV, 1, opts);
    }
}
exports.BLAKE512 = BLAKE512;
/** blake1-224 hash function

## blake256

Source: `my-backend/node_modules/@noble/hashes/blake1.js`

Signature: `blake256(= (0, utils_ts_1.createOptHasher)`

JSDoc:

blake1-256 hash function

## blake384

Source: `my-backend/node_modules/@noble/hashes/blake1.js`

Signature: `blake384(= (0, utils_ts_1.createOptHasher)`

JSDoc:

blake1-384 hash function

## blake512

Source: `my-backend/node_modules/@noble/hashes/blake1.js`

Signature: `blake512(= (0, utils_ts_1.createOptHasher)`

JSDoc:

blake1-512 hash function

## blake2b

Source: `my-backend/node_modules/@noble/hashes/blake2.js`

Signature: `blake2b(= (0, utils_ts_1.createOptHasher)`

JSDoc:

blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.
b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.
@module
/
const _blake_ts_1 = require("./_blake.js");
const _md_ts_1 = require("./_md.js");
const u64 = require("./_u64.js");
// prettier-ignore
const utils_ts_1 = require("./utils.js");
// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.
const B2B_IV = /* @__PURE__ */ Uint32Array.from([
    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,
    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19,
]);
// Temporary buffer
const BBUF = /* @__PURE__ */ new Uint32Array(32);
// Mixing function G splitted in two halfs
function G1b(a, b, c, d, msg, x) {
    // NOTE: V is LE here
    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore
    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore
    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore
    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore
    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = u64.add3L(Al, Bl, Xl);
    Ah = u64.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    // v[d] = rotr(v[d] ^ v[a], 32)
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });
    // v[c] = (v[c] + v[d]) | 0;
    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));
    // v[b] = rotr(v[b] ^ v[c], 24)
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });
    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);
    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);
    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);
    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);
}
function G2b(a, b, c, d, msg, x) {
    // NOTE: V is LE here
    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore
    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore
    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore
    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore
    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore
    // v[a] = (v[a] + v[b] + x) | 0;
    let ll = u64.add3L(Al, Bl, Xl);
    Ah = u64.add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    // v[d] = rotr(v[d] ^ v[a], 16)
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });
    // v[c] = (v[c] + v[d]) | 0;
    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));
    // v[b] = rotr(v[b] ^ v[c], 63)
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });
    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);
    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);
    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);
    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
    (0, utils_ts_1.anumber)(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
        throw new Error('outputLen bigger than keyLen');
    const { key, salt, personalization } = opts;
    if (key !== undefined && (key.length < 1 || key.length > keyLen))
        throw new Error('key length must be undefined or 1..' + keyLen);
    if (salt !== undefined && salt.length !== saltLen)
        throw new Error('salt must be undefined or ' + saltLen);
    if (personalization !== undefined && personalization.length !== persLen)
        throw new Error('personalization must be undefined or ' + persLen);
}
/** Class, from which others are subclassed. */
class BLAKE2 extends utils_ts_1.Hash {
    constructor(blockLen, outputLen) {
        super();
        this.finished = false;
        this.destroyed = false;
        this.length = 0;
        this.pos = 0;
        (0, utils_ts_1.anumber)(blockLen);
        (0, utils_ts_1.anumber)(outputLen);
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.buffer = new Uint8Array(blockLen);
        this.buffer32 = (0, utils_ts_1.u32)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        // Main difference with other hashes: there is flag for last block,
        // so we cannot process current block before we know that there
        // is the next one. This significantly complicates logic and reduces ability
        // to do zero-copy processing
        const { blockLen, buffer, buffer32 } = this;
        const len = data.length;
        const offset = data.byteOffset;
        const buf = data.buffer;
        for (let pos = 0; pos < len;) {
            // If buffer is full and we still have input (don't process last block, same as blake2s)
            if (this.pos === blockLen) {
                (0, utils_ts_1.swap32IfBE)(buffer32);
                this.compress(buffer32, 0, false);
                (0, utils_ts_1.swap32IfBE)(buffer32);
                this.pos = 0;
            }
            const take = Math.min(blockLen - this.pos, len - pos);
            const dataOffset = offset + pos;
            // full block && aligned to 4 bytes && not last in input
            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
                const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
                (0, utils_ts_1.swap32IfBE)(data32);
                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
                    this.length += blockLen;
                    this.compress(data32, pos32, false);
                }
                (0, utils_ts_1.swap32IfBE)(data32);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            this.length += take;
            pos += take;
        }
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        const { pos, buffer32 } = this;
        this.finished = true;
        // Padding
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        (0, utils_ts_1.swap32IfBE)(buffer32);
        this.compress(buffer32, 0, true);
        (0, utils_ts_1.swap32IfBE)(buffer32);
        const out32 = (0, utils_ts_1.u32)(out);
        this.get().forEach((v, i) => (out32[i] = (0, utils_ts_1.swap8IfBE)(v)));
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        const { buffer, length, finished, destroyed, outputLen, pos } = this;
        to || (to = new this.constructor({ dkLen: outputLen }));
        to.set(...this.get());
        to.buffer.set(buffer);
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        // @ts-ignore
        to.outputLen = outputLen;
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.BLAKE2 = BLAKE2;
class BLAKE2b extends BLAKE2 {
    constructor(opts = {}) {
        const olen = opts.dkLen === undefined ? 64 : opts.dkLen;
        super(128, olen);
        // Same as SHA-512, but LE
        this.v0l = B2B_IV[0] | 0;
        this.v0h = B2B_IV[1] | 0;
        this.v1l = B2B_IV[2] | 0;
        this.v1h = B2B_IV[3] | 0;
        this.v2l = B2B_IV[4] | 0;
        this.v2h = B2B_IV[5] | 0;
        this.v3l = B2B_IV[6] | 0;
        this.v3h = B2B_IV[7] | 0;
        this.v4l = B2B_IV[8] | 0;
        this.v4h = B2B_IV[9] | 0;
        this.v5l = B2B_IV[10] | 0;
        this.v5h = B2B_IV[11] | 0;
        this.v6l = B2B_IV[12] | 0;
        this.v6h = B2B_IV[13] | 0;
        this.v7l = B2B_IV[14] | 0;
        this.v7h = B2B_IV[15] | 0;
        checkBlake2Opts(olen, opts, 64, 16, 16);
        let { key, personalization, salt } = opts;
        let keyLength = 0;
        if (key !== undefined) {
            key = (0, utils_ts_1.toBytes)(key);
            keyLength = key.length;
        }
        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);
        if (salt !== undefined) {
            salt = (0, utils_ts_1.toBytes)(salt);
            const slt = (0, utils_ts_1.u32)(salt);
            this.v4l ^= (0, utils_ts_1.swap8IfBE)(slt[0]);
            this.v4h ^= (0, utils_ts_1.swap8IfBE)(slt[1]);
            this.v5l ^= (0, utils_ts_1.swap8IfBE)(slt[2]);
            this.v5h ^= (0, utils_ts_1.swap8IfBE)(slt[3]);
        }
        if (personalization !== undefined) {
            personalization = (0, utils_ts_1.toBytes)(personalization);
            const pers = (0, utils_ts_1.u32)(personalization);
            this.v6l ^= (0, utils_ts_1.swap8IfBE)(pers[0]);
            this.v6h ^= (0, utils_ts_1.swap8IfBE)(pers[1]);
            this.v7l ^= (0, utils_ts_1.swap8IfBE)(pers[2]);
            this.v7h ^= (0, utils_ts_1.swap8IfBE)(pers[3]);
        }
        if (key !== undefined) {
            // Pad to blockLen and update
            const tmp = new Uint8Array(this.blockLen);
            tmp.set(key);
            this.update(tmp);
        }
    }
    // prettier-ignore
    get() {
        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
    }
    // prettier-ignore
    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
        this.v0l = v0l | 0;
        this.v0h = v0h | 0;
        this.v1l = v1l | 0;
        this.v1h = v1h | 0;
        this.v2l = v2l | 0;
        this.v2h = v2h | 0;
        this.v3l = v3l | 0;
        this.v3h = v3h | 0;
        this.v4l = v4l | 0;
        this.v4h = v4h | 0;
        this.v5l = v5l | 0;
        this.v5h = v5h | 0;
        this.v6l = v6l | 0;
        this.v6h = v6h | 0;
        this.v7l = v7l | 0;
        this.v7h = v7h | 0;
    }
    compress(msg, offset, isLast) {
        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.
        BBUF.set(B2B_IV, 16); // Second half from IV.
        let { h, l } = u64.fromBig(BigInt(this.length));
        BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.
        BBUF[25] = B2B_IV[9] ^ h; // High word.
        // Invert all bits for last block
        if (isLast) {
            BBUF[28] = ~BBUF[28];
            BBUF[29] = ~BBUF[29];
        }
        let j = 0;
        const s = _blake_ts_1.BSIGMA;
        for (let i = 0; i < 12; i++) {
            G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
            G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
            G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
            G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
            G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
            G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
            G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
            G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
            G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
            G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
            G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
            G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
            G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
            G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
            G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
            G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
        }
        this.v0l ^= BBUF[0] ^ BBUF[16];
        this.v0h ^= BBUF[1] ^ BBUF[17];
        this.v1l ^= BBUF[2] ^ BBUF[18];
        this.v1h ^= BBUF[3] ^ BBUF[19];
        this.v2l ^= BBUF[4] ^ BBUF[20];
        this.v2h ^= BBUF[5] ^ BBUF[21];
        this.v3l ^= BBUF[6] ^ BBUF[22];
        this.v3h ^= BBUF[7] ^ BBUF[23];
        this.v4l ^= BBUF[8] ^ BBUF[24];
        this.v4h ^= BBUF[9] ^ BBUF[25];
        this.v5l ^= BBUF[10] ^ BBUF[26];
        this.v5h ^= BBUF[11] ^ BBUF[27];
        this.v6l ^= BBUF[12] ^ BBUF[28];
        this.v6h ^= BBUF[13] ^ BBUF[29];
        this.v7l ^= BBUF[14] ^ BBUF[30];
        this.v7h ^= BBUF[15] ^ BBUF[31];
        (0, utils_ts_1.clean)(BBUF);
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer32);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.BLAKE2b = BLAKE2b;
/**
Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.
@param msg - message that would be hashed
@param opts - dkLen output length, key for MAC mode, salt, personalization

## blake2s

Source: `my-backend/node_modules/@noble/hashes/blake2.js`

Signature: `blake2s(= (0, utils_ts_1.createOptHasher)`

JSDoc:

Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.
@param msg - message that would be hashed
@param opts - dkLen output length, key for MAC mode, salt, personalization

## BLAKE2b

Source: `my-backend/node_modules/@noble/hashes/blake2b.js`

Signature: `BLAKE2b(= blake2_ts_1.BLAKE2b;
/** @deprecated Use import from `noble/hashes/blake2` module */
exports.blake2b = blake2_ts_1.blake2b;
//# sourceMappingURL=blake2b.js.map)`

JSDoc:

Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.
@module
@deprecated
/
const blake2_ts_1 = require("./blake2.js");
/** @deprecated Use import from `noble/hashes/blake2` module

## B2S_IV

Source: `my-backend/node_modules/@noble/hashes/blake2s.js`

Signature: `B2S_IV(= _md_ts_1.SHA256_IV;
/** @deprecated Use import from `noble/hashes/blake2` module */
exports.G1s = _blake_ts_1.G1s;
/** @deprecated Use import from `noble/hashes/blake2` module */
exports.G2s = _blake_ts_1.G2s;
/** @deprecated Use import from `noble/hashes/blake2` module */
exports.compress = blake2_ts_1.compress;
/** @deprecated Use import from `noble/hashes/blake2` module */
exports.BLAKE2s = blake2_ts_1.BLAKE2s;
/** @deprecated Use import from `noble/hashes/blake2` module */
exports.blake2s = blake2_ts_1.blake2s;
//# sourceMappingURL=blake2s.js.map)`

JSDoc:

Blake2s hash function. Focuses on 8-bit to 32-bit platforms. blake2b for 64-bit, but in JS it is slower.
@module
@deprecated
/
const _blake_ts_1 = require("./_blake.js");
const _md_ts_1 = require("./_md.js");
const blake2_ts_1 = require("./blake2.js");
/** @deprecated Use import from `noble/hashes/blake2` module

## blake3

Source: `my-backend/node_modules/@noble/hashes/blake3.js`

Signature: `blake3(= (0, utils_ts_1.createXOFer)`

JSDoc:

Blake3 fast hash is Blake2 with reduced security (round count). Can also be used as MAC & KDF.

It is advertised as "the fastest cryptographic hash". However, it isn't true in JS.
Why is this so slow? While it should be 6x faster than blake2b, perf diff is only 20%:

* There is only 30% reduction in number of rounds from blake2s
* Speed-up comes from tree structure, which is parallelized using SIMD & threading.
  These features are not present in JS, so we only get overhead from trees.
* Parallelization only happens on 1024-byte chunks: there is no benefit for small inputs.
* It is still possible to make it faster using: a) loop unrolling b) web workers c) wasm
@module
/
const _md_ts_1 = require("./_md.js");
const _u64_ts_1 = require("./_u64.js");
const blake2_ts_1 = require("./blake2.js");
// prettier-ignore
const utils_ts_1 = require("./utils.js");
// Flag bitset
const B3_Flags = {
    CHUNK_START: 0b1,
    CHUNK_END: 0b10,
    PARENT: 0b100,
    ROOT: 0b1000,
    KEYED_HASH: 0b10000,
    DERIVE_KEY_CONTEXT: 0b100000,
    DERIVE_KEY_MATERIAL: 0b1000000,
};
const B3_IV = _md_ts_1.SHA256_IV.slice();
const B3_SIGMA = /* @__PURE__ */ (() => {
    const Id = Array.from({ length: 16 }, (_, i) => i);
    const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);
    const res = [];
    for (let i = 0, v = Id; i < 7; i++, v = permute(v))
        res.push(...v);
    return Uint8Array.from(res);
})();
/** Blake3 hash. Can be used as MAC and KDF. */
class BLAKE3 extends blake2_ts_1.BLAKE2 {
    constructor(opts = {}, flags = 0) {
        super(64, opts.dkLen === undefined ? 32 : opts.dkLen);
        this.chunkPos = 0; // Position of current block in chunk
        this.chunksDone = 0; // How many chunks we already have
        this.flags = 0 | 0;
        this.stack = [];
        // Output
        this.posOut = 0;
        this.bufferOut32 = new Uint32Array(16);
        this.chunkOut = 0; // index of output chunk
        this.enableXOF = true;
        const { key, context } = opts;
        const hasContext = context !== undefined;
        if (key !== undefined) {
            if (hasContext)
                throw new Error('Only "key" or "context" can be specified at same time');
            const k = (0, utils_ts_1.toBytes)(key).slice();
            (0, utils_ts_1.abytes)(k, 32);
            this.IV = (0, utils_ts_1.u32)(k);
            (0, utils_ts_1.swap32IfBE)(this.IV);
            this.flags = flags | B3_Flags.KEYED_HASH;
        }
        else if (hasContext) {
            const ctx = (0, utils_ts_1.toBytes)(context);
            const contextKey = new BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT)
                .update(ctx)
                .digest();
            this.IV = (0, utils_ts_1.u32)(contextKey);
            (0, utils_ts_1.swap32IfBE)(this.IV);
            this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
        }
        else {
            this.IV = B3_IV.slice();
            this.flags = flags;
        }
        this.state = this.IV.slice();
        this.bufferOut = (0, utils_ts_1.u8)(this.bufferOut32);
    }
    // Unused
    get() {
        return [];
    }
    set() { }
    b2Compress(counter, flags, buf, bufPos = 0) {
        const { state: s, pos } = this;
        const { h, l } = (0, _u64_ts_1.fromBig)(BigInt(counter), true);
        // prettier-ignore
        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = (0, blake2_ts_1.compress)(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);
        s[0] = v0 ^ v8;
        s[1] = v1 ^ v9;
        s[2] = v2 ^ v10;
        s[3] = v3 ^ v11;
        s[4] = v4 ^ v12;
        s[5] = v5 ^ v13;
        s[6] = v6 ^ v14;
        s[7] = v7 ^ v15;
    }
    compress(buf, bufPos = 0, isLast = false) {
        // Compress last block
        let flags = this.flags;
        if (!this.chunkPos)
            flags |= B3_Flags.CHUNK_START;
        if (this.chunkPos === 15 || isLast)
            flags |= B3_Flags.CHUNK_END;
        if (!isLast)
            this.pos = this.blockLen;
        this.b2Compress(this.chunksDone, flags, buf, bufPos);
        this.chunkPos += 1;
        // If current block is last in chunk (16 blocks), then compress chunks
        if (this.chunkPos === 16 || isLast) {
            let chunk = this.state;
            this.state = this.IV.slice();
            // If not the last one, compress only when there are trailing zeros in chunk counter
            // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.
            // 1 (001) - leaf not finished (just push current chunk to stack)
            // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)
            // 3 (011) - last leaf not finished
            // 4 (100) - leafs finished at depth=1 and depth=2
            for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
                if (!(last = this.stack.pop()))
                    break;
                this.buffer32.set(last, 0);
                this.buffer32.set(chunk, 8);
                this.pos = this.blockLen;
                this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
                chunk = this.state;
                this.state = this.IV.slice();
            }
            this.chunksDone++;
            this.chunkPos = 0;
            this.stack.push(chunk);
        }
        this.pos = 0;
    }
    _cloneInto(to) {
        to = super._cloneInto(to);
        const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
        to.state.set(state.slice());
        to.stack = stack.map((i) => Uint32Array.from(i));
        to.IV.set(IV);
        to.flags = flags;
        to.chunkPos = chunkPos;
        to.chunksDone = chunksDone;
        to.posOut = posOut;
        to.chunkOut = chunkOut;
        to.enableXOF = this.enableXOF;
        to.bufferOut32.set(this.bufferOut32);
        return to;
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state, this.buffer32, this.IV, this.bufferOut32);
        (0, utils_ts_1.clean)(...this.stack);
    }
    // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
    b2CompressOut() {
        const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;
        const { h, l } = (0, _u64_ts_1.fromBig)(BigInt(this.chunkOut++));
        (0, utils_ts_1.swap32IfBE)(buffer32);
        // prettier-ignore
        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = (0, blake2_ts_1.compress)(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);
        out32[0] = v0 ^ v8;
        out32[1] = v1 ^ v9;
        out32[2] = v2 ^ v10;
        out32[3] = v3 ^ v11;
        out32[4] = v4 ^ v12;
        out32[5] = v5 ^ v13;
        out32[6] = v6 ^ v14;
        out32[7] = v7 ^ v15;
        out32[8] = s[0] ^ v8;
        out32[9] = s[1] ^ v9;
        out32[10] = s[2] ^ v10;
        out32[11] = s[3] ^ v11;
        out32[12] = s[4] ^ v12;
        out32[13] = s[5] ^ v13;
        out32[14] = s[6] ^ v14;
        out32[15] = s[7] ^ v15;
        (0, utils_ts_1.swap32IfBE)(buffer32);
        (0, utils_ts_1.swap32IfBE)(out32);
        this.posOut = 0;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        // Padding
        (0, utils_ts_1.clean)(this.buffer.subarray(this.pos));
        // Process last chunk
        let flags = this.flags | B3_Flags.ROOT;
        if (this.stack.length) {
            flags |= B3_Flags.PARENT;
            (0, utils_ts_1.swap32IfBE)(this.buffer32);
            this.compress(this.buffer32, 0, true);
            (0, utils_ts_1.swap32IfBE)(this.buffer32);
            this.chunksDone = 0;
            this.pos = this.blockLen;
        }
        else {
            flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
        }
        this.flags = flags;
        this.b2CompressOut();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const { blockLen, bufferOut } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.b2CompressOut();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        if (!this.enableXOF)
            throw new Error('XOF is not possible after digest call');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.enableXOF = false;
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
}
exports.BLAKE3 = BLAKE3;
/**
BLAKE3 hash function. Can be used as MAC and KDF.
@param msg - message that would be hashed
@param opts - `dkLen` for output length, `key` for MAC mode, `context` for KDF mode
@example
const data = new Uint8Array(32);
const hash = blake3(data);
const mac = blake3(data, { key: new Uint8Array(32) });
const kdf = blake3(data, { context: 'application name' });

## setBigUint64

Source: `my-backend/node_modules/@noble/hashes/esm/_md.js`

Signature: `setBigUint64(view, byteOffset, value, isLE)`

JSDoc:

Internal Merkle-Damgard hash utils.
@module
/
import { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from "./utils.js";
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64

## Chi

Source: `my-backend/node_modules/@noble/hashes/esm/_md.js`

Signature: `Chi(a, b, c)`

JSDoc:

Choice: a ? b : c

## Maj

Source: `my-backend/node_modules/@noble/hashes/esm/_md.js`

Signature: `Maj(a, b, c)`

JSDoc:

Majority function, true if any two inputs is true.

## deriveMainSeed

Source: `my-backend/node_modules/@noble/hashes/esm/eskdf.js`

Signature: `deriveMainSeed(username, password)`

JSDoc:

Experimental KDF for AES.
/
import { hkdf } from "./hkdf.js";
import { pbkdf2 as _pbkdf2 } from "./pbkdf2.js";
import { scrypt as _scrypt } from "./scrypt.js";
import { sha256 } from "./sha256.js";
import { abytes, bytesToHex, clean, createView, hexToBytes, kdfInputToBytes } from "./utils.js";
// A tiny KDF for various applications like AES key-gen.
// Uses HKDF in a non-standard way, so it's not "KDF-secure", only "PRF-secure".
// Which is good enough: assume sha2-256 retained preimage resistance.
const SCRYPT_FACTOR = 2 ** 19;
const PBKDF2_FACTOR = 2 ** 17;
// Scrypt KDF
export function scrypt(password, salt) {
    return _scrypt(password, salt, { N: SCRYPT_FACTOR, r: 8, p: 1, dkLen: 32 });
}
// PBKDF2-HMAC-SHA256
export function pbkdf2(password, salt) {
    return _pbkdf2(sha256, password, salt, { c: PBKDF2_FACTOR, dkLen: 32 });
}
// Combines two 32-byte byte arrays
function xor32(a, b) {
    abytes(a, 32);
    abytes(b, 32);
    const arr = new Uint8Array(32);
    for (let i = 0; i < 32; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function strHasLength(str, min, max) {
    return typeof str === 'string' && str.length >= min && str.length <= max;
}
/**
Derives main seed. Takes a lot of time. Prefer `eskdf` method instead.

## extract

Source: `my-backend/node_modules/@noble/hashes/esm/hkdf.js`

Signature: `extract(hash, ikm, salt)`

JSDoc:

HKDF (RFC 5869): extract + expand in one step.
See https://soatok.blog/2021/11/17/understanding-hkdf/.
@module
/
import { hmac } from "./hmac.js";
import { ahash, anumber, clean, toBytes } from "./utils.js";
/**
HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`
Arguments position differs from spec (IKM is first one, since it is not optional)
@param hash - hash function that would be used (e.g. sha256)
@param ikm - input keying material, the initial key
@param salt - optional salt value (a non-secret random value)

## expand

Source: `my-backend/node_modules/@noble/hashes/esm/hkdf.js`

Signature: `expand(hash, prk, info, length = 32)`

JSDoc:

HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`
@param hash - hash function that would be used (e.g. sha256)
@param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)
@param info - optional context and application specific information (can be a zero-length string)
@param length - length of output keying material in bytes

## pbkdf2

Source: `my-backend/node_modules/@noble/hashes/esm/pbkdf2.js`

Signature: `pbkdf2(hash, password, salt, opts)`

JSDoc:

PBKDF (RFC 2898). Can be used to create a key from password and salt.
@module
/
import { hmac } from "./hmac.js";
// prettier-ignore
import { ahash, anumber, asyncLoop, checkOpts, clean, createView, Hash, kdfInputToBytes } from "./utils.js";
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    ahash(hash);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    anumber(c);
    anumber(dkLen);
    anumber(asyncTick);
    if (c < 1)
        throw new Error('iterations (c) should be >= 1');
    const password = kdfInputToBytes(_password);
    const salt = kdfInputToBytes(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    clean(u);
    return DK;
}
/**
PBKDF2-HMAC: RFC 2898 key derivation function
@param hash - hash function that would be used e.g. sha256
@param password - password from which a derived key is generated
@param salt - cryptographic salt
@param opts - {c, dkLen} where c is work factor and dkLen is output message size
@example
const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });

## scrypt

Source: `my-backend/node_modules/@noble/hashes/esm/scrypt.js`

Signature: `scrypt(password, salt, opts)`

JSDoc:

RFC 7914 Scrypt KDF. Can be used to create a key from password and salt.
@module
/
import { pbkdf2 } from "./pbkdf2.js";
import { sha256 } from "./sha2.js";
// prettier-ignore
import { anumber, asyncLoop, checkOpts, clean, rotl, swap32IfBE, u32 } from "./utils.js";
// The main Scrypt loop: uses Salsa extensively.
// Six versions of the function were tried, this is the fastest one.
// prettier-ignore
function XorAndSalsa(prev, pi, input, ii, out, oi) {
    // Based on https://cr.yp.to/salsa20.html
    // Xor blocks
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    // Save state to temporary variables (salsa)
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    // Main loop (salsa)
    for (let i = 0; i < 8; i += 2) {
        x04 ^= rotl(x00 + x12 | 0, 7);
        x08 ^= rotl(x04 + x00 | 0, 9);
        x12 ^= rotl(x08 + x04 | 0, 13);
        x00 ^= rotl(x12 + x08 | 0, 18);
        x09 ^= rotl(x05 + x01 | 0, 7);
        x13 ^= rotl(x09 + x05 | 0, 9);
        x01 ^= rotl(x13 + x09 | 0, 13);
        x05 ^= rotl(x01 + x13 | 0, 18);
        x14 ^= rotl(x10 + x06 | 0, 7);
        x02 ^= rotl(x14 + x10 | 0, 9);
        x06 ^= rotl(x02 + x14 | 0, 13);
        x10 ^= rotl(x06 + x02 | 0, 18);
        x03 ^= rotl(x15 + x11 | 0, 7);
        x07 ^= rotl(x03 + x15 | 0, 9);
        x11 ^= rotl(x07 + x03 | 0, 13);
        x15 ^= rotl(x11 + x07 | 0, 18);
        x01 ^= rotl(x00 + x03 | 0, 7);
        x02 ^= rotl(x01 + x00 | 0, 9);
        x03 ^= rotl(x02 + x01 | 0, 13);
        x00 ^= rotl(x03 + x02 | 0, 18);
        x06 ^= rotl(x05 + x04 | 0, 7);
        x07 ^= rotl(x06 + x05 | 0, 9);
        x04 ^= rotl(x07 + x06 | 0, 13);
        x05 ^= rotl(x04 + x07 | 0, 18);
        x11 ^= rotl(x10 + x09 | 0, 7);
        x08 ^= rotl(x11 + x10 | 0, 9);
        x09 ^= rotl(x08 + x11 | 0, 13);
        x10 ^= rotl(x09 + x08 | 0, 18);
        x12 ^= rotl(x15 + x14 | 0, 7);
        x13 ^= rotl(x12 + x15 | 0, 9);
        x14 ^= rotl(x13 + x12 | 0, 13);
        x15 ^= rotl(x14 + x13 | 0, 18);
    }
    // Write output (salsa)
    out[oi++] = (y00 + x00) | 0;
    out[oi++] = (y01 + x01) | 0;
    out[oi++] = (y02 + x02) | 0;
    out[oi++] = (y03 + x03) | 0;
    out[oi++] = (y04 + x04) | 0;
    out[oi++] = (y05 + x05) | 0;
    out[oi++] = (y06 + x06) | 0;
    out[oi++] = (y07 + x07) | 0;
    out[oi++] = (y08 + x08) | 0;
    out[oi++] = (y09 + x09) | 0;
    out[oi++] = (y10 + x10) | 0;
    out[oi++] = (y11 + x11) | 0;
    out[oi++] = (y12 + x12) | 0;
    out[oi++] = (y13 + x13) | 0;
    out[oi++] = (y14 + x14) | 0;
    out[oi++] = (y15 + x15) | 0;
}
function BlockMix(input, ii, out, oi, r) {
    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
        if (i > 0)
            tail += 16; // First iteration overwrites tmp value in tail
        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
    }
}
// Common prologue and epilogue for sync/async functions
function scryptInit(password, salt, _opts) {
    // Maxmem - 1GB+1KB by default
    const opts = checkOpts({
        dkLen: 32,
        asyncTick: 10,
        maxmem: 1024 ** 3 + 1024,
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    anumber(N);
    anumber(r);
    anumber(p);
    anumber(dkLen);
    anumber(asyncTick);
    anumber(maxmem);
    if (onProgress !== undefined && typeof onProgress !== 'function')
        throw new Error('progressCb should be function');
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    // Max N is 2^32 (Integrify is 32-bit). Real limit is 2^22: JS engines Uint8Array limit is 4GB in 2024.
    // Spec check `N >= 2^(blockSize / 8)` is not done for compat with popular libs,
    // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:
    // https://www.rfc-editor.org/errata_search.php?rfc=7914
    const pow32 = Math.pow(2, 32);
    if (N <= 1 || (N & (N - 1)) !== 0 || N > pow32) {
        throw new Error('Scrypt: N must be larger than 1, a power of 2, and less than 2^32');
    }
    if (p < 0 || p > ((pow32 - 1) * 32) / blockSize) {
        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');
    }
    if (dkLen < 0 || dkLen > (pow32 - 1) * 32) {
        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');
    }
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
        throw new Error('Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of ' + maxmem);
    }
    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
    // Since it has only one iteration there is no reason to use async variant
    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    // Re-used between parallel iterations. Array(iterations) of B
    const V = u32(new Uint8Array(blockSize * N));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => { };
    if (onProgress) {
        const totalBlockMix = 2 * N * p;
        // Invoke callback if progress changes from 10.01 to 10.02
        // Allows to draw smooth progress bar on up to 8K screen
        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
        let blockMixCnt = 0;
        blockMixCb = () => {
            blockMixCnt++;
            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
                onProgress(blockMixCnt / totalBlockMix);
        };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
    clean(B, V, tmp);
    return res;
}
/**
Scrypt KDF from RFC 7914.
@param password - pass
@param salt - salt
@param opts - parameters
- `N` is cpu/mem work factor (power of 2 e.g. 2**18)
- `r` is block size (8 is common), fine-tunes sequential memory read size and performance
- `p` is parallelization factor (1 is common)
- `dkLen` is output key length in bytes e.g. 32.
- `asyncTick` - (default: 10) max time in ms for which async function can block execution
- `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
- `onProgress` - callback function that would be executed for progress report
@returns Derived key
@example
scrypt('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });

## keccakP

Source: `my-backend/node_modules/@noble/hashes/esm/sha3.js`

Signature: `keccakP(s, rounds = 24)`

JSDoc:

SHA3 (keccak) hash function, based on a new "Sponge function" design.
Different from older hashes, the internal state is bigger than output size.

Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
[Website](https://keccak.team/keccak.html),
[the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).

Check out `sha3-addons` module for cSHAKE, k12, and others.
@module
/
import { rotlBH, rotlBL, rotlSH, rotlSL, split } from "./_u64.js";
// prettier-ignore
import { abytes, aexists, anumber, aoutput, clean, createHasher, createXOFer, Hash, swap32IfBE, toBytes, u32 } from "./utils.js";
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = split(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
/** `keccakf1600` internal function, additionally allows to adjust round count.

## isBytes

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `isBytes(a)`

JSDoc:

Utilities for hex, bytes, CSPRNG.
@module
/
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
import { crypto } from '@noble/hashes/crypto';
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true.

## anumber

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `anumber(n)`

JSDoc:

Asserts something is positive integer.

## abytes

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `abytes(b, ...lengths)`

JSDoc:

Asserts something is Uint8Array.

## ahash

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `ahash(h)`

JSDoc:

Asserts something is hash

## aexists

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `aexists(instance, checkFinished = true)`

JSDoc:

Asserts a hash instance has not been destroyed / finished

## aoutput

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `aoutput(out, instance)`

JSDoc:

Asserts output is properly-sized byte array

## u8

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `u8(arr)`

JSDoc:

Cast u8 / u16 / u32 to u8.

## u32

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `u32(arr)`

JSDoc:

Cast u8 / u16 / u32 to u32.

## clean

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `clean(...arrays)`

JSDoc:

Zeroize a byte array. Warning: JS provides no guarantees.

## createView

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `createView(arr)`

JSDoc:

Create DataView of an array for easy byte-level manipulation.

## rotr

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `rotr(word, shift)`

JSDoc:

The rotate right (circular right shift) operation for uint32

## rotl

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `rotl(word, shift)`

JSDoc:

The rotate left (circular left shift) operation for uint32

## byteSwap

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `byteSwap(word)`

JSDoc:

Is current platform little-endian? Most are. Big-Endian platform: IBM */
export const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32

## byteSwap32

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `byteSwap32(arr)`

JSDoc:

Conditionally byte swap if on a big-endian platform */
export const swap8IfBE = isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
export const byteSwapIfBE = swap8IfBE;
/** In place byte swap for Uint32Array

## bytesToHex

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `bytesToHex(bytes)`

JSDoc:

Convert byte array to hex string. Uses built-in function, when available.
@example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'

## hexToBytes

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `hexToBytes(hex)`

JSDoc:

Convert hex string to byte array. Uses built-in function, when available.
@example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])

## utf8ToBytes

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `utf8ToBytes(str)`

JSDoc:

There is no setImmediate in browser and setTimeout is slow.
Call of async fn will return Promise, which will be fullfiled only on
next scheduler queue processing step and this is exactly what we need.
/
export const nextTick = async () => { };
/** Returns control to thread each 'tick' ms to avoid blocking. */
export async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await nextTick();
        ts += diff;
    }
}
/**
Converts string to bytes using UTF8 encoding.
@example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])

## bytesToUtf8

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `bytesToUtf8(bytes)`

JSDoc:

Converts bytes to string using UTF8 encoding.
@example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'

## toBytes

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `toBytes(data)`

JSDoc:

Normalizes (non-hex) string or Uint8Array to Uint8Array.
Warning: when Uint8Array is passed, it would NOT get copied.
Keep in mind for future mutable operations.

## kdfInputToBytes

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `kdfInputToBytes(data)`

JSDoc:

Helper for KDFs: consumes uint8array or string.
When string is passed, does utf8 decoding, using TextDecoder.

## concatBytes

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `concatBytes(...arrays)`

JSDoc:

Copies several Uint8Arrays into one.

## createHasher

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `createHasher(hashCons)`

JSDoc:

For runtime check if class implements interface */
export class Hash {
}
/** Wraps hash function, creating an interface on top of it

## randomBytes

Source: `my-backend/node_modules/@noble/hashes/esm/utils.js`

Signature: `randomBytes(bytesLength = 32)`

JSDoc:

Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`.

## sha1

Source: `my-backend/node_modules/@noble/hashes/legacy.js`

Signature: `sha1(= (0, utils_ts_1.createHasher)`

JSDoc:

SHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.
Don't use them in a new protocol. What "weak" means:

- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.
- No practical pre-image attacks (only theoretical, 2^123.4)
- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151
@module
/
const _md_ts_1 = require("./_md.js");
const utils_ts_1 = require("./utils.js");
/** Initial SHA1 state */
const SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,
]);
// Reusable temporary buffer
const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
/** SHA1 legacy hash class. */
class SHA1 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
            SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
            let F, K;
            if (i < 20) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                K = 0x5a827999;
            }
            else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            }
            else if (i < 60) {
                F = (0, _md_ts_1.Maj)(B, C, D);
                K = 0x8f1bbcdc;
            }
            else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;
            E = D;
            D = C;
            C = (0, utils_ts_1.rotl)(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA1 = SHA1;
/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken.

## md5

Source: `my-backend/node_modules/@noble/hashes/legacy.js`

Signature: `md5(= (0, utils_ts_1.createHasher)`

JSDoc:

Per-round constants */
const p32 = /* @__PURE__ */ Math.pow(2, 32);
const K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
/** md5 initial state: same as sha1, but 4 u32 instead of 5. */
const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
// Reusable temporary buffer
const MD5_W = /* @__PURE__ */ new Uint32Array(16);
/** MD5 legacy hash class. */
class MD5 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
    }
    get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
    }
    set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            MD5_W[i] = view.getUint32(offset, true);
        // Compression function main loop, 64 rounds
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
            let F, g, s;
            if (i < 16) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                g = i;
                s = [7, 12, 17, 22];
            }
            else if (i < 32) {
                F = (0, _md_ts_1.Chi)(D, B, C);
                g = (5 * i + 1) % 16;
                s = [5, 9, 14, 20];
            }
            else if (i < 48) {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
                s = [4, 11, 16, 23];
            }
            else {
                F = C ^ (B | ~D);
                g = (7 * i) % 16;
                s = [6, 10, 15, 21];
            }
            F = F + A + K[i] + MD5_W[g];
            A = D;
            D = C;
            C = B;
            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        this.set(A, B, C, D);
    }
    roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
    }
    destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.MD5 = MD5;
/**
MD5 (RFC 1321) legacy hash function. It was cryptographically broken.
MD5 architecture is similar to SHA1, with some differences:
- Reduced output length: 16 bytes (128 bit) instead of 20
- 64 rounds, instead of 80
- Little-endian: could be faster, but will require more code
- Non-linear index selection: huge speed-up for unroll
- Per round constants: more memory accesses, additional speed-up for unroll

## ripemd160

Source: `my-backend/node_modules/@noble/hashes/legacy.js`

Signature: `ripemd160(= (0, utils_ts_1.createHasher)`

JSDoc:

RIPEMD-160 - a legacy hash function from 1990s.
* https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
* https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf

## RIPEMD160

Source: `my-backend/node_modules/@noble/hashes/ripemd160.js`

Signature: `RIPEMD160(= legacy_ts_1.RIPEMD160;
/** @deprecated Use import from `noble/hashes/legacy` module */
exports.ripemd160 = legacy_ts_1.ripemd160;
//# sourceMappingURL=ripemd160.js.map)`

JSDoc:

RIPEMD-160 legacy hash function.
https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
@module
@deprecated
/
const legacy_ts_1 = require("./legacy.js");
/** @deprecated Use import from `noble/hashes/legacy` module

## SHA1

Source: `my-backend/node_modules/@noble/hashes/sha1.js`

Signature: `SHA1(= legacy_ts_1.SHA1;
/** @deprecated Use import from `noble/hashes/legacy` module */
exports.sha1 = legacy_ts_1.sha1;
//# sourceMappingURL=sha1.js.map)`

JSDoc:

SHA1 (RFC 3174) legacy hash function.
@module
@deprecated
/
const legacy_ts_1 = require("./legacy.js");
/** @deprecated Use import from `noble/hashes/legacy` module

## sha256

Source: `my-backend/node_modules/@noble/hashes/sha2.js`

Signature: `sha256(= (0, utils_ts_1.createHasher)`

JSDoc:

SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
SHA256 is the fastest hash implementable in JS, even faster than Blake3.
Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
[FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
@module
/
const _md_ts_1 = require("./_md.js");
const u64 = require("./_u64.js");
const utils_ts_1 = require("./utils.js");
/**
Round constants:
First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
/
// prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (() => u64.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
Truncated SHA512/256 and SHA512/224.
SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
Then t hashes string to produce result IV.
See `test/misc/sha2-gen-iv.js`.
/
/** SHA512/224 IV */
const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,
    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,
]);
/** SHA512/256 IV */
const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,
    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,
]);
class SHA512_224 extends SHA512 {
    constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
SHA2-256 hash function from RFC 4634.

It is the fastest JS hash, even faster than Blake3.
To break sha256 using birthday attack, attackers need to try 2^128 hashes.
BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.

## sha224

Source: `my-backend/node_modules/@noble/hashes/sha2.js`

Signature: `sha224(= (0, utils_ts_1.createHasher)`

JSDoc:

SHA2-224 hash function from RFC 4634

## sha512

Source: `my-backend/node_modules/@noble/hashes/sha2.js`

Signature: `sha512(= (0, utils_ts_1.createHasher)`

JSDoc:

SHA2-512 hash function from RFC 4634.

## sha384

Source: `my-backend/node_modules/@noble/hashes/sha2.js`

Signature: `sha384(= (0, utils_ts_1.createHasher)`

JSDoc:

SHA2-384 hash function from RFC 4634.

## sha512_256

Source: `my-backend/node_modules/@noble/hashes/sha2.js`

Signature: `sha512_256(= (0, utils_ts_1.createHasher)`

JSDoc:

SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).

## sha512_224

Source: `my-backend/node_modules/@noble/hashes/sha2.js`

Signature: `sha512_224(= (0, utils_ts_1.createHasher)`

JSDoc:

SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).

## SHA256

Source: `my-backend/node_modules/@noble/hashes/sha256.js`

Signature: `SHA256(= sha2_ts_1.SHA256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha256 = sha2_ts_1.sha256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA224 = sha2_ts_1.SHA224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha224 = sha2_ts_1.sha224;
//# sourceMappingURL=sha256.js.map)`

JSDoc:

SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.

To break sha256 using birthday attack, attackers need to try 2^128 hashes.
BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.

Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
@module
@deprecated
/
const sha2_ts_1 = require("./sha2.js");
/** @deprecated Use import from `noble/hashes/sha2` module

## tuplehash128

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `tuplehash128(= (()`

JSDoc:

SHA3 (keccak) addons.

* Full [NIST SP 800-185](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf):
  cSHAKE, KMAC, TupleHash, ParallelHash + XOF variants
* Reduced-round Keccak [(draft)](https://datatracker.ietf.org/doc/draft-irtf-cfrg-kangarootwelve/):
    *  K12 aka KangarooTwelve
    * M14 aka MarsupilamiFourteen
    * TurboSHAKE
* KeccakPRG: Pseudo-random generator based on Keccak [(pdf)](https://keccak.team/files/CSF-0.1.pdf)
@module
/
const sha3_ts_1 = require("./sha3.js");
const utils_ts_1 = require("./utils.js");
// cSHAKE && KMAC (NIST SP800-185)
const _8n = BigInt(8);
const _ffn = BigInt(0xff);
// NOTE: it is safe to use bigints here, since they used only for length encoding (not actual data).
// We use bigints in sha256 for lengths too.
function leftEncode(n) {
    n = BigInt(n);
    const res = [Number(n & _ffn)];
    n >>= _8n;
    for (; n > 0; n >>= _8n)
        res.unshift(Number(n & _ffn));
    res.unshift(res.length);
    return new Uint8Array(res);
}
function rightEncode(n) {
    n = BigInt(n);
    const res = [Number(n & _ffn)];
    n >>= _8n;
    for (; n > 0; n >>= _8n)
        res.unshift(Number(n & _ffn));
    res.push(res.length);
    return new Uint8Array(res);
}
function chooseLen(opts, outputLen) {
    return opts.dkLen === undefined ? outputLen : opts.dkLen;
}
const abytesOrZero = (buf) => {
    if (buf === undefined)
        return Uint8Array.of();
    return (0, utils_ts_1.toBytes)(buf);
};
// NOTE: second modulo is necessary since we don't need to add padding if current element takes whole block
const getPadding = (len, block) => new Uint8Array((block - (len % block)) % block);
// Personalization
function cshakePers(hash, opts = {}) {
    if (!opts || (!opts.personalization && !opts.NISTfn))
        return hash;
    // Encode and pad inplace to avoid unneccesary memory copies/slices (so we don't need to zero them later)
    // bytepad(encode_string(N) || encode_string(S), 168)
    const blockLenBytes = leftEncode(hash.blockLen);
    const fn = abytesOrZero(opts.NISTfn);
    const fnLen = leftEncode(_8n * BigInt(fn.length)); // length in bits
    const pers = abytesOrZero(opts.personalization);
    const persLen = leftEncode(_8n * BigInt(pers.length)); // length in bits
    if (!fn.length && !pers.length)
        return hash;
    hash.suffix = 0x04;
    hash.update(blockLenBytes).update(fnLen).update(fn).update(persLen).update(pers);
    let totalLen = blockLenBytes.length + fnLen.length + fn.length + persLen.length + pers.length;
    hash.update(getPadding(totalLen, hash.blockLen));
    return hash;
}
const gencShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => cshakePers(new sha3_ts_1.Keccak(blockLen, suffix, chooseLen(opts, outputLen), true), opts));
exports.cshake128 = (() => gencShake(0x1f, 168, 128 / 8))();
exports.cshake256 = (() => gencShake(0x1f, 136, 256 / 8))();
class KMAC extends sha3_ts_1.Keccak {
    constructor(blockLen, outputLen, enableXOF, key, opts = {}) {
        super(blockLen, 0x1f, outputLen, enableXOF);
        cshakePers(this, { NISTfn: 'KMAC', personalization: opts.personalization });
        key = (0, utils_ts_1.toBytes)(key);
        (0, utils_ts_1.abytes)(key);
        // 1. newX = bytepad(encode_string(K), 168) || X || right_encode(L).
        const blockLenBytes = leftEncode(this.blockLen);
        const keyLen = leftEncode(_8n * BigInt(key.length));
        this.update(blockLenBytes).update(keyLen).update(key);
        const totalLen = blockLenBytes.length + keyLen.length + key.length;
        this.update(getPadding(totalLen, this.blockLen));
    }
    finish() {
        if (!this.finished)
            this.update(rightEncode(this.enableXOF ? 0 : _8n * BigInt(this.outputLen))); // outputLen in bits
        super.finish();
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        // Force "to" to be instance of KMAC instead of Sha3.
        if (!to) {
            to = Object.create(Object.getPrototypeOf(this), {});
            to.state = this.state.slice();
            to.blockLen = this.blockLen;
            to.state32 = (0, utils_ts_1.u32)(to.state);
        }
        return super._cloneInto(to);
    }
    clone() {
        return this._cloneInto();
    }
}
exports.KMAC = KMAC;
function genKmac(blockLen, outputLen, xof = false) {
    const kmac = (key, message, opts) => kmac.create(key, opts).update(message).digest();
    kmac.create = (key, opts = {}) => new KMAC(blockLen, chooseLen(opts, outputLen), xof, key, opts);
    return kmac;
}
exports.kmac128 = (() => genKmac(168, 128 / 8))();
exports.kmac256 = (() => genKmac(136, 256 / 8))();
exports.kmac128xof = (() => genKmac(168, 128 / 8, true))();
exports.kmac256xof = (() => genKmac(136, 256 / 8, true))();
// TupleHash
// Usage: tuple(['ab', 'cd']) != tuple(['a', 'bcd'])
class TupleHash extends sha3_ts_1.Keccak {
    constructor(blockLen, outputLen, enableXOF, opts = {}) {
        super(blockLen, 0x1f, outputLen, enableXOF);
        cshakePers(this, { NISTfn: 'TupleHash', personalization: opts.personalization });
        // Change update after cshake processed
        this.update = (data) => {
            data = (0, utils_ts_1.toBytes)(data);
            (0, utils_ts_1.abytes)(data);
            super.update(leftEncode(_8n * BigInt(data.length)));
            super.update(data);
            return this;
        };
    }
    finish() {
        if (!this.finished)
            super.update(rightEncode(this.enableXOF ? 0 : _8n * BigInt(this.outputLen))); // outputLen in bits
        super.finish();
    }
    _cloneInto(to) {
        to || (to = new TupleHash(this.blockLen, this.outputLen, this.enableXOF));
        return super._cloneInto(to);
    }
    clone() {
        return this._cloneInto();
    }
}
exports.TupleHash = TupleHash;
function genTuple(blockLen, outputLen, xof = false) {
    const tuple = (messages, opts) => {
        const h = tuple.create(opts);
        for (const msg of messages)
            h.update(msg);
        return h.digest();
    };
    tuple.create = (opts = {}) => new TupleHash(blockLen, chooseLen(opts, outputLen), xof, opts);
    return tuple;
}
/** 128-bit TupleHASH.

## tuplehash256

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `tuplehash256(= (()`

JSDoc:

256-bit TupleHASH.

## tuplehash128xof

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `tuplehash128xof(= (()`

JSDoc:

128-bit TupleHASH XOF.

## tuplehash256xof

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `tuplehash256xof(= (()`

JSDoc:

256-bit TupleHASH XOF.

## parallelhash128

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `parallelhash128(= (()`

JSDoc:

128-bit ParallelHash. In JS, it is not parallel.

## parallelhash256

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `parallelhash256(= (()`

JSDoc:

256-bit ParallelHash. In JS, it is not parallel.

## parallelhash128xof

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `parallelhash128xof(= (()`

JSDoc:

128-bit ParallelHash XOF. In JS, it is not parallel.

## parallelhash256xof

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `parallelhash256xof(= (()`

JSDoc:

256-bit ParallelHash. In JS, it is not parallel.

## turboshake128

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `turboshake128(= genTurboshake(168, 256 / 8)`

JSDoc:

TurboSHAKE 128-bit: reduced 12-round keccak.

## turboshake256

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `turboshake256(= genTurboshake(136, 512 / 8)`

JSDoc:

TurboSHAKE 256-bit: reduced 12-round keccak.

## k12

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `k12(= (()`

JSDoc:

KangarooTwelve: reduced 12-round keccak.

## m14

Source: `my-backend/node_modules/@noble/hashes/sha3-addons.js`

Signature: `m14(= (()`

JSDoc:

MarsupilamiFourteen: reduced 14-round keccak.

## sha3_224

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `sha3_224(= (()`

JSDoc:

SHA3 (keccak) hash function, based on a new "Sponge function" design.
Different from older hashes, the internal state is bigger than output size.

Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
[Website](https://keccak.team/keccak.html),
[the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).

Check out `sha3-addons` module for cSHAKE, k12, and others.
@module
/
const _u64_ts_1 = require("./_u64.js");
// prettier-ignore
const utils_ts_1 = require("./utils.js");
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s));
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */
class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200))
            throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function.

## sha3_256

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `sha3_256(= (()`

JSDoc:

SHA3-256 hash function. Different from keccak-256.

## sha3_384

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `sha3_384(= (()`

JSDoc:

SHA3-384 hash function.

## sha3_512

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `sha3_512(= (()`

JSDoc:

SHA3-512 hash function.

## keccak_224

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `keccak_224(= (()`

JSDoc:

keccak-224 hash function.

## keccak_256

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `keccak_256(= (()`

JSDoc:

keccak-256 hash function. Different from SHA3-256.

## keccak_384

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `keccak_384(= (()`

JSDoc:

keccak-384 hash function.

## keccak_512

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `keccak_512(= (()`

JSDoc:

keccak-512 hash function.

## shake128

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `shake128(= (()`

JSDoc:

SHAKE128 XOF with 128-bit security.

## shake256

Source: `my-backend/node_modules/@noble/hashes/sha3.js`

Signature: `shake256(= (()`

JSDoc:

SHAKE256 XOF with 256-bit security.

## SHA512

Source: `my-backend/node_modules/@noble/hashes/sha512.js`

Signature: `SHA512(= sha2_ts_1.SHA512;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512 = sha2_ts_1.sha512;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA384 = sha2_ts_1.SHA384;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha384 = sha2_ts_1.sha384;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA512_224 = sha2_ts_1.SHA512_224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512_224 = sha2_ts_1.sha512_224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA512_256 = sha2_ts_1.SHA512_256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha512_256 = sha2_ts_1.sha512_256;
//# sourceMappingURL=sha512.js.map)`

JSDoc:

SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.

Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
[the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).
@module
@deprecated
/
const sha2_ts_1 = require("./sha2.js");
/** @deprecated Use import from `noble/hashes/sha2` module

## setBigUint64

Source: `my-backend/node_modules/@noble/hashes/src/_md.ts`

Signature: `setBigUint64(
  view: DataView,
  byteOffset: number,
  value: bigint,
  isLE: boolean
)`

JSDoc:

Internal Merkle-Damgard hash utils.
@module
/
import { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';

/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64

## Chi

Source: `my-backend/node_modules/@noble/hashes/src/_md.ts`

Signature: `Chi(a: number, b: number, c: number)`

JSDoc:

Choice: a ? b : c

## Maj

Source: `my-backend/node_modules/@noble/hashes/src/_md.ts`

Signature: `Maj(a: number, b: number, c: number)`

JSDoc:

Majority function, true if any two inputs is true.

## deriveMainSeed

Source: `my-backend/node_modules/@noble/hashes/src/eskdf.ts`

Signature: `deriveMainSeed(username: string, password: string)`

JSDoc:

Experimental KDF for AES.
/
import { hkdf } from './hkdf.ts';
import { pbkdf2 as _pbkdf2 } from './pbkdf2.ts';
import { scrypt as _scrypt } from './scrypt.ts';
import { sha256 } from './sha256.ts';
import { abytes, bytesToHex, clean, createView, hexToBytes, kdfInputToBytes } from './utils.ts';

// A tiny KDF for various applications like AES key-gen.
// Uses HKDF in a non-standard way, so it's not "KDF-secure", only "PRF-secure".
// Which is good enough: assume sha2-256 retained preimage resistance.

const SCRYPT_FACTOR = 2 ** 19;
const PBKDF2_FACTOR = 2 ** 17;

// Scrypt KDF
export function scrypt(password: string, salt: string): Uint8Array {
  return _scrypt(password, salt, { N: SCRYPT_FACTOR, r: 8, p: 1, dkLen: 32 });
}

// PBKDF2-HMAC-SHA256
export function pbkdf2(password: string, salt: string): Uint8Array {
  return _pbkdf2(sha256, password, salt, { c: PBKDF2_FACTOR, dkLen: 32 });
}

// Combines two 32-byte byte arrays
function xor32(a: Uint8Array, b: Uint8Array): Uint8Array {
  abytes(a, 32);
  abytes(b, 32);
  const arr = new Uint8Array(32);
  for (let i = 0; i < 32; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}

function strHasLength(str: string, min: number, max: number): boolean {
  return typeof str === 'string' && str.length >= min && str.length <= max;
}

/**
Derives main seed. Takes a lot of time. Prefer `eskdf` method instead.

## extract

Source: `my-backend/node_modules/@noble/hashes/src/hkdf.ts`

Signature: `extract(hash: CHash, ikm: Input, salt?: Input)`

JSDoc:

HKDF (RFC 5869): extract + expand in one step.
See https://soatok.blog/2021/11/17/understanding-hkdf/.
@module
/
import { hmac } from './hmac.ts';
import { ahash, anumber, type CHash, clean, type Input, toBytes } from './utils.ts';

/**
HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`
Arguments position differs from spec (IKM is first one, since it is not optional)
@param hash - hash function that would be used (e.g. sha256)
@param ikm - input keying material, the initial key
@param salt - optional salt value (a non-secret random value)

## expand

Source: `my-backend/node_modules/@noble/hashes/src/hkdf.ts`

Signature: `expand(hash: CHash, prk: Input, info?: Input, length: number = 32)`

JSDoc:

HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`
@param hash - hash function that would be used (e.g. sha256)
@param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)
@param info - optional context and application specific information (can be a zero-length string)
@param length - length of output keying material in bytes

## pbkdf2

Source: `my-backend/node_modules/@noble/hashes/src/pbkdf2.ts`

Signature: `pbkdf2(
  hash: CHash,
  password: KDFInput,
  salt: KDFInput,
  opts: Pbkdf2Opt
)`

JSDoc:

PBKDF (RFC 2898). Can be used to create a key from password and salt.
@module
/
import { hmac } from './hmac.ts';
// prettier-ignore
import {
  ahash, anumber,
  asyncLoop, checkOpts, clean, createView, Hash, kdfInputToBytes,
  type CHash,
  type KDFInput
} from './utils.ts';

export type Pbkdf2Opt = {
  c: number; // Iterations
  dkLen?: number; // Desired key length in bytes (Intended output length in octets of the derived key
  asyncTick?: number; // Maximum time in ms for which async function can block execution
};
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash: CHash, _password: KDFInput, _salt: KDFInput, _opts: Pbkdf2Opt) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber(c);
  anumber(dkLen);
  anumber(asyncTick);
  if (c < 1) throw new Error('iterations (c) should be >= 1');
  const password = kdfInputToBytes(_password);
  const salt = kdfInputToBytes(_salt);
  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
  const DK = new Uint8Array(dkLen);
  // U1 = PRF(Password, Salt + INT_32_BE(i))
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}

function pbkdf2Output<T extends Hash<T>>(
  PRF: Hash<T>,
  PRFSalt: Hash<T>,
  DK: Uint8Array,
  prfW: Hash<T>,
  u: Uint8Array
) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW) prfW.destroy();
  clean(u);
  return DK;
}

/**
PBKDF2-HMAC: RFC 2898 key derivation function
@param hash - hash function that would be used e.g. sha256
@param password - password from which a derived key is generated
@param salt - cryptographic salt
@param opts - {c, dkLen} where c is work factor and dkLen is output message size
@example
const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });

## scrypt

Source: `my-backend/node_modules/@noble/hashes/src/scrypt.ts`

Signature: `scrypt(password: KDFInput, salt: KDFInput, opts: ScryptOpts)`

JSDoc:

RFC 7914 Scrypt KDF. Can be used to create a key from password and salt.
@module
/
import { pbkdf2 } from './pbkdf2.ts';
import { sha256 } from './sha2.ts';
// prettier-ignore
import {
  anumber, asyncLoop,
  checkOpts, clean,
  type KDFInput, rotl,
  swap32IfBE,
  u32
} from './utils.ts';

// The main Scrypt loop: uses Salsa extensively.
// Six versions of the function were tried, this is the fastest one.
// prettier-ignore
function XorAndSalsa(
  prev: Uint32Array,
  pi: number,
  input: Uint32Array,
  ii: number,
  out: Uint32Array,
  oi: number
) {
  // Based on https://cr.yp.to/salsa20.html
  // Xor blocks
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  // Save state to temporary variables (salsa)
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,
      x04 = y04, x05 = y05, x06 = y06, x07 = y07,
      x08 = y08, x09 = y09, x10 = y10, x11 = y11,
      x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  // Main loop (salsa)
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0,  7); x08 ^= rotl(x04 + x00 | 0,  9);
    x12 ^= rotl(x08 + x04 | 0, 13); x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0,  7); x13 ^= rotl(x09 + x05 | 0,  9);
    x01 ^= rotl(x13 + x09 | 0, 13); x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0,  7); x02 ^= rotl(x14 + x10 | 0,  9);
    x06 ^= rotl(x02 + x14 | 0, 13); x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0,  7); x07 ^= rotl(x03 + x15 | 0,  9);
    x11 ^= rotl(x07 + x03 | 0, 13); x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0,  7); x02 ^= rotl(x01 + x00 | 0,  9);
    x03 ^= rotl(x02 + x01 | 0, 13); x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0,  7); x07 ^= rotl(x06 + x05 | 0,  9);
    x04 ^= rotl(x07 + x06 | 0, 13); x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0,  7); x08 ^= rotl(x11 + x10 | 0,  9);
    x09 ^= rotl(x08 + x11 | 0, 13); x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0,  7); x13 ^= rotl(x12 + x15 | 0,  9);
    x14 ^= rotl(x13 + x12 | 0, 13); x15 ^= rotl(x14 + x13 | 0, 18);
  }
  // Write output (salsa)
  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;
  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;
  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;
  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;
  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;
  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;
  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;
  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;
}

function BlockMix(input: Uint32Array, ii: number, out: Uint32Array, oi: number, r: number) {
  // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
    XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
    if (i > 0) tail += 16; // First iteration overwrites tmp value in tail
    XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
  }
}

export type ScryptOpts = {
  N: number; // cost factor
  r: number; // block size
  p: number; // parallelization
  dkLen?: number; // key length
  asyncTick?: number; // block execution max time
  maxmem?: number;
  onProgress?: (progress: number) => void;
};

// Common prologue and epilogue for sync/async functions
function scryptInit(password: KDFInput, salt: KDFInput, _opts?: ScryptOpts) {
  // Maxmem - 1GB+1KB by default
  const opts = checkOpts(
    {
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024,
    },
    _opts
  );
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  anumber(N);
  anumber(r);
  anumber(p);
  anumber(dkLen);
  anumber(asyncTick);
  anumber(maxmem);
  if (onProgress !== undefined && typeof onProgress !== 'function')
    throw new Error('progressCb should be function');
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;

  // Max N is 2^32 (Integrify is 32-bit). Real limit is 2^22: JS engines Uint8Array limit is 4GB in 2024.
  // Spec check `N >= 2^(blockSize / 8)` is not done for compat with popular libs,
  // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:
  // https://www.rfc-editor.org/errata_search.php?rfc=7914
  const pow32 = Math.pow(2, 32);
  if (N <= 1 || (N & (N - 1)) !== 0 || N > pow32) {
    throw new Error('Scrypt: N must be larger than 1, a power of 2, and less than 2^32');
  }
  if (p < 0 || p > ((pow32 - 1) * 32) / blockSize) {
    throw new Error(
      'Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)'
    );
  }
  if (dkLen < 0 || dkLen > (pow32 - 1) * 32) {
    throw new Error(
      'Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32'
    );
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(
      'Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of ' + maxmem
    );
  }
  // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
  // Since it has only one iteration there is no reason to use async variant
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  // Re-used between parallel iterations. Array(iterations) of B
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {};
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    // Invoke callback if progress changes from 10.01 to 10.02
    // Allows to draw smooth progress bar on up to 8K screen
    const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}

function scryptOutput(
  password: KDFInput,
  dkLen: number,
  B: Uint8Array,
  V: Uint32Array,
  tmp: Uint32Array
) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  clean(B, V, tmp);
  return res;
}

/**
Scrypt KDF from RFC 7914.
@param password - pass
@param salt - salt
@param opts - parameters
- `N` is cpu/mem work factor (power of 2 e.g. 2**18)
- `r` is block size (8 is common), fine-tunes sequential memory read size and performance
- `p` is parallelization factor (1 is common)
- `dkLen` is output key length in bytes e.g. 32.
- `asyncTick` - (default: 10) max time in ms for which async function can block execution
- `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
- `onProgress` - callback function that would be executed for progress report
@returns Derived key
@example
scrypt('password', 'salt', { N: 2**18, r: 8, p: 1, dkLen: 32 });

## keccakP

Source: `my-backend/node_modules/@noble/hashes/src/sha3.ts`

Signature: `keccakP(s: Uint32Array, rounds: number = 24)`

JSDoc:

SHA3 (keccak) hash function, based on a new "Sponge function" design.
Different from older hashes, the internal state is bigger than output size.

Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
[Website](https://keccak.team/keccak.html),
[the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).

Check out `sha3-addons` module for cSHAKE, k12, and others.
@module
/
import { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';
// prettier-ignore
import {
  abytes, aexists, anumber, aoutput,
  clean, createHasher, createXOFer, Hash,
  swap32IfBE,
  toBytes, u32,
  type CHash, type CHashXO, type HashXOF, type Input
} from './utils.ts';

// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI: number[] = [];
const SHA3_ROTL: number[] = [];
const _SHA3_IOTA: bigint[] = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  // Pi
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  // Rotational
  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
  // Iota
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
  }
  _SHA3_IOTA.push(t);
}
const IOTAS = split(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];

// Left rotation (without 0, 32, 64)
const rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
const rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));

/** `keccakf1600` internal function, additionally allows to adjust round count.

## isBytes

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `isBytes(a: unknown)`

JSDoc:

Utilities for hex, bytes, CSPRNG.
@module
/
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */

// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
import { crypto } from '@noble/hashes/crypto';

/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true.

## anumber

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `anumber(n: number)`

JSDoc:

Asserts something is positive integer.

## abytes

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `abytes(b: Uint8Array | undefined, ...lengths: number[])`

JSDoc:

Asserts something is Uint8Array.

## ahash

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `ahash(h: IHash)`

JSDoc:

Asserts something is hash

## aexists

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `aexists(instance: any, checkFinished = true)`

JSDoc:

Asserts a hash instance has not been destroyed / finished

## aoutput

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `aoutput(out: any, instance: any)`

JSDoc:

Asserts output is properly-sized byte array

## u8

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `u8(arr: TypedArray)`

JSDoc:

Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */
// prettier-ignore
export type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |
  Uint16Array | Int16Array | Uint32Array | Int32Array;

/** Cast u8 / u16 / u32 to u8.

## u32

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `u32(arr: TypedArray)`

JSDoc:

Cast u8 / u16 / u32 to u32.

## clean

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `clean(...arrays: TypedArray[])`

JSDoc:

Zeroize a byte array. Warning: JS provides no guarantees.

## createView

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `createView(arr: TypedArray)`

JSDoc:

Create DataView of an array for easy byte-level manipulation.

## rotr

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `rotr(word: number, shift: number)`

JSDoc:

The rotate right (circular right shift) operation for uint32

## rotl

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `rotl(word: number, shift: number)`

JSDoc:

The rotate left (circular left shift) operation for uint32

## byteSwap

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `byteSwap(word: number)`

JSDoc:

Is current platform little-endian? Most are. Big-Endian platform: IBM */
export const isLE: boolean = /* @__PURE__ */ (() =>
  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();

/** The byte swap operation for uint32

## byteSwap32

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `byteSwap32(arr: Uint32Array)`

JSDoc:

Conditionally byte swap if on a big-endian platform */
export const swap8IfBE: (n: number) => number = isLE
  ? (n: number) => n
  : (n: number) => byteSwap(n);

/** @deprecated */
export const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;
/** In place byte swap for Uint32Array

## bytesToHex

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `bytesToHex(bytes: Uint8Array)`

JSDoc:

Convert byte array to hex string. Uses built-in function, when available.
@example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'

## hexToBytes

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `hexToBytes(hex: string)`

JSDoc:

Convert hex string to byte array. Uses built-in function, when available.
@example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])

## utf8ToBytes

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `utf8ToBytes(str: string)`

JSDoc:

There is no setImmediate in browser and setTimeout is slow.
Call of async fn will return Promise, which will be fullfiled only on
next scheduler queue processing step and this is exactly what we need.
/
export const nextTick = async (): Promise<void> => {};

/** Returns control to thread each 'tick' ms to avoid blocking. */
export async function asyncLoop(
  iters: number,
  tick: number,
  cb: (i: number) => void
): Promise<void> {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick) continue;
    await nextTick();
    ts += diff;
  }
}

// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535
declare const TextEncoder: any;
declare const TextDecoder: any;

/**
Converts string to bytes using UTF8 encoding.
@example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])

## bytesToUtf8

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `bytesToUtf8(bytes: Uint8Array)`

JSDoc:

Converts bytes to string using UTF8 encoding.
@example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'

## toBytes

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `toBytes(data: Input)`

JSDoc:

Accepted input of hash functions. Strings are converted to byte arrays. */
export type Input = string | Uint8Array;
/**
Normalizes (non-hex) string or Uint8Array to Uint8Array.
Warning: when Uint8Array is passed, it would NOT get copied.
Keep in mind for future mutable operations.

## kdfInputToBytes

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `kdfInputToBytes(data: KDFInput)`

JSDoc:

KDFs can accept string or Uint8Array for user convenience. */
export type KDFInput = string | Uint8Array;
/**
Helper for KDFs: consumes uint8array or string.
When string is passed, does utf8 decoding, using TextDecoder.

## concatBytes

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `concatBytes(...arrays: Uint8Array[])`

JSDoc:

Copies several Uint8Arrays into one.

## createHasher

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `createHasher(<T extends Hash<T>>(
  hashCons: ()`

JSDoc:

Hash interface. */
export type IHash = {
  (data: Uint8Array): Uint8Array;
  blockLen: number;
  outputLen: number;
  create: any;
};

/** For runtime check if class implements interface */
export abstract class Hash<T extends Hash<T>> {
  abstract blockLen: number; // Bytes per block
  abstract outputLen: number; // Bytes in output
  abstract update(buf: Input): this;
  // Writes digest into buf
  abstract digestInto(buf: Uint8Array): void;
  abstract digest(): Uint8Array;
  /**
Resets internal state. Makes Hash instance unusable.
Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed
by user, they will need to manually call `destroy()` when zeroing is necessary.
/
  abstract destroy(): void;
  /**
Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`
when no options are passed.
Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal
buffers are overwritten => causes buffer overwrite which is used for digest in some cases.
There are no guarantees for clean-up because it's impossible in JS.
/
  abstract _cloneInto(to?: T): T;
  // Safe version that clones internal state
  abstract clone(): T;
}

/**
XOF: streaming API to read digest in chunks.
Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.
When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot
destroy state, next call can require more bytes.
/
export type HashXOF<T extends Hash<T>> = Hash<T> & {
  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream
  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf
};

/** Hash function */
export type CHash = ReturnType<typeof createHasher>;
/** Hash function with output */
export type CHashO = ReturnType<typeof createOptHasher>;
/** XOF with output */
export type CHashXO = ReturnType<typeof createXOFer>;

/** Wraps hash function, creating an interface on top of it

## randomBytes

Source: `my-backend/node_modules/@noble/hashes/src/utils.ts`

Signature: `randomBytes(bytesLength = 32)`

JSDoc:

Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`.

## isLE

Source: `my-backend/node_modules/@noble/hashes/utils.js`

Signature: `isLE(= (()`

JSDoc:

Utilities for hex, bytes, CSPRNG.
@module
/
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = require("@noble/hashes/crypto");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM

## swap8IfBE

Source: `my-backend/node_modules/@noble/hashes/utils.js`

Signature: `swap8IfBE(= exports.isLE
    ? (n)`

JSDoc:

The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform

## byteSwapIfBE

Source: `my-backend/node_modules/@noble/hashes/utils.js`

Signature: `byteSwapIfBE(= exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr)`

JSDoc:

@deprecated

## StandardType

Source: `my-backend/node_modules/@sinclair/typebox/typebox.js`

Signature: `StandardType(= new StandardTypeBuilder()`

JSDoc:

A registry for user defined types */
var TypeRegistry;
(function (TypeRegistry) {
    const map = new Map();
    /** Returns the entries in this registry */
    function Entries() {
        return new Map(map);
    }
    TypeRegistry.Entries = Entries;
    /** Clears all user defined types */
    function Clear() {
        return map.clear();
    }
    TypeRegistry.Clear = Clear;
    /** Returns true if this registry contains this kind */
    function Has(kind) {
        return map.has(kind);
    }
    TypeRegistry.Has = Has;
    /** Sets a validation function for a user defined type */
    function Set(kind, func) {
        map.set(kind, func);
    }
    TypeRegistry.Set = Set;
    /** Gets a custom validation function for a user defined type */
    function Get(kind) {
        return map.get(kind);
    }
    TypeRegistry.Get = Get;
})(TypeRegistry = exports.TypeRegistry || (exports.TypeRegistry = {}));
/** A registry for user defined string formats */
var FormatRegistry;
(function (FormatRegistry) {
    const map = new Map();
    /** Returns the entries in this registry */
    function Entries() {
        return new Map(map);
    }
    FormatRegistry.Entries = Entries;
    /** Clears all user defined string formats */
    function Clear() {
        return map.clear();
    }
    FormatRegistry.Clear = Clear;
    /** Returns true if the user defined string format exists */
    function Has(format) {
        return map.has(format);
    }
    FormatRegistry.Has = Has;
    /** Sets a validation function for a user defined string format */
    function Set(format, func) {
        map.set(format, func);
    }
    FormatRegistry.Set = Set;
    /** Gets a validation function for a user defined string format */
    function Get(format) {
        return map.get(format);
    }
    FormatRegistry.Get = Get;
})(FormatRegistry = exports.FormatRegistry || (exports.FormatRegistry = {}));
// --------------------------------------------------------------------------
// TypeGuard
// --------------------------------------------------------------------------
class TypeGuardUnknownTypeError extends Error {
    constructor(schema) {
        super('TypeGuard: Unknown type');
        this.schema = schema;
    }
}
exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
/** Provides functions to test if JavaScript values are TypeBox types */
var TypeGuard;
(function (TypeGuard) {
    function IsObject(value) {
        return typeof value === 'object' && value !== null && !Array.isArray(value);
    }
    function IsArray(value) {
        return typeof value === 'object' && value !== null && Array.isArray(value);
    }
    function IsPattern(value) {
        try {
            new RegExp(value);
            return true;
        }
        catch {
            return false;
        }
    }
    function IsControlCharacterFree(value) {
        if (typeof value !== 'string')
            return false;
        for (let i = 0; i < value.length; i++) {
            const code = value.charCodeAt(i);
            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {
                return false;
            }
        }
        return true;
    }
    function IsBigInt(value) {
        return typeof value === 'bigint';
    }
    function IsString(value) {
        return typeof value === 'string';
    }
    function IsNumber(value) {
        return typeof value === 'number' && globalThis.Number.isFinite(value);
    }
    function IsBoolean(value) {
        return typeof value === 'boolean';
    }
    function IsOptionalBigInt(value) {
        return value === undefined || (value !== undefined && IsBigInt(value));
    }
    function IsOptionalNumber(value) {
        return value === undefined || (value !== undefined && IsNumber(value));
    }
    function IsOptionalBoolean(value) {
        return value === undefined || (value !== undefined && IsBoolean(value));
    }
    function IsOptionalString(value) {
        return value === undefined || (value !== undefined && IsString(value));
    }
    function IsOptionalPattern(value) {
        return value === undefined || (value !== undefined && IsString(value) && IsControlCharacterFree(value) && IsPattern(value));
    }
    function IsOptionalFormat(value) {
        return value === undefined || (value !== undefined && IsString(value) && IsControlCharacterFree(value));
    }
    function IsOptionalSchema(value) {
        return value === undefined || TSchema(value);
    }
    /** Returns true if the given schema is TAny */
    function TAny(schema) {
        return TKind(schema) && schema[exports.Kind] === 'Any' && IsOptionalString(schema.$id);
    }
    TypeGuard.TAny = TAny;
    /** Returns true if the given schema is TArray */
    function TArray(schema) {
        return (TKind(schema) &&
            schema[exports.Kind] === 'Array' &&
            schema.type === 'array' &&
            IsOptionalString(schema.$id) &&
            TSchema(schema.items) &&
            IsOptionalNumber(schema.minItems) &&
            IsOptionalNumber(schema.maxItems) &&
            IsOptionalBoolean(schema.uniqueItems));
    }
    TypeGuard.TArray = TArray;
    /** Returns true if the given schema is TBigInt */
    function TBigInt(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'BigInt' &&
            schema.type === 'null' &&
            schema.typeOf === 'BigInt' &&
            IsOptionalString(schema.$id) &&
            IsOptionalBigInt(schema.multipleOf) &&
            IsOptionalBigInt(schema.minimum) &&
            IsOptionalBigInt(schema.maximum) &&
            IsOptionalBigInt(schema.exclusiveMinimum) &&
            IsOptionalBigInt(schema.exclusiveMaximum));
    }
    TypeGuard.TBigInt = TBigInt;
    /** Returns true if the given schema is TBoolean */
    function TBoolean(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Boolean' &&
            schema.type === 'boolean' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TBoolean = TBoolean;
    /** Returns true if the given schema is TConstructor */
    function TConstructor(schema) {
        // prettier-ignore
        if (!(TKind(schema) &&
            schema[exports.Kind] === 'Constructor' &&
            schema.type === 'object' &&
            schema.instanceOf === 'Constructor' &&
            IsOptionalString(schema.$id) &&
            IsArray(schema.parameters) &&
            TSchema(schema.returns))) {
            return false;
        }
        for (const parameter of schema.parameters) {
            if (!TSchema(parameter))
                return false;
        }
        return true;
    }
    TypeGuard.TConstructor = TConstructor;
    /** Returns true if the given schema is TDate */
    function TDate(schema) {
        return (TKind(schema) &&
            schema[exports.Kind] === 'Date' &&
            schema.type === 'object' &&
            schema.instanceOf === 'Date' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.minimumTimestamp) &&
            IsOptionalNumber(schema.maximumTimestamp) &&
            IsOptionalNumber(schema.exclusiveMinimumTimestamp) &&
            IsOptionalNumber(schema.exclusiveMaximumTimestamp));
    }
    TypeGuard.TDate = TDate;
    /** Returns true if the given schema is TFunction */
    function TFunction(schema) {
        // prettier-ignore
        if (!(TKind(schema) &&
            schema[exports.Kind] === 'Function' &&
            schema.type === 'object' &&
            schema.instanceOf === 'Function' &&
            IsOptionalString(schema.$id) &&
            IsArray(schema.parameters) &&
            TSchema(schema.returns))) {
            return false;
        }
        for (const parameter of schema.parameters) {
            if (!TSchema(parameter))
                return false;
        }
        return true;
    }
    TypeGuard.TFunction = TFunction;
    /** Returns true if the given schema is TInteger */
    function TInteger(schema) {
        return (TKind(schema) &&
            schema[exports.Kind] === 'Integer' &&
            schema.type === 'integer' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.multipleOf) &&
            IsOptionalNumber(schema.minimum) &&
            IsOptionalNumber(schema.maximum) &&
            IsOptionalNumber(schema.exclusiveMinimum) &&
            IsOptionalNumber(schema.exclusiveMaximum));
    }
    TypeGuard.TInteger = TInteger;
    /** Returns true if the given schema is TIntersect */
    function TIntersect(schema) {
        // prettier-ignore
        if (!(TKind(schema) &&
            schema[exports.Kind] === 'Intersect' &&
            IsArray(schema.allOf) &&
            IsOptionalString(schema.type) &&
            (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &&
            IsOptionalString(schema.$id))) {
            return false;
        }
        if ('type' in schema && schema.type !== 'object') {
            return false;
        }
        for (const inner of schema.allOf) {
            if (!TSchema(inner))
                return false;
        }
        return true;
    }
    TypeGuard.TIntersect = TIntersect;
    /** Returns true if the given schema is TKind */
    function TKind(schema) {
        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === 'string'; // TS 4.1.5: any required for symbol indexer
    }
    TypeGuard.TKind = TKind;
    /** Returns true if the given schema is TLiteral */
    function TLiteral(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Literal' &&
            IsOptionalString(schema.$id) &&
            (IsString(schema.const) ||
                IsNumber(schema.const) ||
                IsBoolean(schema.const) ||
                IsBigInt(schema.const)));
    }
    TypeGuard.TLiteral = TLiteral;
    /** Returns true if the given schema is TNever */
    function TNever(schema) {
        return TKind(schema) && schema[exports.Kind] === 'Never' && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;
    }
    TypeGuard.TNever = TNever;
    /** Returns true if the given schema is TNot */
    function TNot(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Not' &&
            IsArray(schema.allOf) &&
            schema.allOf.length === 2 &&
            IsObject(schema.allOf[0]) &&
            TSchema(schema.allOf[0].not) &&
            TSchema(schema.allOf[1]));
    }
    TypeGuard.TNot = TNot;
    /** Returns true if the given schema is TNull */
    function TNull(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Null' &&
            schema.type === 'null' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TNull = TNull;
    /** Returns true if the given schema is TNumber */
    function TNumber(schema) {
        return (TKind(schema) &&
            schema[exports.Kind] === 'Number' &&
            schema.type === 'number' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.multipleOf) &&
            IsOptionalNumber(schema.minimum) &&
            IsOptionalNumber(schema.maximum) &&
            IsOptionalNumber(schema.exclusiveMinimum) &&
            IsOptionalNumber(schema.exclusiveMaximum));
    }
    TypeGuard.TNumber = TNumber;
    /** Returns true if the given schema is TObject */
    function TObject(schema) {
        if (!(TKind(schema) &&
            schema[exports.Kind] === 'Object' &&
            schema.type === 'object' &&
            IsOptionalString(schema.$id) &&
            IsObject(schema.properties) &&
            (IsOptionalBoolean(schema.additionalProperties) || IsOptionalSchema(schema.additionalProperties)) &&
            IsOptionalNumber(schema.minProperties) &&
            IsOptionalNumber(schema.maxProperties))) {
            return false;
        }
        for (const [key, value] of Object.entries(schema.properties)) {
            if (!IsControlCharacterFree(key))
                return false;
            if (!TSchema(value))
                return false;
        }
        return true;
    }
    TypeGuard.TObject = TObject;
    /** Returns true if the given schema is TPromise */
    function TPromise(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Promise' &&
            schema.type === 'object' &&
            schema.instanceOf === 'Promise' &&
            IsOptionalString(schema.$id) &&
            TSchema(schema.item));
    }
    TypeGuard.TPromise = TPromise;
    /** Returns true if the given schema is TRecord */
    function TRecord(schema) {
        // prettier-ignore
        if (!(TKind(schema) &&
            schema[exports.Kind] === 'Record' &&
            schema.type === 'object' &&
            IsOptionalString(schema.$id) &&
            schema.additionalProperties === false &&
            IsObject(schema.patternProperties))) {
            return false;
        }
        const keys = Object.keys(schema.patternProperties);
        if (keys.length !== 1) {
            return false;
        }
        if (!IsPattern(keys[0])) {
            return false;
        }
        if (!TSchema(schema.patternProperties[keys[0]])) {
            return false;
        }
        return true;
    }
    TypeGuard.TRecord = TRecord;
    /** Returns true if the given schema is TRef */
    function TRef(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Ref' &&
            IsOptionalString(schema.$id) &&
            IsString(schema.$ref));
    }
    TypeGuard.TRef = TRef;
    /** Returns true if the given schema is TString */
    function TString(schema) {
        return (TKind(schema) &&
            schema[exports.Kind] === 'String' &&
            schema.type === 'string' &&
            IsOptionalString(schema.$id) &&
            IsOptionalNumber(schema.minLength) &&
            IsOptionalNumber(schema.maxLength) &&
            IsOptionalPattern(schema.pattern) &&
            IsOptionalFormat(schema.format));
    }
    TypeGuard.TString = TString;
    /** Returns true if the given schema is TSymbol */
    function TSymbol(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Symbol' &&
            schema.type === 'null' &&
            schema.typeOf === 'Symbol' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TSymbol = TSymbol;
    /** Returns true if the given schema is TTemplateLiteral */
    function TTemplateLiteral(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'TemplateLiteral' &&
            schema.type === 'string' &&
            IsString(schema.pattern) &&
            schema.pattern[0] === '^' &&
            schema.pattern[schema.pattern.length - 1] === '$');
    }
    TypeGuard.TTemplateLiteral = TTemplateLiteral;
    /** Returns true if the given schema is TThis */
    function TThis(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'This' &&
            IsOptionalString(schema.$id) &&
            IsString(schema.$ref));
    }
    TypeGuard.TThis = TThis;
    /** Returns true if the given schema is TTuple */
    function TTuple(schema) {
        // prettier-ignore
        if (!(TKind(schema) &&
            schema[exports.Kind] === 'Tuple' &&
            schema.type === 'array' &&
            IsOptionalString(schema.$id) &&
            IsNumber(schema.minItems) &&
            IsNumber(schema.maxItems) &&
            schema.minItems === schema.maxItems)) {
            return false;
        }
        if (schema.items === undefined && schema.additionalItems === undefined && schema.minItems === 0) {
            return true;
        }
        if (!IsArray(schema.items)) {
            return false;
        }
        for (const inner of schema.items) {
            if (!TSchema(inner))
                return false;
        }
        return true;
    }
    TypeGuard.TTuple = TTuple;
    /** Returns true if the given schema is TUndefined */
    function TUndefined(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Undefined' &&
            schema.type === 'null' &&
            schema.typeOf === 'Undefined' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TUndefined = TUndefined;
    /** Returns true if the given schema is TUnion */
    function TUnion(schema) {
        // prettier-ignore
        if (!(TKind(schema) &&
            schema[exports.Kind] === 'Union' &&
            IsArray(schema.anyOf) &&
            IsOptionalString(schema.$id))) {
            return false;
        }
        for (const inner of schema.anyOf) {
            if (!TSchema(inner))
                return false;
        }
        return true;
    }
    TypeGuard.TUnion = TUnion;
    /** Returns true if the given schema is TUnion<Literal<string>[]> */
    function TUnionLiteral(schema) {
        return TUnion(schema) && schema.anyOf.every((schema) => TLiteral(schema) && typeof schema.const === 'string');
    }
    TypeGuard.TUnionLiteral = TUnionLiteral;
    /** Returns true if the given schema is TUint8Array */
    function TUint8Array(schema) {
        return TKind(schema) && schema[exports.Kind] === 'Uint8Array' && schema.type === 'object' && IsOptionalString(schema.$id) && schema.instanceOf === 'Uint8Array' && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
    }
    TypeGuard.TUint8Array = TUint8Array;
    /** Returns true if the given schema is TUnknown */
    function TUnknown(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Unknown' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TUnknown = TUnknown;
    /** Returns true if the given schema is a raw TUnsafe */
    function TUnsafe(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Unsafe');
    }
    TypeGuard.TUnsafe = TUnsafe;
    /** Returns true if the given schema is TVoid */
    function TVoid(schema) {
        // prettier-ignore
        return (TKind(schema) &&
            schema[exports.Kind] === 'Void' &&
            schema.type === 'null' &&
            schema.typeOf === 'Void' &&
            IsOptionalString(schema.$id));
    }
    TypeGuard.TVoid = TVoid;
    /** Returns true if this schema has the ReadonlyOptional modifier */
    function TReadonlyOptional(schema) {
        return IsObject(schema) && schema[exports.Modifier] === 'ReadonlyOptional';
    }
    TypeGuard.TReadonlyOptional = TReadonlyOptional;
    /** Returns true if this schema has the Readonly modifier */
    function TReadonly(schema) {
        return IsObject(schema) && schema[exports.Modifier] === 'Readonly';
    }
    TypeGuard.TReadonly = TReadonly;
    /** Returns true if this schema has the Optional modifier */
    function TOptional(schema) {
        return IsObject(schema) && schema[exports.Modifier] === 'Optional';
    }
    TypeGuard.TOptional = TOptional;
    /** Returns true if the given schema is TSchema */
    function TSchema(schema) {
        return (typeof schema === 'object' &&
            (TAny(schema) ||
                TArray(schema) ||
                TBoolean(schema) ||
                TBigInt(schema) ||
                TConstructor(schema) ||
                TDate(schema) ||
                TFunction(schema) ||
                TInteger(schema) ||
                TIntersect(schema) ||
                TLiteral(schema) ||
                TNever(schema) ||
                TNot(schema) ||
                TNull(schema) ||
                TNumber(schema) ||
                TObject(schema) ||
                TPromise(schema) ||
                TRecord(schema) ||
                TRef(schema) ||
                TString(schema) ||
                TSymbol(schema) ||
                TTemplateLiteral(schema) ||
                TThis(schema) ||
                TTuple(schema) ||
                TUndefined(schema) ||
                TUnion(schema) ||
                TUint8Array(schema) ||
                TUnknown(schema) ||
                TUnsafe(schema) ||
                TVoid(schema) ||
                (TKind(schema) && TypeRegistry.Has(schema[exports.Kind]))));
    }
    TypeGuard.TSchema = TSchema;
})(TypeGuard = exports.TypeGuard || (exports.TypeGuard = {}));
// --------------------------------------------------------------------------
// ExtendsUndefined
// --------------------------------------------------------------------------
/** Fast undefined check used for properties of type undefined */
var ExtendsUndefined;
(function (ExtendsUndefined) {
    function Check(schema) {
        if (schema[exports.Kind] === 'Undefined')
            return true;
        if (schema[exports.Kind] === 'Union') {
            const union = schema;
            return union.anyOf.some((schema) => Check(schema));
        }
        return false;
    }
    ExtendsUndefined.Check = Check;
})(ExtendsUndefined = exports.ExtendsUndefined || (exports.ExtendsUndefined = {}));
// --------------------------------------------------------------------------
// TypeExtends
// --------------------------------------------------------------------------
var TypeExtendsResult;
(function (TypeExtendsResult) {
    TypeExtendsResult[TypeExtendsResult["Union"] = 0] = "Union";
    TypeExtendsResult[TypeExtendsResult["True"] = 1] = "True";
    TypeExtendsResult[TypeExtendsResult["False"] = 2] = "False";
})(TypeExtendsResult = exports.TypeExtendsResult || (exports.TypeExtendsResult = {}));
var TypeExtends;
(function (TypeExtends) {
    // --------------------------------------------------------------------------
    // IntoBooleanResult
    // --------------------------------------------------------------------------
    function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    // --------------------------------------------------------------------------
    // Any
    // --------------------------------------------------------------------------
    function AnyRight(left, right) {
        return TypeExtendsResult.True;
    }
    function Any(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))
            return TypeExtendsResult.True;
        if (TypeGuard.TUnion(right))
            return TypeExtendsResult.Union;
        if (TypeGuard.TUnknown(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TAny(right))
            return TypeExtendsResult.True;
        return TypeExtendsResult.Union;
    }
    // --------------------------------------------------------------------------
    // Array
    // --------------------------------------------------------------------------
    function ArrayRight(left, right) {
        if (TypeGuard.TUnknown(left))
            return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
            return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
            return TypeExtendsResult.True;
        return TypeExtendsResult.False;
    }
    function Array(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
            return TypeExtendsResult.True;
        if (!TypeGuard.TArray(right))
            return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.items, right.items));
    }
    // --------------------------------------------------------------------------
    // BigInt
    // --------------------------------------------------------------------------
    function BigInt(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Boolean
    // --------------------------------------------------------------------------
    function BooleanRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === 'boolean')
            return TypeExtendsResult.True;
        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Boolean(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Constructor
    // --------------------------------------------------------------------------
    function Constructor(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (!TypeGuard.TConstructor(right))
            return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
            return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
            return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
    }
    // --------------------------------------------------------------------------
    // Date
    // --------------------------------------------------------------------------
    function Date(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Function
    // --------------------------------------------------------------------------
    function Function(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (!TypeGuard.TFunction(right))
            return TypeExtendsResult.False;
        if (left.parameters.length > right.parameters.length)
            return TypeExtendsResult.False;
        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {
            return TypeExtendsResult.False;
        }
        return IntoBooleanResult(Visit(left.returns, right.returns));
    }
    // --------------------------------------------------------------------------
    // Integer
    // --------------------------------------------------------------------------
    function IntegerRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === 'number')
            return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Integer(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Intersect
    // --------------------------------------------------------------------------
    function IntersectRight(left, right) {
        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Intersect(left, right) {
        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Literal
    // --------------------------------------------------------------------------
    function IsLiteralString(schema) {
        return typeof schema.const === 'string';
    }
    function IsLiteralNumber(schema) {
        return typeof schema.const === 'number';
    }
    function IsLiteralBoolean(schema) {
        return typeof schema.const === 'boolean';
    }
    function Literal(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        if (TypeGuard.TString(right))
            return StringRight(left, right);
        if (TypeGuard.TNumber(right))
            return NumberRight(left, right);
        if (TypeGuard.TInteger(right))
            return IntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
            return BooleanRight(left, right);
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Never
    // --------------------------------------------------------------------------
    function NeverRight(left, right) {
        return TypeExtendsResult.False;
    }
    function Never(left, right) {
        return TypeExtendsResult.True;
    }
    // --------------------------------------------------------------------------
    // Null
    // --------------------------------------------------------------------------
    function Null(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Number
    // --------------------------------------------------------------------------
    function NumberRight(left, right) {
        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left))
            return TypeExtendsResult.True;
        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Number(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Object
    // --------------------------------------------------------------------------
    function IsObjectPropertyCount(schema, count) {
        return globalThis.Object.keys(schema.properties).length === count;
    }
    function IsObjectStringLike(schema) {
        return IsObjectArrayLike(schema);
    }
    function IsObjectSymbolLike(schema) {
        // prettier-ignore
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.TString(schema.properties.description.anyOf[0]) &&
            TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &&
            TypeGuard.TUndefined(schema.properties.description.anyOf[0]))));
    }
    function IsObjectNumberLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBooleanLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBigIntLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectDateLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectUint8ArrayLike(schema) {
        return IsObjectArrayLike(schema);
    }
    function IsObjectFunctionLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);
    }
    function IsObjectConstructorLike(schema) {
        return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectArrayLike(schema) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);
    }
    function IsObjectPromiseLike(schema) {
        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);
    }
    // --------------------------------------------------------------------------
    // Property
    // --------------------------------------------------------------------------
    function Property(left, right) {
        if (Visit(left, right) === TypeExtendsResult.False)
            return TypeExtendsResult.False;
        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))
            return TypeExtendsResult.False;
        return TypeExtendsResult.True;
    }
    function ObjectRight(left, right) {
        if (TypeGuard.TUnknown(left))
            return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
            return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
            return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TString(left) && IsObjectStringLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TDate(left) && IsObjectDateLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {
            // When expressing a Record with literal key values, the Record is converted into a Object with
            // the Hint assigned as `Record`. This is used to invert the extends logic.
            return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {
            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        }
        return TypeExtendsResult.False;
    }
    function Object(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        if (!TypeGuard.TObject(right))
            return TypeExtendsResult.False;
        for (const key of globalThis.Object.keys(right.properties)) {
            if (!(key in left.properties))
                return TypeExtendsResult.False;
            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
                return TypeExtendsResult.False;
            }
        }
        return TypeExtendsResult.True;
    }
    // --------------------------------------------------------------------------
    // Promise
    // --------------------------------------------------------------------------
    function Promise(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))
            return TypeExtendsResult.True;
        if (!TypeGuard.TPromise(right))
            return TypeExtendsResult.False;
        return IntoBooleanResult(Visit(left.item, right.item));
    }
    // --------------------------------------------------------------------------
    // Record
    // --------------------------------------------------------------------------
    function RecordKey(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
            return exports.Type.Number();
        if (exports.PatternStringExact in schema.patternProperties)
            return exports.Type.String();
        throw Error('TypeExtends: Cannot get record key');
    }
    function RecordValue(schema) {
        if (exports.PatternNumberExact in schema.patternProperties)
            return schema.patternProperties[exports.PatternNumberExact];
        if (exports.PatternStringExact in schema.patternProperties)
            return schema.patternProperties[exports.PatternStringExact];
        throw Error('TypeExtends: Cannot get record value');
    }
    function RecordRight(left, right) {
        const Key = RecordKey(right);
        const Value = RecordValue(right);
        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)
            return TypeExtendsResult.True;
        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))
            return Visit(left, Value);
        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))
            return Visit(left, Value);
        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))
            return Visit(left, Value);
        if (TypeGuard.TObject(left)) {
            for (const key of globalThis.Object.keys(left.properties)) {
                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
                    return TypeExtendsResult.False;
                }
            }
            return TypeExtendsResult.True;
        }
        return TypeExtendsResult.False;
    }
    function Record(left, right) {
        const Value = RecordValue(left);
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (!TypeGuard.TRecord(right))
            return TypeExtendsResult.False;
        return Visit(Value, RecordValue(right));
    }
    // --------------------------------------------------------------------------
    // String
    // --------------------------------------------------------------------------
    function StringRight(left, right) {
        if (TypeGuard.TLiteral(left) && typeof left.const === 'string')
            return TypeExtendsResult.True;
        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function String(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Symbol
    // --------------------------------------------------------------------------
    function Symbol(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Tuple
    // --------------------------------------------------------------------------
    function TupleRight(left, right) {
        if (TypeGuard.TUnknown(left))
            return TypeExtendsResult.False;
        if (TypeGuard.TAny(left))
            return TypeExtendsResult.Union;
        if (TypeGuard.TNever(left))
            return TypeExtendsResult.True;
        return TypeExtendsResult.False;
    }
    function IsArrayOfTuple(left, right) {
        return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
    }
    function Tuple(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))
            return TypeExtendsResult.True;
        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))
            return TypeExtendsResult.True;
        if (!TypeGuard.TTuple(right))
            return TypeExtendsResult.False;
        if ((left.items === undefined && right.items !== undefined) || (left.items !== undefined && right.items === undefined))
            return TypeExtendsResult.False;
        if (left.items === undefined && right.items === undefined)
            return TypeExtendsResult.True;
        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Uint8Array
    // --------------------------------------------------------------------------
    function Uint8Array(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Undefined
    // --------------------------------------------------------------------------
    function Undefined(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TNever(right))
            return NeverRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        if (TypeGuard.TRecord(right))
            return RecordRight(left, right);
        if (TypeGuard.TVoid(right))
            return VoidRight(left, right);
        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Union
    // --------------------------------------------------------------------------
    function UnionRight(left, right) {
        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Union(left, right) {
        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Unknown
    // --------------------------------------------------------------------------
    function UnknownRight(left, right) {
        return TypeExtendsResult.True;
    }
    function Unknown(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TString(right))
            return StringRight(left, right);
        if (TypeGuard.TNumber(right))
            return NumberRight(left, right);
        if (TypeGuard.TInteger(right))
            return IntegerRight(left, right);
        if (TypeGuard.TBoolean(right))
            return BooleanRight(left, right);
        if (TypeGuard.TArray(right))
            return ArrayRight(left, right);
        if (TypeGuard.TTuple(right))
            return TupleRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    // --------------------------------------------------------------------------
    // Void
    // --------------------------------------------------------------------------
    function VoidRight(left, right) {
        if (TypeGuard.TUndefined(left))
            return TypeExtendsResult.True;
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Void(left, right) {
        if (TypeGuard.TIntersect(right))
            return IntersectRight(left, right);
        if (TypeGuard.TUnion(right))
            return UnionRight(left, right);
        if (TypeGuard.TUnknown(right))
            return UnknownRight(left, right);
        if (TypeGuard.TAny(right))
            return AnyRight(left, right);
        if (TypeGuard.TObject(right))
            return ObjectRight(left, right);
        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Visit(left, right) {
        // template union remap
        if (TypeGuard.TTemplateLiteral(left))
            return Visit(TemplateLiteralResolver.Resolve(left), right);
        if (TypeGuard.TTemplateLiteral(right))
            return Visit(left, TemplateLiteralResolver.Resolve(right));
        // standard extends
        if (TypeGuard.TAny(left))
            return Any(left, right);
        if (TypeGuard.TArray(left))
            return Array(left, right);
        if (TypeGuard.TBigInt(left))
            return BigInt(left, right);
        if (TypeGuard.TBoolean(left))
            return Boolean(left, right);
        if (TypeGuard.TConstructor(left))
            return Constructor(left, right);
        if (TypeGuard.TDate(left))
            return Date(left, right);
        if (TypeGuard.TFunction(left))
            return Function(left, right);
        if (TypeGuard.TInteger(left))
            return Integer(left, right);
        if (TypeGuard.TIntersect(left))
            return Intersect(left, right);
        if (TypeGuard.TLiteral(left))
            return Literal(left, right);
        if (TypeGuard.TNever(left))
            return Never(left, right);
        if (TypeGuard.TNull(left))
            return Null(left, right);
        if (TypeGuard.TNumber(left))
            return Number(left, right);
        if (TypeGuard.TObject(left))
            return Object(left, right);
        if (TypeGuard.TRecord(left))
            return Record(left, right);
        if (TypeGuard.TString(left))
            return String(left, right);
        if (TypeGuard.TSymbol(left))
            return Symbol(left, right);
        if (TypeGuard.TTuple(left))
            return Tuple(left, right);
        if (TypeGuard.TPromise(left))
            return Promise(left, right);
        if (TypeGuard.TUint8Array(left))
            return Uint8Array(left, right);
        if (TypeGuard.TUndefined(left))
            return Undefined(left, right);
        if (TypeGuard.TUnion(left))
            return Union(left, right);
        if (TypeGuard.TUnknown(left))
            return Unknown(left, right);
        if (TypeGuard.TVoid(left))
            return Void(left, right);
        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);
    }
    function Extends(left, right) {
        return Visit(left, right);
    }
    TypeExtends.Extends = Extends;
})(TypeExtends = exports.TypeExtends || (exports.TypeExtends = {}));
// --------------------------------------------------------------------------
// TypeClone
// --------------------------------------------------------------------------
/** Specialized Clone for Types */
var TypeClone;
(function (TypeClone) {
    function IsObject(value) {
        return typeof value === 'object' && value !== null;
    }
    function IsArray(value) {
        return globalThis.Array.isArray(value);
    }
    function Array(value) {
        return value.map((value) => Visit(value));
    }
    function Object(value) {
        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {
            return { ...acc, [key]: Visit(value[key]) };
        }, {});
        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) => {
            return { ...acc, [key]: Visit(value[key]) };
        }, {});
        return { ...clonedProperties, ...clonedSymbols };
    }
    function Visit(value) {
        if (IsArray(value))
            return Array(value);
        if (IsObject(value))
            return Object(value);
        return value;
    }
    /** Clones a type. */
    function Clone(schema, options) {
        return { ...Visit(schema), ...options };
    }
    TypeClone.Clone = Clone;
})(TypeClone = exports.TypeClone || (exports.TypeClone = {}));
// --------------------------------------------------------------------------
// ObjectMap
// --------------------------------------------------------------------------
var ObjectMap;
(function (ObjectMap) {
    function Intersect(schema, callback) {
        // prettier-ignore
        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
    }
    function Union(schema, callback) {
        // prettier-ignore
        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
    }
    function Object(schema, callback) {
        return callback(schema);
    }
    function Visit(schema, callback) {
        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would
        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the
        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only
        // used for composition, we use explicit checks instead.
        if (schema[exports.Kind] === 'Intersect')
            return Intersect(schema, callback);
        if (schema[exports.Kind] === 'Union')
            return Union(schema, callback);
        if (schema[exports.Kind] === 'Object')
            return Object(schema, callback);
        return schema;
    }
    function Map(schema, callback, options) {
        return { ...Visit(TypeClone.Clone(schema, {}), callback), ...options };
    }
    ObjectMap.Map = Map;
})(ObjectMap = exports.ObjectMap || (exports.ObjectMap = {}));
// --------------------------------------------------------------------------
// KeyResolver
// --------------------------------------------------------------------------
var KeyResolver;
(function (KeyResolver) {
    function IsKeyable(schema) {
        return TypeGuard.TIntersect(schema) || TypeGuard.TUnion(schema) || (TypeGuard.TObject(schema) && globalThis.Object.getOwnPropertyNames(schema.properties).length > 0);
    }
    function Intersect(schema) {
        return [...schema.allOf.filter((schema) => IsKeyable(schema)).reduce((set, schema) => Visit(schema).map((key) => set.add(key))[0], new Set())];
    }
    function Union(schema) {
        const sets = schema.anyOf.filter((schema) => IsKeyable(schema)).map((inner) => Visit(inner));
        return [...sets.reduce((set, outer) => outer.map((key) => (sets.every((inner) => inner.includes(key)) ? set.add(key) : set))[0], new Set())];
    }
    function Object(schema) {
        return globalThis.Object.keys(schema.properties);
    }
    function Visit(schema) {
        if (TypeGuard.TIntersect(schema))
            return Intersect(schema);
        if (TypeGuard.TUnion(schema))
            return Union(schema);
        if (TypeGuard.TObject(schema))
            return Object(schema);
        return [];
    }
    function Resolve(schema) {
        return Visit(schema);
    }
    KeyResolver.Resolve = Resolve;
})(KeyResolver = exports.KeyResolver || (exports.KeyResolver = {}));
// --------------------------------------------------------------------------
// TemplateLiteralPattern
// --------------------------------------------------------------------------
var TemplateLiteralPattern;
(function (TemplateLiteralPattern) {
    function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    function Visit(schema, acc) {
        if (TypeGuard.TTemplateLiteral(schema)) {
            const pattern = schema.pattern.slice(1, schema.pattern.length - 1);
            return pattern;
        }
        else if (TypeGuard.TUnion(schema)) {
            const tokens = schema.anyOf.map((schema) => Visit(schema, acc)).join('|');
            return `(${tokens})`;
        }
        else if (TypeGuard.TNumber(schema)) {
            return `${acc}${exports.PatternNumber}`;
        }
        else if (TypeGuard.TInteger(schema)) {
            return `${acc}${exports.PatternNumber}`;
        }
        else if (TypeGuard.TBigInt(schema)) {
            return `${acc}${exports.PatternNumber}`;
        }
        else if (TypeGuard.TString(schema)) {
            return `${acc}${exports.PatternString}`;
        }
        else if (TypeGuard.TLiteral(schema)) {
            return `${acc}${Escape(schema.const.toString())}`;
        }
        else if (TypeGuard.TBoolean(schema)) {
            return `${acc}${exports.PatternBoolean}`;
        }
        else if (TypeGuard.TNever(schema)) {
            throw Error('TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever');
        }
        else {
            throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);
        }
    }
    function Create(kinds) {
        return `^${kinds.map((schema) => Visit(schema, '')).join('')}\$`;
    }
    TemplateLiteralPattern.Create = Create;
})(TemplateLiteralPattern = exports.TemplateLiteralPattern || (exports.TemplateLiteralPattern = {}));
// --------------------------------------------------------------------------------------
// TemplateLiteralResolver
// --------------------------------------------------------------------------------------
var TemplateLiteralResolver;
(function (TemplateLiteralResolver) {
    function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
            return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
        return exports.Type.Union(literals);
    }
    TemplateLiteralResolver.Resolve = Resolve;
})(TemplateLiteralResolver = exports.TemplateLiteralResolver || (exports.TemplateLiteralResolver = {}));
// --------------------------------------------------------------------------------------
// TemplateLiteralParser
// --------------------------------------------------------------------------------------
class TemplateLiteralParserError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.TemplateLiteralParserError = TemplateLiteralParserError;
var TemplateLiteralParser;
(function (TemplateLiteralParser) {
    function IsNonEscaped(pattern, index, char) {
        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern, index) {
        return IsNonEscaped(pattern, index, '(');
    }
    function IsCloseParen(pattern, index) {
        return IsNonEscaped(pattern, index, ')');
    }
    function IsSeparator(pattern, index) {
        return IsNonEscaped(pattern, index, '|');
    }
    function IsGroup(pattern) {
        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
            return false;
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (count === 0 && index !== pattern.length - 1)
                return false;
        }
        return true;
    }
    function InGroup(pattern) {
        return pattern.slice(1, pattern.length - 1);
    }
    function IsPrecedenceOr(pattern) {
        let count = 0;
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (IsSeparator(pattern, index) && count === 0)
                return true;
        }
        return false;
    }
    function IsPrecedenceAnd(pattern) {
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                return true;
        }
        return false;
    }
    function Or(pattern) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index))
                count += 1;
            if (IsCloseParen(pattern, index))
                count -= 1;
            if (IsSeparator(pattern, index) && count === 0) {
                const range = pattern.slice(start, index);
                if (range.length > 0)
                    expressions.push(Parse(range));
                start = index + 1;
            }
        }
        const range = pattern.slice(start);
        if (range.length > 0)
            expressions.push(Parse(range));
        if (expressions.length === 0)
            return { type: 'const', const: '' };
        if (expressions.length === 1)
            return expressions[0];
        return { type: 'or', expr: expressions };
    }
    function And(pattern) {
        function Group(value, index) {
            if (!IsOpenParen(value, index))
                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
            let count = 0;
            for (let scan = index; scan < value.length; scan++) {
                if (IsOpenParen(value, scan))
                    count += 1;
                if (IsCloseParen(value, scan))
                    count -= 1;
                if (count === 0)
                    return [index, scan];
            }
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range(pattern, index) {
            for (let scan = index; scan < pattern.length; scan++) {
                if (IsOpenParen(pattern, scan))
                    return [index, scan];
            }
            return [index, pattern.length];
        }
        const expressions = [];
        for (let index = 0; index < pattern.length; index++) {
            if (IsOpenParen(pattern, index)) {
                const [start, end] = Group(pattern, index);
                const range = pattern.slice(start, end + 1);
                expressions.push(Parse(range));
                index = end;
            }
            else {
                const [start, end] = Range(pattern, index);
                const range = pattern.slice(start, end);
                if (range.length > 0)
                    expressions.push(Parse(range));
                index = end - 1;
            }
        }
        if (expressions.length === 0)
            return { type: 'const', const: '' };
        if (expressions.length === 1)
            return expressions[0];
        return { type: 'and', expr: expressions };
    }
    /** Parses a pattern and returns an expression tree */
    function Parse(pattern) {
        if (IsGroup(pattern))
            return Parse(InGroup(pattern));
        if (IsPrecedenceOr(pattern))
            return Or(pattern);
        if (IsPrecedenceAnd(pattern))
            return And(pattern);
        return { type: 'const', const: pattern };
    }
    TemplateLiteralParser.Parse = Parse;
    /** Parses a pattern and strips forward and trailing ^ and $ */
    function ParseExact(pattern) {
        return Parse(pattern.slice(1, pattern.length - 1));
    }
    TemplateLiteralParser.ParseExact = ParseExact;
})(TemplateLiteralParser = exports.TemplateLiteralParser || (exports.TemplateLiteralParser = {}));
// --------------------------------------------------------------------------------------
// TemplateLiteralFinite
// --------------------------------------------------------------------------------------
var TemplateLiteralFinite;
(function (TemplateLiteralFinite) {
    function IsNumber(expression) {
        // prettier-ignore
        return (expression.type === 'or' &&
            expression.expr.length === 2 &&
            expression.expr[0].type === 'const' &&
            expression.expr[0].const === '0' &&
            expression.expr[1].type === 'const' &&
            expression.expr[1].const === '[1-9][0-9]*');
    }
    function IsBoolean(expression) {
        // prettier-ignore
        return (expression.type === 'or' &&
            expression.expr.length === 2 &&
            expression.expr[0].type === 'const' &&
            expression.expr[0].const === 'true' &&
            expression.expr[1].type === 'const' &&
            expression.expr[1].const === 'false');
    }
    function IsString(expression) {
        return expression.type === 'const' && expression.const === '.*';
    }
    function Check(expression) {
        if (IsBoolean(expression))
            return true;
        if (IsNumber(expression) || IsString(expression))
            return false;
        if (expression.type === 'and')
            return expression.expr.every((expr) => Check(expr));
        if (expression.type === 'or')
            return expression.expr.every((expr) => Check(expr));
        if (expression.type === 'const')
            return true;
        throw Error(`TemplateLiteralFinite: Unknown expression type`);
    }
    TemplateLiteralFinite.Check = Check;
})(TemplateLiteralFinite = exports.TemplateLiteralFinite || (exports.TemplateLiteralFinite = {}));
// --------------------------------------------------------------------------------------
// TemplateLiteralGenerator
// --------------------------------------------------------------------------------------
var TemplateLiteralGenerator;
(function (TemplateLiteralGenerator) {
    function* Reduce(buffer) {
        if (buffer.length === 1)
            return yield* buffer[0];
        for (const left of buffer[0]) {
            for (const right of Reduce(buffer.slice(1))) {
                yield `${left}${right}`;
            }
        }
    }
    function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
    }
    function* Or(expression) {
        for (const expr of expression.expr)
            yield* Generate(expr);
    }
    function* Const(expression) {
        return yield expression.const;
    }
    function* Generate(expression) {
        if (expression.type === 'and')
            return yield* And(expression);
        if (expression.type === 'or')
            return yield* Or(expression);
        if (expression.type === 'const')
            return yield* Const(expression);
        throw Error('TemplateLiteralGenerator: Unknown expression');
    }
    TemplateLiteralGenerator.Generate = Generate;
})(TemplateLiteralGenerator = exports.TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = {}));
// --------------------------------------------------------------------------
// TypeOrdinal: Used for auto $id generation
// --------------------------------------------------------------------------
let TypeOrdinal = 0;
// --------------------------------------------------------------------------
// TypeBuilder
// --------------------------------------------------------------------------
class TypeBuilder {
    /** `[Utility]` Creates a schema without `static` and `params` types */
    Create(schema) {
        return schema;
    }
    /** `[Standard]` Omits compositing symbols from this schema */
    Strict(schema) {
        return JSON.parse(JSON.stringify(schema));
    }
}
exports.TypeBuilder = TypeBuilder;
// --------------------------------------------------------------------------
// StandardTypeBuilder
// --------------------------------------------------------------------------
class StandardTypeBuilder extends TypeBuilder {
    // ------------------------------------------------------------------------
    // Modifiers
    // ------------------------------------------------------------------------
    /** `[Modifier]` Creates a Optional property */
    Optional(schema) {
        return { [exports.Modifier]: 'Optional', ...TypeClone.Clone(schema, {}) };
    }
    /** `[Modifier]` Creates a ReadonlyOptional property */
    ReadonlyOptional(schema) {
        return { [exports.Modifier]: 'ReadonlyOptional', ...TypeClone.Clone(schema, {}) };
    }
    /** `[Modifier]` Creates a Readonly object or property */
    Readonly(schema) {
        return { [exports.Modifier]: 'Readonly', ...schema };
    }
    // ------------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------------
    /** `[Standard]` Creates an Any type */
    Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Any' });
    }
    /** `[Standard]` Creates an Array type */
    Array(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Clone(items, {}) });
    }
    /** `[Standard]` Creates a Boolean type */
    Boolean(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });
    }
    /** `[Standard]` Creates a Composite object type. */
    Composite(objects, options) {
        const isOptionalAll = (objects, key) => objects.every((object) => !(key in object.properties) || IsOptional(object.properties[key]));
        const IsOptional = (schema) => TypeGuard.TOptional(schema) || TypeGuard.TReadonlyOptional(schema);
        const [required, optional] = [new Set(), new Set()];
        for (const object of objects) {
            for (const key of globalThis.Object.getOwnPropertyNames(object.properties)) {
                if (isOptionalAll(objects, key))
                    optional.add(key);
            }
        }
        for (const object of objects) {
            for (const key of globalThis.Object.getOwnPropertyNames(object.properties)) {
                if (!optional.has(key))
                    required.add(key);
            }
        }
        const properties = {};
        for (const object of objects) {
            for (const [key, schema] of Object.entries(object.properties)) {
                const property = TypeClone.Clone(schema, {});
                if (!optional.has(key))
                    delete property[exports.Modifier];
                if (key in properties) {
                    const left = TypeExtends.Extends(properties[key], property) !== TypeExtendsResult.False;
                    const right = TypeExtends.Extends(property, properties[key]) !== TypeExtendsResult.False;
                    if (!left && !right)
                        properties[key] = exports.Type.Never();
                    if (!left && right)
                        properties[key] = property;
                }
                else {
                    properties[key] = property;
                }
            }
        }
        if (required.size > 0) {
            return this.Create({ ...options, [exports.Kind]: 'Object', [exports.Hint]: 'Composite', type: 'object', properties, required: [...required] });
        }
        else {
            return this.Create({ ...options, [exports.Kind]: 'Object', [exports.Hint]: 'Composite', type: 'object', properties });
        }
    }
    /** `[Standard]` Creates a Enum type */
    Enum(item, options = {}) {
        // prettier-ignore
        const values = globalThis.Object.keys(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const anyOf = values.map((value) => (typeof value === 'string' ? { [exports.Kind]: 'Literal', type: 'string', const: value } : { [exports.Kind]: 'Literal', type: 'number', const: value }));
        return this.Create({ ...options, [exports.Kind]: 'Union', anyOf });
    }
    /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */
    Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
            case TypeExtendsResult.Union:
                return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);
            case TypeExtendsResult.True:
                return TypeClone.Clone(trueType, options);
            case TypeExtendsResult.False:
                return TypeClone.Clone(falseType, options);
        }
    }
    /** `[Standard]` Excludes from the left type any type that is not assignable to the right */
    Exclude(left, right, options = {}) {
        if (TypeGuard.TTemplateLiteral(left))
            return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);
        if (TypeGuard.TTemplateLiteral(right))
            return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);
        if (TypeGuard.TUnion(left)) {
            const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) === TypeExtendsResult.False);
            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));
        }
        else {
            return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options));
        }
    }
    /** `[Standard]` Extracts from the left type any type that is assignable to the right */
    Extract(left, right, options = {}) {
        if (TypeGuard.TTemplateLiteral(left))
            return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);
        if (TypeGuard.TTemplateLiteral(right))
            return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);
        if (TypeGuard.TUnion(left)) {
            const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);
            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));
        }
        else {
            return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options));
        }
    }
    /** `[Standard]` Creates an Integer type */
    Integer(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });
    }
    Intersect(allOf, options = {}) {
        if (allOf.length === 0)
            return exports.Type.Never();
        if (allOf.length === 1)
            return TypeClone.Clone(allOf[0], options);
        const objects = allOf.every((schema) => TypeGuard.TObject(schema));
        const cloned = allOf.map((schema) => TypeClone.Clone(schema, {}));
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};
        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {
            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned });
        }
        else {
            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });
        }
    }
    /** `[Standard]` Creates a KeyOf type */
    KeyOf(schema, options = {}) {
        if (TypeGuard.TRecord(schema)) {
            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
            if (pattern === exports.PatternNumberExact)
                return this.Number(options);
            if (pattern === exports.PatternStringExact)
                return this.String(options);
            throw Error('StandardTypeBuilder: Unable to resolve key type from Record key pattern');
        }
        else {
            const resolved = KeyResolver.Resolve(schema);
            if (resolved.length === 0)
                return this.Never(options);
            const literals = resolved.map((key) => this.Literal(key));
            return this.Union(literals, options);
        }
    }
    /** `[Standard]` Creates a Literal type */
    Literal(value, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });
    }
    /** `[Standard]` Creates a Never type */
    Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });
    }
    /** `[Standard]` Creates a Not type. The first argument is the disallowed type, the second is the allowed. */
    Not(not, schema, options) {
        return this.Create({ ...options, [exports.Kind]: 'Not', allOf: [{ not: TypeClone.Clone(not, {}) }, TypeClone.Clone(schema, {})] });
    }
    /** `[Standard]` Creates a Null type */
    Null(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });
    }
    /** `[Standard]` Creates a Number type */
    Number(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });
    }
    /** `[Standard]` Creates an Object type */
    Object(properties, options = {}) {
        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});
        if (requiredKeys.length > 0) {
            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys });
        }
        else {
            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });
        }
    }
    Omit(schema, unresolved, options = {}) {
        // prettier-ignore
        const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map((schema) => schema.const) :
            TypeGuard.TLiteral(unresolved) ? [unresolved.const] :
                TypeGuard.TNever(unresolved) ? [] :
                    unresolved;
        // prettier-ignore
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {
            if (schema.required) {
                schema.required = schema.required.filter((key) => !keys.includes(key));
                if (schema.required.length === 0)
                    delete schema.required;
            }
            for (const key of globalThis.Object.keys(schema.properties)) {
                if (keys.includes(key))
                    delete schema.properties[key];
            }
            return this.Create(schema);
        }, options);
    }
    /** `[Standard]` Creates a mapped type where all properties are Optional */
    Partial(schema, options = {}) {
        function Apply(schema) {
            // prettier-ignore
            switch (schema[exports.Modifier]) {
                case 'ReadonlyOptional':
                    schema[exports.Modifier] = 'ReadonlyOptional';
                    break;
                case 'Readonly':
                    schema[exports.Modifier] = 'ReadonlyOptional';
                    break;
                case 'Optional':
                    schema[exports.Modifier] = 'Optional';
                    break;
                default:
                    schema[exports.Modifier] = 'Optional';
                    break;
            }
        }
        // prettier-ignore
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {
            delete schema.required;
            globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));
            return schema;
        }, options);
    }
    Pick(schema, unresolved, options = {}) {
        // prettier-ignore
        const keys = TypeGuard.TUnionLiteral(unresolved) ? unresolved.anyOf.map((schema) => schema.const) :
            TypeGuard.TLiteral(unresolved) ? [unresolved.const] :
                TypeGuard.TNever(unresolved) ? [] :
                    unresolved;
        // prettier-ignore
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {
            if (schema.required) {
                schema.required = schema.required.filter((key) => keys.includes(key));
                if (schema.required.length === 0)
                    delete schema.required;
            }
            for (const key of globalThis.Object.keys(schema.properties)) {
                if (!keys.includes(key))
                    delete schema.properties[key];
            }
            return this.Create(schema);
        }, options);
    }
    /** `[Standard]` Creates a Record type */
    Record(key, schema, options = {}) {
        if (TypeGuard.TTemplateLiteral(key)) {
            const expression = TemplateLiteralParser.ParseExact(key.pattern);
            // prettier-ignore
            return TemplateLiteralFinite.Check(expression)
                ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(schema, {}) }), {}), options))
                : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });
        }
        else if (TypeGuard.TUnionLiteral(key)) {
            if (key.anyOf.every((schema) => TypeGuard.TLiteral(schema) && (typeof schema.const === 'string' || typeof schema.const === 'number'))) {
                const properties = key.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});
                return this.Object(properties, { ...options, [exports.Hint]: 'Record' });
            }
            else
                throw Error('TypeBuilder: Record key can only be derived from union literal of number or string');
        }
        else if (TypeGuard.TLiteral(key)) {
            if (typeof key.const === 'string' || typeof key.const === 'number') {
                return this.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);
            }
            else
                throw Error('TypeBuilder: Record key can only be derived from literals of number or string');
        }
        else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {
            const pattern = exports.PatternNumberExact;
            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });
        }
        else if (TypeGuard.TString(key)) {
            const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;
            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) }, additionalProperties: false });
        }
        else {
            throw Error(`StandardTypeBuilder: Invalid Record Key`);
        }
    }
    /** `[Standard]` Creates a Recursive type */
    Recursive(callback, options = {}) {
        if (options.$id === undefined)
            options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports.Kind]: 'This', $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });
    }
    /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */
    Ref(schema, options = {}) {
        if (schema.$id === undefined)
            throw Error('StandardTypeBuilder.Ref: Target type must specify an $id');
        return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: schema.$id });
    }
    /** `[Standard]` Creates a mapped type where all properties are Required */
    Required(schema, options = {}) {
        function Apply(schema) {
            // prettier-ignore
            switch (schema[exports.Modifier]) {
                case 'ReadonlyOptional':
                    schema[exports.Modifier] = 'Readonly';
                    break;
                case 'Readonly':
                    schema[exports.Modifier] = 'Readonly';
                    break;
                case 'Optional':
                    delete schema[exports.Modifier];
                    break;
                default:
                    delete schema[exports.Modifier];
                    break;
            }
        }
        // prettier-ignore
        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {
            schema.required = globalThis.Object.keys(schema.properties);
            globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));
            return schema;
        }, options);
    }
    /** `[Standard]` Creates a String type */
    String(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });
    }
    /** `[Standard]` Creates a template literal type */
    TemplateLiteral(kinds, options = {}) {
        const pattern = TemplateLiteralPattern.Create(kinds);
        return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });
    }
    /** `[Standard]` Creates a Tuple type */
    Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = items.map((item) => TypeClone.Clone(item, {}));
        // prettier-ignore
        const schema = (items.length > 0 ?
            { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :
            { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });
        return this.Create(schema);
    }
    Union(union, options = {}) {
        if (TypeGuard.TTemplateLiteral(union)) {
            return TemplateLiteralResolver.Resolve(union);
        }
        else {
            const anyOf = union;
            if (anyOf.length === 0)
                return this.Never(options);
            if (anyOf.length === 1)
                return this.Create(TypeClone.Clone(anyOf[0], options));
            const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema, {}));
            return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });
        }
    }
    /** `[Standard]` Creates an Unknown type */
    Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Unknown' });
    }
    /** `[Standard]` Creates a Unsafe type that infers for the generic argument */
    Unsafe(options = {}) {
        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });
    }
}
exports.StandardTypeBuilder = StandardTypeBuilder;
// --------------------------------------------------------------------------
// ExtendedTypeBuilder
// --------------------------------------------------------------------------
class ExtendedTypeBuilder extends StandardTypeBuilder {
    /** `[Extended]` Creates a BigInt type */
    BigInt(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'null', typeOf: 'BigInt' });
    }
    /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */
    ConstructorParameters(schema, options = {}) {
        return this.Tuple([...schema.parameters], { ...options });
    }
    Constructor(parameters, returns, options = {}) {
        const clonedReturns = TypeClone.Clone(returns, {});
        if (TypeGuard.TTuple(parameters)) {
            const clonedParameters = parameters.items === undefined ? [] : parameters.items.map((parameter) => TypeClone.Clone(parameter, {}));
            return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'object', instanceOf: 'Constructor', parameters: clonedParameters, returns: clonedReturns });
        }
        else if (globalThis.Array.isArray(parameters)) {
            const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));
            return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'object', instanceOf: 'Constructor', parameters: clonedParameters, returns: clonedReturns });
        }
        else {
            throw new Error('ExtendedTypeBuilder.Constructor: Invalid parameters');
        }
    }
    /** `[Extended]` Creates a Date type */
    Date(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Date', type: 'object', instanceOf: 'Date' });
    }
    Function(parameters, returns, options = {}) {
        const clonedReturns = TypeClone.Clone(returns, {});
        if (TypeGuard.TTuple(parameters)) {
            const clonedParameters = parameters.items === undefined ? [] : parameters.items.map((parameter) => TypeClone.Clone(parameter, {}));
            return this.Create({ ...options, [exports.Kind]: 'Function', type: 'object', instanceOf: 'Function', parameters: clonedParameters, returns: clonedReturns });
        }
        else if (globalThis.Array.isArray(parameters)) {
            const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));
            return this.Create({ ...options, [exports.Kind]: 'Function', type: 'object', instanceOf: 'Function', parameters: clonedParameters, returns: clonedReturns });
        }
        else {
            throw new Error('ExtendedTypeBuilder.Function: Invalid parameters');
        }
    }
    /** `[Extended]` Extracts the InstanceType from the given Constructor */
    InstanceType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
    }
    /** `[Extended]` Extracts the Parameters from the given Function type */
    Parameters(schema, options = {}) {
        return this.Tuple(schema.parameters, { ...options });
    }
    /** `[Extended]` Creates a Promise type */
    Promise(item, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'object', instanceOf: 'Promise', item: TypeClone.Clone(item, {}) });
    }
    /** `[Extended]` Creates a regular expression type */
    RegEx(regex, options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern: regex.source });
    }
    /** `[Extended]` Extracts the ReturnType from the given Function */
    ReturnType(schema, options = {}) {
        return TypeClone.Clone(schema.returns, options);
    }
    /** `[Extended]` Creates a Symbol type */
    Symbol(options) {
        return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'null', typeOf: 'Symbol' });
    }
    /** `[Extended]` Creates a Undefined type */
    Undefined(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'null', typeOf: 'Undefined' });
    }
    /** `[Extended]` Creates a Uint8Array type */
    Uint8Array(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'object', instanceOf: 'Uint8Array' });
    }
    /** `[Extended]` Creates a Void type */
    Void(options = {}) {
        return this.Create({ ...options, [exports.Kind]: 'Void', type: 'null', typeOf: 'Void' });
    }
}
exports.ExtendedTypeBuilder = ExtendedTypeBuilder;
/** JSON Schema TypeBuilder with Static Resolution for TypeScript

## Type

Source: `my-backend/node_modules/@sinclair/typebox/typebox.js`

Signature: `Type(= new ExtendedTypeBuilder()`

JSDoc:

JSON Schema TypeBuilder with Static Resolution for TypeScript

## wrap

Source: `my-backend/node_modules/@sinonjs/commons/lib/deprecated.js`

Signature: `wrap(= function (func, msg)`

JSDoc:

Returns a function that will invoke the supplied function and print a
deprecation warning to the console each time it is called.
@param  {Function} func
@param  {string} msg
@returns {Function}

## defaultMsg

Source: `my-backend/node_modules/@sinonjs/commons/lib/deprecated.js`

Signature: `defaultMsg(= function (packageName, funcName)`

JSDoc:

Returns a string which can be supplied to `wrap()` to notify the user that a
particular part of the sinon API has been deprecated.
@param  {string} packageName
@param  {string} funcName
@returns {string}

## printWarning

Source: `my-backend/node_modules/@sinonjs/commons/lib/deprecated.js`

Signature: `printWarning(= function (msg)`

JSDoc:

Prints a warning on the console, when it exists
@param  {string} msg
@returns {undefined}

## transform

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transform(code: string, callback: FileResultCallback)`

JSDoc:

Source map standard format as to revision 3
@see {@link https://sourcemaps.info/spec.html}
@see {@link https://github.com/mozilla/source-map/blob/HEAD/source-map.d.ts}
/
interface InputSourceMap {
    version: number;
    sources: string[];
    names: string[];
    sourceRoot?: string | undefined;
    sourcesContent?: string[] | undefined;
    mappings: string;
    file: string;
}

export interface TransformOptions {
    /**
Specify which assumptions it can make about your code, to better optimize the compilation result. **NOTE**: This replaces the various `loose` options in plugins in favor of
top-level options that can apply to multiple plugins

@see https://babeljs.io/docs/en/assumptions
/
    assumptions?: { [name: string]: boolean } | null | undefined;

    /**
Include the AST in the returned object

Default: `false`
/
    ast?: boolean | null | undefined;

    /**
Attach a comment after all non-user injected code

Default: `null`
/
    auxiliaryCommentAfter?: string | null | undefined;

    /**
Attach a comment before all non-user injected code

Default: `null`
/
    auxiliaryCommentBefore?: string | null | undefined;

    /**
Specify the "root" folder that defines the location to search for "babel.config.js", and the default folder to allow `.babelrc` files inside of.

Default: `"."`
/
    root?: string | null | undefined;

    /**
This option, combined with the "root" value, defines how Babel chooses its project root.
The different modes define different ways that Babel can process the "root" value to get
the final project root.

@see https://babeljs.io/docs/en/next/options#rootmode
/
    rootMode?: "root" | "upward" | "upward-optional" | undefined;

    /**
The config file to load Babel's config from. Defaults to searching for "babel.config.js" inside the "root" folder. `false` will disable searching for config files.

Default: `undefined`
/
    configFile?: string | boolean | null | undefined;

    /**
Specify whether or not to use .babelrc and
.babelignore files.

Default: `true`
/
    babelrc?: boolean | null | undefined;

    /**
Specify which packages should be search for .babelrc files when they are being compiled. `true` to always search, or a path string or an array of paths to packages to search
inside of. Defaults to only searching the "root" package.

Default: `(root)`
/
    babelrcRoots?: boolean | MatchPattern | MatchPattern[] | null | undefined;

    /**
Toggles whether or not browserslist config sources are used, which includes searching for any browserslist files or referencing the browserslist key inside package.json.
This is useful for projects that use a browserslist config for files that won't be compiled with Babel.

If a string is specified, it must represent the path of a browserslist configuration file. Relative paths are resolved relative to the configuration file which specifies
this option, or to `cwd` when it's passed as part of the programmatic options.

Default: `true`
/
    browserslistConfigFile?: boolean | null | undefined;

    /**
The Browserslist environment to use.

Default: `undefined`
/
    browserslistEnv?: string | null | undefined;

    /**
By default `babel.transformFromAst` will clone the input AST to avoid mutations.
Specifying `cloneInputAst: false` can improve parsing performance if the input AST is not used elsewhere.

Default: `true`
/
    cloneInputAst?: boolean | null | undefined;

    /**
Defaults to environment variable `BABEL_ENV` if set, or else `NODE_ENV` if set, or else it defaults to `"development"`

Default: env vars
/
    envName?: string | undefined;

    /**
If any of patterns match, the current configuration object is considered inactive and is ignored during config processing.
/
    exclude?: MatchPattern | MatchPattern[] | undefined;

    /**
Enable code generation

Default: `true`
/
    code?: boolean | null | undefined;

    /**
Output comments in generated output

Default: `true`
/
    comments?: boolean | null | undefined;

    /**
Do not include superfluous whitespace characters and line terminators. When set to `"auto"` compact is set to `true` on input sizes of >500KB

Default: `"auto"`
/
    compact?: boolean | "auto" | null | undefined;

    /**
The working directory that Babel's programmatic options are loaded relative to.

Default: `"."`
/
    cwd?: string | null | undefined;

    /**
Utilities may pass a caller object to identify themselves to Babel and
pass capability-related flags for use by configs, presets and plugins.

@see https://babeljs.io/docs/en/next/options#caller
/
    caller?: TransformCaller | undefined;

    /**
This is an object of keys that represent different environments. For example, you may have: `{ env: { production: { \/* specific options *\/ } } }`
which will use those options when the `envName` is `production`

Default: `{}`
/
    env?: { [index: string]: TransformOptions | null | undefined } | null | undefined;

    /**
A path to a `.babelrc` file to extend

Default: `null`
/
    extends?: string | null | undefined;

    /**
Filename for use in errors etc

Default: `"unknown"`
/
    filename?: string | null | undefined;

    /**
Filename relative to `sourceRoot`

Default: `(filename)`
/
    filenameRelative?: string | null | undefined;

    /**
An object containing the options to be passed down to the babel code generator, @babel/generator

Default: `{}`
/
    generatorOpts?: GeneratorOptions | null | undefined;

    /**
Specify a custom callback to generate a module id with. Called as `getModuleId(moduleName)`. If falsy value is returned then the generated module id is used

Default: `null`
/
    getModuleId?: ((moduleName: string) => string | null | undefined) | null | undefined;

    /**
ANSI highlight syntax error code frames

Default: `true`
/
    highlightCode?: boolean | null | undefined;

    /**
Opposite to the `only` option. `ignore` is disregarded if `only` is specified

Default: `null`
/
    ignore?: MatchPattern[] | null | undefined;

    /**
This option is a synonym for "test"
/
    include?: MatchPattern | MatchPattern[] | undefined;

    /**
A source map object that the output source map will be based on

Default: `null`
/
    inputSourceMap?: InputSourceMap | null | undefined;

    /**
Should the output be minified (not printing last semicolons in blocks, printing literal string values instead of escaped ones, stripping `()` from `new` when safe)

Default: `false`
/
    minified?: boolean | null | undefined;

    /**
Specify a custom name for module ids

Default: `null`
/
    moduleId?: string | null | undefined;

    /**
If truthy, insert an explicit id for modules. By default, all modules are anonymous. (Not available for `common` modules)

Default: `false`
/
    moduleIds?: boolean | null | undefined;

    /**
Optional prefix for the AMD module formatter that will be prepend to the filename on module definitions

Default: `(sourceRoot)`
/
    moduleRoot?: string | null | undefined;

    /**
A glob, regex, or mixed array of both, matching paths to **only** compile. Can also be an array of arrays containing paths to explicitly match. When attempting to compile
a non-matching file it's returned verbatim

Default: `null`
/
    only?: MatchPattern[] | null | undefined;

    /**
Allows users to provide an array of options that will be merged into the current configuration one at a time.
This feature is best used alongside the "test"/"include"/"exclude" options to provide conditions for which an override should apply
/
    overrides?: TransformOptions[] | undefined;

    /**
An object containing the options to be passed down to the babel parser, @babel/parser

Default: `{}`
/
    parserOpts?: ParserOptions | null | undefined;

    /**
List of plugins to load and use

Default: `[]`
/
    plugins?: PluginItem[] | null | undefined;

    /**
List of presets (a set of plugins) to load and use

Default: `[]`
/
    presets?: PluginItem[] | null | undefined;

    /**
Retain line numbers. This will lead to wacky code but is handy for scenarios where you can't use source maps. (**NOTE**: This will not retain the columns)

Default: `false`
/
    retainLines?: boolean | null | undefined;

    /**
An optional callback that controls whether a comment should be output or not. Called as `shouldPrintComment(commentContents)`. **NOTE**: This overrides the `comment` option when used

Default: `null`
/
    shouldPrintComment?: ((commentContents: string) => boolean) | null | undefined;

    /**
Set `sources[0]` on returned source map

Default: `(filenameRelative)`
/
    sourceFileName?: string | null | undefined;

    /**
If truthy, adds a `map` property to returned output. If set to `"inline"`, a comment with a sourceMappingURL directive is added to the bottom of the returned code. If set to `"both"`
then a `map` property is returned as well as a source map comment appended. **This does not emit sourcemap files by itself!**

Default: `false`
/
    sourceMaps?: boolean | "inline" | "both" | null | undefined;

    /**
The root from which all sources are relative

Default: `(moduleRoot)`
/
    sourceRoot?: string | null | undefined;

    /**
Indicate the mode the code should be parsed in. Can be one of "script", "module", or "unambiguous". `"unambiguous"` will make Babel attempt to guess, based on the presence of ES6
`import` or `export` statements. Files with ES6 `import`s and `export`s are considered `"module"` and are otherwise `"script"`.

Default: `("module")`
/
    sourceType?: "script" | "module" | "unambiguous" | null | undefined;

    /**
If all patterns fail to match, the current configuration object is considered inactive and is ignored during config processing.
/
    test?: MatchPattern | MatchPattern[] | undefined;

    /**
Describes the environments you support/target for your project.
This can either be a [browserslist-compatible](https://github.com/ai/browserslist) query (with [caveats](https://babeljs.io/docs/en/babel-preset-env#ineffective-browserslist-queries))

Default: `{}`
/
    targets?:
        | string
        | string[]
        | {
            esmodules?: boolean;
            node?: Omit<string, "current"> | "current" | true;
            safari?: Omit<string, "tp"> | "tp";
            browsers?: string | string[];
            android?: string;
            chrome?: string;
            deno?: string;
            edge?: string;
            electron?: string;
            firefox?: string;
            ie?: string;
            ios?: string;
            opera?: string;
            rhino?: string;
            samsung?: string;
        };

    /**
An optional callback that can be used to wrap visitor methods. **NOTE**: This is useful for things like introspection, and not really needed for implementing anything. Called as
`wrapPluginVisitorMethod(pluginAlias, visitorType, callback)`.
/
    wrapPluginVisitorMethod?:
        | ((
            pluginAlias: string,
            visitorType: "enter" | "exit",
            callback: (path: NodePath, state: any) => void,
        ) => (path: NodePath, state: any) => void)
        | null
        | undefined;
}

export interface TransformCaller {
    // the only required property
    name: string;
    // e.g. set to true by `babel-loader` and false by `babel-jest`
    supportsStaticESM?: boolean | undefined;
    supportsDynamicImport?: boolean | undefined;
    supportsExportNamespaceFrom?: boolean | undefined;
    supportsTopLevelAwait?: boolean | undefined;
    // augment this with a "declare module '@babel/core' { ... }" if you need more keys
}

export type FileResultCallback = (err: Error | null, result: BabelFileResult | null) => any;

export interface MatchPatternContext {
    envName: string;
    dirname: string;
    caller: TransformCaller | undefined;
}
export type MatchPattern = string | RegExp | ((filename: string | undefined, context: MatchPatternContext) => boolean);

/**
Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.

## transform

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transform(code: string, opts: TransformOptions | undefined, callback: FileResultCallback)`

JSDoc:

Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.

## transform

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transform(code: string, opts?: TransformOptions)`

JSDoc:

Here for backward-compatibility. Ideally use `transformSync` if you want a synchronous API.

## transformSync

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformSync(code: string, opts?: TransformOptions)`

JSDoc:

Transforms the passed in code. Returning an object with the generated code, source map, and AST.

## transformAsync

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformAsync(code: string, opts?: TransformOptions)`

JSDoc:

Transforms the passed in code. Calling a callback with an object with the generated code, source map, and AST.

## transformFile

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformFile(filename: string, callback: FileResultCallback)`

JSDoc:

Asynchronously transforms the entire contents of a file.

## transformFile

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformFile(filename: string, opts: TransformOptions | undefined, callback: FileResultCallback)`

JSDoc:

Asynchronously transforms the entire contents of a file.

## transformFileSync

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformFileSync(filename: string, opts?: TransformOptions)`

JSDoc:

Synchronous version of `babel.transformFile`. Returns the transformed contents of the `filename`.

## transformFileAsync

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformFileAsync(filename: string, opts?: TransformOptions)`

JSDoc:

Asynchronously transforms the entire contents of a file.

## transformFromAst

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformFromAst(ast: Node, code: string | undefined, callback: FileResultCallback)`

JSDoc:

Given an AST, transform it.

## transformFromAst

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformFromAst(
    ast: Node,
    code: string | undefined,
    opts: TransformOptions | undefined,
    callback: FileResultCallback,
)`

JSDoc:

Given an AST, transform it.

## transformFromAstSync

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformFromAstSync(ast: Node, code?: string, opts?: TransformOptions)`

JSDoc:

Here for backward-compatibility. Ideally use ".transformSync" if you want a synchronous API.

## transformFromAstAsync

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `transformFromAstAsync(
    ast: Node,
    code?: string,
    opts?: TransformOptions,
)`

JSDoc:

Given an AST, transform it.

## parse

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `parse(code: string, callback: FileParseCallback)`

JSDoc:

Given some code, parse it using Babel's standard behavior.
Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.

## parse

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `parse(code: string, options: TransformOptions | undefined, callback: FileParseCallback)`

JSDoc:

Given some code, parse it using Babel's standard behavior.
Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.

## parse

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `parse(code: string, options?: TransformOptions)`

JSDoc:

Given some code, parse it using Babel's standard behavior.
Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.

## parseSync

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `parseSync(code: string, options?: TransformOptions)`

JSDoc:

Given some code, parse it using Babel's standard behavior.
Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.

## parseAsync

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `parseAsync(code: string, options?: TransformOptions)`

JSDoc:

Given some code, parse it using Babel's standard behavior.
Referenced presets and plugins will be loaded such that optional syntax plugins are automatically enabled.

## loadOptions

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `loadOptions(options?: TransformOptions)`

JSDoc:

Resolve Babel's options fully, resulting in an options object where:

* opts.plugins is a full list of Plugin instances.
* opts.presets is empty and all presets are flattened into opts.
* It can be safely passed back to Babel. Fields like babelrc have been set to false so that later calls to Babel
will not make a second attempt to load config files.

Plugin instances aren't meant to be manipulated directly, but often callers will serialize this opts to JSON to
use it as a cache key representing the options Babel has received. Caching on this isn't 100% guaranteed to
invalidate properly, but it is the best we have at the moment.

## loadPartialConfig

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `loadPartialConfig(options?: TransformOptions)`

JSDoc:

To allow systems to easily manipulate and validate a user's config, this function resolves the plugins and
presets and proceeds no further. The expectation is that callers will take the config's .options, manipulate it
as then see fit and pass it back to Babel again.

* `babelrc: string | void` - The path of the `.babelrc` file, if there was one.
* `babelignore: string | void` - The path of the `.babelignore` file, if there was one.
* `options: ValidatedOptions` - The partially resolved options, which can be manipulated and passed back
to Babel again.
 * `plugins: Array<ConfigItem>` - See below.
 * `presets: Array<ConfigItem>` - See below.
 * It can be safely passed back to Babel. Fields like `babelrc` have been set to false so that later calls to
Babel will not make a second attempt to load config files.

`ConfigItem` instances expose properties to introspect the values, but each item should be treated as
immutable. If changes are desired, the item should be removed from the list and replaced with either a normal
Babel config value, or with a replacement item created by `babel.createConfigItem`. See that function for
information about `ConfigItem` fields.

## createConfigItem

Source: `my-backend/node_modules/@types/babel__core/index.d.ts`

Signature: `createConfigItem(
    value: PluginTarget | [PluginTarget, PluginOptions] | [PluginTarget, PluginOptions, string | undefined],
    options?: CreateConfigItemOptions,
)`

JSDoc:

The name that the user gave the plugin instance, e.g. `plugins: [ ['env', {}, 'my-env'] ]`
/
    name?: string | undefined;

    /**
The resolved value of the plugin.
/
    value: object | ((...args: any[]) => any);

    /**
The options object passed to the plugin.
/
    options?: object | false | undefined;

    /**
The path that the options are relative to.
/
    dirname: string;

    /**
Information about the plugin's file, if Babel knows it.
 *
/
    file?:
        | {
            /**
The file that the user requested, e.g. `"@babel/env"`
/
            request: string;

            /**
The full path of the resolved file, e.g. `"/tmp/node_modules/@babel/preset-env/lib/index.js"`
/
            resolved: string;
        }
        | null
        | undefined;
}

export type PluginOptions = object | undefined | false;

export type PluginTarget = string | object | ((...args: any[]) => any);

export type PluginItem =
    | ConfigItem
    | PluginObj<any>
    | PluginTarget
    | [PluginTarget, PluginOptions]
    | [PluginTarget, PluginOptions, string | undefined];

export function resolvePlugin(name: string, dirname: string): string | null;
export function resolvePreset(name: string, dirname: string): string | null;

export interface CreateConfigItemOptions {
    dirname?: string | undefined;
    type?: "preset" | "plugin" | undefined;
}

/**
Allows build tooling to create and cache config items up front. If this function is called multiple times for a
given plugin, Babel will call the plugin's function itself multiple times. If you have a clear set of expected
plugins and presets to inject, pre-constructing the config items would be recommended.

## generate

Source: `my-backend/node_modules/@types/babel__generator/index.d.ts`

Signature: `generate(
    ast: t.Node,
    opts?: GeneratorOptions,
    code?: string | { [filename: string]: string },
)`

JSDoc:

Optional string to add as a block comment at the start of the output file.
/
    auxiliaryCommentBefore?: string | undefined;

    /**
Optional string to add as a block comment at the end of the output file.
/
    auxiliaryCommentAfter?: string | undefined;

    /**
Function that takes a comment (as a string) and returns true if the comment should be included in the output.
By default, comments are included if `opts.comments` is `true` or if `opts.minifed` is `false` and the comment
contains `@preserve` or `@license`.
/
    shouldPrintComment?(comment: string): boolean;

    /**
Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).
Defaults to `false`.
/
    retainLines?: boolean | undefined;

    /**
Retain parens around function expressions (could be used to change engine parsing behavior)
Defaults to `false`.
/
    retainFunctionParens?: boolean | undefined;

    /**
Should comments be included in output? Defaults to `true`.
/
    comments?: boolean | undefined;

    /**
Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.
/
    compact?: boolean | "auto" | undefined;

    /**
Should the output be minified. Defaults to `false`.
/
    minified?: boolean | undefined;

    /**
Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.
/
    concise?: boolean | undefined;

    /**
Used in warning messages
/
    filename?: string | undefined;

    /**
Enable generating source maps. Defaults to `false`.
/
    sourceMaps?: boolean | undefined;

    /**
A root for all relative URLs in the source map.
/
    sourceRoot?: string | undefined;

    /**
The filename for the source code (i.e. the code in the `code` argument).
This will only be used if `code` is a string.
/
    sourceFileName?: string | undefined;

    /**
Set to true to run jsesc with "json": true to print "\u00A9" vs. "";
/
    jsonCompatibleStrings?: boolean | undefined;

    /**
Set to true to enable support for experimental decorators syntax before module exports.
Defaults to `false`.
/
    decoratorsBeforeExport?: boolean | undefined;

    /**
The import attributes/assertions syntax to use.
When not specified, @babel/generator will try to match the style in the input code based on the AST shape.
/
    importAttributesKeyword?: "with" | "assert" | "with-legacy";

    /**
Options for outputting jsesc representation.
/
    jsescOption?: {
        /**
The default value for the quotes option is 'single'. This means that any occurrences of ' in the input
string are escaped as \', so that the output can be used in a string literal wrapped in single quotes.
/
        quotes?: "single" | "double" | "backtick" | undefined;

        /**
The default value for the numbers option is 'decimal'. This means that any numeric values are represented
using decimal integer literals. Other valid options are binary, octal, and hexadecimal, which result in
binary integer literals, octal integer literals, and hexadecimal integer literals, respectively.
/
        numbers?: "binary" | "octal" | "decimal" | "hexadecimal" | undefined;

        /**
The wrap option takes a boolean value (true or false), and defaults to false (disabled). When enabled, the
output is a valid JavaScript string literal wrapped in quotes. The type of quotes can be specified through
the quotes setting.
/
        wrap?: boolean | undefined;

        /**
The es6 option takes a boolean value (true or false), and defaults to false (disabled). When enabled, any
astral Unicode symbols in the input are escaped using ECMAScript 6 Unicode code point escape sequences
instead of using separate escape sequences for each surrogate half. If backwards compatibility with ES5
environments is a concern, dont enable this setting. If the json setting is enabled, the value for the es6
setting is ignored (as if it was false).
/
        es6?: boolean | undefined;

        /**
The escapeEverything option takes a boolean value (true or false), and defaults to false (disabled). When
enabled, all the symbols in the output are escaped  even printable ASCII symbols.
/
        escapeEverything?: boolean | undefined;

        /**
The minimal option takes a boolean value (true or false), and defaults to false (disabled). When enabled,
only a limited set of symbols in the output are escaped: \0, \b, \t, \n, \f, \r, \\, \u2028, \u2029.
/
        minimal?: boolean | undefined;

        /**
The isScriptContext option takes a boolean value (true or false), and defaults to false (disabled). When
enabled, occurrences of </script and </style in the output are escaped as <\/script and <\/style, and <!--
is escaped as \x3C!-- (or \u003C!-- when the json option is enabled). This setting is useful when jsescs
output ends up as part of a <script> or <style> element in an HTML document.
/
        isScriptContext?: boolean | undefined;

        /**
The compact option takes a boolean value (true or false), and defaults to true (enabled). When enabled,
the output for arrays and objects is as compact as possible; its not formatted nicely.
/
        compact?: boolean | undefined;

        /**
The indent option takes a string value, and defaults to '\t'. When the compact setting is enabled (true),
the value of the indent option is used to format the output for arrays and objects.
/
        indent?: string | undefined;

        /**
The indentLevel option takes a numeric value, and defaults to 0. It represents the current indentation level,
i.e. the number of times the value of the indent option is repeated.
/
        indentLevel?: number | undefined;

        /**
The json option takes a boolean value (true or false), and defaults to false (disabled). When enabled, the
output is valid JSON. Hexadecimal character escape sequences and the \v or \0 escape sequences are not used.
Setting json: true implies quotes: 'double', wrap: true, es6: false, although these values can still be
overridden if needed  but in such cases, the output wont be valid JSON anymore.
/
        json?: boolean | undefined;

        /**
The lowercaseHex option takes a boolean value (true or false), and defaults to false (disabled). When enabled,
any alphabetical hexadecimal digits in escape sequences as well as any hexadecimal integer literals (see the
numbers option) in the output are in lowercase.
/
        lowercaseHex?: boolean | undefined;
    } | undefined;
}

export class CodeGenerator {
    constructor(ast: t.Node, opts?: GeneratorOptions, code?: string);
    generate(): GeneratorResult;
}

/**
Turns an AST into code, maintaining sourcemaps, user preferences, and valid output.
@param ast - the abstract syntax tree from which to generate output code.
@param opts - used for specifying options for code generation.
@param code - the original source code, used for source maps.
@returns - an object containing the output code and source map.

## gracefulify

Source: `my-backend/node_modules/@types/graceful-fs/index.d.ts`

Signature: `gracefulify(<T>(fsModule: T)`

JSDoc:

Use this method to patch the global fs module (or any other fs-like module).
NOTE: This should only ever be done at the top-level application layer, in order to delay on
EMFILE errors from any fs-using dependencies. You should **not** do this in a library, because
it can cause unexpected delays in other parts of the program.
@param fsModule The reference to the fs module or an fs-like module.

## createContext

Source: `my-backend/node_modules/@types/istanbul-lib-report/index.d.ts`

Signature: `createContext(options?: Partial<ContextOptions>)`

JSDoc:

returns a reporting context for the supplied options

## getDefaultWatermarks

Source: `my-backend/node_modules/@types/istanbul-lib-report/index.d.ts`

Signature: `getDefaultWatermarks()`

JSDoc:

returns the default watermarks that would be used when not
overridden

## isUtf8

Source: `my-backend/node_modules/@types/node/buffer.d.ts`

Signature: `isUtf8(input: Buffer | ArrayBuffer | NodeJS.TypedArray)`

JSDoc:

`Buffer` objects are used to represent a fixed-length sequence of bytes. Many
Node.js APIs support `Buffer`s.

The `Buffer` class is a subclass of JavaScript's [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) class and
extends it with methods that cover additional use cases. Node.js APIs accept
plain [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) s wherever `Buffer`s are supported as well.

While the `Buffer` class is available within the global scope, it is still
recommended to explicitly reference it via an import or require statement.

```js
import { Buffer } from 'node:buffer';

// Creates a zero-filled Buffer of length 10.
const buf1 = Buffer.alloc(10);

// Creates a Buffer of length 10,
// filled with bytes which all have the value `1`.
const buf2 = Buffer.alloc(10, 1);

// Creates an uninitialized buffer of length 10.
// This is faster than calling Buffer.alloc() but the returned
// Buffer instance might contain old data that needs to be
// overwritten using fill(), write(), or other functions that fill the Buffer's
// contents.
const buf3 = Buffer.allocUnsafe(10);

// Creates a Buffer containing the bytes [1, 2, 3].
const buf4 = Buffer.from([1, 2, 3]);

// Creates a Buffer containing the bytes [1, 1, 1, 1]  the entries
// are all truncated using `(value &#x26; 255)` to fit into the range 0255.
const buf5 = Buffer.from([257, 257.5, -255, '1']);

// Creates a Buffer containing the UTF-8-encoded bytes for the string 'tst':
// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
// [116, 195, 169, 115, 116] (in decimal notation)
const buf6 = Buffer.from('tst');

// Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
const buf7 = Buffer.from('tst', 'latin1');
```
@see [source](https://github.com/nodejs/node/blob/v24.x/lib/buffer.js)
/
declare module "buffer" {
    import { BinaryLike } from "node:crypto";
    import { ReadableStream as WebReadableStream } from "node:stream/web";
    /**
This function returns `true` if `input` contains only valid UTF-8-encoded data,
including the case in which `input` is empty.

Throws if the `input` is a detached array buffer.
@since v19.4.0, v18.14.0
@param input The input to validate.

## isAscii

Source: `my-backend/node_modules/@types/node/buffer.d.ts`

Signature: `isAscii(input: Buffer | ArrayBuffer | NodeJS.TypedArray)`

JSDoc:

This function returns `true` if `input` contains only valid ASCII-encoded data,
including the case in which `input` is empty.

Throws if the `input` is a detached array buffer.
@since v19.6.0, v18.15.0
@param input The input to validate.

## transcode

Source: `my-backend/node_modules/@types/node/buffer.d.ts`

Signature: `transcode(source: Uint8Array, fromEnc: TranscodeEncoding, toEnc: TranscodeEncoding)`

JSDoc:

Re-encodes the given `Buffer` or `Uint8Array` instance from one character
encoding to another. Returns a new `Buffer` instance.

Throws if the `fromEnc` or `toEnc` specify invalid character encodings or if
conversion from `fromEnc` to `toEnc` is not permitted.

Encodings supported by `buffer.transcode()` are: `'ascii'`, `'utf8'`, `'utf16le'`, `'ucs2'`, `'latin1'`, and `'binary'`.

The transcoding process will use substitution characters if a given byte
sequence cannot be adequately represented in the target encoding. For instance:

```js
import { Buffer, transcode } from 'node:buffer';

const newBuf = transcode(Buffer.from(''), 'utf8', 'ascii');
console.log(newBuf.toString('ascii'));
// Prints: '?'
```

Because the Euro (``) sign is not representable in US-ASCII, it is replaced
with `?` in the transcoded `Buffer`.
@since v7.1.0
@param source A `Buffer` or `Uint8Array` instance.
@param fromEnc The current encoding.
@param toEnc To target encoding.

## resolveObjectURL

Source: `my-backend/node_modules/@types/node/buffer.d.ts`

Signature: `resolveObjectURL(id: string)`

JSDoc:

Resolves a `'blob:nodedata:...'` an associated `Blob` object registered using
a prior call to `URL.createObjectURL()`.
@since v16.7.0
@param id A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.

## lookup

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `lookup(
        hostname: string,
        family: number,
        callback: (err: NodeJS.ErrnoException | null, address: string, family: number)`

JSDoc:

The `node:dns` module enables name resolution. For example, use it to look up IP
addresses of host names.

Although named for the [Domain Name System (DNS)](https://en.wikipedia.org/wiki/Domain_Name_System), it does not always use the
DNS protocol for lookups. {@link lookup} uses the operating system
facilities to perform name resolution. It may not need to perform any network
communication. To perform name resolution the way other applications on the same
system do, use {@link lookup}.

```js
import dns from 'node:dns';

dns.lookup('example.org', (err, address, family) => {
  console.log('address: %j family: IPv%s', address, family);
});
// address: "93.184.216.34" family: IPv4
```

All other functions in the `node:dns` module connect to an actual DNS server to
perform name resolution. They will always use the network to perform DNS
queries. These functions do not use the same set of configuration files used by {@link lookup} (e.g. `/etc/hosts`). Use these functions to always perform
DNS queries, bypassing other name-resolution facilities.

```js
import dns from 'node:dns';

dns.resolve4('archive.org', (err, addresses) => {
  if (err) throw err;

  console.log(`addresses: ${JSON.stringify(addresses)}`);

  addresses.forEach((a) => {
    dns.reverse(a, (err, hostnames) => {
      if (err) {
        throw err;
      }
      console.log(`reverse for ${a}: ${JSON.stringify(hostnames)}`);
    });
  });
});
```

See the [Implementation considerations section](https://nodejs.org/docs/latest-v24.x/api/dns.html#implementation-considerations) for more information.
@see [source](https://github.com/nodejs/node/blob/v24.x/lib/dns.js)
/
declare module "dns" {
    import * as dnsPromises from "node:dns/promises";
    // Supported getaddrinfo flags.
    /**
Limits returned address types to the types of non-loopback addresses configured on the system. For example, IPv4 addresses are
only returned if the current system has at least one IPv4 address configured.
/
    export const ADDRCONFIG: number;
    /**
If the IPv6 family was specified, but no IPv6 addresses were found, then return IPv4 mapped IPv6 addresses. It is not supported
on some operating systems (e.g. FreeBSD 10.1).
/
    export const V4MAPPED: number;
    /**
If `dns.V4MAPPED` is specified, return resolved IPv6 addresses as
well as IPv4 mapped IPv6 addresses.
/
    export const ALL: number;
    export interface LookupOptions {
        /**
The record family. Must be `4`, `6`, or `0`. For backward compatibility reasons, `'IPv4'` and `'IPv6'` are interpreted
as `4` and `6` respectively. The value 0 indicates that either an IPv4 or IPv6 address is returned. If the value `0` is used
with `{ all: true } (see below)`, both IPv4 and IPv6 addresses are returned.
@default 0
/
        family?: number | "IPv4" | "IPv6" | undefined;
        /**
One or more [supported `getaddrinfo`](https://nodejs.org/docs/latest-v24.x/api/dns.html#supported-getaddrinfo-flags) flags. Multiple flags may be
passed by bitwise `OR`ing their values.
/
        hints?: number | undefined;
        /**
When `true`, the callback returns all resolved addresses in an array. Otherwise, returns a single address.
@default false
/
        all?: boolean | undefined;
        /**
When `verbatim`, the resolved addresses are return unsorted. When `ipv4first`, the resolved addresses are sorted
by placing IPv4 addresses before IPv6 addresses. When `ipv6first`, the resolved addresses are sorted by placing IPv6
addresses before IPv4 addresses. Default value is configurable using
{@link setDefaultResultOrder} or [`--dns-result-order`](https://nodejs.org/docs/latest-v24.x/api/cli.html#--dns-result-orderorder).
@default `verbatim` (addresses are not reordered)
@since v22.1.0
/
        order?: "ipv4first" | "ipv6first" | "verbatim" | undefined;
        /**
When `true`, the callback receives IPv4 and IPv6 addresses in the order the DNS resolver returned them. When `false`, IPv4
addresses are placed before IPv6 addresses. This option will be deprecated in favor of `order`. When both are specified,
`order` has higher precedence. New code should only use `order`. Default value is configurable using {@link setDefaultResultOrder}
@default true (addresses are not reordered)
@deprecated Please use `order` option
/
        verbatim?: boolean | undefined;
    }
    export interface LookupOneOptions extends LookupOptions {
        all?: false | undefined;
    }
    export interface LookupAllOptions extends LookupOptions {
        all: true;
    }
    export interface LookupAddress {
        /**
A string representation of an IPv4 or IPv6 address.
/
        address: string;
        /**
`4` or `6`, denoting the family of `address`, or `0` if the address is not an IPv4 or IPv6 address. `0` is a likely indicator of a
bug in the name resolution service used by the operating system.
/
        family: number;
    }
    /**
Resolves a host name (e.g. `'nodejs.org'`) into the first found A (IPv4) or
AAAA (IPv6) record. All `option` properties are optional. If `options` is an
integer, then it must be `4` or `6`  if `options` is `0` or not provided, then
IPv4 and IPv6 addresses are both returned if found.

With the `all` option set to `true`, the arguments for `callback` change to `(err, addresses)`, with `addresses` being an array of objects with the
properties `address` and `family`.

On error, `err` is an `Error` object, where `err.code` is the error code.
Keep in mind that `err.code` will be set to `'ENOTFOUND'` not only when
the host name does not exist but also when the lookup fails in other ways
such as no available file descriptors.

`dns.lookup()` does not necessarily have anything to do with the DNS protocol.
The implementation uses an operating system facility that can associate names
with addresses and vice versa. This implementation can have subtle but
important consequences on the behavior of any Node.js program. Please take some
time to consult the [Implementation considerations section](https://nodejs.org/docs/latest-v24.x/api/dns.html#implementation-considerations)
before using `dns.lookup()`.

Example usage:

```js
import dns from 'node:dns';
const options = {
  family: 6,
  hints: dns.ADDRCONFIG | dns.V4MAPPED,
};
dns.lookup('example.com', options, (err, address, family) =>
  console.log('address: %j family: IPv%s', address, family));
// address: "2606:2800:220:1:248:1893:25c8:1946" family: IPv6

// When options.all is true, the result will be an Array.
options.all = true;
dns.lookup('example.com', options, (err, addresses) =>
  console.log('addresses: %j', addresses));
// addresses: [{"address":"2606:2800:220:1:248:1893:25c8:1946","family":6}]
```

If this method is invoked as its [util.promisify()](https://nodejs.org/docs/latest-v24.x/api/util.html#utilpromisifyoriginal) ed
version, and `all` is not set to `true`, it returns a `Promise` for an `Object` with `address` and `family` properties.
@since v0.1.90

## lookupService

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `lookupService(
        address: string,
        port: number,
        callback: (err: NodeJS.ErrnoException | null, hostname: string, service: string)`

JSDoc:

Resolves the given `address` and `port` into a host name and service using
the operating system's underlying `getnameinfo` implementation.

If `address` is not a valid IP address, a `TypeError` will be thrown.
The `port` will be coerced to a number. If it is not a legal port, a `TypeError` will be thrown.

On an error, `err` is an [`Error`](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) object,
where `err.code` is the error code.

```js
import dns from 'node:dns';
dns.lookupService('127.0.0.1', 22, (err, hostname, service) => {
  console.log(hostname, service);
  // Prints: localhost ssh
});
```

If this method is invoked as its [util.promisify()](https://nodejs.org/docs/latest-v24.x/api/util.html#utilpromisifyoriginal) ed
version, it returns a `Promise` for an `Object` with `hostname` and `service` properties.
@since v0.11.14

## resolve

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolve(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[])`

JSDoc:

@deprecated Use `AnyARecord` or `AnyAaaaRecord` instead. */
    export type AnyRecordWithTtl = AnyARecord | AnyAaaaRecord;
    export interface AnyARecord extends RecordWithTtl {
        type: "A";
    }
    export interface AnyAaaaRecord extends RecordWithTtl {
        type: "AAAA";
    }
    export interface CaaRecord {
        critical: number;
        issue?: string | undefined;
        issuewild?: string | undefined;
        iodef?: string | undefined;
        contactemail?: string | undefined;
        contactphone?: string | undefined;
    }
    export interface AnyCaaRecord extends CaaRecord {
        type: "CAA";
    }
    export interface MxRecord {
        priority: number;
        exchange: string;
    }
    export interface AnyMxRecord extends MxRecord {
        type: "MX";
    }
    export interface NaptrRecord {
        flags: string;
        service: string;
        regexp: string;
        replacement: string;
        order: number;
        preference: number;
    }
    export interface AnyNaptrRecord extends NaptrRecord {
        type: "NAPTR";
    }
    export interface SoaRecord {
        nsname: string;
        hostmaster: string;
        serial: number;
        refresh: number;
        retry: number;
        expire: number;
        minttl: number;
    }
    export interface AnySoaRecord extends SoaRecord {
        type: "SOA";
    }
    export interface SrvRecord {
        priority: number;
        weight: number;
        port: number;
        name: string;
    }
    export interface AnySrvRecord extends SrvRecord {
        type: "SRV";
    }
    export interface TlsaRecord {
        certUsage: number;
        selector: number;
        match: number;
        data: ArrayBuffer;
    }
    export interface AnyTlsaRecord extends TlsaRecord {
        type: "TLSA";
    }
    export interface AnyTxtRecord {
        type: "TXT";
        entries: string[];
    }
    export interface AnyNsRecord {
        type: "NS";
        value: string;
    }
    export interface AnyPtrRecord {
        type: "PTR";
        value: string;
    }
    export interface AnyCnameRecord {
        type: "CNAME";
        value: string;
    }
    export type AnyRecord =
        | AnyARecord
        | AnyAaaaRecord
        | AnyCaaRecord
        | AnyCnameRecord
        | AnyMxRecord
        | AnyNaptrRecord
        | AnyNsRecord
        | AnyPtrRecord
        | AnySoaRecord
        | AnySrvRecord
        | AnyTlsaRecord
        | AnyTxtRecord;
    /**
Uses the DNS protocol to resolve a host name (e.g. `'nodejs.org'`) into an array
of the resource records. The `callback` function has arguments `(err, records)`. When successful, `records` will be an array of resource
records. The type and structure of individual results varies based on `rrtype`:

<omitted>

On error, `err` is an [`Error`](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) object,
where `err.code` is one of the `DNS error codes`.
@since v0.1.27
@param hostname Host name to resolve.
@param [rrtype='A'] Resource record type.

## resolve4

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolve4(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[])`

JSDoc:

Uses the DNS protocol to resolve a IPv4 addresses (`A` records) for the `hostname`. The `addresses` argument passed to the `callback` function
will contain an array of IPv4 addresses (e.g.`['74.125.79.104', '74.125.79.105', '74.125.79.106']`).
@since v0.1.16
@param hostname Host name to resolve.

## resolve6

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolve6(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[])`

JSDoc:

Uses the DNS protocol to resolve IPv6 addresses (`AAAA` records) for the `hostname`. The `addresses` argument passed to the `callback` function
will contain an array of IPv6 addresses.
@since v0.1.16
@param hostname Host name to resolve.

## resolveCname

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveCname(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[])`

JSDoc:

Uses the DNS protocol to resolve `CNAME` records for the `hostname`. The `addresses` argument passed to the `callback` function
will contain an array of canonical name records available for the `hostname` (e.g. `['bar.example.com']`).
@since v0.3.2

## resolveCaa

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveCaa(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, records: CaaRecord[])`

JSDoc:

Uses the DNS protocol to resolve `CAA` records for the `hostname`. The `addresses` argument passed to the `callback` function
will contain an array of certification authority authorization records
available for the `hostname` (e.g. `[{critical: 0, iodef: 'mailto:pki@example.com'}, {critical: 128, issue: 'pki.example.com'}]`).
@since v15.0.0, v14.17.0

## resolveMx

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveMx(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: MxRecord[])`

JSDoc:

Uses the DNS protocol to resolve mail exchange records (`MX` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
contain an array of objects containing both a `priority` and `exchange` property (e.g. `[{priority: 10, exchange: 'mx.example.com'}, ...]`).
@since v0.1.27

## resolveNaptr

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveNaptr(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: NaptrRecord[])`

JSDoc:

Uses the DNS protocol to resolve regular expression-based records (`NAPTR` records) for the `hostname`. The `addresses` argument passed to the `callback` function will contain an array of
objects with the following properties:

* `flags`
* `service`
* `regexp`
* `replacement`
* `order`
* `preference`

```js
{
  flags: 's',
  service: 'SIP+D2U',
  regexp: '',
  replacement: '_sip._udp.example.com',
  order: 30,
  preference: 100
}
```
@since v0.9.12

## resolveNs

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveNs(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[])`

JSDoc:

Uses the DNS protocol to resolve name server records (`NS` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
contain an array of name server records available for `hostname` (e.g. `['ns1.example.com', 'ns2.example.com']`).
@since v0.1.90

## resolvePtr

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolvePtr(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[])`

JSDoc:

Uses the DNS protocol to resolve pointer records (`PTR` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
be an array of strings containing the reply records.
@since v6.0.0

## resolveSoa

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveSoa(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, address: SoaRecord)`

JSDoc:

Uses the DNS protocol to resolve a start of authority record (`SOA` record) for
the `hostname`. The `address` argument passed to the `callback` function will
be an object with the following properties:

* `nsname`
* `hostmaster`
* `serial`
* `refresh`
* `retry`
* `expire`
* `minttl`

```js
{
  nsname: 'ns.example.com',
  hostmaster: 'root.example.com',
  serial: 2013101809,
  refresh: 10000,
  retry: 2400,
  expire: 604800,
  minttl: 3600
}
```
@since v0.11.10

## resolveSrv

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveSrv(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: SrvRecord[])`

JSDoc:

Uses the DNS protocol to resolve service records (`SRV` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
be an array of objects with the following properties:

* `priority`
* `weight`
* `port`
* `name`

```js
{
  priority: 10,
  weight: 5,
  port: 21223,
  name: 'service.example.com'
}
```
@since v0.1.27

## resolveTlsa

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveTlsa(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: TlsaRecord[])`

JSDoc:

Uses the DNS protocol to resolve certificate associations (`TLSA` records) for
the `hostname`. The `records` argument passed to the `callback` function is an
array of objects with these properties:

* `certUsage`
* `selector`
* `match`
* `data`

```js
{
  certUsage: 3,
  selector: 1,
  match: 1,
  data: [ArrayBuffer]
}
```
@since v23.9.0, v22.15.0

## resolveTxt

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveTxt(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[][])`

JSDoc:

Uses the DNS protocol to resolve text queries (`TXT` records) for the `hostname`. The `records` argument passed to the `callback` function is a
two-dimensional array of the text records available for `hostname` (e.g.`[ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]`). Each sub-array contains TXT chunks of
one record. Depending on the use case, these could be either joined together or
treated separately.
@since v0.1.27

## resolveAny

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `resolveAny(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: AnyRecord[])`

JSDoc:

Uses the DNS protocol to resolve all records (also known as `ANY` or `*` query).
The `ret` argument passed to the `callback` function will be an array containing
various types of records. Each object has a property `type` that indicates the
type of the current record. And depending on the `type`, additional properties
will be present on the object:

<omitted>

Here is an example of the `ret` object passed to the callback:

```js
[ { type: 'A', address: '127.0.0.1', ttl: 299 },
  { type: 'CNAME', value: 'example.com' },
  { type: 'MX', exchange: 'alt4.aspmx.l.example.com', priority: 50 },
  { type: 'NS', value: 'ns1.example.com' },
  { type: 'TXT', entries: [ 'v=spf1 include:_spf.example.com ~all' ] },
  { type: 'SOA',
    nsname: 'ns1.example.com',
    hostmaster: 'admin.example.com',
    serial: 156696742,
    refresh: 900,
    retry: 900,
    expire: 1800,
    minttl: 60 } ]
```

DNS server operators may choose not to respond to `ANY` queries. It may be better to call individual methods like {@link resolve4}, {@link resolveMx}, and so on. For more details, see
[RFC 8482](https://tools.ietf.org/html/rfc8482).

## reverse

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `reverse(
        ip: string,
        callback: (err: NodeJS.ErrnoException | null, hostnames: string[])`

JSDoc:

Performs a reverse DNS query that resolves an IPv4 or IPv6 address to an
array of host names.

On error, `err` is an [`Error`](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-error) object, where `err.code` is
one of the [DNS error codes](https://nodejs.org/docs/latest-v24.x/api/dns.html#error-codes).
@since v0.1.16

## getDefaultResultOrder

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `getDefaultResultOrder()`

JSDoc:

Get the default value for `order` in {@link lookup} and [`dnsPromises.lookup()`](https://nodejs.org/docs/latest-v24.x/api/dns.html#dnspromiseslookuphostname-options).
The value could be:

* `ipv4first`: for `order` defaulting to `ipv4first`.
* `ipv6first`: for `order` defaulting to `ipv6first`.
* `verbatim`: for `order` defaulting to `verbatim`.
@since v18.17.0

## setServers

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `setServers(servers: readonly string[])`

JSDoc:

Sets the IP address and port of servers to be used when performing DNS
resolution. The `servers` argument is an array of [RFC 5952](https://tools.ietf.org/html/rfc5952#section-6) formatted
addresses. If the port is the IANA default DNS port (53) it can be omitted.

```js
dns.setServers([
  '4.4.4.4',
  '[2001:4860:4860::8888]',
  '4.4.4.4:1053',
  '[2001:4860:4860::8888]:1053',
]);
```

An error will be thrown if an invalid address is provided.

The `dns.setServers()` method must not be called while a DNS query is in
progress.

The {@link setServers} method affects only {@link resolve}, `dns.resolve*()` and {@link reverse} (and specifically _not_ {@link lookup}).

This method works much like [resolve.conf](https://man7.org/linux/man-pages/man5/resolv.conf.5.html).
That is, if attempting to resolve with the first server provided results in a `NOTFOUND` error, the `resolve()` method will _not_ attempt to resolve with
subsequent servers provided. Fallback DNS servers will only be used if the
earlier ones time out or result in some other error.
@since v0.11.3
@param servers array of [RFC 5952](https://datatracker.ietf.org/doc/html/rfc5952#section-6) formatted addresses

## getServers

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `getServers()`

JSDoc:

Returns an array of IP address strings, formatted according to [RFC 5952](https://tools.ietf.org/html/rfc5952#section-6),
that are currently configured for DNS resolution. A string will include a port
section if a custom port is used.

```js
[
  '4.4.4.4',
  '2001:4860:4860::8888',
  '4.4.4.4:1053',
  '[2001:4860:4860::8888]:1053',
]
```
@since v0.11.3

## setDefaultResultOrder

Source: `my-backend/node_modules/@types/node/dns.d.ts`

Signature: `setDefaultResultOrder(order: "ipv4first" | "ipv6first" | "verbatim")`

JSDoc:

Set the default value of `order` in {@link lookup} and [`dnsPromises.lookup()`](https://nodejs.org/docs/latest-v24.x/api/dns.html#dnspromiseslookuphostname-options).
The value could be:

* `ipv4first`: sets default `order` to `ipv4first`.
* `ipv6first`: sets default `order` to `ipv6first`.
* `verbatim`: sets default `order` to `verbatim`.

The default is `verbatim` and {@link setDefaultResultOrder} have higher
priority than [`--dns-result-order`](https://nodejs.org/docs/latest-v24.x/api/cli.html#--dns-result-orderorder). When using
[worker threads](https://nodejs.org/docs/latest-v24.x/api/worker_threads.html), {@link setDefaultResultOrder} from the main
thread won't affect the default dns orders in workers.
@since v16.4.0, v14.18.0
@param order must be `'ipv4first'`, `'ipv6first'` or `'verbatim'`.

## rename

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback)`

JSDoc:

The `node:fs` module enables interacting with the file system in a
way modeled on standard POSIX functions.

To use the promise-based APIs:

```js
import * as fs from 'node:fs/promises';
```

To use the callback and sync APIs:

```js
import * as fs from 'node:fs';
```

All file system operations have synchronous, callback, and promise-based
forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).
@see [source](https://github.com/nodejs/node/blob/v24.x/lib/fs.js)
/
declare module "fs" {
    import * as stream from "node:stream";
    import { Abortable, EventEmitter } from "node:events";
    import { URL } from "node:url";
    import * as promises from "node:fs/promises";
    export { promises };
    /**
Valid types for path values in "fs".
/
    export type PathLike = string | Buffer | URL;
    export type PathOrFileDescriptor = PathLike | number;
    export type TimeLike = string | number | Date;
    export type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;
    export type BufferEncodingOption =
        | "buffer"
        | {
            encoding: "buffer";
        };
    export interface ObjectEncodingOptions {
        encoding?: BufferEncoding | null | undefined;
    }
    export type EncodingOption = ObjectEncodingOptions | BufferEncoding | undefined | null;
    export type OpenMode = number | string;
    export type Mode = number | string;
    export interface StatsBase<T> {
        isFile(): boolean;
        isDirectory(): boolean;
        isBlockDevice(): boolean;
        isCharacterDevice(): boolean;
        isSymbolicLink(): boolean;
        isFIFO(): boolean;
        isSocket(): boolean;
        dev: T;
        ino: T;
        mode: T;
        nlink: T;
        uid: T;
        gid: T;
        rdev: T;
        size: T;
        blksize: T;
        blocks: T;
        atimeMs: T;
        mtimeMs: T;
        ctimeMs: T;
        birthtimeMs: T;
        atime: Date;
        mtime: Date;
        ctime: Date;
        birthtime: Date;
    }
    export interface Stats extends StatsBase<number> {}
    /**
A `fs.Stats` object provides information about a file.

Objects returned from {@link stat}, {@link lstat}, {@link fstat}, and
their synchronous counterparts are of this type.
If `bigint` in the `options` passed to those methods is true, the numeric values
will be `bigint` instead of `number`, and the object will contain additional
nanosecond-precision properties suffixed with `Ns`. `Stat` objects are not to be created directly using the `new` keyword.

```console
Stats {
  dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atimeMs: 1318289051000.1,
  mtimeMs: 1318289051000.1,
  ctimeMs: 1318289051000.1,
  birthtimeMs: 1318289051000.1,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
```

`bigint` version:

```console
BigIntStats {
  dev: 2114n,
  ino: 48064969n,
  mode: 33188n,
  nlink: 1n,
  uid: 85n,
  gid: 100n,
  rdev: 0n,
  size: 527n,
  blksize: 4096n,
  blocks: 8n,
  atimeMs: 1318289051000n,
  mtimeMs: 1318289051000n,
  ctimeMs: 1318289051000n,
  birthtimeMs: 1318289051000n,
  atimeNs: 1318289051000000000n,
  mtimeNs: 1318289051000000000n,
  ctimeNs: 1318289051000000000n,
  birthtimeNs: 1318289051000000000n,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
```
@since v0.1.21
/
    export class Stats {
        private constructor();
    }
    export interface StatsFsBase<T> {
        /** Type of file system. */
        type: T;
        /**  Optimal transfer block size. */
        bsize: T;
        /**  Total data blocks in file system. */
        blocks: T;
        /** Free blocks in file system. */
        bfree: T;
        /** Available blocks for unprivileged users */
        bavail: T;
        /** Total file nodes in file system. */
        files: T;
        /** Free file nodes in file system. */
        ffree: T;
    }
    export interface StatsFs extends StatsFsBase<number> {}
    /**
Provides information about a mounted file system.

Objects returned from {@link statfs} and its synchronous counterpart are of
this type. If `bigint` in the `options` passed to those methods is `true`, the
numeric values will be `bigint` instead of `number`.

```console
StatFs {
  type: 1397114950,
  bsize: 4096,
  blocks: 121938943,
  bfree: 61058895,
  bavail: 61058895,
  files: 999,
  ffree: 1000000
}
```

`bigint` version:

```console
StatFs {
  type: 1397114950n,
  bsize: 4096n,
  blocks: 121938943n,
  bfree: 61058895n,
  bavail: 61058895n,
  files: 999n,
  ffree: 1000000n
}
```
@since v19.6.0, v18.15.0
/
    export class StatsFs {}
    export interface BigIntStatsFs extends StatsFsBase<bigint> {}
    export interface StatFsOptions {
        bigint?: boolean | undefined;
    }
    /**
A representation of a directory entry, which can be a file or a subdirectory
within the directory, as returned by reading from an `fs.Dir`. The
directory entry is a combination of the file name and file type pairs.

Additionally, when {@link readdir} or {@link readdirSync} is called with
the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s.
@since v10.10.0
/
    export class Dirent<Name extends string | Buffer = string> {
        /**
Returns `true` if the `fs.Dirent` object describes a regular file.
@since v10.10.0
/
        isFile(): boolean;
        /**
Returns `true` if the `fs.Dirent` object describes a file system
directory.
@since v10.10.0
/
        isDirectory(): boolean;
        /**
Returns `true` if the `fs.Dirent` object describes a block device.
@since v10.10.0
/
        isBlockDevice(): boolean;
        /**
Returns `true` if the `fs.Dirent` object describes a character device.
@since v10.10.0
/
        isCharacterDevice(): boolean;
        /**
Returns `true` if the `fs.Dirent` object describes a symbolic link.
@since v10.10.0
/
        isSymbolicLink(): boolean;
        /**
Returns `true` if the `fs.Dirent` object describes a first-in-first-out
(FIFO) pipe.
@since v10.10.0
/
        isFIFO(): boolean;
        /**
Returns `true` if the `fs.Dirent` object describes a socket.
@since v10.10.0
/
        isSocket(): boolean;
        /**
The file name that this `fs.Dirent` object refers to. The type of this
value is determined by the `options.encoding` passed to {@link readdir} or {@link readdirSync}.
@since v10.10.0
/
        name: Name;
        /**
The path to the parent directory of the file this `fs.Dirent` object refers to.
@since v20.12.0, v18.20.0
/
        parentPath: string;
    }
    /**
A class representing a directory stream.

Created by {@link opendir}, {@link opendirSync}, or `fsPromises.opendir()`.

```js
import { opendir } from 'node:fs/promises';

try {
  const dir = await opendir('./');
  for await (const dirent of dir)
    console.log(dirent.name);
} catch (err) {
  console.error(err);
}
```

When using the async iterator, the `fs.Dir` object will be automatically
closed after the iterator exits.
@since v12.12.0
/
    export class Dir implements AsyncIterable<Dirent> {
        /**
The read-only path of this directory as was provided to {@link opendir},{@link opendirSync}, or `fsPromises.opendir()`.
@since v12.12.0
/
        readonly path: string;
        /**
Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
/
        [Symbol.asyncIterator](): NodeJS.AsyncIterator<Dirent>;
        /**
Asynchronously close the directory's underlying resource handle.
Subsequent reads will result in errors.

A promise is returned that will be fulfilled after the resource has been
closed.
@since v12.12.0
/
        close(): Promise<void>;
        close(cb: NoParamCallback): void;
        /**
Synchronously close the directory's underlying resource handle.
Subsequent reads will result in errors.
@since v12.12.0
/
        closeSync(): void;
        /**
Asynchronously read the next directory entry via [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) as an `fs.Dirent`.

A promise is returned that will be fulfilled with an `fs.Dirent`, or `null` if there are no more directory entries to read.

Directory entries returned by this function are in no particular order as
provided by the operating system's underlying directory mechanisms.
Entries added or removed while iterating over the directory might not be
included in the iteration results.
@since v12.12.0
@return containing {fs.Dirent|null}
/
        read(): Promise<Dirent | null>;
        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;
        /**
Synchronously read the next directory entry as an `fs.Dirent`. See the
POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more detail.

If there are no more directory entries to read, `null` will be returned.

Directory entries returned by this function are in no particular order as
provided by the operating system's underlying directory mechanisms.
Entries added or removed while iterating over the directory might not be
included in the iteration results.
@since v12.12.0
/
        readSync(): Dirent | null;
        /**
Calls `dir.close()` if the directory handle is open, and returns a promise that
fulfills when disposal is complete.
@since v24.1.0
/
        [Symbol.asyncDispose](): Promise<void>;
        /**
Calls `dir.closeSync()` if the directory handle is open, and returns
`undefined`.
@since v24.1.0
/
        [Symbol.dispose](): void;
    }
    /**
Class: fs.StatWatcher
@since v14.3.0, v12.20.0
Extends `EventEmitter`
A successful call to {@link watchFile} method will return a new fs.StatWatcher object.
/
    export interface StatWatcher extends EventEmitter {
        /**
When called, requests that the Node.js event loop _not_ exit so long as the `fs.StatWatcher` is active. Calling `watcher.ref()` multiple times will have
no effect.

By default, all `fs.StatWatcher` objects are "ref'ed", making it normally
unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
called previously.
@since v14.3.0, v12.20.0
/
        ref(): this;
        /**
When called, the active `fs.StatWatcher` object will not require the Node.js
event loop to remain active. If there is no other activity keeping the
event loop running, the process may exit before the `fs.StatWatcher` object's
callback is invoked. Calling `watcher.unref()` multiple times will have
no effect.
@since v14.3.0, v12.20.0
/
        unref(): this;
    }
    export interface FSWatcher extends EventEmitter {
        /**
Stop watching for changes on the given `fs.FSWatcher`. Once stopped, the `fs.FSWatcher` object is no longer usable.
@since v0.5.8
/
        close(): void;
        /**
When called, requests that the Node.js event loop _not_ exit so long as the `fs.FSWatcher` is active. Calling `watcher.ref()` multiple times will have
no effect.

By default, all `fs.FSWatcher` objects are "ref'ed", making it normally
unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
called previously.
@since v14.3.0, v12.20.0
/
        ref(): this;
        /**
When called, the active `fs.FSWatcher` object will not require the Node.js
event loop to remain active. If there is no other activity keeping the
event loop running, the process may exit before the `fs.FSWatcher` object's
callback is invoked. Calling `watcher.unref()` multiple times will have
no effect.
@since v14.3.0, v12.20.0
/
        unref(): this;
        /**
events.EventEmitter
  1. change
  2. close
  3. error
/
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
    }
    /**
Instances of `fs.ReadStream` are created and returned using the {@link createReadStream} function.
@since v0.1.93
/
    export class ReadStream extends stream.Readable {
        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
        /**
The number of bytes that have been read so far.
@since v6.4.0
/
        bytesRead: number;
        /**
The path to the file the stream is reading from as specified in the first
argument to `fs.createReadStream()`. If `path` is passed as a string, then`readStream.path` will be a string. If `path` is passed as a `Buffer`, then`readStream.path` will be a
`Buffer`. If `fd` is specified, then`readStream.path` will be `undefined`.
@since v0.1.93
/
        path: string | Buffer;
        /**
This property is `true` if the underlying file has not been opened yet,
i.e. before the `'ready'` event is emitted.
@since v11.2.0, v10.16.0
/
        pending: boolean;
        /**
events.EventEmitter
  1. open
  2. close
  3. ready
/
        addListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
        on<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
        once<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
        prependListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
        prependOnceListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
    }

    /**
The Keys are events of the ReadStream and the values are the functions that are called when the event is emitted.
/
    type ReadStreamEvents = {
        close: () => void;
        data: (chunk: Buffer | string) => void;
        end: () => void;
        error: (err: Error) => void;
        open: (fd: number) => void;
        pause: () => void;
        readable: () => void;
        ready: () => void;
        resume: () => void;
    } & CustomEvents;

    /**
string & {} allows to allow any kind of strings for the event
but still allows to have auto completion for the normal events.
/
    type CustomEvents = { [Key in string & {} | symbol]: (...args: any[]) => void };

    /**
The Keys are events of the WriteStream and the values are the functions that are called when the event is emitted.
/
    type WriteStreamEvents = {
        close: () => void;
        drain: () => void;
        error: (err: Error) => void;
        finish: () => void;
        open: (fd: number) => void;
        pipe: (src: stream.Readable) => void;
        ready: () => void;
        unpipe: (src: stream.Readable) => void;
    } & CustomEvents;
    /**
* Extends `stream.Writable`

Instances of `fs.WriteStream` are created and returned using the {@link createWriteStream} function.
@since v0.1.93
/
    export class WriteStream extends stream.Writable {
        /**
Closes `writeStream`. Optionally accepts a
callback that will be executed once the `writeStream`is closed.
@since v0.9.4
/
        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
        /**
The number of bytes written so far. Does not include data that is still queued
for writing.
@since v0.4.7
/
        bytesWritten: number;
        /**
The path to the file the stream is writing to as specified in the first
argument to {@link createWriteStream}. If `path` is passed as a string, then`writeStream.path` will be a string. If `path` is passed as a `Buffer`, then`writeStream.path` will be a
`Buffer`.
@since v0.1.93
/
        path: string | Buffer;
        /**
This property is `true` if the underlying file has not been opened yet,
i.e. before the `'ready'` event is emitted.
@since v11.2.0
/
        pending: boolean;
        /**
events.EventEmitter
  1. open
  2. close
  3. ready
/
        addListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
        on<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
        once<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
        prependListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
        prependOnceListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
    }
    /**
Asynchronously rename file at `oldPath` to the pathname provided
as `newPath`. In the case that `newPath` already exists, it will
be overwritten. If there is a directory at `newPath`, an error will
be raised instead. No arguments other than a possible exception are
given to the completion callback.

See also: [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html).

```js
import { rename } from 'node:fs';

rename('oldFile.txt', 'newFile.txt', (err) => {
  if (err) throw err;
  console.log('Rename complete!');
});
```
@since v0.0.2

## renameSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `renameSync(oldPath: PathLike, newPath: PathLike)`

JSDoc:

Asynchronous rename(2) - Change the name or location of a file or directory.
@param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
URL support is _experimental_.
@param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
URL support is _experimental_.
/
        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;
    }
    /**
Renames the file from `oldPath` to `newPath`. Returns `undefined`.

See the POSIX [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html) documentation for more details.
@since v0.1.21

## truncate

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `truncate(path: PathLike, len: number | undefined, callback: NoParamCallback)`

JSDoc:

Truncates the file. No arguments other than a possible exception are
given to the completion callback. A file descriptor can also be passed as the
first argument. In this case, `fs.ftruncate()` is called.

```js
import { truncate } from 'node:fs';
// Assuming that 'path/file.txt' is a regular file.
truncate('path/file.txt', (err) => {
  if (err) throw err;
  console.log('path/file.txt was truncated');
});
```

Passing a file descriptor is deprecated and may result in an error being thrown
in the future.

See the POSIX [`truncate(2)`](http://man7.org/linux/man-pages/man2/truncate.2.html) documentation for more details.
@since v0.8.6
@param [len=0]

## truncate

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `truncate(path: PathLike, callback: NoParamCallback)`

JSDoc:

Asynchronous truncate(2) - Truncate a file to a specified length.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.

## truncateSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `truncateSync(path: PathLike, len?: number)`

JSDoc:

Asynchronous truncate(2) - Truncate a file to a specified length.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param len If not specified, defaults to `0`.
/
        function __promisify__(path: PathLike, len?: number): Promise<void>;
    }
    /**
Truncates the file. Returns `undefined`. A file descriptor can also be
passed as the first argument. In this case, `fs.ftruncateSync()` is called.

Passing a file descriptor is deprecated and may result in an error being thrown
in the future.
@since v0.8.6
@param [len=0]

## ftruncate

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `ftruncate(fd: number, len: number | undefined, callback: NoParamCallback)`

JSDoc:

Truncates the file descriptor. No arguments other than a possible exception are
given to the completion callback.

See the POSIX [`ftruncate(2)`](http://man7.org/linux/man-pages/man2/ftruncate.2.html) documentation for more detail.

If the file referred to by the file descriptor was larger than `len` bytes, only
the first `len` bytes will be retained in the file.

For example, the following program retains only the first four bytes of the
file:

```js
import { open, close, ftruncate } from 'node:fs';

function closeFd(fd) {
  close(fd, (err) => {
    if (err) throw err;
  });
}

open('temp.txt', 'r+', (err, fd) => {
  if (err) throw err;

  try {
    ftruncate(fd, 4, (err) => {
      closeFd(fd);
      if (err) throw err;
    });
  } catch (err) {
    closeFd(fd);
    if (err) throw err;
  }
});
```

If the file previously was shorter than `len` bytes, it is extended, and the
extended part is filled with null bytes (`'\0'`):

If `len` is negative then `0` will be used.
@since v0.8.6
@param [len=0]

## ftruncate

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `ftruncate(fd: number, callback: NoParamCallback)`

JSDoc:

Asynchronous ftruncate(2) - Truncate a file to a specified length.
@param fd A file descriptor.

## ftruncateSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `ftruncateSync(fd: number, len?: number)`

JSDoc:

Asynchronous ftruncate(2) - Truncate a file to a specified length.
@param fd A file descriptor.
@param len If not specified, defaults to `0`.
/
        function __promisify__(fd: number, len?: number): Promise<void>;
    }
    /**
Truncates the file descriptor. Returns `undefined`.

For detailed information, see the documentation of the asynchronous version of
this API: {@link ftruncate}.
@since v0.8.6
@param [len=0]

## chown

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback)`

JSDoc:

Asynchronously changes owner and group of a file. No arguments other than a
possible exception are given to the completion callback.

See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
@since v0.1.97

## chownSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `chownSync(path: PathLike, uid: number, gid: number)`

JSDoc:

Asynchronous chown(2) - Change ownership of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
/
        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
    }
    /**
Synchronously changes owner and group of a file. Returns `undefined`.
This is the synchronous version of {@link chown}.

See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
@since v0.1.97

## fchown

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fchown(fd: number, uid: number, gid: number, callback: NoParamCallback)`

JSDoc:

Sets the owner of the file. No arguments other than a possible exception are
given to the completion callback.

See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
@since v0.4.7

## fchownSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fchownSync(fd: number, uid: number, gid: number)`

JSDoc:

Asynchronous fchown(2) - Change ownership of a file.
@param fd A file descriptor.
/
        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;
    }
    /**
Sets the owner of the file. Returns `undefined`.

See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
@since v0.4.7
@param uid The file's new owner's user id.
@param gid The file's new group's group id.

## lchown

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback)`

JSDoc:

Set the owner of the symbolic link. No arguments other than a possible
exception are given to the completion callback.

See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more detail.

## lchownSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `lchownSync(path: PathLike, uid: number, gid: number)`

JSDoc:

Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
/
        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
    }
    /**
Set the owner for the path. Returns `undefined`.

See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more details.
@param uid The file's new owner's user id.
@param gid The file's new group's group id.

## lutimes

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback)`

JSDoc:

Changes the access and modification times of a file in the same way as {@link utimes}, with the difference that if the path refers to a symbolic
link, then the link is not dereferenced: instead, the timestamps of the
symbolic link itself are changed.

No arguments other than a possible exception are given to the completion
callback.
@since v14.5.0, v12.19.0

## lutimesSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `lutimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike)`

JSDoc:

Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
with the difference that if the path refers to a symbolic link, then the link is not
dereferenced: instead, the timestamps of the symbolic link itself are changed.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param atime The last access time. If a string is provided, it will be coerced to number.
@param mtime The last modified time. If a string is provided, it will be coerced to number.
/
        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
Change the file system timestamps of the symbolic link referenced by `path`.
Returns `undefined`, or throws an exception when parameters are incorrect or
the operation fails. This is the synchronous version of {@link lutimes}.
@since v14.5.0, v12.19.0

## chmod

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `chmod(path: PathLike, mode: Mode, callback: NoParamCallback)`

JSDoc:

Asynchronously changes the permissions of a file. No arguments other than a
possible exception are given to the completion callback.

See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.

```js
import { chmod } from 'node:fs';

chmod('my_file.txt', 0o775, (err) => {
  if (err) throw err;
  console.log('The permissions for file "my_file.txt" have been changed!');
});
```
@since v0.1.30

## chmodSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `chmodSync(path: PathLike, mode: Mode)`

JSDoc:

Asynchronous chmod(2) - Change permissions of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param mode A file mode. If a string is passed, it is parsed as an octal integer.
/
        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
    }
    /**
For detailed information, see the documentation of the asynchronous version of
this API: {@link chmod}.

See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
@since v0.6.7

## fchmod

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fchmod(fd: number, mode: Mode, callback: NoParamCallback)`

JSDoc:

Sets the permissions on the file. No arguments other than a possible exception
are given to the completion callback.

See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
@since v0.4.7

## fchmodSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fchmodSync(fd: number, mode: Mode)`

JSDoc:

Asynchronous fchmod(2) - Change permissions of a file.
@param fd A file descriptor.
@param mode A file mode. If a string is passed, it is parsed as an octal integer.
/
        function __promisify__(fd: number, mode: Mode): Promise<void>;
    }
    /**
Sets the permissions on the file. Returns `undefined`.

See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
@since v0.4.7

## lchmod

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `lchmod(path: PathLike, mode: Mode, callback: NoParamCallback)`

JSDoc:

Changes the permissions on a symbolic link. No arguments other than a possible
exception are given to the completion callback.

This method is only implemented on macOS.

See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
@deprecated Since v0.4.7

## lchmodSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `lchmodSync(path: PathLike, mode: Mode)`

JSDoc:

@deprecated */
    export namespace lchmod {
        /**
Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param mode A file mode. If a string is passed, it is parsed as an octal integer.
/
        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
    }
    /**
Changes the permissions on a symbolic link. Returns `undefined`.

This method is only implemented on macOS.

See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
@deprecated Since v0.4.7

## stat

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats)`

JSDoc:

Asynchronous [`stat(2)`](http://man7.org/linux/man-pages/man2/stat.2.html). The callback gets two arguments `(err, stats)` where`stats` is an `fs.Stats` object.

In case of an error, the `err.code` will be one of `Common System Errors`.

{@link stat} follows symbolic links. Use {@link lstat} to look at the
links themselves.

Using `fs.stat()` to check for the existence of a file before calling`fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended.
Instead, user code should open/read/write the file directly and handle the
error raised if the file is not available.

To check if a file exists without manipulating it afterwards, {@link access} is recommended.

For example, given the following directory structure:

```text
- txtDir
-- file.txt
- app.js
```

The next program will check for the stats of the given paths:

```js
import { stat } from 'node:fs';

const pathsToCheck = ['./txtDir', './txtDir/file.txt'];

for (let i = 0; i < pathsToCheck.length; i++) {
  stat(pathsToCheck[i], (err, stats) => {
    console.log(stats.isDirectory());
    console.log(stats);
  });
}
```

The resulting output will resemble:

```console
true
Stats {
  dev: 16777220,
  mode: 16877,
  nlink: 3,
  uid: 501,
  gid: 20,
  rdev: 0,
  blksize: 4096,
  ino: 14214262,
  size: 96,
  blocks: 0,
  atimeMs: 1561174653071.963,
  mtimeMs: 1561174614583.3518,
  ctimeMs: 1561174626623.5366,
  birthtimeMs: 1561174126937.2893,
  atime: 2019-06-22T03:37:33.072Z,
  mtime: 2019-06-22T03:36:54.583Z,
  ctime: 2019-06-22T03:37:06.624Z,
  birthtime: 2019-06-22T03:28:46.937Z
}
false
Stats {
  dev: 16777220,
  mode: 33188,
  nlink: 1,
  uid: 501,
  gid: 20,
  rdev: 0,
  blksize: 4096,
  ino: 14214074,
  size: 8,
  blocks: 8,
  atimeMs: 1561174616618.8555,
  mtimeMs: 1561174614584,
  ctimeMs: 1561174614583.8145,
  birthtimeMs: 1561174007710.7478,
  atime: 2019-06-22T03:36:56.619Z,
  mtime: 2019-06-22T03:36:54.584Z,
  ctime: 2019-06-22T03:36:54.584Z,
  birthtime: 2019-06-22T03:26:47.711Z
}
```
@since v0.0.2

## fstat

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats)`

JSDoc:

Asynchronous stat(2) - Get file status.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
/
        function __promisify__(
            path: PathLike,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            path: PathLike,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    export interface StatSyncFn extends Function {
        (path: PathLike, options?: undefined): Stats;
        (
            path: PathLike,
            options?: StatSyncOptions & {
                bigint?: false | undefined;
                throwIfNoEntry: false;
            },
        ): Stats | undefined;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: true;
                throwIfNoEntry: false;
            },
        ): BigIntStats | undefined;
        (
            path: PathLike,
            options?: StatSyncOptions & {
                bigint?: false | undefined;
            },
        ): Stats;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: true;
            },
        ): BigIntStats;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: boolean;
                throwIfNoEntry?: false | undefined;
            },
        ): Stats | BigIntStats;
        (path: PathLike, options?: StatSyncOptions): Stats | BigIntStats | undefined;
    }
    /**
Synchronous stat(2) - Get file status.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
/
    export const statSync: StatSyncFn;
    /**
Invokes the callback with the `fs.Stats` for the file descriptor.

See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
@since v0.1.95

## fstatSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fstatSync(
        fd: number,
        options?: StatOptions & {
            bigint?: false | undefined;
        },
    )`

JSDoc:

Asynchronous fstat(2) - Get file status.
@param fd A file descriptor.
/
        function __promisify__(
            fd: number,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            fd: number,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    /**
Retrieves the `fs.Stats` for the file descriptor.

See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
@since v0.1.95

## lstat

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats)`

JSDoc:

Retrieves the `fs.Stats` for the symbolic link referred to by the path.
The callback gets two arguments `(err, stats)` where `stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if `path` is a symbolic
link, then the link itself is stat-ed, not the file that it refers to.

See the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) documentation for more details.
@since v0.1.30

## statfs

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `statfs(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: StatsFs)`

JSDoc:

Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
/
        function __promisify__(
            path: PathLike,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            path: PathLike,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    /**
Asynchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
contains `path`. The callback gets two arguments `(err, stats)` where `stats`is an `fs.StatFs` object.

In case of an error, the `err.code` will be one of `Common System Errors`.
@since v19.6.0, v18.15.0
@param path A path to an existing file or directory on the file system to be queried.

## statfsSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `statfsSync(
        path: PathLike,
        options?: StatFsOptions & {
            bigint?: false | undefined;
        },
    )`

JSDoc:

Asynchronous statfs(2) - Returns information about the mounted file system which contains path. The callback gets two arguments (err, stats) where stats is an <fs.StatFs> object.
@param path A path to an existing file or directory on the file system to be queried.
/
        function __promisify__(
            path: PathLike,
            options?: StatFsOptions & {
                bigint?: false | undefined;
            },
        ): Promise<StatsFs>;
        function __promisify__(
            path: PathLike,
            options: StatFsOptions & {
                bigint: true;
            },
        ): Promise<BigIntStatsFs>;
        function __promisify__(path: PathLike, options?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;
    }
    /**
Synchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
contains `path`.

In case of an error, the `err.code` will be one of `Common System Errors`.
@since v19.6.0, v18.15.0
@param path A path to an existing file or directory on the file system to be queried.

## link

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback)`

JSDoc:

Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
/
    export const lstatSync: StatSyncFn;
    /**
Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. No arguments other than
a possible
exception are given to the completion callback.
@since v0.1.31

## linkSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `linkSync(existingPath: PathLike, newPath: PathLike)`

JSDoc:

Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
@param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
@param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
/
        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;
    }
    /**
Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. Returns `undefined`.
@since v0.1.31

## symlink

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `symlink(
        target: PathLike,
        path: PathLike,
        type: symlink.Type | undefined | null,
        callback: NoParamCallback,
    )`

JSDoc:

Creates the link called `path` pointing to `target`. No arguments other than a
possible exception are given to the completion callback.

See the POSIX [`symlink(2)`](http://man7.org/linux/man-pages/man2/symlink.2.html) documentation for more details.

The `type` argument is only available on Windows and ignored on other platforms.
It can be set to `'dir'`, `'file'`, or `'junction'`. If the `type` argument is
not a string, Node.js will autodetect `target` type and use `'file'` or `'dir'`.
If the `target` does not exist, `'file'` will be used. Windows junction points
require the destination path to be absolute. When using `'junction'`, the`target` argument will automatically be normalized to absolute path. Junction
points on NTFS volumes can only point to directories.

Relative targets are relative to the link's parent directory.

```js
import { symlink } from 'node:fs';

symlink('./mew', './mewtwo', callback);
```

The above example creates a symbolic link `mewtwo` which points to `mew` in the
same directory:

```bash
$ tree .
.
 mew
 mewtwo -> ./mew
```
@since v0.1.31
@param [type='null']

## symlink

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `symlink(target: PathLike, path: PathLike, callback: NoParamCallback)`

JSDoc:

Asynchronous symlink(2) - Create a new symbolic link to an existing file.
@param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
@param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.

## symlinkSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null)`

JSDoc:

Asynchronous symlink(2) - Create a new symbolic link to an existing file.
@param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
@param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
@param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
/
        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;
        type Type = "dir" | "file" | "junction";
    }
    /**
Returns `undefined`.

For detailed information, see the documentation of the asynchronous version of
this API: {@link symlink}.
@since v0.1.31
@param [type='null']

## readlink

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readlink(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: string)`

JSDoc:

Reads the contents of the symbolic link referred to by `path`. The callback gets
two arguments `(err, linkString)`.

See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use for
the link path passed to the callback. If the `encoding` is set to `'buffer'`,
the link path returned will be passed as a `Buffer` object.
@since v0.1.31

## readlink

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readlink(
        path: PathLike,
        options: BufferEncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: Buffer)`

JSDoc:

Asynchronous readlink(2) - read value of a symbolic link.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## readlink

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readlink(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer)`

JSDoc:

Asynchronous readlink(2) - read value of a symbolic link.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## readlink

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readlink(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, linkString: string)`

JSDoc:

Asynchronous readlink(2) - read value of a symbolic link.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.

## readlinkSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readlinkSync(path: PathLike, options?: EncodingOption)`

JSDoc:

Asynchronous readlink(2) - read value of a symbolic link.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
        /**
Asynchronous readlink(2) - read value of a symbolic link.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
        /**
Asynchronous readlink(2) - read value of a symbolic link.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
    }
    /**
Returns the symbolic link's string value.

See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use for
the link path returned. If the `encoding` is set to `'buffer'`,
the link path returned will be passed as a `Buffer` object.
@since v0.1.31

## readlinkSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readlinkSync(path: PathLike, options: BufferEncodingOption)`

JSDoc:

Synchronous readlink(2) - read value of a symbolic link.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## readlinkSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readlinkSync(path: PathLike, options?: EncodingOption)`

JSDoc:

Synchronous readlink(2) - read value of a symbolic link.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## realpath

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `realpath(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string)`

JSDoc:

Asynchronously computes the canonical pathname by resolving `.`, `..`, and
symbolic links.

A canonical pathname is not necessarily unique. Hard links and bind mounts can
expose a file system entity through many pathnames.

This function behaves like [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html), with some exceptions:

1. No case conversion is performed on case-insensitive file systems.
2. The maximum number of symbolic links is platform-independent and generally
(much) higher than what the native [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html) implementation supports.

The `callback` gets two arguments `(err, resolvedPath)`. May use `process.cwd` to resolve relative paths.

Only paths that can be converted to UTF8 strings are supported.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use for
the path passed to the callback. If the `encoding` is set to `'buffer'`,
the path returned will be passed as a `Buffer` object.

If `path` resolves to a socket or a pipe, the function will return a system
dependent name for that object.
@since v0.1.31

## realpath

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `realpath(
        path: PathLike,
        options: BufferEncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer)`

JSDoc:

Asynchronous realpath(3) - return the canonicalized absolute pathname.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## realpath

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `realpath(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer)`

JSDoc:

Asynchronous realpath(3) - return the canonicalized absolute pathname.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## realpath

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `realpath(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string)`

JSDoc:

Asynchronous realpath(3) - return the canonicalized absolute pathname.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.

## realpathSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `realpathSync(path: PathLike, options?: EncodingOption)`

JSDoc:

Asynchronous realpath(3) - return the canonicalized absolute pathname.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
        /**
Asynchronous realpath(3) - return the canonicalized absolute pathname.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
        /**
Asynchronous realpath(3) - return the canonicalized absolute pathname.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
        /**
Asynchronous [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html).

The `callback` gets two arguments `(err, resolvedPath)`.

Only paths that can be converted to UTF8 strings are supported.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use for
the path passed to the callback. If the `encoding` is set to `'buffer'`,
the path returned will be passed as a `Buffer` object.

On Linux, when Node.js is linked against musl libc, the procfs file system must
be mounted on `/proc` in order for this function to work. Glibc does not have
this restriction.
@since v9.2.0
/
        function native(
            path: PathLike,
            options: EncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
        ): void;
        function native(
            path: PathLike,
            options: BufferEncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
        ): void;
        function native(
            path: PathLike,
            options: EncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
        ): void;
        function native(
            path: PathLike,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
        ): void;
    }
    /**
Returns the resolved pathname.

For detailed information, see the documentation of the asynchronous version of
this API: {@link realpath}.
@since v0.1.31

## realpathSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `realpathSync(path: PathLike, options: BufferEncodingOption)`

JSDoc:

Synchronous realpath(3) - return the canonicalized absolute pathname.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## realpathSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `realpathSync(path: PathLike, options?: EncodingOption)`

JSDoc:

Synchronous realpath(3) - return the canonicalized absolute pathname.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## unlink

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `unlink(path: PathLike, callback: NoParamCallback)`

JSDoc:

Asynchronously removes a file or symbolic link. No arguments other than a
possible exception are given to the completion callback.

```js
import { unlink } from 'node:fs';
// Assuming that 'path/file.txt' is a regular file.
unlink('path/file.txt', (err) => {
  if (err) throw err;
  console.log('path/file.txt was deleted');
});
```

`fs.unlink()` will not work on a directory, empty or otherwise. To remove a
directory, use {@link rmdir}.

See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more details.
@since v0.0.2

## unlinkSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `unlinkSync(path: PathLike)`

JSDoc:

Asynchronous unlink(2) - delete a name and possibly the file it refers to.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
/
        function __promisify__(path: PathLike): Promise<void>;
    }
    /**
Synchronous [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html). Returns `undefined`.
@since v0.1.21

## rmdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `rmdir(path: PathLike, callback: NoParamCallback)`

JSDoc:

If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
`EPERM` error is encountered, Node.js will retry the operation with a linear
backoff wait of `retryDelay` ms longer on each try. This option represents the
number of retries. This option is ignored if the `recursive` option is not
`true`.
@default 0
/
        maxRetries?: number | undefined;
        /**
@deprecated since v14.14.0 In future versions of Node.js and will trigger a warning
`fs.rmdir(path, { recursive: true })` will throw if `path` does not exist or is a file.
Use `fs.rm(path, { recursive: true, force: true })` instead.

If `true`, perform a recursive directory removal. In
recursive mode, operations are retried on failure.
@default false
/
        recursive?: boolean | undefined;
        /**
The amount of time in milliseconds to wait between retries.
This option is ignored if the `recursive` option is not `true`.
@default 100
/
        retryDelay?: number | undefined;
    }
    /**
Asynchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). No arguments other than a possible exception are given
to the completion callback.

Using `fs.rmdir()` on a file (not a directory) results in an `ENOENT` error on
Windows and an `ENOTDIR` error on POSIX.

To get a behavior similar to the `rm -rf` Unix command, use {@link rm} with options `{ recursive: true, force: true }`.
@since v0.0.2

## rmdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `rmdirSync(path: PathLike, options?: RmDirOptions)`

JSDoc:

Asynchronous rmdir(2) - delete a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
/
        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;
    }
    /**
Synchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). Returns `undefined`.

Using `fs.rmdirSync()` on a file (not a directory) results in an `ENOENT` error
on Windows and an `ENOTDIR` error on POSIX.

To get a behavior similar to the `rm -rf` Unix command, use {@link rmSync} with options `{ recursive: true, force: true }`.
@since v0.1.21

## rm

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `rm(path: PathLike, callback: NoParamCallback)`

JSDoc:

When `true`, exceptions will be ignored if `path` does not exist.
@default false
/
        force?: boolean | undefined;
        /**
If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
`EPERM` error is encountered, Node.js will retry the operation with a linear
backoff wait of `retryDelay` ms longer on each try. This option represents the
number of retries. This option is ignored if the `recursive` option is not
`true`.
@default 0
/
        maxRetries?: number | undefined;
        /**
If `true`, perform a recursive directory removal. In
recursive mode, operations are retried on failure.
@default false
/
        recursive?: boolean | undefined;
        /**
The amount of time in milliseconds to wait between retries.
This option is ignored if the `recursive` option is not `true`.
@default 100
/
        retryDelay?: number | undefined;
    }
    /**
Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). No arguments other than a possible exception are given to the
completion callback.
@since v14.14.0

## rmSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `rmSync(path: PathLike, options?: RmOptions)`

JSDoc:

Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility).
/
        function __promisify__(path: PathLike, options?: RmOptions): Promise<void>;
    }
    /**
Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). Returns `undefined`.
@since v14.14.0

## mkdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdir(
        path: PathLike,
        options: MakeDirectoryOptions & {
            recursive: true;
        },
        callback: (err: NodeJS.ErrnoException | null, path?: string)`

JSDoc:

Indicates whether parent folders should be created.
If a folder was created, the path to the first created folder will be returned.
@default false
/
        recursive?: boolean | undefined;
        /**
A file mode. If a string is passed, it is parsed as an octal integer. If not specified
@default 0o777
/
        mode?: Mode | undefined;
    }
    /**
Asynchronously creates a directory.

The callback is given a possible exception and, if `recursive` is `true`, the
first directory path created, `(err[, path])`.`path` can still be `undefined` when `recursive` is `true`, if no directory was
created (for instance, if it was previously created).

The optional `options` argument can be an integer specifying `mode` (permission
and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fs.mkdir()` when `path` is a directory that
exists results in an error only
when `recursive` is false. If `recursive` is false and the directory exists,
an `EEXIST` error occurs.

```js
import { mkdir } from 'node:fs';

// Create ./tmp/a/apple, regardless of whether ./tmp and ./tmp/a exist.
mkdir('./tmp/a/apple', { recursive: true }, (err) => {
  if (err) throw err;
});
```

On Windows, using `fs.mkdir()` on the root directory even with recursion will
result in an error:

```js
import { mkdir } from 'node:fs';

mkdir('/', { recursive: true }, (err) => {
  // => [Error: EPERM: operation not permitted, mkdir 'C:\']
});
```

See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
@since v0.1.8

## mkdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdir(
        path: PathLike,
        options:
            | Mode
            | (MakeDirectoryOptions & {
                recursive?: false | undefined;
            })`

JSDoc:

Asynchronous mkdir(2) - create a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.

## mkdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdir(
        path: PathLike,
        options: Mode | MakeDirectoryOptions | null | undefined,
        callback: (err: NodeJS.ErrnoException | null, path?: string)`

JSDoc:

Asynchronous mkdir(2) - create a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.

## mkdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdir(path: PathLike, callback: NoParamCallback)`

JSDoc:

Asynchronous mkdir(2) - create a directory with a mode of `0o777`.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.

## mkdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdirSync(
        path: PathLike,
        options: MakeDirectoryOptions & {
            recursive: true;
        },
    )`

JSDoc:

Asynchronous mkdir(2) - create a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
/
        function __promisify__(
            path: PathLike,
            options: MakeDirectoryOptions & {
                recursive: true;
            },
        ): Promise<string | undefined>;
        /**
Asynchronous mkdir(2) - create a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
/
        function __promisify__(
            path: PathLike,
            options?:
                | Mode
                | (MakeDirectoryOptions & {
                    recursive?: false | undefined;
                })
                | null,
        ): Promise<void>;
        /**
Asynchronous mkdir(2) - create a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
/
        function __promisify__(
            path: PathLike,
            options?: Mode | MakeDirectoryOptions | null,
        ): Promise<string | undefined>;
    }
    /**
Synchronously creates a directory. Returns `undefined`, or if `recursive` is `true`, the first directory path created.
This is the synchronous version of {@link mkdir}.

See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
@since v0.1.21

## mkdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdirSync(
        path: PathLike,
        options?:
            | Mode
            | (MakeDirectoryOptions & {
                recursive?: false | undefined;
            })`

JSDoc:

Synchronous mkdir(2) - create a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.

## mkdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdirSync(path: PathLike, options?: Mode | MakeDirectoryOptions | null)`

JSDoc:

Synchronous mkdir(2) - create a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.

## mkdtemp

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdtemp(
        prefix: string,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, folder: string)`

JSDoc:

Creates a unique temporary directory.

Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory. Due to platform
inconsistencies, avoid trailing `X` characters in `prefix`. Some platforms,
notably the BSDs, can return more than six random characters, and replace
trailing `X` characters in `prefix` with random characters.

The created directory path is passed as a string to the callback's second
parameter.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use.

```js
import { mkdtemp } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';

mkdtemp(join(tmpdir(), 'foo-'), (err, directory) => {
  if (err) throw err;
  console.log(directory);
  // Prints: /tmp/foo-itXde2 or C:\Users\...\AppData\Local\Temp\foo-itXde2
});
```

The `fs.mkdtemp()` method will append the six randomly selected characters
directly to the `prefix` string. For instance, given a directory `/tmp`, if the
intention is to create a temporary directory _within_`/tmp`, the `prefix`must end with a trailing platform-specific path separator
(`import { sep } from 'node:path'`).

```js
import { tmpdir } from 'node:os';
import { mkdtemp } from 'node:fs';

// The parent directory for the new temporary directory
const tmpDir = tmpdir();

// This method is *INCORRECT*:
mkdtemp(tmpDir, (err, directory) => {
  if (err) throw err;
  console.log(directory);
  // Will print something similar to `/tmpabc123`.
  // A new temporary directory is created at the file system root
  // rather than *within* the /tmp directory.
});

// This method is *CORRECT*:
import { sep } from 'node:path';
mkdtemp(`${tmpDir}${sep}`, (err, directory) => {
  if (err) throw err;
  console.log(directory);
  // Will print something similar to `/tmp/abc123`.
  // A new temporary directory is created within
  // the /tmp directory.
});
```
@since v5.10.0

## mkdtemp

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdtemp(
        prefix: string,
        options:
            | "buffer"
            | {
                encoding: "buffer";
            },
        callback: (err: NodeJS.ErrnoException | null, folder: Buffer)`

JSDoc:

Asynchronously creates a unique temporary directory.
Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## mkdtemp

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdtemp(
        prefix: string,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer)`

JSDoc:

Asynchronously creates a unique temporary directory.
Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## mkdtemp

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdtemp(
        prefix: string,
        callback: (err: NodeJS.ErrnoException | null, folder: string)`

JSDoc:

Asynchronously creates a unique temporary directory.
Generates six random characters to be appended behind a required prefix to create a unique temporary directory.

## mkdtempSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdtempSync(prefix: string, options?: EncodingOption)`

JSDoc:

Asynchronously creates a unique temporary directory.
Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(prefix: string, options?: EncodingOption): Promise<string>;
        /**
Asynchronously creates a unique temporary directory.
Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(prefix: string, options: BufferEncodingOption): Promise<Buffer>;
        /**
Asynchronously creates a unique temporary directory.
Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(prefix: string, options?: EncodingOption): Promise<string | Buffer>;
    }
    /**
Returns the created directory path.

For detailed information, see the documentation of the asynchronous version of
this API: {@link mkdtemp}.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use.
@since v5.10.0

## mkdtempSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdtempSync(prefix: string, options: BufferEncodingOption)`

JSDoc:

Synchronously creates a unique temporary directory.
Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## mkdtempSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdtempSync(prefix: string, options?: EncodingOption)`

JSDoc:

Synchronously creates a unique temporary directory.
Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## mkdtempDisposableSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `mkdtempDisposableSync(prefix: string, options?: EncodingOption)`

JSDoc:

The path of the created directory.
/
        path: string;
        /**
A function which removes the created directory.
/
        remove(): Promise<void>;
        /**
The same as `remove`.
/
        [Symbol.asyncDispose](): Promise<void>;
    }
    /**
Returns a disposable object whose `path` property holds the created directory
path. When the object is disposed, the directory and its contents will be
removed if it still exists. If the directory cannot be deleted, disposal will
throw an error. The object has a `remove()` method which will perform the same
task.

<!-- TODO: link MDN docs for disposables once https://github.com/mdn/content/pull/38027 lands -->

For detailed information, see the documentation of `fs.mkdtemp()`.

There is no callback-based version of this API because it is designed for use
with the `using` syntax.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use.
@since v24.4.0

## readdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdir(
        path: PathLike,
        options:
            | {
                encoding: BufferEncoding | null;
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | BufferEncoding
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, files: string[])`

JSDoc:

Reads the contents of a directory. The callback gets two arguments `(err, files)` where `files` is an array of the names of the files in the directory excluding `'.'` and `'..'`.

See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use for
the filenames passed to the callback. If the `encoding` is set to `'buffer'`,
the filenames returned will be passed as `Buffer` objects.

If `options.withFileTypes` is set to `true`, the `files` array will contain `fs.Dirent` objects.
@since v0.1.8

## readdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdir(
        path: PathLike,
        options:
            | {
                encoding: "buffer";
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | "buffer",
        callback: (err: NodeJS.ErrnoException | null, files: Buffer[])`

JSDoc:

Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## readdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdir(
        path: PathLike,
        options:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })`

JSDoc:

Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## readdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdir(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, files: string[])`

JSDoc:

Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.

## readdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdir(
        path: PathLike,
        options: ObjectEncodingOptions & {
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
        callback: (err: NodeJS.ErrnoException | null, files: Dirent[])`

JSDoc:

Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options If called with `withFileTypes: true` the result data will be an array of Dirent.

## readdir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdir(
        path: PathLike,
        options: {
            encoding: "buffer";
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
        callback: (err: NodeJS.ErrnoException | null, files: Dirent<Buffer>[])`

JSDoc:

Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Must include `withFileTypes: true` and `encoding: 'buffer'`.

## readdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdirSync(
        path: PathLike,
        options?:
            | {
                encoding: BufferEncoding | null;
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | BufferEncoding
            | null,
    )`

JSDoc:

Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(
            path: PathLike,
            options?:
                | {
                    encoding: BufferEncoding | null;
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                }
                | BufferEncoding
                | null,
        ): Promise<string[]>;
        /**
Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(
            path: PathLike,
            options:
                | "buffer"
                | {
                    encoding: "buffer";
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                },
        ): Promise<Buffer[]>;
        /**
Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
/
        function __promisify__(
            path: PathLike,
            options?:
                | (ObjectEncodingOptions & {
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                })
                | BufferEncoding
                | null,
        ): Promise<string[] | Buffer[]>;
        /**
Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options If called with `withFileTypes: true` the result data will be an array of Dirent
/
        function __promisify__(
            path: PathLike,
            options: ObjectEncodingOptions & {
                withFileTypes: true;
                recursive?: boolean | undefined;
            },
        ): Promise<Dirent[]>;
        /**
Asynchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
/
        function __promisify__(
            path: PathLike,
            options: {
                encoding: "buffer";
                withFileTypes: true;
                recursive?: boolean | undefined;
            },
        ): Promise<Dirent<Buffer>[]>;
    }
    /**
Reads the contents of the directory.

See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.

The optional `options` argument can be a string specifying an encoding, or an
object with an `encoding` property specifying the character encoding to use for
the filenames returned. If the `encoding` is set to `'buffer'`,
the filenames returned will be passed as `Buffer` objects.

If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.
@since v0.1.21

## readdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdirSync(
        path: PathLike,
        options:
            | {
                encoding: "buffer";
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | "buffer",
    )`

JSDoc:

Synchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## readdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdirSync(
        path: PathLike,
        options?:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })`

JSDoc:

Synchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.

## readdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdirSync(
        path: PathLike,
        options: ObjectEncodingOptions & {
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
    )`

JSDoc:

Synchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options If called with `withFileTypes: true` the result data will be an array of Dirent.

## readdirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readdirSync(
        path: PathLike,
        options: {
            encoding: "buffer";
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
    )`

JSDoc:

Synchronous readdir(3) - read a directory.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param options Must include `withFileTypes: true` and `encoding: 'buffer'`.

## close

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `close(fd: number, callback?: NoParamCallback)`

JSDoc:

Closes the file descriptor. No arguments other than a possible exception are
given to the completion callback.

Calling `fs.close()` on any file descriptor (`fd`) that is currently in use
through any other `fs` operation may lead to undefined behavior.

See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
@since v0.0.2

## closeSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `closeSync(fd: number)`

JSDoc:

Asynchronous close(2) - close a file descriptor.
@param fd A file descriptor.
/
        function __promisify__(fd: number): Promise<void>;
    }
    /**
Closes the file descriptor. Returns `undefined`.

Calling `fs.closeSync()` on any file descriptor (`fd`) that is currently in use
through any other `fs` operation may lead to undefined behavior.

See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
@since v0.1.21

## open

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `open(
        path: PathLike,
        flags: OpenMode | undefined,
        mode: Mode | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, fd: number)`

JSDoc:

Asynchronous file open. See the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more details.

`mode` sets the file mode (permission and sticky bits), but only if the file was
created. On Windows, only the write permission can be manipulated; see {@link chmod}.

The callback gets two arguments `(err, fd)`.

Some characters (`< > : " / \ | ? *`) are reserved under Windows as documented
by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).

Functions based on `fs.open()` exhibit this behavior as well:`fs.writeFile()`, `fs.readFile()`, etc.
@since v0.0.2
@param [flags='r'] See `support of file system `flags``.
@param [mode=0o666]

## open

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `open(
        path: PathLike,
        flags: OpenMode | undefined,
        callback: (err: NodeJS.ErrnoException | null, fd: number)`

JSDoc:

Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param [flags='r'] See `support of file system `flags``.

## open

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `open(path: PathLike, callback: (err: NodeJS.ErrnoException | null, fd: number)`

JSDoc:

Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.

## openSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `openSync(path: PathLike, flags: OpenMode, mode?: Mode | null)`

JSDoc:

Asynchronous open(2) - open and possibly create a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
/
        function __promisify__(path: PathLike, flags: OpenMode, mode?: Mode | null): Promise<number>;
    }
    /**
Returns an integer representing the file descriptor.

For detailed information, see the documentation of the asynchronous version of
this API: {@link open}.
@since v0.1.21
@param [flags='r']
@param [mode=0o666]

## utimes

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `utimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback)`

JSDoc:

Change the file system timestamps of the object referenced by `path`.

The `atime` and `mtime` arguments follow these rules:

* Values can be either numbers representing Unix epoch time in seconds, `Date`s, or a numeric string like `'123456789.0'`.
* If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.
@since v0.4.2

## utimesSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `utimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike)`

JSDoc:

Asynchronously change file timestamps of the file referenced by the supplied path.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
@param atime The last access time. If a string is provided, it will be coerced to number.
@param mtime The last modified time. If a string is provided, it will be coerced to number.
/
        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
Returns `undefined`.

For detailed information, see the documentation of the asynchronous version of
this API: {@link utimes}.
@since v0.4.2

## futimes

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `futimes(fd: number, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback)`

JSDoc:

Change the file system timestamps of the object referenced by the supplied file
descriptor. See {@link utimes}.
@since v0.4.2

## futimesSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `futimesSync(fd: number, atime: TimeLike, mtime: TimeLike)`

JSDoc:

Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param atime The last access time. If a string is provided, it will be coerced to number.
@param mtime The last modified time. If a string is provided, it will be coerced to number.
/
        function __promisify__(fd: number, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
Synchronous version of {@link futimes}. Returns `undefined`.
@since v0.4.2

## fsync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fsync(fd: number, callback: NoParamCallback)`

JSDoc:

Request that all data for the open file descriptor is flushed to the storage
device. The specific implementation is operating system and device specific.
Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. No arguments other
than a possible exception are given to the completion callback.
@since v0.1.96

## fsyncSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fsyncSync(fd: number)`

JSDoc:

Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
@param fd A file descriptor.
/
        function __promisify__(fd: number): Promise<void>;
    }
    /**
Request that all data for the open file descriptor is flushed to the storage
device. The specific implementation is operating system and device specific.
Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. Returns `undefined`.
@since v0.1.96

## write

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `write(<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        length: number | undefined | null,
        position: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer)`

JSDoc:

@default 0
/
        offset?: number | undefined;
        /**
@default `buffer.byteLength - offset`
/
        length?: number | undefined;
        /**
@default null
/
        position?: number | undefined | null;
    }
    /**
Write `buffer` to the file specified by `fd`.

`offset` determines the part of the buffer to be written, and `length` is
an integer specifying the number of bytes to write.

`position` refers to the offset from the beginning of the file where this data
should be written. If `typeof position !== 'number'`, the data will be written
at the current position. See [`pwrite(2)`](http://man7.org/linux/man-pages/man2/pwrite.2.html).

The callback will be given three arguments `(err, bytesWritten, buffer)` where `bytesWritten` specifies how many _bytes_ were written from `buffer`.

If this method is invoked as its `util.promisify()` ed version, it returns
a promise for an `Object` with `bytesWritten` and `buffer` properties.

It is unsafe to use `fs.write()` multiple times on the same file without waiting
for the callback. For this scenario, {@link createWriteStream} is
recommended.

On Linux, positional writes don't work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.
@since v0.0.2
@param [offset=0]
@param [length=buffer.byteLength - offset]
@param [position='null']

## write

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `write(<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        length: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer)`

JSDoc:

Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param offset The part of the buffer to be written. If not supplied, defaults to `0`.
@param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.

## write

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `write(<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer)`

JSDoc:

Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param offset The part of the buffer to be written. If not supplied, defaults to `0`.

## write

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `write(<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer)`

JSDoc:

Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.

## write

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `write(<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        options: WriteOptions,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer)`

JSDoc:

Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param options An object with the following properties:
* `offset` The part of the buffer to be written. If not supplied, defaults to `0`.
* `length` The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
* `position` The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.

## write

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `write(
        fd: number,
        string: string,
        position: number | undefined | null,
        encoding: BufferEncoding | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string)`

JSDoc:

Asynchronously writes `string` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param string A string to write.
@param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
@param encoding The expected string encoding.

## write

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `write(
        fd: number,
        string: string,
        position: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string)`

JSDoc:

Asynchronously writes `string` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param string A string to write.
@param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.

## write

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `write(
        fd: number,
        string: string,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string)`

JSDoc:

Asynchronously writes `string` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param string A string to write.

## writeSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `writeSync(
        fd: number,
        buffer: NodeJS.ArrayBufferView,
        offset?: number | null,
        length?: number | null,
        position?: number | null,
    )`

JSDoc:

Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param offset The part of the buffer to be written. If not supplied, defaults to `0`.
@param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
@param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
/
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer?: TBuffer,
            offset?: number,
            length?: number,
            position?: number | null,
        ): Promise<{
            bytesWritten: number;
            buffer: TBuffer;
        }>;
        /**
Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param options An object with the following properties:
* `offset` The part of the buffer to be written. If not supplied, defaults to `0`.
* `length` The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
* `position` The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
/
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer?: TBuffer,
            options?: WriteOptions,
        ): Promise<{
            bytesWritten: number;
            buffer: TBuffer;
        }>;
        /**
Asynchronously writes `string` to the file referenced by the supplied file descriptor.
@param fd A file descriptor.
@param string A string to write.
@param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
@param encoding The expected string encoding.
/
        function __promisify__(
            fd: number,
            string: string,
            position?: number | null,
            encoding?: BufferEncoding | null,
        ): Promise<{
            bytesWritten: number;
            buffer: string;
        }>;
    }
    /**
For detailed information, see the documentation of the asynchronous version of
this API: {@link write}.
@since v0.1.21
@param [offset=0]
@param [length=buffer.byteLength - offset]
@param [position='null']
@return The number of bytes written.

## writeSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `writeSync(
        fd: number,
        string: string,
        position?: number | null,
        encoding?: BufferEncoding | null,
    )`

JSDoc:

Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.
@param fd A file descriptor.
@param string A string to write.
@param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
@param encoding The expected string encoding.

## read

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `read(<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number,
        length: number,
        position: ReadPosition | null,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer)`

JSDoc:

@default 0
/
        offset?: number | undefined;
        /**
@default `length of buffer`
/
        length?: number | undefined;
        /**
@default null
/
        position?: ReadPosition | null | undefined;
    }
    export interface ReadAsyncOptions<TBuffer extends NodeJS.ArrayBufferView> extends ReadSyncOptions {
        buffer?: TBuffer;
    }
    /**
Read data from the file specified by `fd`.

The callback is given the three arguments, `(err, bytesRead, buffer)`.

If the file is not modified concurrently, the end-of-file is reached when the
number of bytes read is zero.

If this method is invoked as its `util.promisify()` ed version, it returns
a promise for an `Object` with `bytesRead` and `buffer` properties.
@since v0.0.2
@param buffer The buffer that the data will be written to.
@param offset The position in `buffer` to write the data to.
@param length The number of bytes to read.
@param position Specifies where to begin reading from in the file. If `position` is `null` or `-1 `, data will be read from the current file position, and the file position will be updated. If
`position` is an integer, the file position will be unchanged.

## read

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `read(<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        options: ReadAsyncOptions<TBuffer>,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer)`

JSDoc:

Similar to the above `fs.read` function, this version takes an optional `options` object.
If not otherwise specified in an `options` object,
`buffer` defaults to `Buffer.alloc(16384)`,
`offset` defaults to `0`,
`length` defaults to `buffer.byteLength`, `- offset` as of Node 17.6.0
`position` defaults to `null`
@since v12.17.0, 13.11.0

## readSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readSync(
        fd: number,
        buffer: NodeJS.ArrayBufferView,
        offset: number,
        length: number,
        position: ReadPosition | null,
    )`

JSDoc:

@param fd A file descriptor.
@param buffer The buffer that the data will be written to.
@param offset The offset in the buffer at which to start writing.
@param length The number of bytes to read.
@param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
/
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer: TBuffer,
            offset: number,
            length: number,
            position: ReadPosition | null,
        ): Promise<{
            bytesRead: number;
            buffer: TBuffer;
        }>;
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            options: ReadAsyncOptions<TBuffer>,
        ): Promise<{
            bytesRead: number;
            buffer: TBuffer;
        }>;
        function __promisify__(fd: number): Promise<{
            bytesRead: number;
            buffer: NodeJS.ArrayBufferView;
        }>;
    }
    /**
Returns the number of `bytesRead`.

For detailed information, see the documentation of the asynchronous version of
this API: {@link read}.
@since v0.1.21
@param [position='null']

## readSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions)`

JSDoc:

Similar to the above `fs.readSync` function, this version takes an optional `options` object.
If no `options` object is specified, it will default with the above values.

## readFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readFile(
        path: PathOrFileDescriptor,
        options:
            | ({
                encoding?: null | undefined;
                flag?: string | undefined;
            } & Abortable)`

JSDoc:

Asynchronously reads the entire contents of a file.

```js
import { readFile } from 'node:fs';

readFile('/etc/passwd', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```

The callback is passed two arguments `(err, data)`, where `data` is the
contents of the file.

If no encoding is specified, then the raw buffer is returned.

If `options` is a string, then it specifies the encoding:

```js
import { readFile } from 'node:fs';

readFile('/etc/passwd', 'utf8', callback);
```

When the path is a directory, the behavior of `fs.readFile()` and {@link readFileSync} is platform-specific. On macOS, Linux, and Windows, an
error will be returned. On FreeBSD, a representation of the directory's contents
will be returned.

```js
import { readFile } from 'node:fs';

// macOS, Linux, and Windows
readFile('<directory>', (err, data) => {
  // => [Error: EISDIR: illegal operation on a directory, read <directory>]
});

//  FreeBSD
readFile('<directory>', (err, data) => {
  // => null, <data>
});
```

It is possible to abort an ongoing request using an `AbortSignal`. If a
request is aborted the callback is called with an `AbortError`:

```js
import { readFile } from 'node:fs';

const controller = new AbortController();
const signal = controller.signal;
readFile(fileInfo[0].name, { signal }, (err, buf) => {
  // ...
});
// When you want to abort the request
controller.abort();
```

The `fs.readFile()` function buffers the entire file. To minimize memory costs,
when possible prefer streaming via `fs.createReadStream()`.

Aborting an ongoing request does not abort individual operating
system requests but rather the internal buffering `fs.readFile` performs.
@since v0.1.29
@param path filename or file descriptor

## readFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readFile(
        path: PathOrFileDescriptor,
        options:
            | ({
                encoding: BufferEncoding;
                flag?: string | undefined;
            } & Abortable)`

JSDoc:

Asynchronously reads the entire contents of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
If a flag is not provided, it defaults to `'r'`.

## readFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readFile(
        path: PathOrFileDescriptor,
        options:
            | (ObjectEncodingOptions & {
                flag?: string | undefined;
            } & Abortable)`

JSDoc:

Asynchronously reads the entire contents of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
If a flag is not provided, it defaults to `'r'`.

## readFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readFile(
        path: PathOrFileDescriptor,
        callback: (err: NodeJS.ErrnoException | null, data: NonSharedBuffer)`

JSDoc:

Asynchronously reads the entire contents of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.

## readFileSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readFileSync(
        path: PathOrFileDescriptor,
        options?: {
            encoding?: null | undefined;
            flag?: string | undefined;
        } | null,
    )`

JSDoc:

Asynchronously reads the entire contents of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param options An object that may contain an optional flag.
If a flag is not provided, it defaults to `'r'`.
/
        function __promisify__(
            path: PathOrFileDescriptor,
            options?: {
                encoding?: null | undefined;
                flag?: string | undefined;
            } | null,
        ): Promise<NonSharedBuffer>;
        /**
Asynchronously reads the entire contents of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
URL support is _experimental_.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
If a flag is not provided, it defaults to `'r'`.
/
        function __promisify__(
            path: PathOrFileDescriptor,
            options:
                | {
                    encoding: BufferEncoding;
                    flag?: string | undefined;
                }
                | BufferEncoding,
        ): Promise<string>;
        /**
Asynchronously reads the entire contents of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
URL support is _experimental_.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
If a flag is not provided, it defaults to `'r'`.
/
        function __promisify__(
            path: PathOrFileDescriptor,
            options?:
                | (ObjectEncodingOptions & {
                    flag?: string | undefined;
                })
                | BufferEncoding
                | null,
        ): Promise<string | NonSharedBuffer>;
    }
    /**
Returns the contents of the `path`.

For detailed information, see the documentation of the asynchronous version of
this API: {@link readFile}.

If the `encoding` option is specified then this function returns a
string. Otherwise it returns a buffer.

Similar to {@link readFile}, when the path is a directory, the behavior of `fs.readFileSync()` is platform-specific.

```js
import { readFileSync } from 'node:fs';

// macOS, Linux, and Windows
readFileSync('<directory>');
// => [Error: EISDIR: illegal operation on a directory, read <directory>]

//  FreeBSD
readFileSync('<directory>'); // => <data>
```
@since v0.1.8
@param path filename or file descriptor

## readFileSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readFileSync(
        path: PathOrFileDescriptor,
        options:
            | {
                encoding: BufferEncoding;
                flag?: string | undefined;
            }
            | BufferEncoding,
    )`

JSDoc:

Synchronously reads the entire contents of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
If a flag is not provided, it defaults to `'r'`.

## readFileSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readFileSync(
        path: PathOrFileDescriptor,
        options?:
            | (ObjectEncodingOptions & {
                flag?: string | undefined;
            })`

JSDoc:

Synchronously reads the entire contents of a file.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
If a flag is not provided, it defaults to `'r'`.

## writeFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `writeFile(
        file: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        options: WriteFileOptions,
        callback: NoParamCallback,
    )`

JSDoc:

When `file` is a filename, asynchronously writes data to the file, replacing the
file if it already exists. `data` can be a string or a buffer.

When `file` is a file descriptor, the behavior is similar to calling `fs.write()` directly (which is recommended). See the notes below on using
a file descriptor.

The `encoding` option is ignored if `data` is a buffer.

The `mode` option only affects the newly created file. See {@link open} for more details.

```js
import { writeFile } from 'node:fs';
import { Buffer } from 'node:buffer';

const data = new Uint8Array(Buffer.from('Hello Node.js'));
writeFile('message.txt', data, (err) => {
  if (err) throw err;
  console.log('The file has been saved!');
});
```

If `options` is a string, then it specifies the encoding:

```js
import { writeFile } from 'node:fs';

writeFile('message.txt', 'Hello Node.js', 'utf8', callback);
```

It is unsafe to use `fs.writeFile()` multiple times on the same file without
waiting for the callback. For this scenario, {@link createWriteStream} is
recommended.

Similarly to `fs.readFile` \- `fs.writeFile` is a convenience method that
performs multiple `write` calls internally to write the buffer passed to it.
For performance sensitive code consider using {@link createWriteStream}.

It is possible to use an `AbortSignal` to cancel an `fs.writeFile()`.
Cancelation is "best effort", and some amount of data is likely still
to be written.

```js
import { writeFile } from 'node:fs';
import { Buffer } from 'node:buffer';

const controller = new AbortController();
const { signal } = controller;
const data = new Uint8Array(Buffer.from('Hello Node.js'));
writeFile('message.txt', data, { signal }, (err) => {
  // When a request is aborted - the callback is called with an AbortError
});
// When the request should be aborted
controller.abort();
```

Aborting an ongoing request does not abort individual operating
system requests but rather the internal buffering `fs.writeFile` performs.
@since v0.1.29
@param file filename or file descriptor

## writeFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `writeFile(
        path: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        callback: NoParamCallback,
    )`

JSDoc:

Asynchronously writes data to a file, replacing the file if it already exists.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.

## writeFileSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `writeFileSync(
        file: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        options?: WriteFileOptions,
    )`

JSDoc:

Asynchronously writes data to a file, replacing the file if it already exists.
@param path A path to a file. If a URL is provided, it must use the `file:` protocol.
URL support is _experimental_.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
@param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
If `encoding` is not supplied, the default of `'utf8'` is used.
If `mode` is not supplied, the default of `0o666` is used.
If `mode` is a string, it is parsed as an octal integer.
If `flag` is not supplied, the default of `'w'` is used.
/
        function __promisify__(
            path: PathOrFileDescriptor,
            data: string | NodeJS.ArrayBufferView,
            options?: WriteFileOptions,
        ): Promise<void>;
    }
    /**
Returns `undefined`.

The `mode` option only affects the newly created file. See {@link open} for more details.

For detailed information, see the documentation of the asynchronous version of
this API: {@link writeFile}.
@since v0.1.29
@param file filename or file descriptor

## appendFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `appendFile(
        path: PathOrFileDescriptor,
        data: string | Uint8Array,
        options: WriteFileOptions,
        callback: NoParamCallback,
    )`

JSDoc:

Asynchronously append data to a file, creating the file if it does not yet
exist. `data` can be a string or a `Buffer`.

The `mode` option only affects the newly created file. See {@link open} for more details.

```js
import { appendFile } from 'node:fs';

appendFile('message.txt', 'data to append', (err) => {
  if (err) throw err;
  console.log('The "data to append" was appended to file!');
});
```

If `options` is a string, then it specifies the encoding:

```js
import { appendFile } from 'node:fs';

appendFile('message.txt', 'data to append', 'utf8', callback);
```

The `path` may be specified as a numeric file descriptor that has been opened
for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
not be closed automatically.

```js
import { open, close, appendFile } from 'node:fs';

function closeFd(fd) {
  close(fd, (err) => {
    if (err) throw err;
  });
}

open('message.txt', 'a', (err, fd) => {
  if (err) throw err;

  try {
    appendFile(fd, 'data to append', 'utf8', (err) => {
      closeFd(fd);
      if (err) throw err;
    });
  } catch (err) {
    closeFd(fd);
    throw err;
  }
});
```
@since v0.6.7
@param path filename or file descriptor

## appendFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `appendFile(file: PathOrFileDescriptor, data: string | Uint8Array, callback: NoParamCallback)`

JSDoc:

Asynchronously append data to a file, creating the file if it does not exist.
@param file A path to a file. If a URL is provided, it must use the `file:` protocol.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.

## appendFileSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `appendFileSync(
        path: PathOrFileDescriptor,
        data: string | Uint8Array,
        options?: WriteFileOptions,
    )`

JSDoc:

Asynchronously append data to a file, creating the file if it does not exist.
@param file A path to a file. If a URL is provided, it must use the `file:` protocol.
URL support is _experimental_.
If a file descriptor is provided, the underlying file will _not_ be closed automatically.
@param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
@param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
If `encoding` is not supplied, the default of `'utf8'` is used.
If `mode` is not supplied, the default of `0o666` is used.
If `mode` is a string, it is parsed as an octal integer.
If `flag` is not supplied, the default of `'a'` is used.
/
        function __promisify__(
            file: PathOrFileDescriptor,
            data: string | Uint8Array,
            options?: WriteFileOptions,
        ): Promise<void>;
    }
    /**
Synchronously append data to a file, creating the file if it does not yet
exist. `data` can be a string or a `Buffer`.

The `mode` option only affects the newly created file. See {@link open} for more details.

```js
import { appendFileSync } from 'node:fs';

try {
  appendFileSync('message.txt', 'data to append');
  console.log('The "data to append" was appended to file!');
} catch (err) {
  // Handle the error
}
```

If `options` is a string, then it specifies the encoding:

```js
import { appendFileSync } from 'node:fs';

appendFileSync('message.txt', 'data to append', 'utf8');
```

The `path` may be specified as a numeric file descriptor that has been opened
for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
not be closed automatically.

```js
import { openSync, closeSync, appendFileSync } from 'node:fs';

let fd;

try {
  fd = openSync('message.txt', 'a');
  appendFileSync(fd, 'data to append', 'utf8');
} catch (err) {
  // Handle the error
} finally {
  if (fd !== undefined)
    closeSync(fd);
}
```
@since v0.6.7
@param path filename or file descriptor

## watchFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `watchFile(
        filename: PathLike,
        options:
            | (WatchFileOptions & {
                bigint?: false | undefined;
            })`

JSDoc:

Watch for changes on `filename`. The callback `listener` will be called each
time the file is accessed.

The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
whether the process should continue to run as long as files are being watched.
The `options` object may specify an `interval` property indicating how often the
target should be polled in milliseconds.

The `listener` gets two arguments the current stat object and the previous
stat object:

```js
import { watchFile } from 'node:fs';

watchFile('message.text', (curr, prev) => {
  console.log(`the current mtime is: ${curr.mtime}`);
  console.log(`the previous mtime was: ${prev.mtime}`);
});
```

These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
the numeric values in these objects are specified as `BigInt`s.

To be notified when the file was modified, not just accessed, it is necessary
to compare `curr.mtimeMs` and `prev.mtimeMs`.

When an `fs.watchFile` operation results in an `ENOENT` error, it
will invoke the listener once, with all the fields zeroed (or, for dates, the
Unix Epoch). If the file is created later on, the listener will be called
again, with the latest stat objects. This is a change in functionality since
v0.10.

Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.

When a file being watched by `fs.watchFile()` disappears and reappears,
then the contents of `previous` in the second callback event (the file's
reappearance) will be the same as the contents of `previous` in the first
callback event (its disappearance).

This happens when:

* the file is deleted, followed by a restore
* the file is renamed and then renamed a second time back to its original name
@since v0.1.31
/
    export interface WatchFileOptions {
        bigint?: boolean | undefined;
        persistent?: boolean | undefined;
        interval?: number | undefined;
    }
    /**
Watch for changes on `filename`. The callback `listener` will be called each
time the file is accessed.

The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
whether the process should continue to run as long as files are being watched.
The `options` object may specify an `interval` property indicating how often the
target should be polled in milliseconds.

The `listener` gets two arguments the current stat object and the previous
stat object:

```js
import { watchFile } from 'node:fs';

watchFile('message.text', (curr, prev) => {
  console.log(`the current mtime is: ${curr.mtime}`);
  console.log(`the previous mtime was: ${prev.mtime}`);
});
```

These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
the numeric values in these objects are specified as `BigInt`s.

To be notified when the file was modified, not just accessed, it is necessary
to compare `curr.mtimeMs` and `prev.mtimeMs`.

When an `fs.watchFile` operation results in an `ENOENT` error, it
will invoke the listener once, with all the fields zeroed (or, for dates, the
Unix Epoch). If the file is created later on, the listener will be called
again, with the latest stat objects. This is a change in functionality since
v0.10.

Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.

When a file being watched by `fs.watchFile()` disappears and reappears,
then the contents of `previous` in the second callback event (the file's
reappearance) will be the same as the contents of `previous` in the first
callback event (its disappearance).

This happens when:

* the file is deleted, followed by a restore
* the file is renamed and then renamed a second time back to its original name
@since v0.1.31

## watchFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `watchFile(filename: PathLike, listener: StatsListener)`

JSDoc:

Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
@param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.

## unwatchFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `unwatchFile(filename: PathLike, listener?: StatsListener)`

JSDoc:

Stop watching for changes on `filename`. If `listener` is specified, only that
particular listener is removed. Otherwise, _all_ listeners are removed,
effectively stopping watching of `filename`.

Calling `fs.unwatchFile()` with a filename that is not being watched is a
no-op, not an error.

Using {@link watch} is more efficient than `fs.watchFile()` and `fs.unwatchFile()`. `fs.watch()` should be used instead of `fs.watchFile()` and `fs.unwatchFile()` when possible.
@since v0.1.31
@param listener Optional, a listener previously attached using `fs.watchFile()`

## watch

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `watch(
        filename: PathLike,
        options?: WatchOptionsWithStringEncoding | BufferEncoding | null,
        listener?: WatchListener<string>,
    )`

JSDoc:

Watch for changes on `filename`, where `filename` is either a file or a
directory.

The second argument is optional. If `options` is provided as a string, it
specifies the `encoding`. Otherwise `options` should be passed as an object.

The listener callback gets two arguments `(eventType, filename)`. `eventType`is either `'rename'` or `'change'`, and `filename` is the name of the file
which triggered the event.

On most platforms, `'rename'` is emitted whenever a filename appears or
disappears in the directory.

The listener callback is attached to the `'change'` event fired by `fs.FSWatcher`, but it is not the same thing as the `'change'` value of `eventType`.

If a `signal` is passed, aborting the corresponding AbortController will close
the returned `fs.FSWatcher`.
@since v0.5.10
@param listener

## exists

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `exists(path: PathLike, callback: (exists: boolean)`

JSDoc:

Test whether or not the given path exists by checking with the file system.
Then call the `callback` argument with either true or false:

```js
import { exists } from 'node:fs';

exists('/etc/passwd', (e) => {
  console.log(e ? 'it exists' : 'no passwd!');
});
```

**The parameters for this callback are not consistent with other Node.js**
**callbacks.** Normally, the first parameter to a Node.js callback is an `err` parameter, optionally followed by other parameters. The `fs.exists()` callback
has only one boolean parameter. This is one reason `fs.access()` is recommended
instead of `fs.exists()`.

Using `fs.exists()` to check for the existence of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended. Doing
so introduces a race condition, since other processes may change the file's
state between the two calls. Instead, user code should open/read/write the
file directly and handle the error raised if the file does not exist.

**write (NOT RECOMMENDED)**

```js
import { exists, open, close } from 'node:fs';

exists('myfile', (e) => {
  if (e) {
    console.error('myfile already exists');
  } else {
    open('myfile', 'wx', (err, fd) => {
      if (err) throw err;

      try {
        writeMyData(fd);
      } finally {
        close(fd, (err) => {
          if (err) throw err;
        });
      }
    });
  }
});
```

**write (RECOMMENDED)**

```js
import { open, close } from 'node:fs';
open('myfile', 'wx', (err, fd) => {
  if (err) {
    if (err.code === 'EEXIST') {
      console.error('myfile already exists');
      return;
    }

    throw err;
  }

  try {
    writeMyData(fd);
  } finally {
    close(fd, (err) => {
      if (err) throw err;
    });
  }
});
```

**read (NOT RECOMMENDED)**

```js
import { open, close, exists } from 'node:fs';

exists('myfile', (e) => {
  if (e) {
    open('myfile', 'r', (err, fd) => {
      if (err) throw err;

      try {
        readMyData(fd);
      } finally {
        close(fd, (err) => {
          if (err) throw err;
        });
      }
    });
  } else {
    console.error('myfile does not exist');
  }
});
```

**read (RECOMMENDED)**

```js
import { open, close } from 'node:fs';

open('myfile', 'r', (err, fd) => {
  if (err) {
    if (err.code === 'ENOENT') {
      console.error('myfile does not exist');
      return;
    }

    throw err;
  }

  try {
    readMyData(fd);
  } finally {
    close(fd, (err) => {
      if (err) throw err;
    });
  }
});
```

The "not recommended" examples above check for existence and then use the
file; the "recommended" examples are better because they use the file directly
and handle the error, if any.

In general, check for the existence of a file only if the file won't be
used directly, for example when its existence is a signal from another
process.
@since v0.0.2
@deprecated Since v1.0.0 - Use {@link stat} or {@link access} instead.

## existsSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `existsSync(path: PathLike)`

JSDoc:

@deprecated */
    export namespace exists {
        /**
@param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
URL support is _experimental_.
/
        function __promisify__(path: PathLike): Promise<boolean>;
    }
    /**
Returns `true` if the path exists, `false` otherwise.

For detailed information, see the documentation of the asynchronous version of
this API: {@link exists}.

`fs.exists()` is deprecated, but `fs.existsSync()` is not. The `callback` parameter to `fs.exists()` accepts parameters that are inconsistent with other
Node.js callbacks. `fs.existsSync()` does not use a callback.

```js
import { existsSync } from 'node:fs';

if (existsSync('/etc/passwd'))
  console.log('The path exists.');
```
@since v0.1.21

## access

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `access(path: PathLike, mode: number | undefined, callback: NoParamCallback)`

JSDoc:

Constant for fs.access(). File is visible to the calling process. */
        const F_OK: number;
        /** Constant for fs.access(). File can be read by the calling process. */
        const R_OK: number;
        /** Constant for fs.access(). File can be written by the calling process. */
        const W_OK: number;
        /** Constant for fs.access(). File can be executed by the calling process. */
        const X_OK: number;
        // File Copy Constants
        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */
        const COPYFILE_EXCL: number;
        /**
Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.
If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.
/
        const COPYFILE_FICLONE: number;
        /**
Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.
If the underlying platform does not support copy-on-write, then the operation will fail with an error.
/
        const COPYFILE_FICLONE_FORCE: number;
        // File Open Constants
        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */
        const O_RDONLY: number;
        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */
        const O_WRONLY: number;
        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */
        const O_RDWR: number;
        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */
        const O_CREAT: number;
        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */
        const O_EXCL: number;
        /**
Constant for fs.open(). Flag indicating that if path identifies a terminal device,
opening the path shall not cause that terminal to become the controlling terminal for the process
(if the process does not already have one).
/
        const O_NOCTTY: number;
        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */
        const O_TRUNC: number;
        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */
        const O_APPEND: number;
        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */
        const O_DIRECTORY: number;
        /**
constant for fs.open().
Flag indicating reading accesses to the file system will no longer result in
an update to the atime information associated with the file.
This flag is available on Linux operating systems only.
/
        const O_NOATIME: number;
        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */
        const O_NOFOLLOW: number;
        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */
        const O_SYNC: number;
        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */
        const O_DSYNC: number;
        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */
        const O_SYMLINK: number;
        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */
        const O_DIRECT: number;
        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */
        const O_NONBLOCK: number;
        // File Type Constants
        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */
        const S_IFMT: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */
        const S_IFREG: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */
        const S_IFDIR: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */
        const S_IFCHR: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */
        const S_IFBLK: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */
        const S_IFIFO: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */
        const S_IFLNK: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */
        const S_IFSOCK: number;
        // File Mode Constants
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */
        const S_IRWXU: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */
        const S_IRUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */
        const S_IWUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */
        const S_IXUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */
        const S_IRWXG: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */
        const S_IRGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */
        const S_IWGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */
        const S_IXGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */
        const S_IRWXO: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */
        const S_IROTH: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */
        const S_IWOTH: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */
        const S_IXOTH: number;
        /**
When set, a memory file mapping is used to access the file. This flag
is available on Windows operating systems only. On other operating systems,
this flag is ignored.
/
        const UV_FS_O_FILEMAP: number;
    }
    /**
Tests a user's permissions for the file or directory specified by `path`.
The `mode` argument is an optional integer that specifies the accessibility
checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`
(e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
possible values of `mode`.

The final argument, `callback`, is a callback function that is invoked with
a possible error argument. If any of the accessibility checks fail, the error
argument will be an `Error` object. The following examples check if `package.json` exists, and if it is readable or writable.

```js
import { access, constants } from 'node:fs';

const file = 'package.json';

// Check if the file exists in the current directory.
access(file, constants.F_OK, (err) => {
  console.log(`${file} ${err ? 'does not exist' : 'exists'}`);
});

// Check if the file is readable.
access(file, constants.R_OK, (err) => {
  console.log(`${file} ${err ? 'is not readable' : 'is readable'}`);
});

// Check if the file is writable.
access(file, constants.W_OK, (err) => {
  console.log(`${file} ${err ? 'is not writable' : 'is writable'}`);
});

// Check if the file is readable and writable.
access(file, constants.R_OK | constants.W_OK, (err) => {
  console.log(`${file} ${err ? 'is not' : 'is'} readable and writable`);
});
```

Do not use `fs.access()` to check for the accessibility of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()`. Doing
so introduces a race condition, since other processes may change the file's
state between the two calls. Instead, user code should open/read/write the
file directly and handle the error raised if the file is not accessible.

**write (NOT RECOMMENDED)**

```js
import { access, open, close } from 'node:fs';

access('myfile', (err) => {
  if (!err) {
    console.error('myfile already exists');
    return;
  }

  open('myfile', 'wx', (err, fd) => {
    if (err) throw err;

    try {
      writeMyData(fd);
    } finally {
      close(fd, (err) => {
        if (err) throw err;
      });
    }
  });
});
```

**write (RECOMMENDED)**

```js
import { open, close } from 'node:fs';

open('myfile', 'wx', (err, fd) => {
  if (err) {
    if (err.code === 'EEXIST') {
      console.error('myfile already exists');
      return;
    }

    throw err;
  }

  try {
    writeMyData(fd);
  } finally {
    close(fd, (err) => {
      if (err) throw err;
    });
  }
});
```

**read (NOT RECOMMENDED)**

```js
import { access, open, close } from 'node:fs';
access('myfile', (err) => {
  if (err) {
    if (err.code === 'ENOENT') {
      console.error('myfile does not exist');
      return;
    }

    throw err;
  }

  open('myfile', 'r', (err, fd) => {
    if (err) throw err;

    try {
      readMyData(fd);
    } finally {
      close(fd, (err) => {
        if (err) throw err;
      });
    }
  });
});
```

**read (RECOMMENDED)**

```js
import { open, close } from 'node:fs';

open('myfile', 'r', (err, fd) => {
  if (err) {
    if (err.code === 'ENOENT') {
      console.error('myfile does not exist');
      return;
    }

    throw err;
  }

  try {
    readMyData(fd);
  } finally {
    close(fd, (err) => {
      if (err) throw err;
    });
  }
});
```

The "not recommended" examples above check for accessibility and then use the
file; the "recommended" examples are better because they use the file directly
and handle the error, if any.

In general, check for the accessibility of a file only if the file will not be
used directly, for example when its accessibility is a signal from another
process.

On Windows, access-control policies (ACLs) on a directory may limit access to
a file or directory. The `fs.access()` function, however, does not check the
ACL and therefore may report that a path is accessible even if the ACL restricts
the user from reading or writing to it.
@since v0.11.15
@param [mode=fs.constants.F_OK]

## access

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `access(path: PathLike, callback: NoParamCallback)`

JSDoc:

Asynchronously tests a user's permissions for the file specified by path.
@param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.

## accessSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `accessSync(path: PathLike, mode?: number)`

JSDoc:

Asynchronously tests a user's permissions for the file specified by path.
@param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
URL support is _experimental_.
/
        function __promisify__(path: PathLike, mode?: number): Promise<void>;
    }
    /**
Synchronously tests a user's permissions for the file or directory specified
by `path`. The `mode` argument is an optional integer that specifies the
accessibility checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and
`fs.constants.X_OK` (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
possible values of `mode`.

If any of the accessibility checks fail, an `Error` will be thrown. Otherwise,
the method will return `undefined`.

```js
import { accessSync, constants } from 'node:fs';

try {
  accessSync('etc/passwd', constants.R_OK | constants.W_OK);
  console.log('can read/write');
} catch (err) {
  console.error('no access!');
}
```
@since v0.11.15
@param [mode=fs.constants.F_OK]

## createReadStream

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `createReadStream(path: PathLike, options?: BufferEncoding | ReadStreamOptions)`

JSDoc:

`options` can include `start` and `end` values to read a range of bytes from
the file instead of the entire file. Both `start` and `end` are inclusive and
start counting at 0, allowed values are in the
\[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. If `fd` is specified and `start` is
omitted or `undefined`, `fs.createReadStream()` reads sequentially from the
current file position. The `encoding` can be any one of those accepted by `Buffer`.

If `fd` is specified, `ReadStream` will ignore the `path` argument and will use
the specified file descriptor. This means that no `'open'` event will be
emitted. `fd` should be blocking; non-blocking `fd`s should be passed to `net.Socket`.

If `fd` points to a character device that only supports blocking reads
(such as keyboard or sound card), read operations do not finish until data is
available. This can prevent the process from exiting and the stream from
closing naturally.

By default, the stream will emit a `'close'` event after it has been
destroyed.  Set the `emitClose` option to `false` to change this behavior.

By providing the `fs` option, it is possible to override the corresponding `fs` implementations for `open`, `read`, and `close`. When providing the `fs` option,
an override for `read` is required. If no `fd` is provided, an override for `open` is also required. If `autoClose` is `true`, an override for `close` is
also required.

```js
import { createReadStream } from 'node:fs';

// Create a stream from some character device.
const stream = createReadStream('/dev/input/event0');
setTimeout(() => {
  stream.close(); // This may not close the stream.
  // Artificially marking end-of-stream, as if the underlying resource had
  // indicated end-of-file by itself, allows the stream to close.
  // This does not cancel pending read operations, and if there is such an
  // operation, the process may still not be able to exit successfully
  // until it finishes.
  stream.push(null);
  stream.read(0);
}, 100);
```

If `autoClose` is false, then the file descriptor won't be closed, even if
there's an error. It is the application's responsibility to close it and make
sure there's no file descriptor leak. If `autoClose` is set to true (default
behavior), on `'error'` or `'end'` the file descriptor will be closed
automatically.

`mode` sets the file mode (permission and sticky bits), but only if the
file was created.

An example to read the last 10 bytes of a file which is 100 bytes long:

```js
import { createReadStream } from 'node:fs';

createReadStream('sample.txt', { start: 90, end: 99 });
```

If `options` is a string, then it specifies the encoding.
@since v0.1.31

## createWriteStream

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `createWriteStream(path: PathLike, options?: BufferEncoding | WriteStreamOptions)`

JSDoc:

`options` may also include a `start` option to allow writing data at some
position past the beginning of the file, allowed values are in the
\[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. Modifying a file rather than
replacing it may require the `flags` option to be set to `r+` rather than the
default `w`. The `encoding` can be any one of those accepted by `Buffer`.

If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,
then the file descriptor won't be closed, even if there's an error.
It is the application's responsibility to close it and make sure there's no
file descriptor leak.

By default, the stream will emit a `'close'` event after it has been
destroyed.  Set the `emitClose` option to `false` to change this behavior.

By providing the `fs` option it is possible to override the corresponding `fs` implementations for `open`, `write`, `writev`, and `close`. Overriding `write()` without `writev()` can reduce
performance as some optimizations (`_writev()`)
will be disabled. When providing the `fs` option, overrides for at least one of `write` and `writev` are required. If no `fd` option is supplied, an override
for `open` is also required. If `autoClose` is `true`, an override for `close` is also required.

Like `fs.ReadStream`, if `fd` is specified, `fs.WriteStream` will ignore the `path` argument and will use the specified file descriptor. This means that no `'open'` event will be
emitted. `fd` should be blocking; non-blocking `fd`s
should be passed to `net.Socket`.

If `options` is a string, then it specifies the encoding.
@since v0.1.31

## fdatasync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fdatasync(fd: number, callback: NoParamCallback)`

JSDoc:

Forces all currently queued I/O operations associated with the file to the
operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. No arguments other
than a possible
exception are given to the completion callback.
@since v0.1.96

## fdatasyncSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `fdatasyncSync(fd: number)`

JSDoc:

Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
@param fd A file descriptor.
/
        function __promisify__(fd: number): Promise<void>;
    }
    /**
Forces all currently queued I/O operations associated with the file to the
operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. Returns `undefined`.
@since v0.1.96

## copyFile

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback)`

JSDoc:

Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it
already exists. No arguments other than a possible exception are given to the
callback function. Node.js makes no guarantees about the atomicity of the copy
operation. If an error occurs after the destination file has been opened for
writing, Node.js will attempt to remove the destination.

`mode` is an optional integer that specifies the behavior
of the copy operation. It is possible to create a mask consisting of the bitwise
OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).

* `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
exists.
* `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
copy-on-write reflink. If the platform does not support copy-on-write, then a
fallback copy mechanism is used.
* `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
create a copy-on-write reflink. If the platform does not support
copy-on-write, then the operation will fail.

```js
import { copyFile, constants } from 'node:fs';

function callback(err) {
  if (err) throw err;
  console.log('source.txt was copied to destination.txt');
}

// destination.txt will be created or overwritten by default.
copyFile('source.txt', 'destination.txt', callback);

// By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL, callback);
```
@since v8.5.0
@param src source filename to copy
@param dest destination filename of the copy operation
@param [mode=0] modifiers for copy operation.

## copyFileSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `copyFileSync(src: PathLike, dest: PathLike, mode?: number)`

JSDoc:

Synchronously copies `src` to `dest`. By default, `dest` is overwritten if it
already exists. Returns `undefined`. Node.js makes no guarantees about the
atomicity of the copy operation. If an error occurs after the destination file
has been opened for writing, Node.js will attempt to remove the destination.

`mode` is an optional integer that specifies the behavior
of the copy operation. It is possible to create a mask consisting of the bitwise
OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).

* `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
exists.
* `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
copy-on-write reflink. If the platform does not support copy-on-write, then a
fallback copy mechanism is used.
* `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
create a copy-on-write reflink. If the platform does not support
copy-on-write, then the operation will fail.

```js
import { copyFileSync, constants } from 'node:fs';

// destination.txt will be created or overwritten by default.
copyFileSync('source.txt', 'destination.txt');
console.log('source.txt was copied to destination.txt');

// By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
copyFileSync('source.txt', 'destination.txt', constants.COPYFILE_EXCL);
```
@since v8.5.0
@param src source filename to copy
@param dest destination filename of the copy operation
@param [mode=0] modifiers for copy operation.

## writev

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `writev(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[])`

JSDoc:

Write an array of `ArrayBufferView`s to the file specified by `fd` using `writev()`.

`position` is the offset from the beginning of the file where this data
should be written. If `typeof position !== 'number'`, the data will be written
at the current position.

The callback will be given three arguments: `err`, `bytesWritten`, and `buffers`. `bytesWritten` is how many bytes were written from `buffers`.

If this method is `util.promisify()` ed, it returns a promise for an `Object` with `bytesWritten` and `buffers` properties.

It is unsafe to use `fs.writev()` multiple times on the same file without
waiting for the callback. For this scenario, use {@link createWriteStream}.

On Linux, positional writes don't work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.
@since v12.9.0
@param [position='null']

## writevSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number)`

JSDoc:

For detailed information, see the documentation of the asynchronous version of
this API: {@link writev}.
@since v12.9.0
@param [position='null']
@return The number of bytes written.

## readv

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readv(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[])`

JSDoc:

Read from a file specified by `fd` and write to an array of `ArrayBufferView`s
using `readv()`.

`position` is the offset from the beginning of the file from where data
should be read. If `typeof position !== 'number'`, the data will be read
from the current position.

The callback will be given three arguments: `err`, `bytesRead`, and `buffers`. `bytesRead` is how many bytes were read from the file.

If this method is invoked as its `util.promisify()` ed version, it returns
a promise for an `Object` with `bytesRead` and `buffers` properties.
@since v13.13.0, v12.17.0
@param [position='null']

## readvSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number)`

JSDoc:

For detailed information, see the documentation of the asynchronous version of
this API: {@link readv}.
@since v13.13.0, v12.17.0
@param [position='null']
@return The number of bytes read.

## openAsBlob

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `openAsBlob(path: PathLike, options?: OpenAsBlobOptions)`

JSDoc:

An optional mime type for the blob.

@default 'undefined'
/
        type?: string | undefined;
    }

    /**
Returns a `Blob` whose data is backed by the given file.

The file must not be modified after the `Blob` is created. Any modifications
will cause reading the `Blob` data to fail with a `DOMException` error.
Synchronous stat operations on the file when the `Blob` is created, and before
each read in order to detect whether the file data has been modified on disk.

```js
import { openAsBlob } from 'node:fs';

const blob = await openAsBlob('the.file.txt');
const ab = await blob.arrayBuffer();
blob.stream();
```
@since v19.8.0

## opendirSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `opendirSync(path: PathLike, options?: OpenDirOptions)`

JSDoc:

@default 'utf8'
/
        encoding?: BufferEncoding | undefined;
        /**
Number of directory entries that are buffered
internally when reading from the directory. Higher values lead to better
performance but higher memory usage.
@default 32
/
        bufferSize?: number | undefined;
        /**
@default false
/
        recursive?: boolean;
    }
    /**
Synchronously open a directory. See [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html).

Creates an `fs.Dir`, which contains all further functions for reading from
and cleaning up the directory.

The `encoding` option sets the encoding for the `path` while opening the
directory and subsequent read operations.
@since v12.12.0

## opendir

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `opendir(path: PathLike, cb: (err: NodeJS.ErrnoException | null, dir: Dir)`

JSDoc:

Asynchronously open a directory. See the POSIX [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for
more details.

Creates an `fs.Dir`, which contains all further functions for reading from
and cleaning up the directory.

The `encoding` option sets the encoding for the `path` while opening the
directory and subsequent read operations.
@since v12.12.0

## cp

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `cp(
        source: string | URL,
        destination: string | URL,
        callback: (err: NodeJS.ErrnoException | null)`

JSDoc:

Dereference symlinks
@default false
/
        dereference?: boolean;
        /**
When `force` is `false`, and the destination
exists, throw an error.
@default false
/
        errorOnExist?: boolean;
        /**
Overwrite existing file or directory. _The copy
operation will ignore errors if you set this to false and the destination
exists. Use the `errorOnExist` option to change this behavior.
@default true
/
        force?: boolean;
        /**
Modifiers for copy operation. See `mode` flag of {@link copyFileSync()}
/
        mode?: number;
        /**
When `true` timestamps from `src` will
be preserved.
@default false
/
        preserveTimestamps?: boolean;
        /**
Copy directories recursively.
@default false
/
        recursive?: boolean;
        /**
When true, path resolution for symlinks will be skipped
@default false
/
        verbatimSymlinks?: boolean;
    }
    export interface CopyOptions extends CopyOptionsBase {
        /**
Function to filter copied files/directories. Return
`true` to copy the item, `false` to ignore it.
/
        filter?(source: string, destination: string): boolean | Promise<boolean>;
    }
    export interface CopySyncOptions extends CopyOptionsBase {
        /**
Function to filter copied files/directories. Return
`true` to copy the item, `false` to ignore it.
/
        filter?(source: string, destination: string): boolean;
    }
    /**
Asynchronously copies the entire directory structure from `src` to `dest`,
including subdirectories and files.

When copying a directory to another directory, globs are not supported and
behavior is similar to `cp dir1/ dir2/`.
@since v16.7.0
@experimental
@param src source path to copy.
@param dest destination path to copy to.

## cpSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `cpSync(source: string | URL, destination: string | URL, opts?: CopySyncOptions)`

JSDoc:

Synchronously copies the entire directory structure from `src` to `dest`,
including subdirectories and files.

When copying a directory to another directory, globs are not supported and
behavior is similar to `cp dir1/ dir2/`.
@since v16.7.0
@experimental
@param src source path to copy.
@param dest destination path to copy to.

## glob

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `glob(
        pattern: string | readonly string[],
        callback: (err: NodeJS.ErrnoException | null, matches: string[])`

JSDoc:

Current working directory.
@default process.cwd()
/
        cwd?: string | URL | undefined;
        /**
`true` if the glob should return paths as `Dirent`s, `false` otherwise.
@default false
@since v22.2.0
/
        withFileTypes?: boolean | undefined;
        /**
Function to filter out files/directories or a
list of glob patterns to be excluded. If a function is provided, return
`true` to exclude the item, `false` to include it.
@default undefined
/
        exclude?: ((fileName: T) => boolean) | readonly string[] | undefined;
    }
    export interface GlobOptions extends _GlobOptions<Dirent | string> {}
    export interface GlobOptionsWithFileTypes extends _GlobOptions<Dirent> {
        withFileTypes: true;
    }
    export interface GlobOptionsWithoutFileTypes extends _GlobOptions<string> {
        withFileTypes?: false | undefined;
    }

    /**
Retrieves the files matching the specified pattern.

```js
import { glob } from 'node:fs';

glob('*.js', (err, matches) => {
  if (err) throw err;
  console.log(matches);
});
```
@since v22.0.0

## globSync

Source: `my-backend/node_modules/@types/node/fs.d.ts`

Signature: `globSync(pattern: string | readonly string[])`

JSDoc:

```js
import { globSync } from 'node:fs';

console.log(globSync('*.js'));
```
@since v22.0.0
@returns paths of files that match the pattern.

## getDefaultSettings

Source: `my-backend/node_modules/@types/node/http2.d.ts`

Signature: `getDefaultSettings()`

JSDoc:

The `node:http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol.
It can be accessed using:

```js
import http2 from 'node:http2';
```
@since v8.4.0
@see [source](https://github.com/nodejs/node/blob/v24.x/lib/http2.js)
/
declare module "http2" {
    import EventEmitter = require("node:events");
    import * as fs from "node:fs";
    import * as net from "node:net";
    import * as stream from "node:stream";
    import * as tls from "node:tls";
    import * as url from "node:url";
    import {
        IncomingHttpHeaders as Http1IncomingHttpHeaders,
        IncomingMessage,
        OutgoingHttpHeaders,
        ServerResponse,
    } from "node:http";
    export { OutgoingHttpHeaders } from "node:http";
    export interface IncomingHttpStatusHeader {
        ":status"?: number | undefined;
    }
    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {
        ":path"?: string | undefined;
        ":method"?: string | undefined;
        ":authority"?: string | undefined;
        ":scheme"?: string | undefined;
    }
    // Http2Stream
    export interface StreamState {
        localWindowSize?: number | undefined;
        state?: number | undefined;
        localClose?: number | undefined;
        remoteClose?: number | undefined;
        /** @deprecated */
        sumDependencyWeight?: number | undefined;
        /** @deprecated */
        weight?: number | undefined;
    }
    export interface ServerStreamResponseOptions {
        endStream?: boolean | undefined;
        waitForTrailers?: boolean | undefined;
    }
    export interface StatOptions {
        offset: number;
        length: number;
    }
    export interface ServerStreamFileResponseOptions {
        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
        statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): void | boolean;
        waitForTrailers?: boolean | undefined;
        offset?: number | undefined;
        length?: number | undefined;
    }
    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {
        onError?(err: NodeJS.ErrnoException): void;
    }
    export interface Http2Stream extends stream.Duplex {
        /**
Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,
the `'aborted'` event will have been emitted.
@since v8.4.0
/
        readonly aborted: boolean;
        /**
This property shows the number of characters currently buffered to be written.
See `net.Socket.bufferSize` for details.
@since v11.2.0, v10.16.0
/
        readonly bufferSize: number;
        /**
Set to `true` if the `Http2Stream` instance has been closed.
@since v9.4.0
/
        readonly closed: boolean;
        /**
Set to `true` if the `Http2Stream` instance has been destroyed and is no longer
usable.
@since v8.4.0
/
        readonly destroyed: boolean;
        /**
Set to `true` if the `END_STREAM` flag was set in the request or response
HEADERS frame received, indicating that no additional data should be received
and the readable side of the `Http2Stream` will be closed.
@since v10.11.0
/
        readonly endAfterHeaders: boolean;
        /**
The numeric stream identifier of this `Http2Stream` instance. Set to `undefined` if the stream identifier has not yet been assigned.
@since v8.4.0
/
        readonly id?: number | undefined;
        /**
Set to `true` if the `Http2Stream` instance has not yet been assigned a
numeric stream identifier.
@since v9.4.0
/
        readonly pending: boolean;
        /**
Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is
destroyed after either receiving an `RST_STREAM` frame from the connected peer,
calling `http2stream.close()`, or `http2stream.destroy()`. Will be `undefined` if the `Http2Stream` has not been closed.
@since v8.4.0
/
        readonly rstCode: number;
        /**
An object containing the outbound headers sent for this `Http2Stream`.
@since v9.5.0
/
        readonly sentHeaders: OutgoingHttpHeaders;
        /**
An array of objects containing the outbound informational (additional) headers
sent for this `Http2Stream`.
@since v9.5.0
/
        readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;
        /**
An object containing the outbound trailers sent for this `HttpStream`.
@since v9.5.0
/
        readonly sentTrailers?: OutgoingHttpHeaders | undefined;
        /**
A reference to the `Http2Session` instance that owns this `Http2Stream`. The
value will be `undefined` after the `Http2Stream` instance is destroyed.
@since v8.4.0
/
        readonly session: Http2Session | undefined;
        /**
Provides miscellaneous information about the current state of the `Http2Stream`.

A current state of this `Http2Stream`.
@since v8.4.0
/
        readonly state: StreamState;
        /**
Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the
connected HTTP/2 peer.
@since v8.4.0
@param [code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.
@param callback An optional function registered to listen for the `'close'` event.
/
        close(code?: number, callback?: () => void): void;
        /**
@deprecated Priority signaling is no longer supported in Node.js.
/
        priority(options: unknown): void;
        /**
```js
import http2 from 'node:http2';
const client = http2.connect('http://example.org:8000');
const { NGHTTP2_CANCEL } = http2.constants;
const req = client.request({ ':path': '/' });

// Cancel the stream if there's no activity after 5 seconds
req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));
```
@since v8.4.0
/
        setTimeout(msecs: number, callback?: () => void): void;
        /**
Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method
will cause the `Http2Stream` to be immediately closed and must only be
called after the `'wantTrailers'` event has been emitted. When sending a
request or sending a response, the `options.waitForTrailers` option must be set
in order to keep the `Http2Stream` open after the final `DATA` frame so that
trailers can be sent.

```js
import http2 from 'node:http2';
const server = http2.createServer();
server.on('stream', (stream) => {
  stream.respond(undefined, { waitForTrailers: true });
  stream.on('wantTrailers', () => {
    stream.sendTrailers({ xyz: 'abc' });
  });
  stream.end('Hello World');
});
```

The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
fields (e.g. `':method'`, `':path'`, etc).
@since v10.0.0
/
        sendTrailers(headers: OutgoingHttpHeaders): void;
        addListener(event: "aborted", listener: () => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "streamClosed", listener: (code: number) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: "wantTrailers", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "aborted"): boolean;
        emit(event: "close"): boolean;
        emit(event: "data", chunk: Buffer | string): boolean;
        emit(event: "drain"): boolean;
        emit(event: "end"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "frameError", frameType: number, errorCode: number): boolean;
        emit(event: "pipe", src: stream.Readable): boolean;
        emit(event: "unpipe", src: stream.Readable): boolean;
        emit(event: "streamClosed", code: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: "trailers", trailers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "wantTrailers"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "aborted", listener: () => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "data", listener: (chunk: Buffer | string) => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: "streamClosed", listener: (code: number) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: "wantTrailers", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "aborted", listener: () => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "data", listener: (chunk: Buffer | string) => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: "streamClosed", listener: (code: number) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: "wantTrailers", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "aborted", listener: () => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "streamClosed", listener: (code: number) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: "wantTrailers", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "aborted", listener: () => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "streamClosed", listener: (code: number) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: "wantTrailers", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Stream extends Http2Stream {
        addListener(event: "continue", listener: () => {}): this;
        addListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        addListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "continue"): boolean;
        emit(event: "headers", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: "push", headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "response", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "continue", listener: () => {}): this;
        on(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        on(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        on(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "continue", listener: () => {}): this;
        once(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        once(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        once(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "continue", listener: () => {}): this;
        prependListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "continue", listener: () => {}): this;
        prependOnceListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependOnceListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ServerHttp2Stream extends Http2Stream {
        /**
True if headers were sent, false otherwise (read-only).
@since v8.4.0
/
        readonly headersSent: boolean;
        /**
Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote
client's most recent `SETTINGS` frame. Will be `true` if the remote peer
accepts push streams, `false` otherwise. Settings are the same for every `Http2Stream` in the same `Http2Session`.
@since v8.4.0
/
        readonly pushAllowed: boolean;
        /**
Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.
@since v8.4.0
/
        additionalHeaders(headers: OutgoingHttpHeaders): void;
        /**
Initiates a push stream. The callback is invoked with the new `Http2Stream` instance created for the push stream passed as the second argument, or an `Error` passed as the first argument.

```js
import http2 from 'node:http2';
const server = http2.createServer();
server.on('stream', (stream) => {
  stream.respond({ ':status': 200 });
  stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {
    if (err) throw err;
    pushStream.respond({ ':status': 200 });
    pushStream.end('some pushed data');
  });
  stream.end('some data');
});
```

Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass
a `weight` value to `http2stream.priority` with the `silent` option set to `true` to enable server-side bandwidth balancing between concurrent streams.

Calling `http2stream.pushStream()` from within a pushed stream is not permitted
and will throw an error.
@since v8.4.0
@param callback Callback that is called once the push stream has been initiated.
/
        pushStream(
            headers: OutgoingHttpHeaders,
            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
        ): void;
        pushStream(
            headers: OutgoingHttpHeaders,
            options?: Pick<ClientSessionRequestOptions, "exclusive" | "parent">,
            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
        ): void;
        /**
```js
import http2 from 'node:http2';
const server = http2.createServer();
server.on('stream', (stream) => {
  stream.respond({ ':status': 200 });
  stream.end('some data');
});
```

Initiates a response. When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
will be emitted immediately after queuing the last chunk of payload data to be sent.
The `http2stream.sendTrailers()` method can then be used to send trailing header fields to the peer.

When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
close when the final `DATA` frame is transmitted. User code must call either `http2stream.sendTrailers()` or `http2stream.close()` to close the `Http2Stream`.

```js
import http2 from 'node:http2';
const server = http2.createServer();
server.on('stream', (stream) => {
  stream.respond({ ':status': 200 }, { waitForTrailers: true });
  stream.on('wantTrailers', () => {
    stream.sendTrailers({ ABC: 'some value to send' });
  });
  stream.end('some data');
});
```
@since v8.4.0
/
        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;
        /**
Initiates a response whose data is read from the given file descriptor. No
validation is performed on the given file descriptor. If an error occurs while
attempting to read data using the file descriptor, the `Http2Stream` will be
closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.

When used, the `Http2Stream` object's `Duplex` interface will be closed
automatically.

```js
import http2 from 'node:http2';
import fs from 'node:fs';

const server = http2.createServer();
server.on('stream', (stream) => {
  const fd = fs.openSync('/some/file', 'r');

  const stat = fs.fstatSync(fd);
  const headers = {
    'content-length': stat.size,
    'last-modified': stat.mtime.toUTCString(),
    'content-type': 'text/plain; charset=utf-8',
  };
  stream.respondWithFD(fd, headers);
  stream.on('close', () => fs.closeSync(fd));
});
```

The optional `options.statCheck` function may be specified to give user code
an opportunity to set additional content headers based on the `fs.Stat` details
of the given fd. If the `statCheck` function is provided, the `http2stream.respondWithFD()` method will
perform an `fs.fstat()` call to collect details on the provided file descriptor.

The `offset` and `length` options may be used to limit the response to a
specific range subset. This can be used, for instance, to support HTTP Range
requests.

The file descriptor or `FileHandle` is not closed when the stream is closed,
so it will need to be closed manually once it is no longer needed.
Using the same file descriptor concurrently for multiple streams
is not supported and may result in data loss. Re-using a file descriptor
after a stream has finished is supported.

When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
will be emitted immediately after queuing the last chunk of payload data to be
sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
header fields to the peer.

When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
close when the final `DATA` frame is transmitted. User code _must_ call either `http2stream.sendTrailers()`
or `http2stream.close()` to close the `Http2Stream`.

```js
import http2 from 'node:http2';
import fs from 'node:fs';

const server = http2.createServer();
server.on('stream', (stream) => {
  const fd = fs.openSync('/some/file', 'r');

  const stat = fs.fstatSync(fd);
  const headers = {
    'content-length': stat.size,
    'last-modified': stat.mtime.toUTCString(),
    'content-type': 'text/plain; charset=utf-8',
  };
  stream.respondWithFD(fd, headers, { waitForTrailers: true });
  stream.on('wantTrailers', () => {
    stream.sendTrailers({ ABC: 'some value to send' });
  });

  stream.on('close', () => fs.closeSync(fd));
});
```
@since v8.4.0
@param fd A readable file descriptor.
/
        respondWithFD(
            fd: number | fs.promises.FileHandle,
            headers?: OutgoingHttpHeaders,
            options?: ServerStreamFileResponseOptions,
        ): void;
        /**
Sends a regular file as the response. The `path` must specify a regular file
or an `'error'` event will be emitted on the `Http2Stream` object.

When used, the `Http2Stream` object's `Duplex` interface will be closed
automatically.

The optional `options.statCheck` function may be specified to give user code
an opportunity to set additional content headers based on the `fs.Stat` details
of the given file:

If an error occurs while attempting to read the file data, the `Http2Stream` will be closed using an
`RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
If the `onError` callback is defined, then it will be called. Otherwise, the stream will be destroyed.

Example using a file path:

```js
import http2 from 'node:http2';
const server = http2.createServer();
server.on('stream', (stream) => {
  function statCheck(stat, headers) {
    headers['last-modified'] = stat.mtime.toUTCString();
  }

  function onError(err) {
    // stream.respond() can throw if the stream has been destroyed by
    // the other side.
    try {
      if (err.code === 'ENOENT') {
        stream.respond({ ':status': 404 });
      } else {
        stream.respond({ ':status': 500 });
      }
    } catch (err) {
      // Perform actual error handling.
      console.error(err);
    }
    stream.end();
  }

  stream.respondWithFile('/some/file',
                         { 'content-type': 'text/plain; charset=utf-8' },
                         { statCheck, onError });
});
```

The `options.statCheck` function may also be used to cancel the send operation
by returning `false`. For instance, a conditional request may check the stat
results to determine if the file has been modified to return an appropriate `304` response:

```js
import http2 from 'node:http2';
const server = http2.createServer();
server.on('stream', (stream) => {
  function statCheck(stat, headers) {
    // Check the stat here...
    stream.respond({ ':status': 304 });
    return false; // Cancel the send operation
  }
  stream.respondWithFile('/some/file',
                         { 'content-type': 'text/plain; charset=utf-8' },
                         { statCheck });
});
```

The `content-length` header field will be automatically set.

The `offset` and `length` options may be used to limit the response to a
specific range subset. This can be used, for instance, to support HTTP Range
requests.

The `options.onError` function may also be used to handle all the errors
that could happen before the delivery of the file is initiated. The
default behavior is to destroy the stream.

When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
will be emitted immediately after queuing the last chunk of payload data to be
sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
header fields to the peer.

When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.

```js
import http2 from 'node:http2';
const server = http2.createServer();
server.on('stream', (stream) => {
  stream.respondWithFile('/some/file',
                         { 'content-type': 'text/plain; charset=utf-8' },
                         { waitForTrailers: true });
  stream.on('wantTrailers', () => {
    stream.sendTrailers({ ABC: 'some value to send' });
  });
});
```
@since v8.4.0
/
        respondWithFile(
            path: string,
            headers?: OutgoingHttpHeaders,
            options?: ServerStreamFileResponseOptionsWithError,
        ): void;
    }
    // Http2Session
    export interface Settings {
        headerTableSize?: number | undefined;
        enablePush?: boolean | undefined;
        initialWindowSize?: number | undefined;
        maxFrameSize?: number | undefined;
        maxConcurrentStreams?: number | undefined;
        maxHeaderListSize?: number | undefined;
        enableConnectProtocol?: boolean | undefined;
    }
    export interface ClientSessionRequestOptions {
        endStream?: boolean | undefined;
        exclusive?: boolean | undefined;
        parent?: number | undefined;
        waitForTrailers?: boolean | undefined;
        signal?: AbortSignal | undefined;
    }
    export interface SessionState {
        effectiveLocalWindowSize?: number | undefined;
        effectiveRecvDataLength?: number | undefined;
        nextStreamID?: number | undefined;
        localWindowSize?: number | undefined;
        lastProcStreamID?: number | undefined;
        remoteWindowSize?: number | undefined;
        outboundQueueSize?: number | undefined;
        deflateDynamicTableSize?: number | undefined;
        inflateDynamicTableSize?: number | undefined;
    }
    export interface Http2Session extends EventEmitter {
        /**
Value will be `undefined` if the `Http2Session` is not yet connected to a
socket, `h2c` if the `Http2Session` is not connected to a `TLSSocket`, or
will return the value of the connected `TLSSocket`'s own `alpnProtocol` property.
@since v9.4.0
/
        readonly alpnProtocol?: string | undefined;
        /**
Will be `true` if this `Http2Session` instance has been closed, otherwise `false`.
@since v9.4.0
/
        readonly closed: boolean;
        /**
Will be `true` if this `Http2Session` instance is still connecting, will be set
to `false` before emitting `connect` event and/or calling the `http2.connect` callback.
@since v10.0.0
/
        readonly connecting: boolean;
        /**
Will be `true` if this `Http2Session` instance has been destroyed and must no
longer be used, otherwise `false`.
@since v8.4.0
/
        readonly destroyed: boolean;
        /**
Value is `undefined` if the `Http2Session` session socket has not yet been
connected, `true` if the `Http2Session` is connected with a `TLSSocket`,
and `false` if the `Http2Session` is connected to any other kind of socket
or stream.
@since v9.4.0
/
        readonly encrypted?: boolean | undefined;
        /**
A prototype-less object describing the current local settings of this `Http2Session`.
The local settings are local to _this_`Http2Session` instance.
@since v8.4.0
/
        readonly localSettings: Settings;
        /**
If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property
will return an `Array` of origins for which the `Http2Session` may be
considered authoritative.

The `originSet` property is only available when using a secure TLS connection.
@since v9.4.0
/
        readonly originSet?: string[] | undefined;
        /**
Indicates whether the `Http2Session` is currently waiting for acknowledgment of
a sent `SETTINGS` frame. Will be `true` after calling the `http2session.settings()` method.
Will be `false` once all sent `SETTINGS` frames have been acknowledged.
@since v8.4.0
/
        readonly pendingSettingsAck: boolean;
        /**
A prototype-less object describing the current remote settings of this`Http2Session`.
The remote settings are set by the _connected_ HTTP/2 peer.
@since v8.4.0
/
        readonly remoteSettings: Settings;
        /**
Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
limits available methods to ones safe to use with HTTP/2.

`destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw
an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.

`setTimeout` method will be called on this `Http2Session`.

All other interactions will be routed directly to the socket.
@since v8.4.0
/
        readonly socket: net.Socket | tls.TLSSocket;
        /**
Provides miscellaneous information about the current state of the`Http2Session`.

An object describing the current status of this `Http2Session`.
@since v8.4.0
/
        readonly state: SessionState;
        /**
The `http2session.type` will be equal to `http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a
server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a
client.
@since v8.4.0
/
        readonly type: number;
        /**
Gracefully closes the `Http2Session`, allowing any existing streams to
complete on their own and preventing new `Http2Stream` instances from being
created. Once closed, `http2session.destroy()`_might_ be called if there
are no open `Http2Stream` instances.

If specified, the `callback` function is registered as a handler for the`'close'` event.
@since v9.4.0
/
        close(callback?: () => void): void;
        /**
Immediately terminates the `Http2Session` and the associated `net.Socket` or `tls.TLSSocket`.

Once destroyed, the `Http2Session` will emit the `'close'` event. If `error` is not undefined, an `'error'` event will be emitted immediately before the `'close'` event.

If there are any remaining open `Http2Streams` associated with the `Http2Session`, those will also be destroyed.
@since v8.4.0
@param error An `Error` object if the `Http2Session` is being destroyed due to an error.
@param code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.
/
        destroy(error?: Error, code?: number): void;
        /**
Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.
@since v9.4.0
@param code An HTTP/2 error code
@param lastStreamID The numeric ID of the last processed `Http2Stream`
@param opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.
/
        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;
        /**
Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must
be provided. The method will return `true` if the `PING` was sent, `false` otherwise.

The maximum number of outstanding (unacknowledged) pings is determined by the `maxOutstandingPings` configuration option. The default maximum is 10.

If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView` containing 8 bytes of data that will be transmitted with the `PING` and
returned with the ping acknowledgment.

The callback will be invoked with three arguments: an error argument that will
be `null` if the `PING` was successfully acknowledged, a `duration` argument
that reports the number of milliseconds elapsed since the ping was sent and the
acknowledgment was received, and a `Buffer` containing the 8-byte `PING` payload.

```js
session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {
  if (!err) {
    console.log(`Ping acknowledged in ${duration} milliseconds`);
    console.log(`With payload '${payload.toString()}'`);
  }
});
```

If the `payload` argument is not specified, the default payload will be the
64-bit timestamp (little endian) marking the start of the `PING` duration.
@since v8.9.3
@param payload Optional ping payload.
/
        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
        ping(
            payload: NodeJS.ArrayBufferView,
            callback: (err: Error | null, duration: number, payload: Buffer) => void,
        ): boolean;
        /**
Calls `ref()` on this `Http2Session` instance's underlying `net.Socket`.
@since v9.4.0
/
        ref(): void;
        /**
Sets the local endpoint's window size.
The `windowSize` is the total window size to set, not
the delta.

```js
import http2 from 'node:http2';

const server = http2.createServer();
const expectedWindowSize = 2 ** 20;
server.on('connect', (session) => {

  // Set local window size to be 2 ** 20
  session.setLocalWindowSize(expectedWindowSize);
});
```
@since v15.3.0, v14.18.0
/
        setLocalWindowSize(windowSize: number): void;
        /**
Used to set a callback function that is called when there is no activity on
the `Http2Session` after `msecs` milliseconds. The given `callback` is
registered as a listener on the `'timeout'` event.
@since v8.4.0
/
        setTimeout(msecs: number, callback?: () => void): void;
        /**
Updates the current local settings for this `Http2Session` and sends a new `SETTINGS` frame to the connected HTTP/2 peer.

Once called, the `http2session.pendingSettingsAck` property will be `true` while the session is waiting for the remote peer to acknowledge the new
settings.

The new settings will not become effective until the `SETTINGS` acknowledgment
is received and the `'localSettings'` event is emitted. It is possible to send
multiple `SETTINGS` frames while acknowledgment is still pending.
@since v8.4.0
@param callback Callback that is called once the session is connected or right away if the session is already connected.
/
        settings(
            settings: Settings,
            callback?: (err: Error | null, settings: Settings, duration: number) => void,
        ): void;
        /**
Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.
@since v9.4.0
/
        unref(): void;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        addListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        addListener(event: "localSettings", listener: (settings: Settings) => void): this;
        addListener(event: "ping", listener: () => void): this;
        addListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "close"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "frameError", frameType: number, errorCode: number, streamID: number): boolean;
        emit(event: "goaway", errorCode: number, lastStreamID: number, opaqueData?: Buffer): boolean;
        emit(event: "localSettings", settings: Settings): boolean;
        emit(event: "ping"): boolean;
        emit(event: "remoteSettings", settings: Settings): boolean;
        emit(event: "timeout"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "close", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        on(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
        on(event: "localSettings", listener: (settings: Settings) => void): this;
        on(event: "ping", listener: () => void): this;
        on(event: "remoteSettings", listener: (settings: Settings) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        once(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
        once(event: "localSettings", listener: (settings: Settings) => void): this;
        once(event: "ping", listener: () => void): this;
        once(event: "remoteSettings", listener: (settings: Settings) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        prependListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        prependListener(event: "localSettings", listener: (settings: Settings) => void): this;
        prependListener(event: "ping", listener: () => void): this;
        prependListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        prependOnceListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        prependOnceListener(event: "localSettings", listener: (settings: Settings) => void): this;
        prependOnceListener(event: "ping", listener: () => void): this;
        prependOnceListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Session extends Http2Session {
        /**
For HTTP/2 Client `Http2Session` instances only, the `http2session.request()` creates and returns an `Http2Stream` instance that can be used to send an
HTTP/2 request to the connected server.

When a `ClientHttp2Session` is first created, the socket may not yet be
connected. if `clienthttp2session.request()` is called during this time, the
actual request will be deferred until the socket is ready to go.
If the `session` is closed before the actual request be executed, an `ERR_HTTP2_GOAWAY_SESSION` is thrown.

This method is only available if `http2session.type` is equal to `http2.constants.NGHTTP2_SESSION_CLIENT`.

```js
import http2 from 'node:http2';
const clientSession = http2.connect('https://localhost:1234');
const {
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_STATUS,
} = http2.constants;

const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });
req.on('response', (headers) => {
  console.log(headers[HTTP2_HEADER_STATUS]);
  req.on('data', (chunk) => { // ..  });
  req.on('end', () => { // ..  });
});
```

When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
is emitted immediately after queuing the last chunk of payload data to be sent.
The `http2stream.sendTrailers()` method can then be called to send trailing
headers to the peer.

When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.

When `options.signal` is set with an `AbortSignal` and then `abort` on the
corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.

The `:method` and `:path` pseudo-headers are not specified within `headers`,
they respectively default to:

* `:method` \= `'GET'`
* `:path` \= `/`
@since v8.4.0
/
        request(
            headers?: OutgoingHttpHeaders | readonly string[],
            options?: ClientSessionRequestOptions,
        ): ClientHttp2Stream;
        addListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        addListener(event: "origin", listener: (origins: string[]) => void): this;
        addListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        addListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "altsvc", alt: string, origin: string, stream: number): boolean;
        emit(event: "origin", origins: readonly string[]): boolean;
        emit(event: "connect", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
        emit(
            event: "stream",
            stream: ClientHttp2Stream,
            headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
            flags: number,
        ): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        on(event: "origin", listener: (origins: string[]) => void): this;
        on(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        on(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        once(event: "origin", listener: (origins: string[]) => void): this;
        once(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        once(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        prependListener(event: "origin", listener: (origins: string[]) => void): this;
        prependListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        prependListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        prependOnceListener(event: "origin", listener: (origins: string[]) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        prependOnceListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface AlternativeServiceOptions {
        origin: number | string | url.URL;
    }
    export interface ServerHttp2Session<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends Http2Session {
        readonly server:
            | Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>
            | Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
        /**
Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.

```js
import http2 from 'node:http2';

const server = http2.createServer();
server.on('session', (session) => {
  // Set altsvc for origin https://example.org:80
  session.altsvc('h2=":8000"', 'https://example.org:80');
});

server.on('stream', (stream) => {
  // Set altsvc for a specific stream
  stream.session.altsvc('h2=":8000"', stream.id);
});
```

Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate
service is associated with the origin of the given `Http2Stream`.

The `alt` and origin string _must_ contain only ASCII bytes and are
strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given
domain.

When a string is passed for the `originOrStream` argument, it will be parsed as
a URL and the origin will be derived. For instance, the origin for the
HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string
cannot be parsed as a URL or if a valid origin cannot be derived.

A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be
used. The value of the `origin` property _must_ be a properly serialized
ASCII origin.
@since v9.4.0
@param alt A description of the alternative service configuration as defined by `RFC 7838`.
@param originOrStream Either a URL string specifying the origin (or an `Object` with an `origin` property) or the numeric identifier of an active `Http2Stream` as given by the
`http2stream.id` property.
/
        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;
        /**
Submits an `ORIGIN` frame (as defined by [RFC 8336](https://tools.ietf.org/html/rfc8336)) to the connected client
to advertise the set of origins for which the server is capable of providing
authoritative responses.

```js
import http2 from 'node:http2';
const options = getSecureOptionsSomehow();
const server = http2.createSecureServer(options);
server.on('stream', (stream) => {
  stream.respond();
  stream.end('ok');
});
server.on('session', (session) => {
  session.origin('https://example.com', 'https://example.org');
});
```

When a string is passed as an `origin`, it will be parsed as a URL and the
origin will be derived. For instance, the origin for the HTTP URL `'https://example.org/foo/bar'` is the ASCII string` 'https://example.org'`. An error will be thrown if either the given
string
cannot be parsed as a URL or if a valid origin cannot be derived.

A `URL` object, or any object with an `origin` property, may be passed as
an `origin`, in which case the value of the `origin` property will be
used. The value of the `origin` property _must_ be a properly serialized
ASCII origin.

Alternatively, the `origins` option may be used when creating a new HTTP/2
server using the `http2.createSecureServer()` method:

```js
import http2 from 'node:http2';
const options = getSecureOptionsSomehow();
options.origins = ['https://example.com', 'https://example.org'];
const server = http2.createSecureServer(options);
server.on('stream', (stream) => {
  stream.respond();
  stream.end('ok');
});
```
@since v10.12.0
@param origins One or more URL Strings passed as separate arguments.
/
        origin(
            ...origins: Array<
                | string
                | url.URL
                | {
                    origin: string;
                }
            >
        ): void;
        addListener(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(
            event: "connect",
            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
            socket: net.Socket | tls.TLSSocket,
        ): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    // Http2Server
    export interface SessionOptions {
        /**
Sets the maximum dynamic table size for deflating header fields.
@default 4Kib
/
        maxDeflateDynamicTableSize?: number | undefined;
        /**
Sets the maximum number of settings entries per `SETTINGS` frame.
The minimum value allowed is `1`.
@default 32
/
        maxSettings?: number | undefined;
        /**
Sets the maximum memory that the `Http2Session` is permitted to use.
The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
The minimum value allowed is `1`.
This is a credit based limit, existing `Http2Stream`s may cause this limit to be exceeded,
but new `Http2Stream` instances will be rejected while this limit is exceeded.
The current number of `Http2Stream` sessions, the current memory use of the header compression tables,
current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are all counted towards the current limit.
@default 10
/
        maxSessionMemory?: number | undefined;
        /**
Sets the maximum number of header entries.
This is similar to `server.maxHeadersCount` or `request.maxHeadersCount` in the `node:http` module.
The minimum value is `1`.
@default 128
/
        maxHeaderListPairs?: number | undefined;
        /**
Sets the maximum number of outstanding, unacknowledged pings.
@default 10
/
        maxOutstandingPings?: number | undefined;
        /**
Sets the maximum allowed size for a serialized, compressed block of headers.
Attempts to send headers that exceed this limit will result in
a `'frameError'` event being emitted and the stream being closed and destroyed.
/
        maxSendHeaderBlockLength?: number | undefined;
        /**
Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
@default http2.constants.PADDING_STRATEGY_NONE
/
        paddingStrategy?: number | undefined;
        /**
Sets the maximum number of concurrent streams for the remote peer as if a `SETTINGS` frame had been received.
Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
@default 100
/
        peerMaxConcurrentStreams?: number | undefined;
        /**
The initial settings to send to the remote peer upon connection.
/
        settings?: Settings | undefined;
        /**
The array of integer values determines the settings types,
which are included in the `CustomSettings`-property of the received remoteSettings.
Please see the `CustomSettings`-property of the `Http2Settings` object for more information, on the allowed setting types.
/
        remoteCustomSettings?: number[] | undefined;
        /**
Specifies a timeout in milliseconds that
a server should wait when an [`'unknownProtocol'`][] is emitted. If the
socket has not been destroyed by that time the server will destroy it.
@default 100000
/
        unknownProtocolTimeout?: number | undefined;
        /**
If `true`, it turns on strict leading
and trailing whitespace validation for HTTP/2 header field names and values
as per [RFC-9113](https://www.rfc-editor.org/rfc/rfc9113.html#section-8.2.1).
@since v24.2.0
@default true
/
        strictFieldWhitespaceValidation?: boolean | undefined;
    }
    export interface ClientSessionOptions extends SessionOptions {
        /**
Sets the maximum number of reserved push streams the client will accept at any given time.
Once the current number of currently reserved push streams exceeds reaches this limit,
new push streams sent by the server will be automatically rejected.
The minimum allowed value is 0. The maximum allowed value is 2<sup>32</sup>-1.
A negative value sets this option to the maximum allowed value.
@default 200
/
        maxReservedRemoteStreams?: number | undefined;
        /**
An optional callback that receives the `URL` instance passed to `connect` and the `options` object,
and returns any `Duplex` stream that is to be used as the connection for this session.
/
        createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;
        /**
The protocol to connect with, if not set in the `authority`.
Value may be either `'http:'` or `'https:'`.
@default 'https:'
/
        protocol?: "http:" | "https:" | undefined;
    }
    export interface ServerSessionOptions<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends SessionOptions {
        streamResetBurst?: number | undefined;
        streamResetRate?: number | undefined;
        Http1IncomingMessage?: Http1Request | undefined;
        Http1ServerResponse?: Http1Response | undefined;
        Http2ServerRequest?: Http2Request | undefined;
        Http2ServerResponse?: Http2Response | undefined;
    }
    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions {}
    export interface SecureServerSessionOptions<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>, tls.TlsOptions {}
    export interface ServerOptions<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {}
    export interface SecureServerOptions<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends SecureServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {
        allowHTTP1?: boolean | undefined;
        origins?: string[] | undefined;
    }
    interface HTTP2ServerCommon {
        setTimeout(msec?: number, callback?: () => void): this;
        /**
Throws ERR_HTTP2_INVALID_SETTING_VALUE for invalid settings values.
Throws ERR_INVALID_ARG_TYPE for invalid settings argument.
/
        updateSettings(settings: Settings): void;
    }
    export interface Http2Server<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends net.Server, HTTP2ServerCommon {
        addListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        addListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        addListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        addListener(event: "sessionError", listener: (err: Error) => void): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(
            event: "checkContinue",
            request: InstanceType<Http2Request>,
            response: InstanceType<Http2Response>,
        ): boolean;
        emit(event: "request", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;
        emit(
            event: "session",
            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
        ): boolean;
        emit(event: "sessionError", err: Error): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        on(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        on(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        on(event: "sessionError", listener: (err: Error) => void): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: "timeout", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        once(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        once(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        once(event: "sessionError", listener: (err: Error) => void): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: "timeout", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        prependListener(event: "sessionError", listener: (err: Error) => void): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependOnceListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependOnceListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface Http2SecureServer<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends tls.Server, HTTP2ServerCommon {
        addListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        addListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        addListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        addListener(event: "sessionError", listener: (err: Error) => void): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(
            event: "checkContinue",
            request: InstanceType<Http2Request>,
            response: InstanceType<Http2Response>,
        ): boolean;
        emit(event: "request", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;
        emit(
            event: "session",
            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
        ): boolean;
        emit(event: "sessionError", err: Error): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: "unknownProtocol", socket: tls.TLSSocket): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        on(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        on(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        on(event: "sessionError", listener: (err: Error) => void): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        once(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        once(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        once(event: "sessionError", listener: (err: Error) => void): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        prependListener(event: "sessionError", listener: (err: Error) => void): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependOnceListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependOnceListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
A `Http2ServerRequest` object is created by {@link Server} or {@link SecureServer} and passed as the first argument to the `'request'` event. It may be used to access a request status,
headers, and
data.
@since v8.4.0
/
    export class Http2ServerRequest extends stream.Readable {
        constructor(
            stream: ServerHttp2Stream,
            headers: IncomingHttpHeaders,
            options: stream.ReadableOptions,
            rawHeaders: readonly string[],
        );
        /**
The `request.aborted` property will be `true` if the request has
been aborted.
@since v10.1.0
/
        readonly aborted: boolean;
        /**
The request authority pseudo header field. Because HTTP/2 allows requests
to set either `:authority` or `host`, this value is derived from `req.headers[':authority']` if present. Otherwise, it is derived from `req.headers['host']`.
@since v8.4.0
/
        readonly authority: string;
        /**
See `request.socket`.
@since v8.4.0
@deprecated Since v13.0.0 - Use `socket`.
/
        readonly connection: net.Socket | tls.TLSSocket;
        /**
The `request.complete` property will be `true` if the request has
been completed, aborted, or destroyed.
@since v12.10.0
/
        readonly complete: boolean;
        /**
The request/response headers object.

Key-value pairs of header names and values. Header names are lower-cased.

```js
// Prints something like:
//
// { 'user-agent': 'curl/7.22.0',
//   host: '127.0.0.1:8000',
//   accept: '*' }
console.log(request.headers);
```

See `HTTP/2 Headers Object`.

In HTTP/2, the request path, host name, protocol, and method are represented as
special headers prefixed with the `:` character (e.g. `':path'`). These special
headers will be included in the `request.headers` object. Care must be taken not
to inadvertently modify these special headers or errors may occur. For instance,
removing all headers from the request will cause errors to occur:

```js
removeAllHeaders(request.headers);
assert(request.url);   // Fails because the :path header has been removed
```
@since v8.4.0
/
        readonly headers: IncomingHttpHeaders;
        /**
In case of server request, the HTTP version sent by the client. In the case of
client response, the HTTP version of the connected-to server. Returns `'2.0'`.

Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.
@since v8.4.0
/
        readonly httpVersion: string;
        readonly httpVersionMinor: number;
        readonly httpVersionMajor: number;
        /**
The request method as a string. Read-only. Examples: `'GET'`, `'DELETE'`.
@since v8.4.0
/
        readonly method: string;
        /**
The raw request/response headers list exactly as they were received.

The keys and values are in the same list. It is _not_ a
list of tuples. So, the even-numbered offsets are key values, and the
odd-numbered offsets are the associated values.

Header names are not lowercased, and duplicates are not merged.

```js
// Prints something like:
//
// [ 'user-agent',
//   'this is invalid because there can be only one',
//   'User-Agent',
//   'curl/7.22.0',
//   'Host',
//   '127.0.0.1:8000',
//   'ACCEPT',
//   '*' ]
console.log(request.rawHeaders);
```
@since v8.4.0
/
        readonly rawHeaders: string[];
        /**
The raw request/response trailer keys and values exactly as they were
received. Only populated at the `'end'` event.
@since v8.4.0
/
        readonly rawTrailers: string[];
        /**
The request scheme pseudo header field indicating the scheme
portion of the target URL.
@since v8.4.0
/
        readonly scheme: string;
        /**
Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
applies getters, setters, and methods based on HTTP/2 logic.

`destroyed`, `readable`, and `writable` properties will be retrieved from and
set on `request.stream`.

`destroy`, `emit`, `end`, `on` and `once` methods will be called on `request.stream`.

`setTimeout` method will be called on `request.stream.session`.

`pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
more information.

All other interactions will be routed directly to the socket. With TLS support,
use `request.socket.getPeerCertificate()` to obtain the client's
authentication details.
@since v8.4.0
/
        readonly socket: net.Socket | tls.TLSSocket;
        /**
The `Http2Stream` object backing the request.
@since v8.4.0
/
        readonly stream: ServerHttp2Stream;
        /**
The request/response trailers object. Only populated at the `'end'` event.
@since v8.4.0
/
        readonly trailers: IncomingHttpHeaders;
        /**
Request URL string. This contains only the URL that is present in the actual
HTTP request. If the request is:

```http
GET /status?name=ryan HTTP/1.1
Accept: text/plain
```

Then `request.url` will be:

```js
'/status?name=ryan'
```

To parse the url into its parts, `new URL()` can be used:

```console
$ node
> new URL('/status?name=ryan', 'http://example.com')
URL {
  href: 'http://example.com/status?name=ryan',
  origin: 'http://example.com',
  protocol: 'http:',
  username: '',
  password: '',
  host: 'example.com',
  hostname: 'example.com',
  port: '',
  pathname: '/status',
  search: '?name=ryan',
  searchParams: URLSearchParams { 'name' => 'ryan' },
  hash: ''
}
```
@since v8.4.0
/
        url: string;
        /**
Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
provided, then it is added as a listener on the `'timeout'` event on
the response object.

If no `'timeout'` listener is added to the request, the response, or
the server, then `Http2Stream`s are destroyed when they time out. If a
handler is assigned to the request, the response, or the server's `'timeout'`events, timed out sockets must be handled explicitly.
@since v8.4.0
/
        setTimeout(msecs: number, callback?: () => void): void;
        read(size?: number): Buffer | string | null;
        addListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "readable", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "aborted", hadError: boolean, code: number): boolean;
        emit(event: "close"): boolean;
        emit(event: "data", chunk: Buffer | string): boolean;
        emit(event: "end"): boolean;
        emit(event: "readable"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "data", listener: (chunk: Buffer | string) => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "readable", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "data", listener: (chunk: Buffer | string) => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "readable", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "readable", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "readable", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
This object is created internally by an HTTP server, not by the user. It is
passed as the second parameter to the `'request'` event.
@since v8.4.0
/
    export class Http2ServerResponse<Request extends Http2ServerRequest = Http2ServerRequest> extends stream.Writable {
        constructor(stream: ServerHttp2Stream);
        /**
See `response.socket`.
@since v8.4.0
@deprecated Since v13.0.0 - Use `socket`.
/
        readonly connection: net.Socket | tls.TLSSocket;
        /**
Append a single header value to the header object.

If the value is an array, this is equivalent to calling this method multiple times.

If there were no previous values for the header, this is equivalent to calling {@link setHeader}.

Attempting to set a header field name or value that contains invalid characters will result in a
[TypeError](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-typeerror) being thrown.

```js
// Returns headers including "set-cookie: a" and "set-cookie: b"
const server = http2.createServer((req, res) => {
  res.setHeader('set-cookie', 'a');
  res.appendHeader('set-cookie', 'b');
  res.writeHead(200);
  res.end('ok');
});
```
@since v20.12.0
/
        appendHeader(name: string, value: string | string[]): void;
        /**
Boolean value that indicates whether the response has completed. Starts
as `false`. After `response.end()` executes, the value will be `true`.
@since v8.4.0
@deprecated Since v13.4.0,v12.16.0 - Use `writableEnded`.
/
        readonly finished: boolean;
        /**
True if headers were sent, false otherwise (read-only).
@since v8.4.0
/
        readonly headersSent: boolean;
        /**
A reference to the original HTTP2 `request` object.
@since v15.7.0
/
        readonly req: Request;
        /**
Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
applies getters, setters, and methods based on HTTP/2 logic.

`destroyed`, `readable`, and `writable` properties will be retrieved from and
set on `response.stream`.

`destroy`, `emit`, `end`, `on` and `once` methods will be called on `response.stream`.

`setTimeout` method will be called on `response.stream.session`.

`pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
more information.

All other interactions will be routed directly to the socket.

```js
import http2 from 'node:http2';
const server = http2.createServer((req, res) => {
  const ip = req.socket.remoteAddress;
  const port = req.socket.remotePort;
  res.end(`Your IP address is ${ip} and your source port is ${port}.`);
}).listen(3000);
```
@since v8.4.0
/
        readonly socket: net.Socket | tls.TLSSocket;
        /**
The `Http2Stream` object backing the response.
@since v8.4.0
/
        readonly stream: ServerHttp2Stream;
        /**
When true, the Date header will be automatically generated and sent in
the response if it is not already present in the headers. Defaults to true.

This should only be disabled for testing; HTTP requires the Date header
in responses.
@since v8.4.0
/
        sendDate: boolean;
        /**
When using implicit headers (not calling `response.writeHead()` explicitly),
this property controls the status code that will be sent to the client when
the headers get flushed.

```js
response.statusCode = 404;
```

After response header was sent to the client, this property indicates the
status code which was sent out.
@since v8.4.0
/
        statusCode: number;
        /**
Status message is not supported by HTTP/2 (RFC 7540 8.1.2.4). It returns
an empty string.
@since v8.4.0
/
        statusMessage: "";
        /**
This method adds HTTP trailing headers (a header but at the end of the
message) to the response.

Attempting to set a header field name or value that contains invalid characters
will result in a `TypeError` being thrown.
@since v8.4.0
/
        addTrailers(trailers: OutgoingHttpHeaders): void;
        /**
This method signals to the server that all of the response headers and body
have been sent; that server should consider this message complete.
The method, `response.end()`, MUST be called on each response.

If `data` is specified, it is equivalent to calling `response.write(data, encoding)` followed by `response.end(callback)`.

If `callback` is specified, it will be called when the response stream
is finished.
@since v8.4.0
/
        end(callback?: () => void): this;
        end(data: string | Uint8Array, callback?: () => void): this;
        end(data: string | Uint8Array, encoding: BufferEncoding, callback?: () => void): this;
        /**
Reads out a header that has already been queued but not sent to the client.
The name is case-insensitive.

```js
const contentType = response.getHeader('content-type');
```
@since v8.4.0
/
        getHeader(name: string): string;
        /**
Returns an array containing the unique names of the current outgoing headers.
All header names are lowercase.

```js
response.setHeader('Foo', 'bar');
response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);

const headerNames = response.getHeaderNames();
// headerNames === ['foo', 'set-cookie']
```
@since v8.4.0
/
        getHeaderNames(): string[];
        /**
Returns a shallow copy of the current outgoing headers. Since a shallow copy
is used, array values may be mutated without additional calls to various
header-related http module methods. The keys of the returned object are the
header names and the values are the respective header values. All header names
are lowercase.

The object returned by the `response.getHeaders()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,
`obj.hasOwnProperty()`, and others
are not defined and _will not work_.

```js
response.setHeader('Foo', 'bar');
response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);

const headers = response.getHeaders();
// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
```
@since v8.4.0
/
        getHeaders(): OutgoingHttpHeaders;
        /**
Returns `true` if the header identified by `name` is currently set in the
outgoing headers. The header name matching is case-insensitive.

```js
const hasContentType = response.hasHeader('content-type');
```
@since v8.4.0
/
        hasHeader(name: string): boolean;
        /**
Removes a header that has been queued for implicit sending.

```js
response.removeHeader('Content-Encoding');
```
@since v8.4.0
/
        removeHeader(name: string): void;
        /**
Sets a single header value for implicit headers. If this header already exists
in the to-be-sent headers, its value will be replaced. Use an array of strings
here to send multiple headers with the same name.

```js
response.setHeader('Content-Type', 'text/html; charset=utf-8');
```

or

```js
response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
```

Attempting to set a header field name or value that contains invalid characters
will result in a `TypeError` being thrown.

When headers have been set with `response.setHeader()`, they will be merged
with any headers passed to `response.writeHead()`, with the headers passed
to `response.writeHead()` given precedence.

```js
// Returns content-type = text/plain
const server = http2.createServer((req, res) => {
  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  res.setHeader('X-Foo', 'bar');
  res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
  res.end('ok');
});
```
@since v8.4.0
/
        setHeader(name: string, value: number | string | readonly string[]): void;
        /**
Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
provided, then it is added as a listener on the `'timeout'` event on
the response object.

If no `'timeout'` listener is added to the request, the response, or
the server, then `Http2Stream` s are destroyed when they time out. If a
handler is assigned to the request, the response, or the server's `'timeout'` events, timed out sockets must be handled explicitly.
@since v8.4.0
/
        setTimeout(msecs: number, callback?: () => void): void;
        /**
If this method is called and `response.writeHead()` has not been called,
it will switch to implicit header mode and flush the implicit headers.

This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.

In the `node:http` module, the response body is omitted when the
request is a HEAD request. Similarly, the `204` and `304` responses _must not_ include a message body.

`chunk` can be a string or a buffer. If `chunk` is a string,
the second parameter specifies how to encode it into a byte stream.
By default the `encoding` is `'utf8'`. `callback` will be called when this chunk
of data is flushed.

This is the raw HTTP body and has nothing to do with higher-level multi-part
body encodings that may be used.

The first time `response.write()` is called, it will send the buffered
header information and the first chunk of the body to the client. The second
time `response.write()` is called, Node.js assumes data will be streamed,
and sends the new data separately. That is, the response is buffered up to the
first chunk of the body.

Returns `true` if the entire data was flushed successfully to the kernel
buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is free again.
@since v8.4.0
/
        write(chunk: string | Uint8Array, callback?: (err: Error) => void): boolean;
        write(chunk: string | Uint8Array, encoding: BufferEncoding, callback?: (err: Error) => void): boolean;
        /**
Sends a status `100 Continue` to the client, indicating that the request body
should be sent. See the `'checkContinue'` event on `Http2Server` and `Http2SecureServer`.
@since v8.4.0
/
        writeContinue(): void;
        /**
Sends a status `103 Early Hints` to the client with a Link header,
indicating that the user agent can preload/preconnect the linked resources.
The `hints` is an object containing the values of headers to be sent with
early hints message.

**Example**

```js
const earlyHintsLink = '</styles.css>; rel=preload; as=style';
response.writeEarlyHints({
  'link': earlyHintsLink,
});

const earlyHintsLinks = [
  '</styles.css>; rel=preload; as=style',
  '</scripts.js>; rel=preload; as=script',
];
response.writeEarlyHints({
  'link': earlyHintsLinks,
});
```
@since v18.11.0
/
        writeEarlyHints(hints: Record<string, string | string[]>): void;
        /**
Sends a response header to the request. The status code is a 3-digit HTTP
status code, like `404`. The last argument, `headers`, are the response headers.

Returns a reference to the `Http2ServerResponse`, so that calls can be chained.

For compatibility with `HTTP/1`, a human-readable `statusMessage` may be
passed as the second argument. However, because the `statusMessage` has no
meaning within HTTP/2, the argument will have no effect and a process warning
will be emitted.

```js
const body = 'hello world';
response.writeHead(200, {
  'Content-Length': Buffer.byteLength(body),
  'Content-Type': 'text/plain; charset=utf-8',
});
```

`Content-Length` is given in bytes not characters. The`Buffer.byteLength()` API may be used to determine the number of bytes in a
given encoding. On outbound messages, Node.js does not check if Content-Length
and the length of the body being transmitted are equal or not. However, when
receiving messages, Node.js will automatically reject messages when the `Content-Length` does not match the actual payload size.

This method may be called at most one time on a message before `response.end()` is called.

If `response.write()` or `response.end()` are called before calling
this, the implicit/mutable headers will be calculated and call this function.

When headers have been set with `response.setHeader()`, they will be merged
with any headers passed to `response.writeHead()`, with the headers passed
to `response.writeHead()` given precedence.

```js
// Returns content-type = text/plain
const server = http2.createServer((req, res) => {
  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  res.setHeader('X-Foo', 'bar');
  res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
  res.end('ok');
});
```

Attempting to set a header field name or value that contains invalid characters
will result in a `TypeError` being thrown.
@since v8.4.0
/
        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;
        writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): this;
        /**
Call `http2stream.pushStream()` with the given headers, and wrap the
given `Http2Stream` on a newly created `Http2ServerResponse` as the callback
parameter if successful. When `Http2ServerRequest` is closed, the callback is
called with an error `ERR_HTTP2_INVALID_STREAM`.
@since v8.4.0
@param headers An object describing the headers
@param callback Called once `http2stream.pushStream()` is finished, or either when the attempt to create the pushed `Http2Stream` has failed or has been rejected, or the state of
`Http2ServerRequest` is closed prior to calling the `http2stream.pushStream()` method
/
        createPushResponse(
            headers: OutgoingHttpHeaders,
            callback: (err: Error | null, res: Http2ServerResponse) => void,
        ): void;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "close"): boolean;
        emit(event: "drain"): boolean;
        emit(event: "error", error: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "pipe", src: stream.Readable): boolean;
        emit(event: "unpipe", src: stream.Readable): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "close", listener: () => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export namespace constants {
        const NGHTTP2_SESSION_SERVER: number;
        const NGHTTP2_SESSION_CLIENT: number;
        const NGHTTP2_STREAM_STATE_IDLE: number;
        const NGHTTP2_STREAM_STATE_OPEN: number;
        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;
        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;
        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;
        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;
        const NGHTTP2_STREAM_STATE_CLOSED: number;
        const NGHTTP2_NO_ERROR: number;
        const NGHTTP2_PROTOCOL_ERROR: number;
        const NGHTTP2_INTERNAL_ERROR: number;
        const NGHTTP2_FLOW_CONTROL_ERROR: number;
        const NGHTTP2_SETTINGS_TIMEOUT: number;
        const NGHTTP2_STREAM_CLOSED: number;
        const NGHTTP2_FRAME_SIZE_ERROR: number;
        const NGHTTP2_REFUSED_STREAM: number;
        const NGHTTP2_CANCEL: number;
        const NGHTTP2_COMPRESSION_ERROR: number;
        const NGHTTP2_CONNECT_ERROR: number;
        const NGHTTP2_ENHANCE_YOUR_CALM: number;
        const NGHTTP2_INADEQUATE_SECURITY: number;
        const NGHTTP2_HTTP_1_1_REQUIRED: number;
        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;
        const NGHTTP2_FLAG_NONE: number;
        const NGHTTP2_FLAG_END_STREAM: number;
        const NGHTTP2_FLAG_END_HEADERS: number;
        const NGHTTP2_FLAG_ACK: number;
        const NGHTTP2_FLAG_PADDED: number;
        const NGHTTP2_FLAG_PRIORITY: number;
        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;
        const DEFAULT_SETTINGS_ENABLE_PUSH: number;
        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;
        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;
        const MAX_MAX_FRAME_SIZE: number;
        const MIN_MAX_FRAME_SIZE: number;
        const MAX_INITIAL_WINDOW_SIZE: number;
        const NGHTTP2_DEFAULT_WEIGHT: number;
        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;
        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;
        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;
        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;
        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;
        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;
        const PADDING_STRATEGY_NONE: number;
        const PADDING_STRATEGY_MAX: number;
        const PADDING_STRATEGY_CALLBACK: number;
        const HTTP2_HEADER_STATUS: string;
        const HTTP2_HEADER_METHOD: string;
        const HTTP2_HEADER_AUTHORITY: string;
        const HTTP2_HEADER_SCHEME: string;
        const HTTP2_HEADER_PATH: string;
        const HTTP2_HEADER_ACCEPT_CHARSET: string;
        const HTTP2_HEADER_ACCEPT_ENCODING: string;
        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;
        const HTTP2_HEADER_ACCEPT_RANGES: string;
        const HTTP2_HEADER_ACCEPT: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;
        const HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: string;
        const HTTP2_HEADER_AGE: string;
        const HTTP2_HEADER_ALLOW: string;
        const HTTP2_HEADER_AUTHORIZATION: string;
        const HTTP2_HEADER_CACHE_CONTROL: string;
        const HTTP2_HEADER_CONNECTION: string;
        const HTTP2_HEADER_CONTENT_DISPOSITION: string;
        const HTTP2_HEADER_CONTENT_ENCODING: string;
        const HTTP2_HEADER_CONTENT_LANGUAGE: string;
        const HTTP2_HEADER_CONTENT_LENGTH: string;
        const HTTP2_HEADER_CONTENT_LOCATION: string;
        const HTTP2_HEADER_CONTENT_MD5: string;
        const HTTP2_HEADER_CONTENT_RANGE: string;
        const HTTP2_HEADER_CONTENT_TYPE: string;
        const HTTP2_HEADER_COOKIE: string;
        const HTTP2_HEADER_DATE: string;
        const HTTP2_HEADER_ETAG: string;
        const HTTP2_HEADER_EXPECT: string;
        const HTTP2_HEADER_EXPIRES: string;
        const HTTP2_HEADER_FROM: string;
        const HTTP2_HEADER_HOST: string;
        const HTTP2_HEADER_IF_MATCH: string;
        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;
        const HTTP2_HEADER_IF_NONE_MATCH: string;
        const HTTP2_HEADER_IF_RANGE: string;
        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;
        const HTTP2_HEADER_LAST_MODIFIED: string;
        const HTTP2_HEADER_LINK: string;
        const HTTP2_HEADER_LOCATION: string;
        const HTTP2_HEADER_MAX_FORWARDS: string;
        const HTTP2_HEADER_PREFER: string;
        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;
        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;
        const HTTP2_HEADER_RANGE: string;
        const HTTP2_HEADER_REFERER: string;
        const HTTP2_HEADER_REFRESH: string;
        const HTTP2_HEADER_RETRY_AFTER: string;
        const HTTP2_HEADER_SERVER: string;
        const HTTP2_HEADER_SET_COOKIE: string;
        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;
        const HTTP2_HEADER_TRANSFER_ENCODING: string;
        const HTTP2_HEADER_TE: string;
        const HTTP2_HEADER_UPGRADE: string;
        const HTTP2_HEADER_USER_AGENT: string;
        const HTTP2_HEADER_VARY: string;
        const HTTP2_HEADER_VIA: string;
        const HTTP2_HEADER_WWW_AUTHENTICATE: string;
        const HTTP2_HEADER_HTTP2_SETTINGS: string;
        const HTTP2_HEADER_KEEP_ALIVE: string;
        const HTTP2_HEADER_PROXY_CONNECTION: string;
        const HTTP2_METHOD_ACL: string;
        const HTTP2_METHOD_BASELINE_CONTROL: string;
        const HTTP2_METHOD_BIND: string;
        const HTTP2_METHOD_CHECKIN: string;
        const HTTP2_METHOD_CHECKOUT: string;
        const HTTP2_METHOD_CONNECT: string;
        const HTTP2_METHOD_COPY: string;
        const HTTP2_METHOD_DELETE: string;
        const HTTP2_METHOD_GET: string;
        const HTTP2_METHOD_HEAD: string;
        const HTTP2_METHOD_LABEL: string;
        const HTTP2_METHOD_LINK: string;
        const HTTP2_METHOD_LOCK: string;
        const HTTP2_METHOD_MERGE: string;
        const HTTP2_METHOD_MKACTIVITY: string;
        const HTTP2_METHOD_MKCALENDAR: string;
        const HTTP2_METHOD_MKCOL: string;
        const HTTP2_METHOD_MKREDIRECTREF: string;
        const HTTP2_METHOD_MKWORKSPACE: string;
        const HTTP2_METHOD_MOVE: string;
        const HTTP2_METHOD_OPTIONS: string;
        const HTTP2_METHOD_ORDERPATCH: string;
        const HTTP2_METHOD_PATCH: string;
        const HTTP2_METHOD_POST: string;
        const HTTP2_METHOD_PRI: string;
        const HTTP2_METHOD_PROPFIND: string;
        const HTTP2_METHOD_PROPPATCH: string;
        const HTTP2_METHOD_PUT: string;
        const HTTP2_METHOD_REBIND: string;
        const HTTP2_METHOD_REPORT: string;
        const HTTP2_METHOD_SEARCH: string;
        const HTTP2_METHOD_TRACE: string;
        const HTTP2_METHOD_UNBIND: string;
        const HTTP2_METHOD_UNCHECKOUT: string;
        const HTTP2_METHOD_UNLINK: string;
        const HTTP2_METHOD_UNLOCK: string;
        const HTTP2_METHOD_UPDATE: string;
        const HTTP2_METHOD_UPDATEREDIRECTREF: string;
        const HTTP2_METHOD_VERSION_CONTROL: string;
        const HTTP_STATUS_CONTINUE: number;
        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;
        const HTTP_STATUS_PROCESSING: number;
        const HTTP_STATUS_OK: number;
        const HTTP_STATUS_CREATED: number;
        const HTTP_STATUS_ACCEPTED: number;
        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;
        const HTTP_STATUS_NO_CONTENT: number;
        const HTTP_STATUS_RESET_CONTENT: number;
        const HTTP_STATUS_PARTIAL_CONTENT: number;
        const HTTP_STATUS_MULTI_STATUS: number;
        const HTTP_STATUS_ALREADY_REPORTED: number;
        const HTTP_STATUS_IM_USED: number;
        const HTTP_STATUS_MULTIPLE_CHOICES: number;
        const HTTP_STATUS_MOVED_PERMANENTLY: number;
        const HTTP_STATUS_FOUND: number;
        const HTTP_STATUS_SEE_OTHER: number;
        const HTTP_STATUS_NOT_MODIFIED: number;
        const HTTP_STATUS_USE_PROXY: number;
        const HTTP_STATUS_TEMPORARY_REDIRECT: number;
        const HTTP_STATUS_PERMANENT_REDIRECT: number;
        const HTTP_STATUS_BAD_REQUEST: number;
        const HTTP_STATUS_UNAUTHORIZED: number;
        const HTTP_STATUS_PAYMENT_REQUIRED: number;
        const HTTP_STATUS_FORBIDDEN: number;
        const HTTP_STATUS_NOT_FOUND: number;
        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;
        const HTTP_STATUS_NOT_ACCEPTABLE: number;
        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;
        const HTTP_STATUS_REQUEST_TIMEOUT: number;
        const HTTP_STATUS_CONFLICT: number;
        const HTTP_STATUS_GONE: number;
        const HTTP_STATUS_LENGTH_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_FAILED: number;
        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;
        const HTTP_STATUS_URI_TOO_LONG: number;
        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;
        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;
        const HTTP_STATUS_EXPECTATION_FAILED: number;
        const HTTP_STATUS_TEAPOT: number;
        const HTTP_STATUS_MISDIRECTED_REQUEST: number;
        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;
        const HTTP_STATUS_LOCKED: number;
        const HTTP_STATUS_FAILED_DEPENDENCY: number;
        const HTTP_STATUS_UNORDERED_COLLECTION: number;
        const HTTP_STATUS_UPGRADE_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_REQUIRED: number;
        const HTTP_STATUS_TOO_MANY_REQUESTS: number;
        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;
        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;
        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;
        const HTTP_STATUS_NOT_IMPLEMENTED: number;
        const HTTP_STATUS_BAD_GATEWAY: number;
        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;
        const HTTP_STATUS_GATEWAY_TIMEOUT: number;
        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;
        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;
        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;
        const HTTP_STATUS_LOOP_DETECTED: number;
        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;
        const HTTP_STATUS_NOT_EXTENDED: number;
        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;
    }
    /**
This symbol can be set as a property on the HTTP/2 headers object with
an array value in order to provide a list of headers considered sensitive.
/
    export const sensitiveHeaders: symbol;
    /**
Returns an object containing the default settings for an `Http2Session` instance. This method returns a new object instance every time it is called
so instances returned may be safely modified for use.
@since v8.4.0

## getPackedSettings

Source: `my-backend/node_modules/@types/node/http2.d.ts`

Signature: `getPackedSettings(settings: Settings)`

JSDoc:

Returns a `Buffer` instance containing serialized representation of the given
HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended
for use with the `HTTP2-Settings` header field.

```js
import http2 from 'node:http2';

const packed = http2.getPackedSettings({ enablePush: false });

console.log(packed.toString('base64'));
// Prints: AAIAAAAA
```
@since v8.4.0

## getUnpackedSettings

Source: `my-backend/node_modules/@types/node/http2.d.ts`

Signature: `getUnpackedSettings(buf: Uint8Array)`

JSDoc:

Returns a `HTTP/2 Settings Object` containing the deserialized settings from
the given `Buffer` as generated by `http2.getPackedSettings()`.
@since v8.4.0
@param buf The packed settings.

## createServer

Source: `my-backend/node_modules/@types/node/http2.d.ts`

Signature: `createServer(
        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse)`

JSDoc:

Returns a `net.Server` instance that creates and manages `Http2Session` instances.

Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {@link createSecureServer} is necessary when
communicating
with browser clients.

```js
import http2 from 'node:http2';

// Create an unencrypted HTTP/2 server.
// Since there are no browsers known that support
// unencrypted HTTP/2, the use of `http2.createSecureServer()`
// is necessary when communicating with browser clients.
const server = http2.createServer();

server.on('stream', (stream, headers) => {
  stream.respond({
    'content-type': 'text/html; charset=utf-8',
    ':status': 200,
  });
  stream.end('<h1>Hello World</h1>');
});

server.listen(8000);
```
@since v8.4.0
@param onRequestHandler See `Compatibility API`

## createSecureServer

Source: `my-backend/node_modules/@types/node/http2.d.ts`

Signature: `createSecureServer(
        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse)`

JSDoc:

Returns a `tls.Server` instance that creates and manages `Http2Session` instances.

```js
import http2 from 'node:http2';
import fs from 'node:fs';

const options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem'),
};

// Create a secure HTTP/2 server
const server = http2.createSecureServer(options);

server.on('stream', (stream, headers) => {
  stream.respond({
    'content-type': 'text/html; charset=utf-8',
    ':status': 200,
  });
  stream.end('<h1>Hello World</h1>');
});

server.listen(8443);
```
@since v8.4.0
@param onRequestHandler See `Compatibility API`

## connect

Source: `my-backend/node_modules/@types/node/http2.d.ts`

Signature: `connect(
        authority: string | url.URL,
        listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket)`

JSDoc:

Returns a `ClientHttp2Session` instance.

```js
import http2 from 'node:http2';
const client = http2.connect('https://localhost:1234');

// Use the client

client.close();
```
@since v8.4.0
@param authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port
is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.
@param listener Will be registered as a one-time listener of the {@link 'connect'} event.

## performServerHandshake

Source: `my-backend/node_modules/@types/node/http2.d.ts`

Signature: `performServerHandshake(<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    >(
        socket: stream.Duplex,
        options?: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
    )`

JSDoc:

Create an HTTP/2 server session from an existing socket.
@param socket A Duplex Stream
@param options Any `{@link createServer}` options can be provided.
@since v20.12.0

## createInterface

Source: `my-backend/node_modules/@types/node/readline.d.ts`

Signature: `createInterface(
        input: NodeJS.ReadableStream,
        output?: NodeJS.WritableStream,
        completer?: Completer | AsyncCompleter,
        terminal?: boolean,
    )`

JSDoc:

The `node:readline` module provides an interface for reading data from a [Readable](https://nodejs.org/docs/latest-v24.x/api/stream.html#readable-streams) stream
(such as [`process.stdin`](https://nodejs.org/docs/latest-v24.x/api/process.html#processstdin)) one line at a time.

To use the promise-based APIs:

```js
import * as readline from 'node:readline/promises';
```

To use the callback and sync APIs:

```js
import * as readline from 'node:readline';
```

The following simple example illustrates the basic use of the `node:readline` module.

```js
import * as readline from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';

const rl = readline.createInterface({ input, output });

const answer = await rl.question('What do you think of Node.js? ');

console.log(`Thank you for your valuable feedback: ${answer}`);

rl.close();
```

Once this code is invoked, the Node.js application will not terminate until the `readline.Interface` is closed because the interface waits for data to be
received on the `input` stream.
@see [source](https://github.com/nodejs/node/blob/v24.x/lib/readline.js)
/
declare module "readline" {
    import { Abortable, EventEmitter } from "node:events";
    import * as promises from "node:readline/promises";
    export { promises };
    export interface Key {
        sequence?: string | undefined;
        name?: string | undefined;
        ctrl?: boolean | undefined;
        meta?: boolean | undefined;
        shift?: boolean | undefined;
    }
    /**
Instances of the `readline.Interface` class are constructed using the `readline.createInterface()` method. Every instance is associated with a
single `input` [Readable](https://nodejs.org/docs/latest-v24.x/api/stream.html#readable-streams) stream and a single `output` [Writable](https://nodejs.org/docs/latest-v24.x/api/stream.html#writable-streams) stream.
The `output` stream is used to print prompts for user input that arrives on,
and is read from, the `input` stream.
@since v0.1.104
/
    export class Interface extends EventEmitter implements Disposable {
        readonly terminal: boolean;
        /**
The current input data being processed by node.

This can be used when collecting input from a TTY stream to retrieve the
current value that has been processed thus far, prior to the `line` event
being emitted. Once the `line` event has been emitted, this property will
be an empty string.

Be aware that modifying the value during the instance runtime may have
unintended consequences if `rl.cursor` is not also controlled.

**If not using a TTY stream for input, use the `'line'` event.**

One possible use case would be as follows:

```js
const values = ['lorem ipsum', 'dolor sit amet'];
const rl = readline.createInterface(process.stdin);
const showResults = debounce(() => {
  console.log(
    '\n',
    values.filter((val) => val.startsWith(rl.line)).join(' '),
  );
}, 300);
process.stdin.on('keypress', (c, k) => {
  showResults();
});
```
@since v0.1.98
/
        readonly line: string;
        /**
The cursor position relative to `rl.line`.

This will track where the current cursor lands in the input string, when
reading input from a TTY stream. The position of cursor determines the
portion of the input string that will be modified as input is processed,
as well as the column where the terminal caret will be rendered.
@since v0.1.98
/
        readonly cursor: number;
        /**
NOTE: According to the documentation:

> Instances of the `readline.Interface` class are constructed using the
> `readline.createInterface()` method.

@see https://nodejs.org/dist/latest-v24.x/docs/api/readline.html#class-interfaceconstructor
/
        protected constructor(
            input: NodeJS.ReadableStream,
            output?: NodeJS.WritableStream,
            completer?: Completer | AsyncCompleter,
            terminal?: boolean,
        );
        /**
NOTE: According to the documentation:

> Instances of the `readline.Interface` class are constructed using the
> `readline.createInterface()` method.

@see https://nodejs.org/dist/latest-v24.x/docs/api/readline.html#class-interfaceconstructor
/
        protected constructor(options: ReadLineOptions);
        /**
The `rl.getPrompt()` method returns the current prompt used by `rl.prompt()`.
@since v15.3.0, v14.17.0
@return the current prompt string
/
        getPrompt(): string;
        /**
The `rl.setPrompt()` method sets the prompt that will be written to `output` whenever `rl.prompt()` is called.
@since v0.1.98
/
        setPrompt(prompt: string): void;
        /**
The `rl.prompt()` method writes the `Interface` instances configured`prompt` to a new line in `output` in order to provide a user with a new
location at which to provide input.

When called, `rl.prompt()` will resume the `input` stream if it has been
paused.

If the `Interface` was created with `output` set to `null` or `undefined` the prompt is not written.
@since v0.1.98
@param preserveCursor If `true`, prevents the cursor placement from being reset to `0`.
/
        prompt(preserveCursor?: boolean): void;
        /**
The `rl.question()` method displays the `query` by writing it to the `output`,
waits for user input to be provided on `input`, then invokes the `callback` function passing the provided input as the first argument.

When called, `rl.question()` will resume the `input` stream if it has been
paused.

If the `Interface` was created with `output` set to `null` or `undefined` the `query` is not written.

The `callback` function passed to `rl.question()` does not follow the typical
pattern of accepting an `Error` object or `null` as the first argument.
The `callback` is called with the provided answer as the only argument.

An error will be thrown if calling `rl.question()` after `rl.close()`.

Example usage:

```js
rl.question('What is your favorite food? ', (answer) => {
  console.log(`Oh, so your favorite food is ${answer}`);
});
```

Using an `AbortController` to cancel a question.

```js
const ac = new AbortController();
const signal = ac.signal;

rl.question('What is your favorite food? ', { signal }, (answer) => {
  console.log(`Oh, so your favorite food is ${answer}`);
});

signal.addEventListener('abort', () => {
  console.log('The food question timed out');
}, { once: true });

setTimeout(() => ac.abort(), 10000);
```
@since v0.3.3
@param query A statement or query to write to `output`, prepended to the prompt.
@param callback A callback function that is invoked with the user's input in response to the `query`.
/
        question(query: string, callback: (answer: string) => void): void;
        question(query: string, options: Abortable, callback: (answer: string) => void): void;
        /**
The `rl.pause()` method pauses the `input` stream, allowing it to be resumed
later if necessary.

Calling `rl.pause()` does not immediately pause other events (including `'line'`) from being emitted by the `Interface` instance.
@since v0.3.4
/
        pause(): this;
        /**
The `rl.resume()` method resumes the `input` stream if it has been paused.
@since v0.3.4
/
        resume(): this;
        /**
The `rl.close()` method closes the `Interface` instance and
relinquishes control over the `input` and `output` streams. When called,
the `'close'` event will be emitted.

Calling `rl.close()` does not immediately stop other events (including `'line'`)
from being emitted by the `Interface` instance.
@since v0.1.98
/
        close(): void;
        /**
Alias for `rl.close()`.
@since v22.15.0
/
        [Symbol.dispose](): void;
        /**
The `rl.write()` method will write either `data` or a key sequence identified
by `key` to the `output`. The `key` argument is supported only if `output` is
a `TTY` text terminal. See `TTY keybindings` for a list of key
combinations.

If `key` is specified, `data` is ignored.

When called, `rl.write()` will resume the `input` stream if it has been
paused.

If the `Interface` was created with `output` set to `null` or `undefined` the `data` and `key` are not written.

```js
rl.write('Delete this!');
// Simulate Ctrl+U to delete the line written previously
rl.write(null, { ctrl: true, name: 'u' });
```

The `rl.write()` method will write the data to the `readline` `Interface`'s `input` _as if it were provided by the user_.
@since v0.1.98
/
        write(data: string | Buffer, key?: Key): void;
        write(data: undefined | null | string | Buffer, key: Key): void;
        /**
Returns the real position of the cursor in relation to the input
prompt + string. Long input (wrapping) strings, as well as multiple
line prompts are included in the calculations.
@since v13.5.0, v12.16.0
/
        getCursorPos(): CursorPos;
        /**
events.EventEmitter
1. close
2. line
3. pause
4. resume
5. SIGCONT
6. SIGINT
7. SIGTSTP
8. history
/
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "line", listener: (input: string) => void): this;
        addListener(event: "pause", listener: () => void): this;
        addListener(event: "resume", listener: () => void): this;
        addListener(event: "SIGCONT", listener: () => void): this;
        addListener(event: "SIGINT", listener: () => void): this;
        addListener(event: "SIGTSTP", listener: () => void): this;
        addListener(event: "history", listener: (history: string[]) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "line", input: string): boolean;
        emit(event: "pause"): boolean;
        emit(event: "resume"): boolean;
        emit(event: "SIGCONT"): boolean;
        emit(event: "SIGINT"): boolean;
        emit(event: "SIGTSTP"): boolean;
        emit(event: "history", history: string[]): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "line", listener: (input: string) => void): this;
        on(event: "pause", listener: () => void): this;
        on(event: "resume", listener: () => void): this;
        on(event: "SIGCONT", listener: () => void): this;
        on(event: "SIGINT", listener: () => void): this;
        on(event: "SIGTSTP", listener: () => void): this;
        on(event: "history", listener: (history: string[]) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "line", listener: (input: string) => void): this;
        once(event: "pause", listener: () => void): this;
        once(event: "resume", listener: () => void): this;
        once(event: "SIGCONT", listener: () => void): this;
        once(event: "SIGINT", listener: () => void): this;
        once(event: "SIGTSTP", listener: () => void): this;
        once(event: "history", listener: (history: string[]) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "line", listener: (input: string) => void): this;
        prependListener(event: "pause", listener: () => void): this;
        prependListener(event: "resume", listener: () => void): this;
        prependListener(event: "SIGCONT", listener: () => void): this;
        prependListener(event: "SIGINT", listener: () => void): this;
        prependListener(event: "SIGTSTP", listener: () => void): this;
        prependListener(event: "history", listener: (history: string[]) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "line", listener: (input: string) => void): this;
        prependOnceListener(event: "pause", listener: () => void): this;
        prependOnceListener(event: "resume", listener: () => void): this;
        prependOnceListener(event: "SIGCONT", listener: () => void): this;
        prependOnceListener(event: "SIGINT", listener: () => void): this;
        prependOnceListener(event: "SIGTSTP", listener: () => void): this;
        prependOnceListener(event: "history", listener: (history: string[]) => void): this;
        [Symbol.asyncIterator](): NodeJS.AsyncIterator<string>;
    }
    export type ReadLine = Interface; // type forwarded for backwards compatibility
    export type Completer = (line: string) => CompleterResult;
    export type AsyncCompleter = (
        line: string,
        callback: (err?: null | Error, result?: CompleterResult) => void,
    ) => void;
    export type CompleterResult = [string[], string];
    export interface ReadLineOptions {
        /**
The [`Readable`](https://nodejs.org/docs/latest-v24.x/api/stream.html#readable-streams) stream to listen to
/
        input: NodeJS.ReadableStream;
        /**
The [`Writable`](https://nodejs.org/docs/latest-v24.x/api/stream.html#writable-streams) stream to write readline data to.
/
        output?: NodeJS.WritableStream | undefined;
        /**
An optional function used for Tab autocompletion.
/
        completer?: Completer | AsyncCompleter | undefined;
        /**
`true` if the `input` and `output` streams should be treated like a TTY,
and have ANSI/VT100 escape codes written to it.
Default: checking `isTTY` on the `output` stream upon instantiation.
/
        terminal?: boolean | undefined;
        /**
Initial list of history lines.
This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check,
otherwise the history caching mechanism is not initialized at all.
@default []
/
        history?: string[] | undefined;
        /**
Maximum number of history lines retained.
To disable the history set this value to `0`.
This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check,
otherwise the history caching mechanism is not initialized at all.
@default 30
/
        historySize?: number | undefined;
        /**
If `true`, when a new input line added to the history list duplicates an older one,
this removes the older line from the list.
@default false
/
        removeHistoryDuplicates?: boolean | undefined;
        /**
The prompt string to use.
@default "> "
/
        prompt?: string | undefined;
        /**
If the delay between `\r` and `\n` exceeds `crlfDelay` milliseconds,
both `\r` and `\n` will be treated as separate end-of-line input.
`crlfDelay` will be coerced to a number no less than `100`.
It can be set to `Infinity`, in which case
`\r` followed by `\n` will always be considered a single newline
(which may be reasonable for [reading files](https://nodejs.org/docs/latest-v24.x/api/readline.html#example-read-file-stream-line-by-line) with `\r\n` line delimiter).
@default 100
/
        crlfDelay?: number | undefined;
        /**
The duration `readline` will wait for a character
(when reading an ambiguous key sequence in milliseconds
one that can both form a complete key sequence using the input read so far
and can take additional input to complete a longer key sequence).
@default 500
/
        escapeCodeTimeout?: number | undefined;
        /**
The number of spaces a tab is equal to (minimum 1).
@default 8
/
        tabSize?: number | undefined;
        /**
Allows closing the interface using an AbortSignal.
Aborting the signal will internally call `close` on the interface.
/
        signal?: AbortSignal | undefined;
    }
    /**
The `readline.createInterface()` method creates a new `readline.Interface` instance.

```js
import readline from 'node:readline';
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
```

Once the `readline.Interface` instance is created, the most common case is to
listen for the `'line'` event:

```js
rl.on('line', (line) => {
  console.log(`Received: ${line}`);
});
```

If `terminal` is `true` for this instance then the `output` stream will get
the best compatibility if it defines an `output.columns` property and emits
a `'resize'` event on the `output` if or when the columns ever change
(`process.stdout` does this automatically when it is a TTY).

When creating a `readline.Interface` using `stdin` as input, the program
will not terminate until it receives an [EOF character](https://en.wikipedia.org/wiki/End-of-file#EOF_character). To exit without
waiting for user input, call `process.stdin.unref()`.
@since v0.1.98

## emitKeypressEvents

Source: `my-backend/node_modules/@types/node/readline.d.ts`

Signature: `emitKeypressEvents(stream: NodeJS.ReadableStream, readlineInterface?: Interface)`

JSDoc:

The `readline.emitKeypressEvents()` method causes the given `Readable` stream to begin emitting `'keypress'` events corresponding to received input.

Optionally, `interface` specifies a `readline.Interface` instance for which
autocompletion is disabled when copy-pasted input is detected.

If the `stream` is a `TTY`, then it must be in raw mode.

This is automatically called by any readline instance on its `input` if the `input` is a terminal. Closing the `readline` instance does not stop
the `input` from emitting `'keypress'` events.

```js
readline.emitKeypressEvents(process.stdin);
if (process.stdin.isTTY)
  process.stdin.setRawMode(true);
```

## Example: Tiny CLI

The following example illustrates the use of `readline.Interface` class to
implement a small command-line interface:

```js
import readline from 'node:readline';
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  prompt: 'OHAI> ',
});

rl.prompt();

rl.on('line', (line) => {
  switch (line.trim()) {
    case 'hello':
      console.log('world!');
      break;
    default:
      console.log(`Say what? I might have heard '${line.trim()}'`);
      break;
  }
  rl.prompt();
}).on('close', () => {
  console.log('Have a great day!');
  process.exit(0);
});
```

## Example: Read file stream line-by-Line

A common use case for `readline` is to consume an input file one line at a
time. The easiest way to do so is leveraging the `fs.ReadStream` API as
well as a `for await...of` loop:

```js
import fs from 'node:fs';
import readline from 'node:readline';

async function processLineByLine() {
  const fileStream = fs.createReadStream('input.txt');

  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity,
  });
  // Note: we use the crlfDelay option to recognize all instances of CR LF
  // ('\r\n') in input.txt as a single line break.

  for await (const line of rl) {
    // Each line in input.txt will be successively available here as `line`.
    console.log(`Line from file: ${line}`);
  }
}

processLineByLine();
```

Alternatively, one could use the `'line'` event:

```js
import fs from 'node:fs';
import readline from 'node:readline';

const rl = readline.createInterface({
  input: fs.createReadStream('sample.txt'),
  crlfDelay: Infinity,
});

rl.on('line', (line) => {
  console.log(`Line from file: ${line}`);
});
```

Currently, `for await...of` loop can be a bit slower. If `async` / `await` flow and speed are both essential, a mixed approach can be applied:

```js
import { once } from 'node:events';
import { createReadStream } from 'node:fs';
import { createInterface } from 'node:readline';

(async function processLineByLine() {
  try {
    const rl = createInterface({
      input: createReadStream('big-file.txt'),
      crlfDelay: Infinity,
    });

    rl.on('line', (line) => {
      // Process the line.
    });

    await once(rl, 'close');

    console.log('File processed.');
  } catch (err) {
    console.error(err);
  }
})();
```
@since v0.7.7

## clearLine

Source: `my-backend/node_modules/@types/node/readline.d.ts`

Signature: `clearLine(stream: NodeJS.WritableStream, dir: Direction, callback?: ()`

JSDoc:

The `readline.clearLine()` method clears current line of given [TTY](https://nodejs.org/docs/latest-v24.x/api/tty.html) stream
in a specified direction identified by `dir`.
@since v0.7.7
@param callback Invoked once the operation completes.
@return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.

## clearScreenDown

Source: `my-backend/node_modules/@types/node/readline.d.ts`

Signature: `clearScreenDown(stream: NodeJS.WritableStream, callback?: ()`

JSDoc:

The `readline.clearScreenDown()` method clears the given [TTY](https://nodejs.org/docs/latest-v24.x/api/tty.html) stream from
the current position of the cursor down.
@since v0.7.7
@param callback Invoked once the operation completes.
@return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.

## cursorTo

Source: `my-backend/node_modules/@types/node/readline.d.ts`

Signature: `cursorTo(stream: NodeJS.WritableStream, x: number, y?: number, callback?: ()`

JSDoc:

The `readline.cursorTo()` method moves cursor to the specified position in a
given [TTY](https://nodejs.org/docs/latest-v24.x/api/tty.html) `stream`.
@since v0.7.7
@param callback Invoked once the operation completes.
@return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.

## moveCursor

Source: `my-backend/node_modules/@types/node/readline.d.ts`

Signature: `moveCursor(stream: NodeJS.WritableStream, dx: number, dy: number, callback?: ()`

JSDoc:

The `readline.moveCursor()` method moves the cursor _relative_ to its current
position in a given [TTY](https://nodejs.org/docs/latest-v24.x/api/tty.html) `stream`.
@since v0.7.7
@param callback Invoked once the operation completes.
@return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.

## diff

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `diff(actual: string | readonly string[], expected: string | readonly string[])`

JSDoc:

The `node:util` module supports the needs of Node.js internal APIs. Many of the
utilities are useful for application and module developers as well. To access
it:

```js
import util from 'node:util';
```
@see [source](https://github.com/nodejs/node/blob/v24.x/lib/util.js)
/
declare module "util" {
    import * as types from "node:util/types";
    export interface InspectOptions {
        /**
If `true`, object's non-enumerable symbols and properties are included in the formatted result.
`WeakMap` and `WeakSet` entries are also included as well as user defined prototype properties (excluding method properties).
@default false
/
        showHidden?: boolean | undefined;
        /**
Specifies the number of times to recurse while formatting object.
This is useful for inspecting large objects.
To recurse up to the maximum call stack size pass `Infinity` or `null`.
@default 2
/
        depth?: number | null | undefined;
        /**
If `true`, the output is styled with ANSI color codes. Colors are customizable.
/
        colors?: boolean | undefined;
        /**
If `false`, `[util.inspect.custom](depth, opts, inspect)` functions are not invoked.
@default true
/
        customInspect?: boolean | undefined;
        /**
If `true`, `Proxy` inspection includes the target and handler objects.
@default false
/
        showProxy?: boolean | undefined;
        /**
Specifies the maximum number of `Array`, `TypedArray`, `WeakMap`, and `WeakSet` elements
to include when formatting. Set to `null` or `Infinity` to show all elements.
Set to `0` or negative to show no elements.
@default 100
/
        maxArrayLength?: number | null | undefined;
        /**
Specifies the maximum number of characters to
include when formatting. Set to `null` or `Infinity` to show all elements.
Set to `0` or negative to show no characters.
@default 10000
/
        maxStringLength?: number | null | undefined;
        /**
The length at which input values are split across multiple lines.
Set to `Infinity` to format the input as a single line
(in combination with `compact` set to `true` or any number >= `1`).
@default 80
/
        breakLength?: number | undefined;
        /**
Setting this to `false` causes each object key
to be displayed on a new line. It will also add new lines to text that is
longer than `breakLength`. If set to a number, the most `n` inner elements
are united on a single line as long as all properties fit into
`breakLength`. Short array elements are also grouped together. Note that no
text will be reduced below 16 characters, no matter the `breakLength` size.
For more information, see the example below.
@default true
/
        compact?: boolean | number | undefined;
        /**
If set to `true` or a function, all properties of an object, and `Set` and `Map`
entries are sorted in the resulting string.
If set to `true` the default sort is used.
If set to a function, it is used as a compare function.
/
        sorted?: boolean | ((a: string, b: string) => number) | undefined;
        /**
If set to `true`, getters are going to be
inspected as well. If set to `'get'` only getters without setter are going
to be inspected. If set to `'set'` only getters having a corresponding
setter are going to be inspected. This might cause side effects depending on
the getter function.
@default false
/
        getters?: "get" | "set" | boolean | undefined;
        /**
If set to `true`, an underscore is used to separate every three digits in all bigints and numbers.
@default false
/
        numericSeparator?: boolean | undefined;
    }
    export type Style =
        | "special"
        | "number"
        | "bigint"
        | "boolean"
        | "undefined"
        | "null"
        | "string"
        | "symbol"
        | "date"
        | "regexp"
        | "module";
    export type CustomInspectFunction = (depth: number, options: InspectOptionsStylized) => any; // TODO: , inspect: inspect
    export interface InspectOptionsStylized extends InspectOptions {
        stylize(text: string, styleType: Style): string;
    }
    export interface CallSiteObject {
        /**
Returns the name of the function associated with this call site.
/
        functionName: string;
        /**
Returns the name of the resource that contains the script for the
function for this call site.
/
        scriptName: string;
        /**
Returns the unique id of the script, as in Chrome DevTools protocol
[`Runtime.ScriptId`](https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/#type-ScriptId).
@since v22.14.0
/
        scriptId: string;
        /**
Returns the number, 1-based, of the line for the associate function call.
/
        lineNumber: number;
        /**
Returns the 1-based column offset on the line for the associated function call.
/
        columnNumber: number;
    }
    export type DiffEntry = [operation: -1 | 0 | 1, value: string];
    /**
`util.diff()` compares two string or array values and returns an array of difference entries.
It uses the Myers diff algorithm to compute minimal differences, which is the same algorithm
used internally by assertion error messages.

If the values are equal, an empty array is returned.

```js
const { diff } = require('node:util');

// Comparing strings
const actualString = '12345678';
const expectedString = '12!!5!7!';
console.log(diff(actualString, expectedString));
// [
//   [0, '1'],
//   [0, '2'],
//   [1, '3'],
//   [1, '4'],
//   [-1, '!'],
//   [-1, '!'],
//   [0, '5'],
//   [1, '6'],
//   [-1, '!'],
//   [0, '7'],
//   [1, '8'],
//   [-1, '!'],
// ]
// Comparing arrays
const actualArray = ['1', '2', '3'];
const expectedArray = ['1', '3', '4'];
console.log(diff(actualArray, expectedArray));
// [
//   [0, '1'],
//   [1, '2'],
//   [0, '3'],
//   [-1, '4'],
// ]
// Equal values return empty array
console.log(diff('same', 'same'));
// []
```
@since v22.15.0
@experimental
@param actual The first value to compare
@param expected The second value to compare
@returns An array of difference entries. Each entry is an array with two elements:
* Index 0: `number` Operation code: `-1` for delete, `0` for no-op/unchanged, `1` for insert
* Index 1: `string` The value associated with the operation

## format

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `format(format?: any, ...param: any[])`

JSDoc:

The `util.format()` method returns a formatted string using the first argument
as a `printf`-like format string which can contain zero or more format
specifiers. Each specifier is replaced with the converted value from the
corresponding argument. Supported specifiers are:

If a specifier does not have a corresponding argument, it is not replaced:

```js
util.format('%s:%s', 'foo');
// Returns: 'foo:%s'
```

Values that are not part of the format string are formatted using `util.inspect()` if their type is not `string`.

If there are more arguments passed to the `util.format()` method than the
number of specifiers, the extra arguments are concatenated to the returned
string, separated by spaces:

```js
util.format('%s:%s', 'foo', 'bar', 'baz');
// Returns: 'foo:bar baz'
```

If the first argument does not contain a valid format specifier, `util.format()` returns a string that is the concatenation of all arguments separated by spaces:

```js
util.format(1, 2, 3);
// Returns: '1 2 3'
```

If only one argument is passed to `util.format()`, it is returned as it is
without any formatting:

```js
util.format('%% %s');
// Returns: '%% %s'
```

`util.format()` is a synchronous method that is intended as a debugging tool.
Some input values can have a significant performance overhead that can block the
event loop. Use this function with care and never in a hot code path.
@since v0.5.3
@param format A `printf`-like format string.

## formatWithOptions

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `formatWithOptions(inspectOptions: InspectOptions, format?: any, ...param: any[])`

JSDoc:

This function is identical to {@link format}, except in that it takes
an `inspectOptions` argument which specifies options that are passed along to {@link inspect}.

```js
util.formatWithOptions({ colors: true }, 'See object %O', { foo: 42 });
// Returns 'See object { foo: 42 }', where `42` is colored as a number
// when printed to a terminal.
```
@since v10.0.0

## getCallSites

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `getCallSites(frameCount?: number, options?: GetCallSitesOptions)`

JSDoc:

Reconstruct the original location in the stacktrace from the source-map.
Enabled by default with the flag `--enable-source-maps`.
/
        sourceMap?: boolean | undefined;
    }
    /**
Returns an array of call site objects containing the stack of
the caller function.

```js
import { getCallSites } from 'node:util';

function exampleFunction() {
  const callSites = getCallSites();

  console.log('Call Sites:');
  callSites.forEach((callSite, index) => {
    console.log(`CallSite ${index + 1}:`);
    console.log(`Function Name: ${callSite.functionName}`);
    console.log(`Script Name: ${callSite.scriptName}`);
    console.log(`Line Number: ${callSite.lineNumber}`);
    console.log(`Column Number: ${callSite.column}`);
  });
  // CallSite 1:
  // Function Name: exampleFunction
  // Script Name: /home/example.js
  // Line Number: 5
  // Column Number: 26

  // CallSite 2:
  // Function Name: anotherFunction
  // Script Name: /home/example.js
  // Line Number: 22
  // Column Number: 3

  // ...
}

// A function to simulate another stack layer
function anotherFunction() {
  exampleFunction();
}

anotherFunction();
```

It is possible to reconstruct the original locations by setting the option `sourceMap` to `true`.
If the source map is not available, the original location will be the same as the current location.
When the `--enable-source-maps` flag is enabled, for example when using `--experimental-transform-types`,
`sourceMap` will be true by default.

```ts
import { getCallSites } from 'node:util';

interface Foo {
  foo: string;
}

const callSites = getCallSites({ sourceMap: true });

// With sourceMap:
// Function Name: ''
// Script Name: example.js
// Line Number: 7
// Column Number: 26

// Without sourceMap:
// Function Name: ''
// Script Name: example.js
// Line Number: 2
// Column Number: 26
```
@param frameCount Number of frames to capture as call site objects.
**Default:** `10`. Allowable range is between 1 and 200.
@return An array of call site objects
@since v22.9.0

## getSystemErrorName

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `getSystemErrorName(err: number)`

JSDoc:

Returns the string name for a numeric error code that comes from a Node.js API.
The mapping between error codes and error names is platform-dependent.
See `Common System Errors` for the names of common errors.

```js
fs.access('file/that/does/not/exist', (err) => {
  const name = util.getSystemErrorName(err.errno);
  console.error(name);  // ENOENT
});
```
@since v9.7.0

## getSystemErrorMap

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `getSystemErrorMap()`

JSDoc:

Returns a Map of all system error codes available from the Node.js API.
The mapping between error codes and error names is platform-dependent.
See `Common System Errors` for the names of common errors.

```js
fs.access('file/that/does/not/exist', (err) => {
  const errorMap = util.getSystemErrorMap();
  const name = errorMap.get(err.errno);
  console.error(name);  // ENOENT
});
```
@since v16.0.0, v14.17.0

## getSystemErrorMessage

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `getSystemErrorMessage(err: number)`

JSDoc:

Returns the string message for a numeric error code that comes from a Node.js
API.
The mapping between error codes and string messages is platform-dependent.

```js
fs.access('file/that/does/not/exist', (err) => {
  const message = util.getSystemErrorMessage(err.errno);
  console.error(message);  // no such file or directory
});
```
@since v22.12.0

## toUSVString

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `toUSVString(string: string)`

JSDoc:

Returns the `string` after replacing any surrogate code points
(or equivalently, any unpaired surrogate code units) with the
Unicode "replacement character" U+FFFD.
@since v16.8.0, v14.18.0

## transferableAbortController

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `transferableAbortController()`

JSDoc:

Creates and returns an `AbortController` instance whose `AbortSignal` is marked
as transferable and can be used with `structuredClone()` or `postMessage()`.
@since v18.11.0
@returns A transferable AbortController

## transferableAbortSignal

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `transferableAbortSignal(signal: AbortSignal)`

JSDoc:

Marks the given `AbortSignal` as transferable so that it can be used with`structuredClone()` and `postMessage()`.

```js
const signal = transferableAbortSignal(AbortSignal.timeout(100));
const channel = new MessageChannel();
channel.port2.postMessage(signal, [signal]);
```
@since v18.11.0
@param signal The AbortSignal
@returns The same AbortSignal

## aborted

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `aborted(signal: AbortSignal, resource: any)`

JSDoc:

Listens to abort event on the provided `signal` and returns a promise that resolves when the `signal` is aborted.
If `resource` is provided, it weakly references the operation's associated object,
so if `resource` is garbage collected before the `signal` aborts,
then returned promise shall remain pending.
This prevents memory leaks in long-running or non-cancelable operations.

```js
import { aborted } from 'node:util';

// Obtain an object with an abortable signal, like a custom resource or operation.
const dependent = obtainSomethingAbortable();

// Pass `dependent` as the resource, indicating the promise should only resolve
// if `dependent` is still in memory when the signal is aborted.
aborted(dependent.signal, dependent).then(() => {
  // This code runs when `dependent` is aborted.
  console.log('Dependent resource was aborted.');
});

// Simulate an event that triggers the abort.
dependent.on('event', () => {
  dependent.abort(); // This will cause the `aborted` promise to resolve.
});
```
@since v19.7.0
@param resource Any non-null object tied to the abortable operation and held weakly.
If `resource` is garbage collected before the `signal` aborts, the promise remains pending,
allowing Node.js to stop tracking it.
This helps prevent memory leaks in long-running or non-cancelable operations.

## inspect

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean)`

JSDoc:

The `util.inspect()` method returns a string representation of `object` that is
intended for debugging. The output of `util.inspect` may change at any time
and should not be depended upon programmatically. Additional `options` may be
passed that alter the result.
`util.inspect()` will use the constructor's name and/or `Symbol.toStringTag`
property to make an identifiable tag for an inspected value.

```js
class Foo {
  get [Symbol.toStringTag]() {
    return 'bar';
  }
}

class Bar {}

const baz = Object.create(null, { [Symbol.toStringTag]: { value: 'foo' } });

util.inspect(new Foo()); // 'Foo [bar] {}'
util.inspect(new Bar()); // 'Bar {}'
util.inspect(baz);       // '[foo] {}'
```

Circular references point to their anchor by using a reference index:

```js
import { inspect } from 'node:util';

const obj = {};
obj.a = [obj];
obj.b = {};
obj.b.inner = obj.b;
obj.b.obj = obj;

console.log(inspect(obj));
// <ref *1> {
//   a: [ [Circular *1] ],
//   b: <ref *2> { inner: [Circular *2], obj: [Circular *1] }
// }
```

The following example inspects all properties of the `util` object:

```js
import util from 'node:util';

console.log(util.inspect(util, { showHidden: true, depth: null }));
```

The following example highlights the effect of the `compact` option:

```js
import { inspect } from 'node:util';

const o = {
  a: [1, 2, [[
    'Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit, sed do ' +
      'eiusmod \ntempor incididunt ut labore et dolore magna aliqua.',
    'test',
    'foo']], 4],
  b: new Map([['za', 1], ['zb', 'test']]),
};
console.log(inspect(o, { compact: true, depth: 5, breakLength: 80 }));

// { a:
//   [ 1,
//     2,
//     [ [ 'Lorem ipsum dolor sit amet,\nconsectetur [...]', // A long line
//           'test',
//           'foo' ] ],
//     4 ],
//   b: Map(2) { 'za' => 1, 'zb' => 'test' } }

// Setting `compact` to false or an integer creates more reader friendly output.
console.log(inspect(o, { compact: false, depth: 5, breakLength: 80 }));

// {
//   a: [
//     1,
//     2,
//     [
//       [
//         'Lorem ipsum dolor sit amet,\n' +
//           'consectetur adipiscing elit, sed do eiusmod \n' +
//           'tempor incididunt ut labore et dolore magna aliqua.',
//         'test',
//         'foo'
//       ]
//     ],
//     4
//   ],
//   b: Map(2) {
//     'za' => 1,
//     'zb' => 'test'
//   }
// }

// Setting `breakLength` to e.g. 150 will print the "Lorem ipsum" text in a
// single line.
```

The `showHidden` option allows `WeakMap` and `WeakSet` entries to be
inspected. If there are more entries than `maxArrayLength`, there is no
guarantee which entries are displayed. That means retrieving the same
`WeakSet` entries twice may result in different output. Furthermore, entries
with no remaining strong references may be garbage collected at any time.

```js
import { inspect } from 'node:util';

const obj = { a: 1 };
const obj2 = { b: 2 };
const weakSet = new WeakSet([obj, obj2]);

console.log(inspect(weakSet, { showHidden: true }));
// WeakSet { { a: 1 }, { b: 2 } }
```

The `sorted` option ensures that an object's property insertion order does not
impact the result of `util.inspect()`.

```js
import { inspect } from 'node:util';
import assert from 'node:assert';

const o1 = {
  b: [2, 3, 1],
  a: '`a` comes before `b`',
  c: new Set([2, 3, 1]),
};
console.log(inspect(o1, { sorted: true }));
// { a: '`a` comes before `b`', b: [ 2, 3, 1 ], c: Set(3) { 1, 2, 3 } }
console.log(inspect(o1, { sorted: (a, b) => b.localeCompare(a) }));
// { c: Set(3) { 3, 2, 1 }, b: [ 2, 3, 1 ], a: '`a` comes before `b`' }

const o2 = {
  c: new Set([2, 1, 3]),
  a: '`a` comes before `b`',
  b: [2, 3, 1],
};
assert.strict.equal(
  inspect(o1, { sorted: true }),
  inspect(o2, { sorted: true }),
);
```

The `numericSeparator` option adds an underscore every three digits to all
numbers.

```js
import { inspect } from 'node:util';

const thousand = 1000;
const million = 1000000;
const bigNumber = 123456789n;
const bigDecimal = 1234.12345;

console.log(inspect(thousand, { numericSeparator: true }));
// 1_000
console.log(inspect(million, { numericSeparator: true }));
// 1_000_000
console.log(inspect(bigNumber, { numericSeparator: true }));
// 123_456_789n
console.log(inspect(bigDecimal, { numericSeparator: true }));
// 1_234.123_45
```

`util.inspect()` is a synchronous method intended for debugging. Its maximum
output length is approximately 128 MiB. Inputs that result in longer output will
be truncated.
@since v0.3.0
@param object Any JavaScript primitive or `Object`.
@return The representation of `object`.

## isArray

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `isArray(object: unknown)`

JSDoc:

Allows changing inspect settings from the repl.
/
        let replDefaults: InspectOptions;
        /**
That can be used to declare custom inspect functions.
/
        const custom: unique symbol;
    }
    /**
Alias for [`Array.isArray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray).

Returns `true` if the given `object` is an `Array`. Otherwise, returns `false`.

```js
import util from 'node:util';

util.isArray([]);
// Returns: true
util.isArray(new Array());
// Returns: true
util.isArray({});
// Returns: false
```
@since v0.6.0
@deprecated Since v4.0.0 - Use `isArray` instead.

## inherits

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `inherits(constructor: unknown, superConstructor: unknown)`

JSDoc:

Usage of `util.inherits()` is discouraged. Please use the ES6 `class` and
`extends` keywords to get language level inheritance support. Also note
that the two styles are [semantically incompatible](https://github.com/nodejs/node/issues/4179).

Inherit the prototype methods from one
[constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) into another. The
prototype of `constructor` will be set to a new object created from
`superConstructor`.

This mainly adds some input validation on top of
`Object.setPrototypeOf(constructor.prototype, superConstructor.prototype)`.
As an additional convenience, `superConstructor` will be accessible
through the `constructor.super_` property.

```js
const util = require('node:util');
const EventEmitter = require('node:events');

function MyStream() {
  EventEmitter.call(this);
}

util.inherits(MyStream, EventEmitter);

MyStream.prototype.write = function(data) {
  this.emit('data', data);
};

const stream = new MyStream();

console.log(stream instanceof EventEmitter); // true
console.log(MyStream.super_ === EventEmitter); // true

stream.on('data', (data) => {
  console.log(`Received data: "${data}"`);
});
stream.write('It works!'); // Received data: "It works!"
```

ES6 example using `class` and `extends`:

```js
import EventEmitter from 'node:events';

class MyStream extends EventEmitter {
  write(data) {
    this.emit('data', data);
  }
}

const stream = new MyStream();

stream.on('data', (data) => {
  console.log(`Received data: "${data}"`);
});
stream.write('With ES6');
```
@since v0.3.0
@legacy Use ES2015 class syntax and `extends` keyword instead.

## debuglog

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `debuglog(section: string, callback?: (fn: DebugLoggerFunction)`

JSDoc:

The `util.debuglog().enabled` getter is used to create a test that can be used
in conditionals based on the existence of the `NODE_DEBUG` environment variable.
If the `section` name appears within the value of that environment variable,
then the returned value will be `true`. If not, then the returned value will be
`false`.

```js
import { debuglog } from 'node:util';
const enabled = debuglog('foo').enabled;
if (enabled) {
  console.log('hello from foo [%d]', 123);
}
```

If this program is run with `NODE_DEBUG=foo` in the environment, then it will
output something like:

```console
hello from foo [123]
```
/
        enabled: boolean;
    }
    /**
The `util.debuglog()` method is used to create a function that conditionally
writes debug messages to `stderr` based on the existence of the `NODE_DEBUG`
environment variable. If the `section` name appears within the value of that
environment variable, then the returned function operates similar to
`console.error()`. If not, then the returned function is a no-op.

```js
import { debuglog } from 'node:util';
const log = debuglog('foo');

log('hello from foo [%d]', 123);
```

If this program is run with `NODE_DEBUG=foo` in the environment, then
it will output something like:

```console
FOO 3245: hello from foo [123]
```

where `3245` is the process id. If it is not run with that
environment variable set, then it will not print anything.

The `section` supports wildcard also:

```js
import { debuglog } from 'node:util';
const log = debuglog('foo');

log('hi there, it\'s foo-bar [%d]', 2333);
```

if it is run with `NODE_DEBUG=foo*` in the environment, then it will output
something like:

```console
FOO-BAR 3257: hi there, it's foo-bar [2333]
```

Multiple comma-separated `section` names may be specified in the `NODE_DEBUG`
environment variable: `NODE_DEBUG=fs,net,tls`.

The optional `callback` argument can be used to replace the logging function
with a different function that doesn't have any initialization or
unnecessary wrapping.

```js
import { debuglog } from 'node:util';
let log = debuglog('internals', (debug) => {
  // Replace with a logging function that optimizes out
  // testing if the section is enabled
  log = debug;
});
```
@since v0.11.3
@param section A string identifying the portion of the application for which the `debuglog` function is being created.
@param callback A callback invoked the first time the logging function is called with a function argument that is a more optimized logging function.
@return The logging function

## deprecate

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `deprecate(<T extends Function>(fn: T, msg: string, code?: string)`

JSDoc:

The `util.deprecate()` method wraps `fn` (which may be a function or class) in
such a way that it is marked as deprecated.

```js
import { deprecate } from 'node:util';

export const obsoleteFunction = deprecate(() => {
  // Do something here.
}, 'obsoleteFunction() is deprecated. Use newShinyFunction() instead.');
```

When called, `util.deprecate()` will return a function that will emit a
`DeprecationWarning` using the `'warning'` event. The warning will
be emitted and printed to `stderr` the first time the returned function is
called. After the warning is emitted, the wrapped function is called without
emitting a warning.

If the same optional `code` is supplied in multiple calls to `util.deprecate()`,
the warning will be emitted only once for that `code`.

```js
import { deprecate } from 'node:util';

const fn1 = deprecate(
  () => 'a value',
  'deprecation message',
  'DEP0001',
);
const fn2 = deprecate(
  () => 'a  different value',
  'other dep message',
  'DEP0001',
);
fn1(); // Emits a deprecation warning with code DEP0001
fn2(); // Does not emit a deprecation warning because it has the same code
```

If either the `--no-deprecation` or `--no-warnings` command-line flags are
used, or if the `process.noDeprecation` property is set to `true` _prior_ to
the first deprecation warning, the `util.deprecate()` method does nothing.

If the `--trace-deprecation` or `--trace-warnings` command-line flags are set,
or the `process.traceDeprecation` property is set to `true`, a warning and a
stack trace are printed to `stderr` the first time the deprecated function is
called.

If the `--throw-deprecation` command-line flag is set, or the
`process.throwDeprecation` property is set to `true`, then an exception will be
thrown when the deprecated function is called.

The `--throw-deprecation` command-line flag and `process.throwDeprecation`
property take precedence over `--trace-deprecation` and
`process.traceDeprecation`.
@since v0.8.0
@param fn The function that is being deprecated.
@param msg A warning message to display when the deprecated function is invoked.
@param code A deprecation code. See the `list of deprecated APIs` for a list of codes.
@return The deprecated function wrapped to emit a warning.

## isDeepStrictEqual

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `isDeepStrictEqual(val1: unknown, val2: unknown)`

JSDoc:

Returns `true` if there is deep strict equality between `val1` and `val2`.
Otherwise, returns `false`.

See `assert.deepStrictEqual()` for more information about deep strict
equality.
@since v9.0.0

## stripVTControlCharacters

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `stripVTControlCharacters(str: string)`

JSDoc:

Returns `str` with any ANSI escape codes removed.

```js
console.log(util.stripVTControlCharacters('\u001B[4mvalue\u001B[0m'));
// Prints "value"
```
@since v16.11.0

## callbackify

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `callbackify(fn: ()`

JSDoc:

Takes an `async` function (or a function that returns a `Promise`) and returns a
function following the error-first callback style, i.e. taking
an `(err, value) => ...` callback as the last argument. In the callback, the
first argument will be the rejection reason (or `null` if the `Promise`
resolved), and the second argument will be the resolved value.

```js
import { callbackify } from 'node:util';

async function fn() {
  return 'hello world';
}
const callbackFunction = callbackify(fn);

callbackFunction((err, ret) => {
  if (err) throw err;
  console.log(ret);
});
```

Will print:

```text
hello world
```

The callback is executed asynchronously, and will have a limited stack trace.
If the callback throws, the process will emit an `'uncaughtException'`
event, and if not handled will exit.

Since `null` has a special meaning as the first argument to a callback, if a
wrapped function rejects a `Promise` with a falsy value as a reason, the value
is wrapped in an `Error` with the original value stored in a field named
`reason`.

```js
function fn() {
  return Promise.reject(null);
}
const callbackFunction = util.callbackify(fn);

callbackFunction((err, ret) => {
  // When the Promise was rejected with `null` it is wrapped with an Error and
  // the original value is stored in `reason`.
  err && Object.hasOwn(err, 'reason') && err.reason === null;  // true
});
```
@since v8.2.0
@param fn An `async` function
@return a callback style function

## promisify

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `promisify(<TCustom extends Function>(fn: CustomPromisify<TCustom>)`

JSDoc:

Takes a function following the common error-first callback style, i.e. taking
an `(err, value) => ...` callback as the last argument, and returns a version
that returns promises.

```js
import { promisify } from 'node:util';
import { stat } from 'node:fs';

const promisifiedStat = promisify(stat);
promisifiedStat('.').then((stats) => {
  // Do something with `stats`
}).catch((error) => {
  // Handle the error.
});
```

Or, equivalently using `async function`s:

```js
import { promisify } from 'node:util';
import { stat } from 'node:fs';

const promisifiedStat = promisify(stat);

async function callStat() {
  const stats = await promisifiedStat('.');
  console.log(`This directory is owned by ${stats.uid}`);
}

callStat();
```

If there is an `original[util.promisify.custom]` property present, `promisify`
will return its value, see [Custom promisified functions](https://nodejs.org/docs/latest-v24.x/api/util.html#custom-promisified-functions).

`promisify()` assumes that `original` is a function taking a callback as its
final argument in all cases. If `original` is not a function, `promisify()`
will throw an error. If `original` is a function but its last argument is not
an error-first callback, it will still be passed an error-first
callback as its last argument.

Using `promisify()` on class methods or other methods that use `this` may not
work as expected unless handled specially:

```js
import { promisify } from 'node:util';

class Foo {
  constructor() {
    this.a = 42;
  }

  bar(callback) {
    callback(null, this.a);
  }
}

const foo = new Foo();

const naiveBar = promisify(foo.bar);
// TypeError: Cannot read properties of undefined (reading 'a')
// naiveBar().then(a => console.log(a));

naiveBar.call(foo).then((a) => console.log(a)); // '42'

const bindBar = naiveBar.bind(foo);
bindBar().then((a) => console.log(a)); // '42'
```
@since v8.0.0

## parseEnv

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `parseEnv(content: string)`

JSDoc:

That can be used to declare custom promisified variants of functions.
/
        const custom: unique symbol;
    }
    /**
Stability: 1.1 - Active development
Given an example `.env` file:

```js
import { parseEnv } from 'node:util';

parseEnv('HELLO=world\nHELLO=oh my\n');
// Returns: { HELLO: 'oh my' }
```
@param content The raw contents of a `.env` file.
@since v20.12.0

## styleText

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `styleText(
        format:
            | ForegroundColors
            | BackgroundColors
            | Modifiers
            | Array<ForegroundColors | BackgroundColors | Modifiers>,
        text: string,
        options?: StyleTextOptions,
    )`

JSDoc:

When true, `stream` is checked to see if it can handle colors.
@default true
/
        validateStream?: boolean | undefined;
        /**
A stream that will be validated if it can be colored.
@default process.stdout
/
        stream?: NodeJS.WritableStream | undefined;
    }
    /**
This function returns a formatted text considering the `format` passed
for printing in a terminal. It is aware of the terminal's capabilities
and acts according to the configuration set via `NO_COLOR`,
`NODE_DISABLE_COLORS` and `FORCE_COLOR` environment variables.

```js
import { styleText } from 'node:util';
import { stderr } from 'node:process';

const successMessage = styleText('green', 'Success!');
console.log(successMessage);

const errorMessage = styleText(
  'red',
  'Error! Error!',
  // Validate if process.stderr has TTY
  { stream: stderr },
);
console.error(errorMessage);
```

`util.inspect.colors` also provides text formats such as `italic`, and
`underline` and you can combine both:

```js
console.log(
  util.styleText(['underline', 'italic'], 'My italic underlined message'),
);
```

When passing an array of formats, the order of the format applied
is left to right so the following style might overwrite the previous one.

```js
console.log(
  util.styleText(['red', 'green'], 'text'), // green
);
```

The special format value `none` applies no additional styling to the text.

The full list of formats can be found in [modifiers](https://nodejs.org/docs/latest-v24.x/api/util.html#modifiers).
@param format A text format or an Array of text formats defined in `util.inspect.colors`.
@param text The text to to be formatted.
@since v20.12.0

## parseArgs

Source: `my-backend/node_modules/@types/node/util.d.ts`

Signature: `parseArgs(<T extends ParseArgsConfig>(config?: T)`

JSDoc:

An implementation of the [WHATWG Encoding Standard](https://encoding.spec.whatwg.org/) `TextDecoder` API.

```js
const decoder = new TextDecoder();
const u8arr = new Uint8Array([72, 101, 108, 108, 111]);
console.log(decoder.decode(u8arr)); // Hello
```
@since v8.3.0
/
    export class TextDecoder {
        /**
The encoding supported by the `TextDecoder` instance.
/
        readonly encoding: string;
        /**
The value will be `true` if decoding errors result in a `TypeError` being
thrown.
/
        readonly fatal: boolean;
        /**
The value will be `true` if the decoding result will include the byte order
mark.
/
        readonly ignoreBOM: boolean;
        constructor(
            encoding?: string,
            options?: {
                fatal?: boolean | undefined;
                ignoreBOM?: boolean | undefined;
            },
        );
        /**
Decodes the `input` and returns a string. If `options.stream` is `true`, any
incomplete byte sequences occurring at the end of the `input` are buffered
internally and emitted after the next call to `textDecoder.decode()`.

If `textDecoder.fatal` is `true`, decoding errors that occur will result in a `TypeError` being thrown.
@param input An `ArrayBuffer`, `DataView`, or `TypedArray` instance containing the encoded data.
/
        decode(
            input?: NodeJS.ArrayBufferView | ArrayBuffer | null,
            options?: {
                stream?: boolean | undefined;
            },
        ): string;
    }
    export interface EncodeIntoResult {
        /**
The read Unicode code units of input.
/
        read: number;
        /**
The written UTF-8 bytes of output.
/
        written: number;
    }
    export { types };

    //// TextEncoder/Decoder
    /**
An implementation of the [WHATWG Encoding Standard](https://encoding.spec.whatwg.org/) `TextEncoder` API. All
instances of `TextEncoder` only support UTF-8 encoding.

```js
const encoder = new TextEncoder();
const uint8array = encoder.encode('this is some data');
```

The `TextEncoder` class is also available on the global object.
@since v8.3.0
/
    export class TextEncoder {
        /**
The encoding supported by the `TextEncoder` instance. Always set to `'utf-8'`.
/
        readonly encoding: string;
        /**
UTF-8 encodes the `input` string and returns a `Uint8Array` containing the
encoded bytes.
@param [input='an empty string'] The text to encode.
/
        encode(input?: string): Uint8Array;
        /**
UTF-8 encodes the `src` string to the `dest` Uint8Array and returns an object
containing the read Unicode code units and written UTF-8 bytes.

```js
const encoder = new TextEncoder();
const src = 'this is some data';
const dest = new Uint8Array(10);
const { read, written } = encoder.encodeInto(src, dest);
```
@param src The text to encode.
@param dest The array to hold the encode result.
/
        encodeInto(src: string, dest: Uint8Array): EncodeIntoResult;
    }
    import { TextDecoder as _TextDecoder, TextEncoder as _TextEncoder } from "util";
    global {
        /**
`TextDecoder` class is a global reference for `import { TextDecoder } from 'node:util'`
https://nodejs.org/api/globals.html#textdecoder
@since v11.0.0
/
        var TextDecoder: typeof globalThis extends {
            onmessage: any;
            TextDecoder: infer TextDecoder;
        } ? TextDecoder
            : typeof _TextDecoder;
        /**
`TextEncoder` class is a global reference for `import { TextEncoder } from 'node:util'`
https://nodejs.org/api/globals.html#textencoder
@since v11.0.0
/
        var TextEncoder: typeof globalThis extends {
            onmessage: any;
            TextEncoder: infer TextEncoder;
        } ? TextEncoder
            : typeof _TextEncoder;
    }

    //// parseArgs
    /**
Provides a higher level API for command-line argument parsing than interacting
with `process.argv` directly. Takes a specification for the expected arguments
and returns a structured object with the parsed options and positionals.

```js
import { parseArgs } from 'node:util';
const args = ['-f', '--bar', 'b'];
const options = {
  foo: {
    type: 'boolean',
    short: 'f',
  },
  bar: {
    type: 'string',
  },
};
const {
  values,
  positionals,
} = parseArgs({ args, options });
console.log(values, positionals);
// Prints: [Object: null prototype] { foo: true, bar: 'b' } []
```
@since v18.3.0, v16.17.0
@param config Used to provide arguments for parsing and to configure the parser. `config` supports the following properties:
@return The parsed command line arguments:

## find

Source: `my-backend/node_modules/braces/lib/utils.js`

Signature: `find(= (node, type)`

JSDoc:

Find a node of the given type

## exceedsLimit

Source: `my-backend/node_modules/braces/lib/utils.js`

Signature: `exceedsLimit(= (min, max, step = 1, limit)`

JSDoc:

Find a node of the given type

## escapeNode

Source: `my-backend/node_modules/braces/lib/utils.js`

Signature: `escapeNode(= (block, n = 0, type)`

JSDoc:

Escape the given node with '\\' before node.value

## encloseBrace

Source: `my-backend/node_modules/braces/lib/utils.js`

Signature: `encloseBrace(= node => {
  if (node.type !== 'brace')`

JSDoc:

Returns true if the given brace node should be enclosed in literal braces

## isInvalidBrace

Source: `my-backend/node_modules/braces/lib/utils.js`

Signature: `isInvalidBrace(= block => {
  if (block.type !== 'brace')`

JSDoc:

Returns true if a brace node is invalid.

## isOpenOrClose

Source: `my-backend/node_modules/braces/lib/utils.js`

Signature: `isOpenOrClose(= node => {
  if (node.type === 'open' || node.type === 'close')`

JSDoc:

Returns true if a node is an open or close node

## reduce

Source: `my-backend/node_modules/braces/lib/utils.js`

Signature: `reduce(= nodes => nodes.reduce((acc, node)`

JSDoc:

Reduce an array of text nodes.

## flatten

Source: `my-backend/node_modules/braces/lib/utils.js`

Signature: `flatten(= (...args)`

JSDoc:

Flatten an array

## watch

Source: `my-backend/node_modules/c12/node_modules/chokidar/esm/index.js`

Signature: `watch(paths, options = {})`

JSDoc:

Directory entry.
/
class DirEntry {
    constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = new Set();
    }
    add(item) {
        const { items } = this;
        if (!items)
            return;
        if (item !== ONE_DOT && item !== TWO_DOTS)
            items.add(item);
    }
    async remove(item) {
        const { items } = this;
        if (!items)
            return;
        items.delete(item);
        if (items.size > 0)
            return;
        const dir = this.path;
        try {
            await readdir(dir);
        }
        catch (err) {
            if (this._removeWatcher) {
                this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
            }
        }
    }
    has(item) {
        const { items } = this;
        if (!items)
            return;
        return items.has(item);
    }
    getChildren() {
        const { items } = this;
        if (!items)
            return [];
        return [...items.values()];
    }
    dispose() {
        this.items.clear();
        this.path = '';
        this._removeWatcher = EMPTY_FN;
        this.items = EMPTY_SET;
        Object.freeze(this);
    }
}
const STAT_METHOD_F = 'stat';
const STAT_METHOD_L = 'lstat';
export class WatchHelper {
    constructor(path, follow, fsw) {
        this.fsw = fsw;
        const watchPath = path;
        this.path = path = path.replace(REPLACER_RE, '');
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.dirParts = [];
        this.dirParts.forEach((parts) => {
            if (parts.length > 1)
                parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
    }
    entryPath(entry) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, entry.fullPath));
    }
    filterPath(entry) {
        const { stats } = entry;
        if (stats && stats.isSymbolicLink())
            return this.filterDir(entry);
        const resolvedPath = this.entryPath(entry);
        // TODO: what if stats is undefined? remove !
        return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
    }
    filterDir(entry) {
        return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
    }
}
/**
Watches files & directories for changes. Emitted events:
`add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`

    new FSWatcher()
      .add(directories)
      .on('add', path => log('File', path, 'was added'))
/
export class FSWatcher extends EventEmitter {
    // Not indenting methods for history sake; for now.
    constructor(_opts = {}) {
        super();
        this.closed = false;
        this._closers = new Map();
        this._ignoredPaths = new Set();
        this._throttled = new Map();
        this._streams = new Set();
        this._symlinkPaths = new Map();
        this._watched = new Map();
        this._pendingWrites = new Map();
        this._pendingUnlinks = new Map();
        this._readyCount = 0;
        this._readyEmitted = false;
        const awf = _opts.awaitWriteFinish;
        const DEF_AWF = { stabilityThreshold: 2000, pollInterval: 100 };
        const opts = {
            // Defaults
            persistent: true,
            ignoreInitial: false,
            ignorePermissionErrors: false,
            interval: 100,
            binaryInterval: 300,
            followSymlinks: true,
            usePolling: false,
            // useAsync: false,
            atomic: true, // NOTE: overwritten later (depends on usePolling)
            ..._opts,
            // Change format
            ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),
            awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === 'object' ? { ...DEF_AWF, ...awf } : false,
        };
        // Always default to polling on IBM i because fs.watch() is not available on IBM i.
        if (isIBMi)
            opts.usePolling = true;
        // Editor atomic write normalization enabled by default with fs.watch
        if (opts.atomic === undefined)
            opts.atomic = !opts.usePolling;
        // opts.atomic = typeof _opts.atomic === 'number' ? _opts.atomic : 100;
        // Global override. Useful for developers, who need to force polling for all
        // instances of chokidar, regardless of usage / dependency depth
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== undefined) {
            const envLower = envPoll.toLowerCase();
            if (envLower === 'false' || envLower === '0')
                opts.usePolling = false;
            else if (envLower === 'true' || envLower === '1')
                opts.usePolling = true;
            else
                opts.usePolling = !!envLower;
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval)
            opts.interval = Number.parseInt(envInterval, 10);
        // This is done to emit ready only once, but each 'add' will increase that?
        let readyCalls = 0;
        this._emitReady = () => {
            readyCalls++;
            if (readyCalls >= this._readyCount) {
                this._emitReady = EMPTY_FN;
                this._readyEmitted = true;
                // use process.nextTick to allow time for listener to be bound
                process.nextTick(() => this.emit(EV.READY));
            }
        };
        this._emitRaw = (...args) => this.emit(EV.RAW, ...args);
        this._boundRemove = this._remove.bind(this);
        this.options = opts;
        this._nodeFsHandler = new NodeFsHandler(this);
        // Youre frozen when your hearts not open.
        Object.freeze(opts);
    }
    _addIgnoredPath(matcher) {
        if (isMatcherObject(matcher)) {
            // return early if we already have a deeply equal matcher object
            for (const ignored of this._ignoredPaths) {
                if (isMatcherObject(ignored) &&
                    ignored.path === matcher.path &&
                    ignored.recursive === matcher.recursive) {
                    return;
                }
            }
        }
        this._ignoredPaths.add(matcher);
    }
    _removeIgnoredPath(matcher) {
        this._ignoredPaths.delete(matcher);
        // now find any matcher objects with the matcher as path
        if (typeof matcher === 'string') {
            for (const ignored of this._ignoredPaths) {
                // TODO (43081j): make this more efficient.
                // probably just make a `this._ignoredDirectories` or some
                // such thing.
                if (isMatcherObject(ignored) && ignored.path === matcher) {
                    this._ignoredPaths.delete(ignored);
                }
            }
        }
    }
    // Public methods
    /**
Adds paths to be watched on an existing FSWatcher instance.
@param paths_ file or file list. Other arguments are unused
/
    add(paths_, _origAdd, _internal) {
        const { cwd } = this.options;
        this.closed = false;
        this._closePromise = undefined;
        let paths = unifyPaths(paths_);
        if (cwd) {
            paths = paths.map((path) => {
                const absPath = getAbsolutePath(path, cwd);
                // Check `path` instead of `absPath` because the cwd portion can't be a glob
                return absPath;
            });
        }
        paths.forEach((path) => {
            this._removeIgnoredPath(path);
        });
        this._userIgnored = undefined;
        if (!this._readyCount)
            this._readyCount = 0;
        this._readyCount += paths.length;
        Promise.all(paths.map(async (path) => {
            const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, undefined, 0, _origAdd);
            if (res)
                this._emitReady();
            return res;
        })).then((results) => {
            if (this.closed)
                return;
            results.forEach((item) => {
                if (item)
                    this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
        });
        return this;
    }
    /**
Close watchers or start ignoring events from specified paths.
/
    unwatch(paths_) {
        if (this.closed)
            return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path) => {
            // convert to absolute path unless relative path already matches
            if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {
                if (cwd)
                    path = sysPath.join(cwd, path);
                path = sysPath.resolve(path);
            }
            this._closePath(path);
            this._addIgnoredPath(path);
            if (this._watched.has(path)) {
                this._addIgnoredPath({
                    path,
                    recursive: true,
                });
            }
            // reset the cached userIgnored anymatch fn
            // to make ignoredPaths changes effective
            this._userIgnored = undefined;
        });
        return this;
    }
    /**
Close watchers and remove all listeners from watched paths.
/
    close() {
        if (this._closePromise) {
            return this._closePromise;
        }
        this.closed = true;
        // Memory management.
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
            const promise = closer();
            if (promise instanceof Promise)
                closers.push(promise);
        }));
        this._streams.forEach((stream) => stream.destroy());
        this._userIgnored = undefined;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        this._closers.clear();
        this._watched.clear();
        this._streams.clear();
        this._symlinkPaths.clear();
        this._throttled.clear();
        this._closePromise = closers.length
            ? Promise.all(closers).then(() => undefined)
            : Promise.resolve();
        return this._closePromise;
    }
    /**
Expose list of watched paths
@returns for chaining
/
    getWatched() {
        const watchList = {};
        this._watched.forEach((entry, dir) => {
            const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
            const index = key || ONE_DOT;
            watchList[index] = entry.getChildren().sort();
        });
        return watchList;
    }
    emitWithAll(event, args) {
        this.emit(event, ...args);
        if (event !== EV.ERROR)
            this.emit(EV.ALL, event, ...args);
    }
    // Common helpers
    // --------------
    /**
Normalize and emit events.
Calling _emit DOES NOT MEAN emit() would be called!
@param event Type of event
@param path File or directory path
@param stats arguments to be passed with event
@returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
/
    async _emit(event, path, stats) {
        if (this.closed)
            return;
        const opts = this.options;
        if (isWindows)
            path = sysPath.normalize(path);
        if (opts.cwd)
            path = sysPath.relative(opts.cwd, path);
        const args = [path];
        if (stats != null)
            args.push(stats);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path))) {
            pw.lastChange = new Date();
            return this;
        }
        if (opts.atomic) {
            if (event === EV.UNLINK) {
                this._pendingUnlinks.set(path, [event, ...args]);
                setTimeout(() => {
                    this._pendingUnlinks.forEach((entry, path) => {
                        this.emit(...entry);
                        this.emit(EV.ALL, ...entry);
                        this._pendingUnlinks.delete(path);
                    });
                }, typeof opts.atomic === 'number' ? opts.atomic : 100);
                return this;
            }
            if (event === EV.ADD && this._pendingUnlinks.has(path)) {
                event = EV.CHANGE;
                this._pendingUnlinks.delete(path);
            }
        }
        if (awf && (event === EV.ADD || event === EV.CHANGE) && this._readyEmitted) {
            const awfEmit = (err, stats) => {
                if (err) {
                    event = EV.ERROR;
                    args[0] = err;
                    this.emitWithAll(event, args);
                }
                else if (stats) {
                    // if stats doesn't exist the file must have been deleted
                    if (args.length > 1) {
                        args[1] = stats;
                    }
                    else {
                        args.push(stats);
                    }
                    this.emitWithAll(event, args);
                }
            };
            this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
            return this;
        }
        if (event === EV.CHANGE) {
            const isThrottled = !this._throttle(EV.CHANGE, path, 50);
            if (isThrottled)
                return this;
        }
        if (opts.alwaysStat &&
            stats === undefined &&
            (event === EV.ADD || event === EV.ADD_DIR || event === EV.CHANGE)) {
            const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
            let stats;
            try {
                stats = await stat(fullPath);
            }
            catch (err) {
                // do nothing
            }
            // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
            if (!stats || this.closed)
                return;
            args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
    }
    /**
Common handler for errors
@returns The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
/
    _handleError(error) {
        const code = error && error.code;
        if (error &&
            code !== 'ENOENT' &&
            code !== 'ENOTDIR' &&
            (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))) {
            this.emit(EV.ERROR, error);
        }
        return error || this.closed;
    }
    /**
Helper utility for throttling
@param actionType type being throttled
@param path being acted upon
@param timeout duration of time to suppress duplicate actions
@returns tracking object or false if action should be suppressed
/
    _throttle(actionType, path, timeout) {
        if (!this._throttled.has(actionType)) {
            this._throttled.set(actionType, new Map());
        }
        const action = this._throttled.get(actionType);
        if (!action)
            throw new Error('invalid throttle');
        const actionPath = action.get(path);
        if (actionPath) {
            actionPath.count++;
            return false;
        }
        // eslint-disable-next-line prefer-const
        let timeoutObject;
        const clear = () => {
            const item = action.get(path);
            const count = item ? item.count : 0;
            action.delete(path);
            clearTimeout(timeoutObject);
            if (item)
                clearTimeout(item.timeoutObject);
            return count;
        };
        timeoutObject = setTimeout(clear, timeout);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path, thr);
        return thr;
    }
    _incrReadyCount() {
        return this._readyCount++;
    }
    /**
Awaits write operation to finish.
Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
@param path being acted upon
@param threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
@param event
@param awfEmit Callback to be called when ready for event to be emitted.
/
    _awaitWriteFinish(path, threshold, event, awfEmit) {
        const awf = this.options.awaitWriteFinish;
        if (typeof awf !== 'object')
            return;
        const pollInterval = awf.pollInterval;
        let timeoutHandler;
        let fullPath = path;
        if (this.options.cwd && !sysPath.isAbsolute(path)) {
            fullPath = sysPath.join(this.options.cwd, path);
        }
        const now = new Date();
        const writes = this._pendingWrites;
        function awaitWriteFinishFn(prevStat) {
            statcb(fullPath, (err, curStat) => {
                if (err || !writes.has(path)) {
                    if (err && err.code !== 'ENOENT')
                        awfEmit(err);
                    return;
                }
                const now = Number(new Date());
                if (prevStat && curStat.size !== prevStat.size) {
                    writes.get(path).lastChange = now;
                }
                const pw = writes.get(path);
                const df = now - pw.lastChange;
                if (df >= threshold) {
                    writes.delete(path);
                    awfEmit(undefined, curStat);
                }
                else {
                    timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);
                }
            });
        }
        if (!writes.has(path)) {
            writes.set(path, {
                lastChange: now,
                cancelWait: () => {
                    writes.delete(path);
                    clearTimeout(timeoutHandler);
                    return event;
                },
            });
            timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);
        }
    }
    /**
Determines whether user has asked to ignore this path.
/
    _isIgnored(path, stats) {
        if (this.options.atomic && DOT_RE.test(path))
            return true;
        if (!this._userIgnored) {
            const { cwd } = this.options;
            const ign = this.options.ignored;
            const ignored = (ign || []).map(normalizeIgnored(cwd));
            const ignoredPaths = [...this._ignoredPaths];
            const list = [...ignoredPaths.map(normalizeIgnored(cwd)), ...ignored];
            this._userIgnored = anymatch(list, undefined);
        }
        return this._userIgnored(path, stats);
    }
    _isntIgnored(path, stat) {
        return !this._isIgnored(path, stat);
    }
    /**
Provides a set of common helpers and properties relating to symlink handling.
@param path file or directory pattern being watched
/
    _getWatchHelpers(path) {
        return new WatchHelper(path, this.options.followSymlinks, this);
    }
    // Directory helpers
    // -----------------
    /**
Provides directory tracking objects
@param directory path of the directory
/
    _getWatchedDir(directory) {
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir))
            this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
    }
    // File helpers
    // ------------
    /**
Check for read permissions: https://stackoverflow.com/a/11781404/1358405
/
    _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
            return true;
        return Boolean(Number(stats.mode) & 0o400);
    }
    /**
Handles emitting unlink events for
files and directories, and via recursion, for
files and directories within directories that are unlinked
@param directory within which the following item is located
@param item      base path of item/directory
/
    _remove(directory, item, isDirectory) {
        // if what is being deleted is a directory, get that directory's paths
        // for recursive deleting and cleaning of watched object
        // if it is not a directory, nestedDirectoryChildren will be empty array
        const path = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path);
        isDirectory =
            isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);
        // prevent duplicate handling in case of arriving here nearly simultaneously
        // via multiple paths (such as _handleFile and _handleDir)
        if (!this._throttle('remove', path, 100))
            return;
        // if the only watched file is removed, watch for its return
        if (!isDirectory && this._watched.size === 1) {
            this.add(directory, item, true);
        }
        // This will create a new entry in the watched object in either case
        // so we got to do the directory check beforehand
        const wp = this._getWatchedDir(path);
        const nestedDirectoryChildren = wp.getChildren();
        // Recursively remove children directories / files.
        nestedDirectoryChildren.forEach((nested) => this._remove(path, nested));
        // Check if item was on the watched list and remove it
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        // Fixes issue #1042 -> Relative paths were detected and added as symlinks
        // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
        // but never removed from the map in case the path was deleted.
        // This leads to an incorrect state if the path was recreated:
        // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
        if (this._symlinkPaths.has(fullPath)) {
            this._symlinkPaths.delete(fullPath);
        }
        // If we wait for this file to be fully written, cancel the wait.
        let relPath = path;
        if (this.options.cwd)
            relPath = sysPath.relative(this.options.cwd, path);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
            const event = this._pendingWrites.get(relPath).cancelWait();
            if (event === EV.ADD)
                return;
        }
        // The Entry will either be a directory that just got removed
        // or a bogus entry to a file, in either case we have to remove it
        this._watched.delete(path);
        this._watched.delete(fullPath);
        const eventName = isDirectory ? EV.UNLINK_DIR : EV.UNLINK;
        if (wasTracked && !this._isIgnored(path))
            this._emit(eventName, path);
        // Avoid conflicts if we later create another file with the same name
        this._closePath(path);
    }
    /**
Closes all watchers for a path
/
    _closePath(path) {
        this._closeFile(path);
        const dir = sysPath.dirname(path);
        this._getWatchedDir(dir).remove(sysPath.basename(path));
    }
    /**
Closes only file-specific watchers
/
    _closeFile(path) {
        const closers = this._closers.get(path);
        if (!closers)
            return;
        closers.forEach((closer) => closer());
        this._closers.delete(path);
    }
    _addPathCloser(path, closer) {
        if (!closer)
            return;
        let list = this._closers.get(path);
        if (!list) {
            list = [];
            this._closers.set(path, list);
        }
        list.push(closer);
    }
    _readdirp(root, opts) {
        if (this.closed)
            return;
        const options = { type: EV.ALL, alwaysStat: true, lstat: true, ...opts, depth: 0 };
        let stream = readdirp(root, options);
        this._streams.add(stream);
        stream.once(STR_CLOSE, () => {
            stream = undefined;
        });
        stream.once(STR_END, () => {
            if (stream) {
                this._streams.delete(stream);
                stream = undefined;
            }
        });
        return stream;
    }
}
/**
Instantiates watcher with paths to be tracked.
@param paths file / directory paths
@param options opts, such as `atomic`, `awaitWriteFinish`, `ignored`, and others
@returns an instance of FSWatcher for chaining.
@example
const watcher = watch('.').on('all', (event, path) => { console.log(event, path); });
watch('.', { atomic: true, awaitWriteFinish: true, ignored: (f, stats) => stats?.isFile() && !f.endsWith('.js') })

## readdirp

Source: `my-backend/node_modules/c12/node_modules/readdirp/esm/index.js`

Signature: `readdirp(root, options = {})`

JSDoc:

Readable readdir stream, emitting new files as they're being listed. */
export class ReaddirpStream extends Readable {
    constructor(options = {}) {
        super({
            objectMode: true,
            autoDestroy: true,
            highWaterMark: options.highWaterMark,
        });
        const opts = { ...defaultOptions, ...options };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat : stat;
        // Use bigint stats if it's windows and stat() supports options (node 10+).
        if (wantBigintFsStats) {
            this._stat = (path) => statMethod(path, { bigint: true });
        }
        else {
            this._stat = statMethod;
        }
        this._maxDepth = opts.depth ?? defaultOptions.depth;
        this._wantsDir = type ? DIR_TYPES.has(type) : false;
        this._wantsFile = type ? FILE_TYPES.has(type) : false;
        this._wantsEverything = type === EntryTypes.EVERYTHING_TYPE;
        this._root = presolve(root);
        this._isDirent = !opts.alwaysStat;
        this._statsProp = this._isDirent ? 'dirent' : 'stats';
        this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };
        // Launch stream with one parent, the root dir.
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = undefined;
    }
    async _read(batch) {
        if (this.reading)
            return;
        this.reading = true;
        try {
            while (!this.destroyed && batch > 0) {
                const par = this.parent;
                const fil = par && par.files;
                if (fil && fil.length > 0) {
                    const { path, depth } = par;
                    const slice = fil.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));
                    const awaited = await Promise.all(slice);
                    for (const entry of awaited) {
                        if (!entry)
                            continue;
                        if (this.destroyed)
                            return;
                        const entryType = await this._getEntryType(entry);
                        if (entryType === 'directory' && this._directoryFilter(entry)) {
                            if (depth <= this._maxDepth) {
                                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                            }
                            if (this._wantsDir) {
                                this.push(entry);
                                batch--;
                            }
                        }
                        else if ((entryType === 'file' || this._includeAsFile(entry)) &&
                            this._fileFilter(entry)) {
                            if (this._wantsFile) {
                                this.push(entry);
                                batch--;
                            }
                        }
                    }
                }
                else {
                    const parent = this.parents.pop();
                    if (!parent) {
                        this.push(null);
                        break;
                    }
                    this.parent = await parent;
                    if (this.destroyed)
                        return;
                }
            }
        }
        catch (error) {
            this.destroy(error);
        }
        finally {
            this.reading = false;
        }
    }
    async _exploreDir(path, depth) {
        let files;
        try {
            files = await readdir(path, this._rdOptions);
        }
        catch (error) {
            this._onError(error);
        }
        return { files, depth, path };
    }
    async _formatEntry(dirent, path) {
        let entry;
        const basename = this._isDirent ? dirent.name : dirent;
        try {
            const fullPath = presolve(pjoin(path, basename));
            entry = { path: prelative(this._root, fullPath), fullPath, basename };
            entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        }
        catch (err) {
            this._onError(err);
            return;
        }
        return entry;
    }
    _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
            this.emit('warn', err);
        }
        else {
            this.destroy(err);
        }
    }
    async _getEntryType(entry) {
        // entry may be undefined, because a warning or an error were emitted
        // and the statsProp is undefined
        if (!entry && this._statsProp in entry) {
            return '';
        }
        const stats = entry[this._statsProp];
        if (stats.isFile())
            return 'file';
        if (stats.isDirectory())
            return 'directory';
        if (stats && stats.isSymbolicLink()) {
            const full = entry.fullPath;
            try {
                const entryRealPath = await realpath(full);
                const entryRealPathStats = await lstat(entryRealPath);
                if (entryRealPathStats.isFile()) {
                    return 'file';
                }
                if (entryRealPathStats.isDirectory()) {
                    const len = entryRealPath.length;
                    if (full.startsWith(entryRealPath) && full.substr(len, 1) === psep) {
                        const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
                        // @ts-ignore
                        recursiveError.code = RECURSIVE_ERROR_CODE;
                        return this._onError(recursiveError);
                    }
                    return 'directory';
                }
            }
            catch (error) {
                this._onError(error);
                return '';
            }
        }
    }
    _includeAsFile(entry) {
        const stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
    }
}
/**
Streaming version: Reads all files and directories in given root recursively.
Consumes ~constant small amount of RAM.
@param root Root directory
@param options Options to specify root (start directory), filters and recursion depth

## readdirpPromise

Source: `my-backend/node_modules/c12/node_modules/readdirp/esm/index.js`

Signature: `readdirpPromise(root, options = {})`

JSDoc:

Promise version: Reads all files and directories in given root recursively.
Compared to streaming version, will consume a lot of RAM e.g. when 1 million files are listed.
@returns array of paths and their entry infos

## watch

Source: `my-backend/node_modules/chokidar/types/index.d.ts`

Signature: `watch(
  paths: string | ReadonlyArray<string>,
  options?: WatchOptions
)`

JSDoc:

Constructs a new FSWatcher instance with optional WatchOptions parameter.
/
  constructor(options?: WatchOptions);

  /**
Add files, directories, or glob patterns for tracking. Takes an array of strings or just one
string.
/
  add(paths: string | ReadonlyArray<string>): this;

  /**
Stop watching files, directories, or glob patterns. Takes an array of strings or just one
string.
/
  unwatch(paths: string | ReadonlyArray<string>): this;

  /**
Returns an object representing all the paths on the file system being watched by this
`FSWatcher` instance. The object's keys are all the directories (using absolute paths unless
the `cwd` option was used), and the values are arrays of the names of the items contained in
each directory.
/
  getWatched(): {
    [directory: string]: string[];
  };

  /**
Removes all listeners from watched files.
/
  close(): Promise<void>;

  on(event: 'add'|'addDir'|'change', listener: (path: string, stats?: fs.Stats) => void): this;

  on(event: 'all', listener: (eventName: 'add'|'addDir'|'change'|'unlink'|'unlinkDir', path: string, stats?: fs.Stats) => void): this;

  /**
Error occurred
/
  on(event: 'error', listener: (error: Error) => void): this;

  /**
Exposes the native Node `fs.FSWatcher events`
/
  on(event: 'raw', listener: (eventName: string, path: string, details: any) => void): this;

  /**
Fires when the initial scan is complete
/
  on(event: 'ready', listener: () => void): this;

  on(event: 'unlink'|'unlinkDir', listener: (path: string) => void): this;

  on(event: string, listener: (...args: any[]) => void): this;

  ref(): this;
  
  unref(): this;
}

export interface WatchOptions {
  /**
Indicates whether the process should continue to run as long as files are being watched. If
set to `false` when using `fsevents` to watch, no more events will be emitted after `ready`,
even if the process continues to run.
/
  persistent?: boolean;

  /**
([anymatch](https://github.com/micromatch/anymatch)-compatible definition) Defines files/paths to
be ignored. The whole relative or absolute path is tested, not just filename. If a function
with two arguments is provided, it gets called twice per path - once with a single argument
(the path), second time with two arguments (the path and the
[`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats) object of that path).
/
  ignored?: Matcher;

  /**
If set to `false` then `add`/`addDir` events are also emitted for matching paths while
instantiating the watching as chokidar discovers these file paths (before the `ready` event).
/
  ignoreInitial?: boolean;

  /**
When `false`, only the symlinks themselves will be watched for changes instead of following
the link references and bubbling events through the link's path.
/
  followSymlinks?: boolean;

  /**
The base directory from which watch `paths` are to be derived. Paths emitted with events will
be relative to this.
/
  cwd?: string;

  /**
 If set to true then the strings passed to .watch() and .add() are treated as literal path
 names, even if they look like globs. Default: false.
/
  disableGlobbing?: boolean;

  /**
Whether to use fs.watchFile (backed by polling), or fs.watch. If polling leads to high CPU
utilization, consider setting this to `false`. It is typically necessary to **set this to
`true` to successfully watch files over a network**, and it may be necessary to successfully
watch files in other non-standard situations. Setting to `true` explicitly on OS X overrides
the `useFsEvents` default.
/
  usePolling?: boolean;

  /**
Whether to use the `fsevents` watching interface if available. When set to `true` explicitly
and `fsevents` is available this supercedes the `usePolling` setting. When set to `false` on
OS X, `usePolling: true` becomes the default.
/
  useFsEvents?: boolean;

  /**
If relying upon the [`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats) object that
may get passed with `add`, `addDir`, and `change` events, set this to `true` to ensure it is
provided even in cases where it wasn't already available from the underlying watch events.
/
  alwaysStat?: boolean;

  /**
If set, limits how many levels of subdirectories will be traversed.
/
  depth?: number;

  /**
Interval of file system polling.
/
  interval?: number;

  /**
Interval of file system polling for binary files. ([see list of binary extensions](https://gi
thub.com/sindresorhus/binary-extensions/blob/master/binary-extensions.json))
/
  binaryInterval?: number;

  /**
 Indicates whether to watch files that don't have read permissions if possible. If watching
 fails due to `EPERM` or `EACCES` with this set to `true`, the errors will be suppressed
 silently.
/
  ignorePermissionErrors?: boolean;

  /**
`true` if `useFsEvents` and `usePolling` are `false`). Automatically filters out artifacts
that occur when using editors that use "atomic writes" instead of writing directly to the
source file. If a file is re-added within 100 ms of being deleted, Chokidar emits a `change`
event rather than `unlink` then `add`. If the default of 100 ms does not work well for you,
you can override it by setting `atomic` to a custom value, in milliseconds.
/
  atomic?: boolean | number;

  /**
can be set to an object in order to adjust timing params:
/
  awaitWriteFinish?: AwaitWriteFinishOptions | boolean;
}

export interface AwaitWriteFinishOptions {
  /**
Amount of time in milliseconds for a file size to remain constant before emitting its event.
/
  stabilityThreshold?: number;

  /**
File size polling interval.
/
  pollInterval?: number;
}

/**
produces an instance of `FSWatcher`.

## format

Source: `my-backend/node_modules/content-type/index.js`

Signature: `format(= format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format (obj)`

JSDoc:

RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1

parameter     = token "=" ( token / quoted-string )
token         = 1*tchar
tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
              / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
              / DIGIT / ALPHA
              ; any VCHAR, except delimiters
quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
obs-text      = %x80-FF
quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
/
var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/ // eslint-disable-line no-control-regex
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
RegExp to match quoted-pair in RFC 7230 sec 3.2.6

quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
obs-text    = %x80-FF
/
var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g // eslint-disable-line no-control-regex

/**
RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
/
var QUOTE_REGEXP = /([\\"])/g

/**
RegExp to match type in RFC 7231 sec 3.1.1.1

media-type = type "/" subtype
type       = token
subtype    = token
/
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/

/**
Module exports.
@public

## parse

Source: `my-backend/node_modules/cookie/index.js`

Signature: `parse(= parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString

/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */

var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )`

JSDoc:

Module exports.
@public

## parse

Source: `my-backend/node_modules/cookie-parser/node_modules/cookie/index.js`

Signature: `parse(= parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString
var __hasOwnProperty = Object.prototype.hasOwnProperty

/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 */

var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )`

JSDoc:

Module exports.
@public

## sign

Source: `my-backend/node_modules/cookie-signature/index.js`

Signature: `sign(= function(val, secret)`

JSDoc:

Module dependencies.
/

var crypto = require('crypto');

/**
Sign the given `val` with `secret`.

@param {String} val
@param {String} secret
@return {String}
@api private

## unsign

Source: `my-backend/node_modules/cookie-signature/index.js`

Signature: `unsign(= function(val, secret)`

JSDoc:

Unsign and decode the given `val` with `secret`,
returning `false` if the signature is invalid.

@param {String} val
@param {String} secret
@return {String|Boolean}
@api private

## colors

Source: `my-backend/node_modules/debug/src/browser.js`

Signature: `colors(= [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version)`

JSDoc:

This is the web browser implementation of `debug()`.

Expose `debug()` as the module.
/

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
Colors.

## formatters

Source: `my-backend/node_modules/debug/src/browser.js`

Signature: `formatters(.j = function(v)`

JSDoc:

Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.

## enable

Source: `my-backend/node_modules/debug/src/browser.js`

Signature: `enable(load()`

JSDoc:

Colorize log arguments if enabled.

@api public
/

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
Invokes `console.log()` when available.
No-op when `console.log` is not a "function".

@api public
/

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
Save `namespaces`.

@param {String} namespaces
@api private
/

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
Load `namespaces`.

@return {String} returns the previously persisted debug modes
@api private
/

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
Enable namespaces listed in `localStorage.debug` initially.

## names

Source: `my-backend/node_modules/debug/src/debug.js`

Signature: `names(= [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace)`

JSDoc:

This is the common logic for both the Node.js and web browser
implementations of `debug()`.

Expose `debug()` as the module.
/

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
The currently active debug mode names, and names to skip.

## colors

Source: `my-backend/node_modules/debug/src/node.js`

Signature: `colors(= [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env)`

JSDoc:

Module dependencies.
/

var tty = require('tty');
var util = require('util');

/**
This is the Node.js implementation of `debug()`.

Expose `debug()` as the module.
/

exports = module.exports = require('./debug');
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
Colors.

## formatters

Source: `my-backend/node_modules/debug/src/node.js`

Signature: `formatters(.o = function(v)`

JSDoc:

The file descriptor to write the `debug()` calls to.
Set the `DEBUG_FD` env variable to override with another value. i.e.:

  $ DEBUG_FD=3 node script.js 3>debug.log
/

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()
}

var stream = 1 === fd ? process.stdout :
             2 === fd ? process.stderr :
             createWritableStdioStream(fd);

/**
Is stdout a TTY? Colored output is enabled when `true`.
/

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(fd);
}

/**
Map %o to `util.inspect()`, all on a single line.

## formatters

Source: `my-backend/node_modules/debug/src/node.js`

Signature: `formatters(.O = function(v)`

JSDoc:

Map %o to `util.inspect()`, allowing multiple lines if needed.

## enable

Source: `my-backend/node_modules/debug/src/node.js`

Signature: `enable(load()`

JSDoc:

Adds ANSI color escape codes if enabled.

@api public
/

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString()
      + ' ' + name + ' ' + args[0];
  }
}

/**
Invokes `util.format()` with the specified arguments and writes to `stream`.
/

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
Save `namespaces`.

@param {String} namespaces
@api private
/

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
Load `namespaces`.

@return {String} returns the previously persisted debug modes
@api private
/

function load() {
  return process.env.DEBUG;
}

/**
Copied from `node/src/node.js`.

XXX: It's lame that node doesn't expose this API out-of-the-box. It also
relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
/

function createWritableStdioStream (fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs = require('fs');
      stream = new fs.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require('net');
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
Init logic for `debug` instances.

Create a new `inspectOpts` object in case `useColors` is set
differently for a particular `debug` instance.
/

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
Enable namespaces listed in `process.env.DEBUG` initially.

## parse

Source: `my-backend/node_modules/dotenv/lib/main.d.ts`

Signature: `parse(<T extends DotenvParseOutput = DotenvParseOutput>(
  src: string | Buffer
)`

JSDoc:

Parses a string or buffer in the .env file format into an object.

See https://dotenvx.com/docs

@param src - contents to be parsed. example: `'DB_HOST=localhost'`
@returns an object with keys and values based on `src`. example: `{ DB_HOST : 'localhost' }`

## config

Source: `my-backend/node_modules/dotenv/lib/main.d.ts`

Signature: `config(options?: DotenvConfigOptions)`

JSDoc:

Default: `path.resolve(process.cwd(), '.env')`

Specify a custom path if your file containing environment variables is located elsewhere.
Can also be an array of strings, specifying multiple paths.

example: `require('dotenv').config({ path: '/custom/path/to/.env' })`
example: `require('dotenv').config({ path: ['/path/to/first.env', '/path/to/second.env'] })`
/
  path?: string | string[] | URL;

  /**
Default: `utf8`

Specify the encoding of your file containing environment variables.

example: `require('dotenv').config({ encoding: 'latin1' })`
/
  encoding?: string;

  /**
Default: `false`

Suppress all output (except errors).

example: `require('dotenv').config({ quiet: true })`
/
  quiet?: boolean;

  /**
Default: `false`

Turn on logging to help debug why certain keys or values are not being set as you expect.

example: `require('dotenv').config({ debug: process.env.DEBUG })`
/
  debug?: boolean;

  /**
Default: `false`

Override any environment variables that have already been set on your machine with values from your .env file.

example: `require('dotenv').config({ override: true })`
/
  override?: boolean;

  /**
Default: `process.env`

Specify an object to write your secrets to. Defaults to process.env environment variables.

example: `const processEnv = {}; require('dotenv').config({ processEnv: processEnv })`
/
  processEnv?: DotenvPopulateInput;

  /**
Default: `undefined`

Pass the DOTENV_KEY directly to config options. Defaults to looking for process.env.DOTENV_KEY environment variable. Note this only applies to decrypting .env.vault files. If passed as null or undefined, or not passed at all, dotenv falls back to its traditional job of parsing a .env file.

example: `require('dotenv').config({ DOTENV_KEY: 'dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=production' })`
/
  DOTENV_KEY?: string;
}

export interface DotenvConfigOutput {
  error?: Error;
  parsed?: DotenvParseOutput;
}

export interface DotenvPopulateOptions {
  /**
Default: `false`

Turn on logging to help debug why certain keys or values are not being set as you expect.

example: `require('dotenv').config({ debug: process.env.DEBUG })`
/
  debug?: boolean;

  /**
Default: `false`

Override any environment variables that have already been set on your machine with values from your .env file.

example: `require('dotenv').config({ override: true })`
/
  override?: boolean;
}

export interface DotenvPopulateInput {
  [name: string]: string;
}

/**
Loads `.env` file contents into process.env by default. If `DOTENV_KEY` is present, it smartly attempts to load encrypted `.env.vault` file contents into process.env.

See https://dotenvx.com/docs

@param options - additional options. example: `{ path: './custom/path', encoding: 'latin1', quiet: false, debug: true, override: false }`
@returns an object with a `parsed` key if successful or `error` key if an error occurred. example: { parsed: { KEY: 'value' } }


## configDotenv

Source: `my-backend/node_modules/dotenv/lib/main.d.ts`

Signature: `configDotenv(options?: DotenvConfigOptions)`

JSDoc:

Loads `.env` file contents into process.env.

See https://dotenvx.com/docs

@param options - additional options. example: `{ path: './custom/path', encoding: 'latin1', quiet: false, debug: true, override: false }`
@returns an object with a `parsed` key if successful or `error` key if an error occurred. example: { parsed: { KEY: 'value' } }


## populate

Source: `my-backend/node_modules/dotenv/lib/main.d.ts`

Signature: `populate(processEnv: DotenvPopulateInput, parsed: DotenvPopulateInput, options?: DotenvConfigOptions)`

JSDoc:

Loads `source` json contents into `target` like process.env.

See https://dotenvx.com/docs

@param processEnv - the target JSON object. in most cases use process.env but you can also pass your own JSON object
@param parsed - the source JSON object
@param options - additional options. example: `{ quiet: false, debug: true, override: false }`
@returns {void}


## decrypt

Source: `my-backend/node_modules/dotenv/lib/main.d.ts`

Signature: `decrypt(encrypted: string, keyStr: string)`

JSDoc:

Decrypt ciphertext

See https://dotenvx.com/docs

@param encrypted - the encrypted ciphertext string
@param keyStr - the decryption key string
@returns {string}


## derToJose

Source: `my-backend/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.d.ts`

Signature: `derToJose(signature: Buffer | string, alg: string)`

JSDoc:

Convert the ASN.1/DER encoded signature to a JOSE-style concatenated signature. Returns a base64 url encoded String.
   If signature is a String, it should be base64 encoded
   alg must be one of ES256, ES384 or ES512

## joseToDer

Source: `my-backend/node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.d.ts`

Signature: `joseToDer(signature: Buffer | string, alg: string)`

JSDoc:

Convert the JOSE-style concatenated signature to an ASN.1/DER encoded signature. Returns a Buffer
    If signature is a String, it should be base64 url encoded
    alg must be one of ES256, ES384 or ES512

## makeLazy

Source: `my-backend/node_modules/effect/dist/cjs/Arbitrary.js`

Signature: `makeLazy(= makeLazy;
const make = schema => makeLazy(schema)`

JSDoc:

@since 3.10.0
/

/**
Returns a LazyArbitrary for the `A` type of the provided schema.

@category arbitrary
@since 3.10.0
/
const makeLazy = schema => {
  const description = getDescription(schema.ast, []);
  return go(description, {
    maxDepth: 2
  });
};
/**
Returns a fast-check Arbitrary for the `A` type of the provided schema.

@category arbitrary
@since 3.10.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/Arbitrary.js`

Signature: `make(= make;
const makeStringConstraints = options => {
  const out = {
    _tag: "StringConstraints",
    constraints: {}
  };
  if (Predicate.isNumber(options.minLength)`

JSDoc:

@internal

## makeStringConstraints

Source: `my-backend/node_modules/effect/dist/cjs/Arbitrary.js`

Signature: `makeStringConstraints(= makeStringConstraints;
const makeNumberConstraints = options => {
  const out = {
    _tag: "NumberConstraints",
    constraints: {},
    isInteger: options.isInteger ?? false
  };
  if (Predicate.isNumber(options.min)`

JSDoc:

@internal

## makeNumberConstraints

Source: `my-backend/node_modules/effect/dist/cjs/Arbitrary.js`

Signature: `makeNumberConstraints(= makeNumberConstraints;
const makeBigIntConstraints = options => {
  const out = {
    _tag: "BigIntConstraints",
    constraints: {}
  };
  if (Predicate.isBigInt(options.min)`

JSDoc:

@internal

## makeBigIntConstraints

Source: `my-backend/node_modules/effect/dist/cjs/Arbitrary.js`

Signature: `makeBigIntConstraints(= makeBigIntConstraints;
const makeArrayConstraints = options => {
  const out = {
    _tag: "ArrayConstraints",
    constraints: {}
  };
  if (Predicate.isNumber(options.minLength)`

JSDoc:

@internal

## makeArrayConstraints

Source: `my-backend/node_modules/effect/dist/cjs/Arbitrary.js`

Signature: `makeArrayConstraints(= makeArrayConstraints;
const makeDateConstraints = options => {
  const out = {
    _tag: "DateConstraints",
    constraints: {}
  };
  if (Predicate.isDate(options.min)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `make(= make;
const allocate = n => new Array(n)`

JSDoc:

This module provides utility functions for working with arrays in TypeScript.

@since 2.0.0
/

/**
Builds a `NonEmptyArray` from an non-empty collection of elements.

**Example**

```ts
import { Array } from "effect"

const result = Array.make(1, 2, 3)
console.log(result) // [1, 2, 3]
```

@category constructors
@since 2.0.0
/
const make = (...elements) => elements;
/**
Creates a new `Array` of the specified length.

**Example**

```ts
import { Array } from "effect"

const result = Array.allocate<number>(3)
console.log(result) // [ <3 empty items> ]
```

@category constructors
@since 2.0.0

## allocate

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `allocate(= allocate;
const makeBy = exports.makeBy = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.

**Note**. `n` is normalized to an integer >= 1.

**Example**

```ts
import { makeBy } from "effect/Array"

const result = makeBy(5, n => n * 2)
console.log(result) // [0, 2, 4, 6, 8]
```

@category constructors
@since 2.0.0

## range

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `range(= range;
const replicate = exports.replicate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Return a `NonEmptyArray` containing a range of integers, including both endpoints.

**Example**

```ts
import { range } from "effect/Array"

const result = range(1, 3)
console.log(result) // [1, 2, 3]
```

@category constructors
@since 2.0.0
/
const range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : [start];
/**
Return a `NonEmptyArray` containing a value repeated the specified number of times.

**Note**. `n` is normalized to an integer >= 1.

**Example**

```ts
import { Array } from "effect"

const result = Array.replicate("a", 3)
console.log(result) // ["a", "a", "a"]
```

@category constructors
@since 2.0.0

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `fromIterable(= fromIterable;
const ensure = self => Array.isArray(self)`

JSDoc:

Creates a new `Array` from an iterable collection of values.
If the input is already an array, it returns the input as-is.
Otherwise, it converts the iterable collection to an array.

**Example**

```ts
import { Array } from "effect"

const result = Array.fromIterable(new Set([1, 2, 3]))
console.log(result) // [1, 2, 3]
```

@category constructors
@since 2.0.0
/
const fromIterable = collection => Array.isArray(collection) ? collection : Array.from(collection);
/**
Creates a new `Array` from a value that might not be an iterable.

**Example**

```ts
import { Array } from "effect"

console.log(Array.ensure("a")) // ["a"]
console.log(Array.ensure(["a"])) // ["a"]
console.log(Array.ensure(["a", "b", "c"])) // ["a", "b", "c"]
```

@category constructors
@since 3.3.0

## ensure

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `ensure(= ensure;
const fromRecord = exports.fromRecord = Record.toEntries;
/**
 * Converts an `Option` to an array.
 *
 * **Example**
 *
 * ```ts
 * import { Array, Option } from "effect"
 *
 * console.log(Array.fromOption(Option.some(1)`

JSDoc:

Takes a record and returns an array of tuples containing its keys and values.

**Example**

```ts
import { Array } from "effect"

const result = Array.fromRecord({ a: 1, b: 2, c: 3 })
console.log(result) // [["a", 1], ["b", 2], ["c", 3]]
```

@category conversions
@since 2.0.0

## isEmptyArray

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `isEmptyArray(= isEmptyArray;
const isEmptyReadonlyArray = exports.isEmptyReadonlyArray = isEmptyArray;
/**
 * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.
 *
 * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.
 *
 * **Example**
 *
 * ```ts
 * import { Array } from "effect"
 *
 * console.log(Array.isNonEmptyArray([])`

JSDoc:

Matches the elements of an array, applying functions to cases of empty and non-empty arrays.

**Example**

```ts
import { Array } from "effect"

const match = Array.match({
  onEmpty: () => "empty",
  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`
})
console.log(match([])) // "empty"
console.log(match([1, 2, 3])) // "head: 1, tail: 2"
```

@category pattern matching
@since 2.0.0
/
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
/**
Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.

**Example**

```ts
import { Array } from "effect"

const matchLeft = Array.matchLeft({
  onEmpty: () => "empty",
  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`
})
console.log(matchLeft([])) // "empty"
console.log(matchLeft([1, 2, 3])) // "head: 1, tail: 2"
```

@category pattern matching
@since 2.0.0
/
const matchLeft = exports.matchLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
/**
Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.

**Example**

```ts
import { Array } from "effect"

const matchRight = Array.matchRight({
  onEmpty: () => "empty",
  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`
})
console.log(matchRight([])) // "empty"
console.log(matchRight([1, 2, 3])) // "init: 2, last: 3"
```

@category pattern matching
@since 2.0.0
/
const matchRight = exports.matchRight = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
/**
Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.prepend([2, 3, 4], 1)
console.log(result) // [1, 2, 3, 4]
```

@category concatenating
@since 2.0.0
/
const prepend = exports.prepend = /*#__PURE__*/(0, _Function.dual)(2, (self, head) => [head, ...self]);
/**
Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).
If either array is non-empty, the result is also a non-empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.prependAll([2, 3], [0, 1])
console.log(result) // [0, 1, 2, 3]
```

@category concatenating
@since 2.0.0
/
const prependAll = exports.prependAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => fromIterable(that).concat(fromIterable(self)));
/**
Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.append([1, 2, 3], 4);
console.log(result) // [1, 2, 3, 4]
```

@category concatenating
@since 2.0.0
/
const append = exports.append = /*#__PURE__*/(0, _Function.dual)(2, (self, last) => [...self, last]);
/**
Concatenates two arrays (or iterables), combining their elements.
If either array is non-empty, the result is also a non-empty array.

@category concatenating
@since 2.0.0
/
const appendAll = exports.appendAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
/**
Accumulates values from an `Iterable` starting from the left, storing
each intermediate result in an array. Useful for tracking the progression of
a value through a series of transformations.

**Example**

```ts
import { Array } from "effect";

const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)
console.log(result) // [0, 1, 3, 6, 10]

// Explanation:
// This function starts with the initial value (0 in this case)
// and adds each element of the array to this accumulator one by one,
// keeping track of the cumulative sum after each addition.
// Each of these sums is captured in the resulting array.
```

@category folding
@since 2.0.0
/
const scan = exports.scan = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => {
  const out = [b];
  let i = 0;
  for (const a of self) {
    out[i + 1] = f(out[i], a);
    i++;
  }
  return out;
});
/**
Accumulates values from an `Iterable` starting from the right, storing
each intermediate result in an array. Useful for tracking the progression of
a value through a series of transformations.

**Example**

```ts
import { Array } from "effect";

const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)
console.log(result) // [10, 9, 7, 4, 0]
```

@category folding
@since 2.0.0
/
const scanRight = exports.scanRight = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => {
  const input = fromIterable(self);
  const out = new Array(input.length + 1);
  out[input.length] = b;
  for (let i = input.length - 1; i >= 0; i--) {
    out[i] = f(out[i + 1], input[i]);
  }
  return out;
});
/**
Determine if `unknown` is an Array.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isArray(null)) // false
console.log(Array.isArray([1, 2, 3])) // true
```

@category guards
@since 2.0.0
/
const isArray = exports.isArray = Array.isArray;
/**
Determine if an `Array` is empty narrowing down the type to `[]`.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isEmptyArray([])) // true
console.log(Array.isEmptyArray([1, 2, 3])) // false
```

@category guards
@since 2.0.0
/
const isEmptyArray = self => self.length === 0;
/**
Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isEmptyReadonlyArray([])) // true
console.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false
```

@category guards
@since 2.0.0

## unprepend

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `unprepend(= unprepend;
const unappend = self => [initNonEmpty(self)`

JSDoc:

Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.

A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.

**Example**

```ts
import { Array } from "effect"

console.log(Array.isNonEmptyReadonlyArray([])) // false
console.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true
```

@category guards
@since 2.0.0
/
const isNonEmptyReadonlyArray = exports.isNonEmptyReadonlyArray = internalArray.isNonEmptyArray;
/**
Return the number of elements in a `ReadonlyArray`.

@category getters
@since 2.0.0
/
const length = self => self.length;
exports.length = length;
const isOutOfBounds = (i, as) => i < 0 || i >= as.length;
const clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
/**
This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.

@category getters
@since 2.0.0
/
const get = exports.get = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? Option.none() : Option.some(self[i]);
});
/**
Gets an element unsafely, will throw on out of bounds.

@since 2.0.0
@category unsafe
/
const unsafeGet = exports.unsafeGet = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
/**
Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.

**Example**

```ts
import { Array } from "effect";

const result = Array.unprepend([1, 2, 3, 4])
console.log(result) // [1, [2, 3, 4]]
```

@category splitting
@since 2.0.0
/
const unprepend = self => [headNonEmpty(self), tailNonEmpty(self)];
/**
Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.

**Example**

```ts
import { Array } from "effect";

const result = Array.unappend([1, 2, 3, 4])
console.log(result) // [[1, 2, 3], 4]
```

@category splitting
@since 2.0.0

## unappend

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `unappend(= unappend;
const head = exports.head = /*#__PURE__*/get(0)`

JSDoc:

Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.

@category getters
@since 2.0.0

## last

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `last(= last;
const lastNonEmpty = self => self[self.length - 1];
/**
 * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.
 *
 * @category getters
 * @since 2.0.0
 */
exports.lastNonEmpty = lastNonEmpty;
const tail = self => {
  const input = fromIterable(self)`

JSDoc:

Get the first element of a non empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.headNonEmpty([1, 2, 3, 4])
console.log(result) // 1
```

@category getters
@since 2.0.0
/
const headNonEmpty = exports.headNonEmpty = /*#__PURE__*/unsafeGet(0);
/**
Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.

@category getters
@since 2.0.0
/
const last = self => isNonEmptyReadonlyArray(self) ? Option.some(lastNonEmpty(self)) : Option.none();
/**
Get the last element of a non empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.lastNonEmpty([1, 2, 3, 4])
console.log(result) // 4
```

@category getters
@since 2.0.0

## tail

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `tail(= tail;
const tailNonEmpty = self => self.slice(1)`

JSDoc:

Get all but the first element of a `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.tailNonEmpty([1, 2, 3, 4])
console.log(result) // [2, 3, 4]
```

@category getters
@since 2.0.0

## tailNonEmpty

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `tailNonEmpty(= tailNonEmpty;
const init = self => {
  const input = fromIterable(self)`

JSDoc:

Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.

@category getters
@since 2.0.0

## init

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `init(= init;
const initNonEmpty = self => self.slice(0, -1)`

JSDoc:

Get all but the last element of a non empty array, creating a new array.

**Example**

```ts
import { Array } from "effect"

const result = Array.initNonEmpty([1, 2, 3, 4])
console.log(result) // [1, 2, 3]
```

@category getters
@since 2.0.0

## initNonEmpty

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `initNonEmpty(= initNonEmpty;
const take = exports.take = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

**Example**

```ts
import { Array } from "effect"

const result = Array.take([1, 2, 3, 4, 5], 3)
console.log(result) // [1, 2, 3]
```

@category getters
@since 2.0.0

## reverse

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `reverse(= reverse;
const sort = exports.sort = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

**Example**

```ts
import { Array } from "effect"

const result = Array.takeRight([1, 2, 3, 4, 5], 3)
console.log(result) // [3, 4, 5]
```

@category getters
@since 2.0.0
/
const takeRight = exports.takeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const input = fromIterable(self);
  const i = clamp(n, input);
  return i === 0 ? [] : input.slice(-i);
});
/**
Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.

**Example**

```ts
import { Array } from "effect"

const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)
console.log(result) // [1, 3, 2]

// Explanation:
// - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.
// - The next element (`3`) is also less than `4`, so it adds `3`.
// - The next element (`2`) is again less than `4`, so it adds `2`.
// - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.
```

@category getters
@since 2.0.0
/
const takeWhile = exports.takeWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    out.push(a);
    i++;
  }
  return out;
});
const spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
/**
Split an `Iterable` into two parts:

1. the longest initial subarray for which all elements satisfy the specified predicate
2. the remaining elements

@category splitting
@since 2.0.0
/
const span = exports.span = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
/**
Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

**Example**

```ts
import { Array } from "effect"

const result = Array.drop([1, 2, 3, 4, 5], 2)
console.log(result) // [3, 4, 5]
```

@category getters
@since 2.0.0
/
const drop = exports.drop = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(clamp(n, input), input.length);
});
/**
Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.

**Note**. `n` is normalized to a non negative integer.

**Example**

```ts
import { Array } from "effect"

const result = Array.dropRight([1, 2, 3, 4, 5], 2)
console.log(result) // [1, 2, 3]
```

@category getters
@since 2.0.0
/
const dropRight = exports.dropRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(0, input.length - clamp(n, input));
});
/**
Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.

**Example**

```ts
import { Array } from "effect"

const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)
console.log(result) // [4, 5]
```

@category getters
@since 2.0.0
/
const dropWhile = exports.dropWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => fromIterable(self).slice(spanIndex(self, predicate)));
/**
Return the first index for which a predicate holds.

**Example**

```ts
import { Array } from "effect"

const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)
console.log(result) // Option.some(2)
```

@category elements
@since 2.0.0
/
const findFirstIndex = exports.findFirstIndex = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return Option.some(i);
    }
    i++;
  }
  return Option.none();
});
/**
Return the last index for which a predicate holds.

**Example**

```ts
import { Array } from "effect"

const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)
console.log(result) // Option.some(1)
```

@category elements
@since 2.0.0
/
const findLastIndex = exports.findLastIndex = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const input = fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return Option.some(i);
    }
  }
  return Option.none();
});
/**
Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

**Example**

```ts
import { Array } from "effect"

const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)
console.log(result) // Option.some(4)
```

@category elements
@since 2.0.0
/
const findFirst = exports.findFirst = moduleIterable.findFirst;
/**
Finds the last element in an iterable collection that satisfies the given predicate or refinement.
Returns an `Option` containing the found element, or `Option.none` if no element matches.

**Example**

```ts
import { Array } from "effect"

const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)
console.log(result) // Option.some(4)
```

@category elements
@since 2.0.0
/
const findLast = exports.findLast = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const input = fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (Predicate.isBoolean(o)) {
      if (o) {
        return Option.some(a);
      }
    } else {
      if (Option.isSome(o)) {
        return o;
      }
    }
  }
  return Option.none();
});
/**
Counts all the element of the given array that pass the given predicate

**Example**

```ts
import { Array } from "effect"

const result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)
console.log(result) // 2
```

@category folding
@since 3.16.0
/
const countBy = exports.countBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  let count = 0;
  const as = fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    const a = as[i];
    if (f(a, i)) {
      count++;
    }
  }
  return count;
});
/**
Insert an element at the specified index, creating a new `NonEmptyArray`,
or return `None` if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')
console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])
```

@since 2.0.0
/
const insertAt = exports.insertAt = /*#__PURE__*/(0, _Function.dual)(3, (self, i, b) => {
  const out = Array.from(self);
  //             v--- `= self.length` is ok, it means inserting in last position
  if (i < 0 || i > out.length) {
    return Option.none();
  }
  out.splice(i, 0, b);
  return Option.some(out);
});
/**
Change the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')
console.log(result) // ['a', 'z', 'c', 'd']
```

@since 2.0.0
/
const replace = exports.replace = /*#__PURE__*/(0, _Function.dual)(3, (self, i, b) => modify(self, i, () => b));
/**
Replaces an element in an array with the given value, returning an option of the updated array.

**Example**

```ts
import { Array } from "effect"

const result = Array.replaceOption([1, 2, 3], 1, 4)
console.log(result) // Option.some([1, 4, 3])
```

@since 2.0.0
/
const replaceOption = exports.replaceOption = /*#__PURE__*/(0, _Function.dual)(3, (self, i, b) => modifyOption(self, i, () => b));
/**
Apply a function to the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)
console.log(result) // [1, 2, 6, 4]
```

@since 2.0.0
/
const modify = exports.modify = /*#__PURE__*/(0, _Function.dual)(3, (self, i, f) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  const b = f(out[i]);
  out[i] = b;
  return out;
});
/**
Apply a function to the element at the specified index, creating a new `Array`,
or return `None` if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const input = [1, 2, 3, 4]
const result = Array.modifyOption(input, 2, (n) => n * 2)
console.log(result) // Option.some([1, 2, 6, 4])

const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)
console.log(outOfBoundsResult) // Option.none()
```

@since 2.0.0
/
const modifyOption = exports.modifyOption = /*#__PURE__*/(0, _Function.dual)(3, (self, i, f) => {
  const arr = fromIterable(self);
  if (isOutOfBounds(i, arr)) {
    return Option.none();
  }
  const out = Array.isArray(self) ? self.slice() : arr;
  const b = f(arr[i]);
  out[i] = b;
  return Option.some(out);
});
/**
Delete the element at the specified index, creating a new `Array`,
or return a copy of the input if the index is out of bounds.

**Example**

```ts
import { Array } from "effect"

const input = [1, 2, 3, 4]
const result = Array.remove(input, 2)
console.log(result) // [1, 2, 4]

const outOfBoundsResult = Array.remove(input, 5)
console.log(outOfBoundsResult) // [1, 2, 3, 4]
```

@since 2.0.0
/
const remove = exports.remove = /*#__PURE__*/(0, _Function.dual)(2, (self, i) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
/**
Delete the element at the specified index, creating a new `Array`,
or return `None` if the index is out of bounds.

@example
```ts
import * as assert from "node:assert"
import { Array, Option } from "effect"

const numbers = [1, 2, 3, 4]
const result = Array.removeOption(numbers, 2)
assert.deepStrictEqual(result, Option.some([1, 2, 4]))

const outOfBoundsResult = Array.removeOption(numbers, 5)
assert.deepStrictEqual(outOfBoundsResult, Option.none())
```

@since 3.16.0
/
const removeOption = exports.removeOption = /*#__PURE__*/(0, _Function.dual)(2, (self, i) => {
  const arr = fromIterable(self);
  if (isOutOfBounds(i, arr)) {
    return Option.none();
  }
  const out = Array.isArray(self) ? self.slice() : arr;
  out.splice(i, 1);
  return Option.some(out);
});
/**
Reverse an `Iterable`, creating a new `Array`.

**Example**

```ts
import { Array } from "effect"

const result = Array.reverse([1, 2, 3, 4])
console.log(result) // [4, 3, 2, 1]
```

@category elements
@since 2.0.0
/
const reverse = self => Array.from(self).reverse();
/**
Create a new array with elements sorted in increasing order based on the specified comparator.
If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.

@category sorting
@since 2.0.0

## sortBy

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `sortBy(= sortBy;
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Sorts an array based on a provided mapping function and order. The mapping
function transforms the elements into a value that can be compared, and the
order defines how those values should be sorted.

**Example**

```ts
import { Array, Order } from "effect"

const result = Array.sortWith(["aaa", "b", "cc"], (s) => s.length, Order.number)
console.log(result) // ["b", "cc", "aaa"]

// Explanation:
// The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`
// converts each string into its length, and the `Order.number` specifies that the lengths should
// be sorted in ascending order.
```

@since 2.0.0
@category elements
/
const sortWith = exports.sortWith = /*#__PURE__*/(0, _Function.dual)(3, (self, f, order) => Array.from(self).map(a => [a, f(a)]).sort(([, a], [, b]) => order(a, b)).map(([_]) => _));
/**
Sorts the elements of an `Iterable` in increasing order based on the provided
orders. The elements are compared using the first order in `orders`, then the
second order if the first comparison is equal, and so on.

**Example**

```ts
import { Array, Order, pipe } from "effect"

const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 30 }
]

const result = pipe(
  users,
  Array.sortBy(
    Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),
    Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)
  )
)

console.log(result)
// [
//   { name: "Bob", age: 25 },
//   { name: "Alice", age: 30 },
//   { name: "Charlie", age: 30 }
// ]

// Explanation:
// The array of users is sorted first by age in ascending order. When ages are equal,
// the users are further sorted by name in ascending order.
```

@category sorting
@since 2.0.0
/
const sortBy = (...orders) => {
  const sortByAll = sort(Order.combineAll(orders));
  return self => {
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
      return sortByAll(input);
    }
    return [];
  };
};
/**
Takes two `Iterable`s and returns an `Array` of corresponding pairs.
If one input `Iterable` is short, excess elements of the
longer `Iterable` are discarded.

**Example**

```ts
import { Array } from "effect"

const result = Array.zip([1, 2, 3], ['a', 'b'])
console.log(result) // [[1, 'a'], [2, 'b']]
```

@category zipping
@since 2.0.0

## unzip

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `unzip(= unzip;
const intersperse = exports.intersperse = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one
input `Iterable` is short, excess elements of the longer `Iterable` are discarded.

**Example**

```ts
import { Array } from "effect"

const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)
console.log(result) // [5, 7, 9]
```

@category zipping
@since 2.0.0
/
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {
  const as = fromIterable(self);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as), headNonEmpty(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as[i], bs[i]);
    }
    return out;
  }
  return [];
});
/**
This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.

**Example**

```ts
import { Array } from "effect"

const result = Array.unzip([[1, "a"], [2, "b"], [3, "c"]])
console.log(result) // [[1, 2, 3], ['a', 'b', 'c']]
```

@since 2.0.0
/
const unzip = self => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1; i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
};
/**
Places an element in between members of an `Iterable`.
If the input is a non-empty array, the result is also a non-empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.intersperse([1, 2, 3], 0)
console.log(result) // [1, 0, 2, 0, 3]
```

@since 2.0.0

## copy

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `copy(= copy;
const pad = exports.pad = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Apply a function to the head, creating a new `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)
console.log(result) // [10, 2, 3]
```

@since 2.0.0
/
const modifyNonEmptyHead = exports.modifyNonEmptyHead = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => [f(headNonEmpty(self)), ...tailNonEmpty(self)]);
/**
Change the head, creating a new `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.setNonEmptyHead([1, 2, 3], 10)
console.log(result) // [10, 2, 3]
```

@since 2.0.0
/
const setNonEmptyHead = exports.setNonEmptyHead = /*#__PURE__*/(0, _Function.dual)(2, (self, b) => modifyNonEmptyHead(self, () => b));
/**
Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)
console.log(result) // [1, 2, 6]
```

@since 2.0.0
/
const modifyNonEmptyLast = exports.modifyNonEmptyLast = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => append(initNonEmpty(self), f(lastNonEmpty(self))));
/**
Change the last element, creating a new `NonEmptyReadonlyArray`.

**Example**

```ts
import { Array } from "effect"

const result = Array.setNonEmptyLast([1, 2, 3], 4)
console.log(result) // [1, 2, 4]
```

@since 2.0.0
/
const setNonEmptyLast = exports.setNonEmptyLast = /*#__PURE__*/(0, _Function.dual)(2, (self, b) => modifyNonEmptyLast(self, () => b));
/**
Rotate an `Iterable` by `n` steps.
If the input is a non-empty array, the result is also a non-empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.rotate(['a', 'b', 'c', 'd'], 2)
console.log(result) // ['c', 'd', 'a', 'b']
```

@since 2.0.0
/
const rotate = exports.rotate = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const len = input.length;
    const m = Math.round(n) % len;
    if (isOutOfBounds(Math.abs(m), input) || m === 0) {
      return copy(input);
    }
    if (m < 0) {
      const [f, s] = splitNonEmptyAt(input, -m);
      return appendAll(s, f);
    } else {
      return rotate(self, m - len);
    }
  }
  return [];
});
/**
Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.

**Example**

```ts
import { Array, pipe } from "effect"

const isEquivalent = (a: number, b: number) => a === b
const containsNumber = Array.containsWith(isEquivalent)
const result = pipe([1, 2, 3, 4], containsNumber(3))
console.log(result) // true
```

@category elements
@since 2.0.0
/
const containsWith = isEquivalent => (0, _Function.dual)(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
exports.containsWith = containsWith;
const _equivalence = /*#__PURE__*/Equal.equivalence();
/**
Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.

**Example**

```ts
import { Array, pipe } from "effect"

const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))
console.log(result) // true
```

@category elements
@since 2.0.0
/
const contains = exports.contains = /*#__PURE__*/containsWith(_equivalence);
/**
A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for "chopping" up the input
`Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a
value and the rest of the `Array`.

**Example**

```ts
import { Array } from "effect"

const result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])
console.log(result) // [2, 4, 6, 8, 10]

// Explanation:
// The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.
// The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,
// resulting in a new array `[2, 4, 6, 8, 10]`.
```

@since 2.0.0
/
const chop = exports.chop = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const [b, rest] = f(input);
    const out = [b];
    let next = rest;
    while (internalArray.isNonEmptyArray(next)) {
      const [b, rest] = f(next);
      out.push(b);
      next = rest;
    }
    return out;
  }
  return [];
});
/**
Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` can be `0`.

**Example**

```ts
import { Array } from "effect"

const result = Array.splitAt([1, 2, 3, 4, 5], 3)
console.log(result) // [[1, 2, 3], [4, 5]]
```

@category splitting
@since 2.0.0
/
const splitAt = exports.splitAt = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
/**
Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` must be `>= 1`.

**Example**

```ts
import { Array } from "effect"

const result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)
console.log(result) // [["a", "b", "c"], ["d", "e"]]
```

@category splitting
@since 2.0.0
/
const splitNonEmptyAt = exports.splitNonEmptyAt = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
/**
Splits this iterable into `n` equally sized arrays.

**Example**

```ts
import { Array } from "effect"

const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)
console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]
```

@since 2.0.0
@category splitting
/
const split = exports.split = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const input = fromIterable(self);
  return chunksOf(input, Math.ceil(input.length / Math.floor(n)));
});
/**
Splits this iterable on the first element that matches this predicate.
Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.

**Example**

```ts
import { Array } from "effect"

const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)
console.log(result) // [[1, 2, 3], [4, 5]]
```

@category splitting
@since 2.0.0
/
const splitWhere = exports.splitWhere = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => span(self, (a, i) => !predicate(a, i)));
/**
Copies an array.

**Example**

```ts
import { Array } from "effect"

const result = Array.copy([1, 2, 3])
console.log(result) // [1, 2, 3]
```

@since 2.0.0
/
const copy = self => self.slice();
/**
Pads an array.
Returns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.
If `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.
If `n` is less than or equal to 0, the returned array will be an empty array.

**Example**

```ts
import { Array } from "effect"

const result = Array.pad([1, 2, 3], 6, 0)
console.log(result) // [1, 2, 3, 0, 0, 0]
```

@since 3.8.4

## intersectionWith

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `intersectionWith(= intersectionWith;
const intersection = exports.intersection = /*#__PURE__*/intersectionWith(_equivalence)`

JSDoc:

Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
definition of `chunksOf`; it satisfies the property that

```ts skip-type-checking
chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
```

whenever `n` evenly divides the length of `self`.

**Example**

```ts
import { Array } from "effect"

const result = Array.chunksOf([1, 2, 3, 4, 5], 2)
console.log(result) // [[1, 2], [3, 4], [5]]

// Explanation:
// The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.
// It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,
// the last chunk contains the remaining elements.
// The result is `[[1, 2], [3, 4], [5]]`.
```

@category splitting
@since 2.0.0
/
const chunksOf = exports.chunksOf = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
});
/**
Creates sliding windows of size `n` from an `Iterable`.
If the number of elements is less than `n` or if `n` is not greater than zero,
an empty array is returned.

@example
```ts
import * as assert from "node:assert"
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])
assert.deepStrictEqual(Array.window(numbers, 6), [])
```

@category splitting
@since 3.13.2
/
const window = exports.window = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const input = fromIterable(self);
  if (n > 0 && isNonEmptyReadonlyArray(input)) {
    return Array.from({
      length: input.length - (n - 1)
    }, (_, index) => input.slice(index, index + n));
  }
  return [];
});
/**
Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.

**Example**

```ts
import { Array } from "effect"

const result = Array.groupWith(["a", "a", "b", "b", "b", "c", "a"], (x, y) => x === y)
console.log(result) // [["a", "a"], ["b", "b", "b"], ["c"], ["a"]]
```

@category grouping
@since 2.0.0
/
const groupWith = exports.groupWith = /*#__PURE__*/(0, _Function.dual)(2, (self, isEquivalent) => chop(self, as => {
  const h = headNonEmpty(as);
  const out = [h];
  let i = 1;
  for (; i < as.length; i++) {
    const a = as[i];
    if (isEquivalent(a, h)) {
      out.push(a);
    } else {
      break;
    }
  }
  return [out, as.slice(i)];
}));
/**
Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.

**Example**

```ts
import { Array } from "effect"

const result = Array.group([1, 1, 2, 2, 2, 3, 1])
console.log(result) // [[1, 1], [2, 2, 2], [3], [1]]
```

@category grouping
@since 2.0.0
/
const group = exports.group = /*#__PURE__*/groupWith(/*#__PURE__*/Equal.equivalence());
/**
Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
function on each element, and grouping the results according to values returned

**Example**

```ts
import { Array } from "effect"

const people = [
  { name: "Alice", group: "A" },
  { name: "Bob", group: "B" },
  { name: "Charlie", group: "A" }
]

const result = Array.groupBy(people, person => person.group)
console.log(result)
// {
//  A: [{ name: "Alice", group: "A" }, { name: "Charlie", group: "A" }],
//  B: [{ name: "Bob", group: "B" }]
// }
```

@category grouping
@since 2.0.0
/
const groupBy = exports.groupBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const out = {};
  for (const a of self) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
/**
Calculates the union of two arrays using the provided equivalence relation.

**Example**

```ts
import { Array } from "effect"

const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)
console.log(union) // [1, 2, 3]
```

@since 2.0.0
/
const unionWith = exports.unionWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, isEquivalent) => {
  const a = fromIterable(self);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe = dedupeWith(isEquivalent);
      return dedupe(appendAll(a, b));
    }
    return a;
  }
  return b;
});
/**
Creates a union of two arrays, removing duplicates.

**Example**

```ts
import { Array } from "effect"

const result = Array.union([1, 2], [2, 3])
console.log(result) // [1, 2, 3]
```

@since 2.0.0
/
const union = exports.union = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => unionWith(self, that, _equivalence));
/**
Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Iterable`.

**Example**

```ts
import { Array } from "effect"

const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]
const array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]
const isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id
const result = Array.intersectionWith(isEquivalent)(array2)(array1)
console.log(result) // [{ id: 1 }, { id: 3 }]
```

@since 2.0.0
/
const intersectionWith = isEquivalent => {
  const has = containsWith(isEquivalent);
  return (0, _Function.dual)(2, (self, that) => fromIterable(self).filter(a => has(that, a)));
};
/**
Creates an `Array` of unique values that are included in all given `Iterable`s.
The order and references of result values are determined by the first `Iterable`.

**Example**

```ts
import { Array } from "effect"

const result = Array.intersection([1, 2, 3], [3, 4, 1])
console.log(result) // [1, 3]
```

@since 2.0.0

## differenceWith

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `differenceWith(= differenceWith;
const difference = exports.difference = /*#__PURE__*/differenceWith(_equivalence)`

JSDoc:

Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Iterable`.

**Example**

```ts
import { Array } from "effect"

const array1 = [1, 2, 3]
const array2 = [2, 3, 4]
const difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)
console.log(difference) // [1]
```

@since 2.0.0
/
const differenceWith = isEquivalent => {
  const has = containsWith(isEquivalent);
  return (0, _Function.dual)(2, (self, that) => fromIterable(self).filter(a => !has(that, a)));
};
/**
Creates a `Array` of values not included in the other given `Iterable`.
The order and references of result values are determined by the first `Iterable`.

**Example**

```ts
import { Array } from "effect"

const difference = Array.difference([1, 2, 3], [2, 3, 4])
console.log(difference) // [1]
```

@since 2.0.0

## empty

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `empty(= empty;
const of = a => [a];
/**
 * @category mapping
 * @since 2.0.0
 */
exports.of = of;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category constructors
@since 2.0.0
/
const empty = () => [];
/**
Constructs a new `NonEmptyArray<A>` from the specified value.

@category constructors
@since 2.0.0

## getLefts

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `getLefts(= getLefts;
const getRights = self => {
  const out = [];
  for (const a of self)`

JSDoc:

Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.

@category sequencing
@since 2.0.0
/
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
/**
Combines multiple arrays into a single array by concatenating all elements
from each nested array. This function ensures that the structure of nested
arrays is collapsed into a single, flat array.

**Example**

```ts
import { Array } from "effect"

const result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])
console.log(result) // [1, 2, 3, 4, 5, 6]
```

@category sequencing
@since 2.0.0
/
const flatten = exports.flatten = /*#__PURE__*/flatMap(_Function.identity);
/**
Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.
This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.

**Example**

```ts
import { Array, Option } from "effect"

const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()

const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);
console.log(result) // [4, 16]
```

@category filtering
@since 2.0.0
/
const filterMap = exports.filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    const o = f(as[i], i);
    if (Option.isSome(o)) {
      out.push(o.value);
    }
  }
  return out;
});
/**
Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.
This method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.
This is useful when you need to transform an array but only up to the point where a certain condition holds true.

**Example**

```ts
import { Array, Option } from "effect"

const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()

const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)
console.log(result) // [4, 16]
```

@category filtering
@since 2.0.0
/
const filterMapWhile = exports.filterMapWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    const b = f(a, i);
    if (Option.isSome(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
/**
Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.
This function is particularly useful for operations where each element can result in two possible types,
and you want to separate these types into different collections. For instance, separating validation results
into successes and failures.

**Example**

```ts
import { Array, Either } from "effect";

const isEven = (x: number) => x % 2 === 0

const result = Array.partitionMap([1, 2, 3, 4, 5], x =>
  isEven(x) ? Either.right(x) : Either.left(x)
)
console.log(result)
// [
//   [1, 3, 5],
//   [2, 4]
// ]
```

@category filtering
@since 2.0.0
/
const partitionMap = exports.partitionMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const left = [];
  const right = [];
  const as = fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    const e = f(as[i], i);
    if (Either.isLeft(e)) {
      left.push(e.left);
    } else {
      right.push(e.right);
    }
  }
  return [left, right];
});
/**
Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.

**Example**

```ts
import { Array, Option } from "effect"

const result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])
console.log(result) // [1, 2]
```

@category filtering
@since 2.0.0
/
const getSomes = exports.getSomes = /*#__PURE__*/filterMap(_Function.identity);
/**
Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.

**Example**

```ts
import { Array, Either } from "effect"

const result = Array.getLefts([Either.right(1), Either.left("err"), Either.right(2)])
console.log(result) // ["err"]
```

@category filtering
@since 2.0.0
/
const getLefts = self => {
  const out = [];
  for (const a of self) {
    if (Either.isLeft(a)) {
      out.push(a.left);
    }
  }
  return out;
};
/**
Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.

**Example**

```ts
import { Array, Either } from "effect"

const result = Array.getRights([Either.right(1), Either.left("err"), Either.right(2)])
console.log(result) // [1, 2]
```

@category filtering
@since 2.0.0

## getRights

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `getRights(= getRights;
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category filtering
@since 2.0.0

## liftPredicate

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `liftPredicate(= liftPredicate;
const liftOption = f => (...a)`

JSDoc:

Separate elements based on a predicate that also exposes the index of the element.

**Example**

```ts
import { Array } from "effect"

const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)
console.log(result) // [[1, 3], [2, 4]]
```

@category filtering
@since 2.0.0
/
const partition = exports.partition = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const left = [];
  const right = [];
  const as = fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      right.push(as[i]);
    } else {
      left.push(as[i]);
    }
  }
  return [left, right];
});
/**
Separates an `Iterable` into two arrays based on a predicate.

@category filtering
@since 2.0.0
/
const separate = exports.separate = /*#__PURE__*/partitionMap(_Function.identity);
/**
Reduces an array from the left.

**Example**

```ts
import { Array } from "effect"

const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)
console.log(result) // 6
```

@category folding
@since 2.0.0
/
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => fromIterable(self).reduce((b, a, i) => f(b, a, i), b));
/**
Reduces an array from the right.

**Example**

```ts
import { Array } from "effect"

const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)
console.log(result) // 6
```

@category folding
@since 2.0.0
/
const reduceRight = exports.reduceRight = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b));
/**
Lifts a predicate into an array.

**Example**

```ts
import { Array } from "effect"

const isEven = (n: number) => n % 2 === 0
const to = Array.liftPredicate(isEven)
console.log(to(1)) // []
console.log(to(2)) // [2]
```

@category lifting
@since 2.0.0
/
const liftPredicate = predicate => b => predicate(b) ? [b] : [];
/**
@category lifting
@since 2.0.0

## liftOption

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `liftOption(= liftOption;
const fromNullable = a => a == null ? empty()`

JSDoc:

@category conversions
@since 2.0.0

## fromNullable

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `fromNullable(= fromNullable;
const liftNullable = f => (...a)`

JSDoc:

@category lifting
@since 2.0.0

## liftNullable

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `liftNullable(= liftNullable;
const flatMapNullable = exports.flatMapNullable = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Maps over an array and flattens the result, removing null and undefined values.

**Example**

```ts
import { Array } from "effect"

const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))
console.log(result) // [1, 3]

// Explanation:
// The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers
// and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened
// to remove null values, resulting in [1, 3].
```

@category sequencing
@since 2.0.0

## liftEither

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `liftEither(= liftEither;
const every = exports.every = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Lifts a function that returns an `Either` into a function that returns an array.
If the `Either` is a left, it returns an empty array.
If the `Either` is a right, it returns an array with the right value.

**Example**

```ts
import { Array, Either } from "effect"

const parseNumber = (s: string): Either.Either<number, Error> =>
  isNaN(Number(s)) ? Either.left(new Error("Not a number")) : Either.right(Number(s))

const liftedParseNumber = Array.liftEither(parseNumber)

const result1 = liftedParseNumber("42")
console.log(result1) // [42]

const result2 = liftedParseNumber("not a number")
console.log(result2) // []

// Explanation:
// The function parseNumber is lifted to return an array.
// When parsing "42", it returns an Either.left with the number 42, resulting in [42].
// When parsing "not a number", it returns an Either.right with an error, resulting in an empty array [].
```

@category lifting
@since 2.0.0
/
const liftEither = f => (...a) => {
  const e = f(...a);
  return Either.isLeft(e) ? [] : [e.right];
};
/**
Check if a predicate holds true for every `ReadonlyArray` element.

@category elements
@since 2.0.0

## unfold

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `unfold(= unfold;
const getOrder = exports.getOrder = Order.array;
/**
 * Creates an equivalence relation for arrays.
 *
 * **Example**
 *
 * ```ts
 * import { Array } from "effect"
 *
 * const eq = Array.getEquivalence<number>((a, b)`

JSDoc:

Check if a predicate holds true for some `ReadonlyArray` element.

@category elements
@since 2.0.0
/
const some = exports.some = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => self.some(predicate));
/**
Extends an array with a function that maps each subarray to a value.

**Example**

```ts
import { Array } from "effect"

const result = Array.extend([1, 2, 3], as => as.length)
console.log(result) // [3, 2, 1]

// Explanation:
// The function maps each subarray starting from each element to its length.
// The subarrays are: [1, 2, 3], [2, 3], [3].
// The lengths are: 3, 2, 1.
// Therefore, the result is [3, 2, 1].
```

@since 2.0.0
/
const extend = exports.extend = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.map((_, i, as) => f(as.slice(i))));
/**
Finds the minimum element in an array based on a comparator.

**Example**

```ts
import { Array, Order } from "effect"

const result = Array.min([3, 1, 2], Order.number)
console.log(result) // 1
```

@since 2.0.0
/
const min = exports.min = /*#__PURE__*/(0, _Function.dual)(2, (self, O) => self.reduce(Order.min(O)));
/**
Finds the maximum element in an array based on a comparator.

**Example**

```ts
import { Array, Order } from "effect"

const result = Array.max([3, 1, 2], Order.number)
console.log(result) // 3
```

@since 2.0.0
/
const max = exports.max = /*#__PURE__*/(0, _Function.dual)(2, (self, O) => self.reduce(Order.max(O)));
/**
@category constructors
@since 2.0.0
/
const unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (Option.isSome(o = f(next))) {
    const [a, b] = o.value;
    out.push(a);
    next = b;
  }
  return out;
};
/**
This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
If all elements are equal, the arrays are then compared based on their length.
It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.

@category instances
@since 2.0.0

## dedupe

Source: `my-backend/node_modules/effect/dist/cjs/Array.js`

Signature: `dedupe(= dedupe;
const dedupeAdjacentWith = exports.dedupeAdjacentWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Performs a side-effect for each element of the `Iterable`.

**Example**

```ts
import { Array } from "effect"

Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3
```

@since 2.0.0
/
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => fromIterable(self).forEach((a, i) => f(a, i)));
/**
Remove duplicates from an `Iterable` using the provided `isEquivalent` function,
preserving the order of the first occurrence of each element.

**Example**

```ts
import { Array } from "effect"

const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)
console.log(result) // [1, 2, 3]
```

@since 2.0.0
/
const dedupeWith = exports.dedupeWith = /*#__PURE__*/(0, _Function.dual)(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every(a => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
/**
Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.
The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.

@since 2.0.0
/
const dedupe = self => dedupeWith(self, Equal.equivalence());
/**
Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.

**Example**

```ts
import { Array } from "effect"

const result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)
console.log(result) // [1, 2, 3]
```

@since 2.0.0

## isBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `isBigDecimal(= isBigDecimal;
const make = (value, scale)`

JSDoc:

This module provides utility functions and type class instances for working with the `BigDecimal` type in TypeScript.
It includes functions for basic arithmetic operations, as well as type class instances for `Equivalence` and `Order`.

A `BigDecimal` allows storing any real number to arbitrary precision; which avoids common floating point errors
(such as 0.1 + 0.2  0.3) at the cost of complexity.

Internally, `BigDecimal` uses a `BigInt` object, paired with a 64-bit integer which determines the position of the
decimal point. Therefore, the precision *is not* actually arbitrary, but limited to 2<sup>63</sup> decimal places.

It is not recommended to convert a floating point number to a decimal directly, as the floating point representation
may be unexpected.

@module BigDecimal
@since 2.0.0
@see {@link module:BigInt} for more similar operations on `bigint` types
@see {@link module:Number} for more similar operations on `number` types
/

const DEFAULT_PRECISION = 100;
const FINITE_INT_REGEX = /^[+-]?\d+$/;
/**
@since 2.0.0
@category symbols
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/BigDecimal");
const BigDecimalProto = {
  [TypeId]: TypeId,
  [Hash.symbol]() {
    const normalized = normalize(this);
    return (0, _Function.pipe)(Hash.hash(normalized.value), Hash.combine(Hash.number(normalized.scale)), Hash.cached(this));
  },
  [Equal.symbol](that) {
    return isBigDecimal(that) && equals(this, that);
  },
  toString() {
    return `BigDecimal(${format(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/**
Checks if a given value is a `BigDecimal`.

@since 2.0.0
@category guards
/
const isBigDecimal = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
Creates a `BigDecimal` from a `bigint` value and a scale.

@since 2.0.0
@category constructors

## make

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `make(= make;
const unsafeMakeNormalized = (value, scale)`

JSDoc:

Internal function used to create pre-normalized `BigDecimal`s.

@internal

## normalize

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `normalize(= normalize;
const scale = exports.scale = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Normalizes a given `BigDecimal` by removing trailing zeros.

**Example**

```ts
import * as assert from "node:assert"
import { normalize, make, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(normalize(unsafeFromString("123.00000")), normalize(make(123n, 0)))
assert.deepStrictEqual(normalize(unsafeFromString("12300000")), normalize(make(123n, -5)))
```

@since 2.0.0
@category scaling
/
const normalize = self => {
  if (self.normalized === undefined) {
    if (self.value === bigint0) {
      self.normalized = zero;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value = BigInt(digits.substring(0, digits.length - trail));
      const scale = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value, scale);
    }
  }
  return self.normalized;
};
/**
Scales a given `BigDecimal` to the specified scale.

If the given scale is smaller than the current scale, the value will be rounded down to
the nearest integer.

@since 2.0.0
@category scaling

## roundTerminal

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `roundTerminal(= roundTerminal;
const divide = exports.divide = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Provides an addition operation on `BigDecimal`s.

@example
```ts
import * as assert from "node:assert"
import { sum, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(sum(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("5"))
```

@since 2.0.0
@category math
/
const sum = exports.sum = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return that;
  }
  if (self.scale > that.scale) {
    return make(scale(that, self.scale).value + self.value, self.scale);
  }
  if (self.scale < that.scale) {
    return make(scale(self, that.scale).value + that.value, that.scale);
  }
  return make(self.value + that.value, self.scale);
});
/**
Provides a multiplication operation on `BigDecimal`s.

@example
```ts
import * as assert from "node:assert"
import { multiply, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(multiply(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("6"))
```

@since 2.0.0
@category math
/
const multiply = exports.multiply = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (that.value === bigint0 || self.value === bigint0) {
    return zero;
  }
  return make(self.value * that.value, self.scale + that.scale);
});
/**
Provides a subtraction operation on `BigDecimal`s.

@example
```ts
import * as assert from "node:assert"
import { subtract, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(subtract(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("-1"))
```

@since 2.0.0
@category math
/
const subtract = exports.subtract = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return make(-that.value, that.scale);
  }
  if (self.scale > that.scale) {
    return make(self.value - scale(that, self.scale).value, self.scale);
  }
  if (self.scale < that.scale) {
    return make(scale(self, that.scale).value - that.value, that.scale);
  }
  return make(self.value - that.value, self.scale);
});
/**
Internal function used for arbitrary precision division.
/
const divideWithPrecision = (num, den, scale, precision) => {
  const numNegative = num < bigint0;
  const denNegative = den < bigint0;
  const negateResult = numNegative !== denNegative;
  num = numNegative ? -num : num;
  den = denNegative ? -den : den;
  // Shift digits until numerator is larger than denominator (set scale appropriately).
  while (num < den) {
    num *= bigint10;
    scale++;
  }
  // First division.
  let quotient = num / den;
  let remainder = num % den;
  if (remainder === bigint0) {
    // No remainder, return immediately.
    return make(negateResult ? -quotient : quotient, scale);
  }
  // The quotient is guaranteed to be non-negative at this point. No need to consider sign.
  let count = `${quotient}`.length;
  // Shift the remainder by 1 decimal; The quotient will be 1 digit upon next division.
  remainder *= bigint10;
  while (remainder !== bigint0 && count < precision) {
    const q = remainder / den;
    const r = remainder % den;
    quotient = quotient * bigint10 + q;
    remainder = r * bigint10;
    count++;
    scale++;
  }
  if (remainder !== bigint0) {
    // Round final number with remainder.
    quotient += roundTerminal(remainder / den);
  }
  return make(negateResult ? -quotient : quotient, scale);
};
/**
Internal function used for rounding.

Returns 1 if the most significant digit is >= 5, otherwise 0.

This is used after dividing a number by a power of ten and rounding the last digit.

@internal
/
const roundTerminal = n => {
  const pos = n >= bigint0 ? 0 : 1;
  return Number(`${n}`[pos]) < 5 ? bigint0 : bigint1;
};
/**
Provides a division operation on `BigDecimal`s.

If the dividend is not a multiple of the divisor the result will be a `BigDecimal` value
which represents the integer division rounded down to the nearest integer.

If the divisor is `0`, the result will be `None`.

@example
```ts
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("3")), Option.some(BigDecimal.unsafeFromString("2")))
assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("4")), Option.some(BigDecimal.unsafeFromString("1.5")))
assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("0")), Option.none())
```

@since 2.0.0
@category math

## sign

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `sign(= sign;
const abs = n => n.value < bigint0 ? make(-n.value, n.scale)`

JSDoc:

Provides an unsafe division operation on `BigDecimal`s.

If the dividend is not a multiple of the divisor the result will be a `BigDecimal` value
which represents the integer division rounded down to the nearest integer.

Throws a `RangeError` if the divisor is `0`.

@example
```ts
import * as assert from "node:assert"
import { unsafeDivide, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeDivide(unsafeFromString("6"), unsafeFromString("3")), unsafeFromString("2"))
assert.deepStrictEqual(unsafeDivide(unsafeFromString("6"), unsafeFromString("4")), unsafeFromString("1.5"))
```

@since 2.0.0
@category math
/
const unsafeDivide = exports.unsafeDivide = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (that.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  if (self.value === bigint0) {
    return zero;
  }
  const scale = self.scale - that.scale;
  if (self.value === that.value) {
    return make(bigint1, scale);
  }
  return divideWithPrecision(self.value, that.value, scale, DEFAULT_PRECISION);
});
/**
@since 2.0.0
@category instances
/
const Order = exports.Order = /*#__PURE__*/order.make((self, that) => {
  const scmp = order.number(sign(self), sign(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self.scale > that.scale) {
    return order.bigint(self.value, scale(that, self.scale).value);
  }
  if (self.scale < that.scale) {
    return order.bigint(scale(self, that.scale).value, that.value);
  }
  return order.bigint(self.value, that.value);
});
/**
Returns `true` if the first argument is less than the second, otherwise `false`.

@example
```ts
import * as assert from "node:assert"
import { lessThan, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(lessThan(unsafeFromString("2"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThan(unsafeFromString("3"), unsafeFromString("3")), false)
assert.deepStrictEqual(lessThan(unsafeFromString("4"), unsafeFromString("3")), false)
```

@since 2.0.0
@category predicates
/
const lessThan = exports.lessThan = /*#__PURE__*/order.lessThan(Order);
/**
Checks if a given `BigDecimal` is less than or equal to the provided one.

@example
```ts
import * as assert from "node:assert"
import { lessThanOrEqualTo, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("2"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("3"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("4"), unsafeFromString("3")), false)
```

@since 2.0.0
@category predicates
/
const lessThanOrEqualTo = exports.lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);
/**
Returns `true` if the first argument is greater than the second, otherwise `false`.

@example
```ts
import * as assert from "node:assert"
import { greaterThan, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(greaterThan(unsafeFromString("2"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThan(unsafeFromString("3"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThan(unsafeFromString("4"), unsafeFromString("3")), true)
```

@since 2.0.0
@category predicates
/
const greaterThan = exports.greaterThan = /*#__PURE__*/order.greaterThan(Order);
/**
Checks if a given `BigDecimal` is greater than or equal to the provided one.

@example
```ts
import * as assert from "node:assert"
import { greaterThanOrEqualTo, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("2"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("3"), unsafeFromString("3")), true)
assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("4"), unsafeFromString("3")), true)
```

@since 2.0.0
@category predicates
/
const greaterThanOrEqualTo = exports.greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);
/**
Checks if a `BigDecimal` is between a `minimum` and `maximum` value (inclusive).

@example
```ts
import * as assert from "node:assert"
import { BigDecimal } from "effect"

const between = BigDecimal.between({
  minimum: BigDecimal.unsafeFromString("1"),
  maximum: BigDecimal.unsafeFromString("5") }
)

assert.deepStrictEqual(between(BigDecimal.unsafeFromString("3")), true)
assert.deepStrictEqual(between(BigDecimal.unsafeFromString("0")), false)
assert.deepStrictEqual(between(BigDecimal.unsafeFromString("6")), false)
```

@since 2.0.0
@category predicates
/
const between = exports.between = /*#__PURE__*/order.between(Order);
/**
Restricts the given `BigDecimal` to be within the range specified by the `minimum` and `maximum` values.

- If the `BigDecimal` is less than the `minimum` value, the function returns the `minimum` value.
- If the `BigDecimal` is greater than the `maximum` value, the function returns the `maximum` value.
- Otherwise, it returns the original `BigDecimal`.

@example
```ts
import * as assert from "node:assert"
import { BigDecimal } from "effect"

const clamp = BigDecimal.clamp({
  minimum: BigDecimal.unsafeFromString("1"),
  maximum: BigDecimal.unsafeFromString("5") }
)

assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("3")), BigDecimal.unsafeFromString("3"))
assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("0")), BigDecimal.unsafeFromString("1"))
assert.deepStrictEqual(clamp(BigDecimal.unsafeFromString("6")), BigDecimal.unsafeFromString("5"))
```

@since 2.0.0
@category math
/
const clamp = exports.clamp = /*#__PURE__*/order.clamp(Order);
/**
Returns the minimum between two `BigDecimal`s.

@example
```ts
import * as assert from "node:assert"
import { min, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(min(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("2"))
```

@since 2.0.0
@category math
/
const min = exports.min = /*#__PURE__*/order.min(Order);
/**
Returns the maximum between two `BigDecimal`s.

@example
```ts
import * as assert from "node:assert"
import { max, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(max(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("3"))
```

@since 2.0.0
@category math
/
const max = exports.max = /*#__PURE__*/order.max(Order);
/**
Determines the sign of a given `BigDecimal`.

@example
```ts
import * as assert from "node:assert"
import { sign, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(sign(unsafeFromString("-5")), -1)
assert.deepStrictEqual(sign(unsafeFromString("0")), 0)
assert.deepStrictEqual(sign(unsafeFromString("5")), 1)
```

@since 2.0.0
@category math
/
const sign = n => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;
/**
Determines the absolute value of a given `BigDecimal`.

@example
```ts
import * as assert from "node:assert"
import { abs, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(abs(unsafeFromString("-5")), unsafeFromString("5"))
assert.deepStrictEqual(abs(unsafeFromString("0")), unsafeFromString("0"))
assert.deepStrictEqual(abs(unsafeFromString("5")), unsafeFromString("5"))
```

@since 2.0.0
@category math

## abs

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `abs(= abs;
const negate = n => make(-n.value, n.scale)`

JSDoc:

Provides a negate operation on `BigDecimal`s.

@example
```ts
import * as assert from "node:assert"
import { negate, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(negate(unsafeFromString("3")), unsafeFromString("-3"))
assert.deepStrictEqual(negate(unsafeFromString("-6")), unsafeFromString("6"))
```

@since 2.0.0
@category math

## negate

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `negate(= negate;
const remainder = exports.remainder = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns the remainder left over when one operand is divided by a second operand.

If the divisor is `0`, the result will be `None`.

@example
```ts
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("2"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("0")))
assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("3"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("1")))
assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("-4"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("0")))
```

@since 2.0.0
@category math

## fromBigInt

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `fromBigInt(= fromBigInt;
const unsafeFromNumber = n => Option.getOrThrowWith(safeFromNumber(n)`

JSDoc:

Returns the remainder left over when one operand is divided by a second operand.

Throws a `RangeError` if the divisor is `0`.

@example
```ts
import * as assert from "node:assert"
import { unsafeRemainder, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeRemainder(unsafeFromString("2"), unsafeFromString("2")), unsafeFromString("0"))
assert.deepStrictEqual(unsafeRemainder(unsafeFromString("3"), unsafeFromString("2")), unsafeFromString("1"))
assert.deepStrictEqual(unsafeRemainder(unsafeFromString("-4"), unsafeFromString("2")), unsafeFromString("0"))
```

@since 2.0.0
@category math
/
const unsafeRemainder = exports.unsafeRemainder = /*#__PURE__*/(0, _Function.dual)(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  const max = Math.max(self.scale, divisor.scale);
  return make(scale(self, max).value % scale(divisor, max).value, max);
});
/**
@category instances
@since 2.0.0
/
const Equivalence = exports.Equivalence = /*#__PURE__*/equivalence.make((self, that) => {
  if (self.scale > that.scale) {
    return scale(that, self.scale).value === self.value;
  }
  if (self.scale < that.scale) {
    return scale(self, that.scale).value === that.value;
  }
  return self.value === that.value;
});
/**
Checks if two `BigDecimal`s are equal.

@since 2.0.0
@category predicates
/
const equals = exports.equals = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => Equivalence(self, that));
/**
Creates a `BigDecimal` from a `bigint` value.

@since 2.0.0
@category constructors
/
const fromBigInt = n => make(n, 0);
/**
Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

@example
```ts
import * as assert from "node:assert"
import { unsafeFromNumber, make } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeFromNumber(123), make(123n, 0))
assert.deepStrictEqual(unsafeFromNumber(123.456), make(123456n, 3))
```

@since 3.11.0
@category constructors

## unsafeFromNumber

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `unsafeFromNumber(= unsafeFromNumber;
const fromNumber = exports.fromNumber = unsafeFromNumber;
// TODO(4.0)`

JSDoc:

Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Throws a `RangeError` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

@since 2.0.0
@category constructors
@deprecated Use {@link unsafeFromNumber} instead.

## safeFromNumber

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `safeFromNumber(= safeFromNumber;
const fromString = s => {
  if (s === "")`

JSDoc:

Creates a `BigDecimal` from a `number` value.

It is not recommended to convert a floating point number to a decimal directly,
as the floating point representation may be unexpected.

Returns `None` if the number is not finite (`NaN`, `+Infinity` or `-Infinity`).

@example
```ts
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))
assert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))
assert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())
```

@since 3.11.0
@category constructors
/
const safeFromNumber = n => {
  if (!Number.isFinite(n)) {
    return Option.none();
  }
  const string = `${n}`;
  if (string.includes("e")) {
    return fromString(string);
  }
  const [lead, trail = ""] = string.split(".");
  return Option.some(make(BigInt(`${lead}${trail}`), trail.length));
};
/**
Parses a numerical `string` into a `BigDecimal`.

@example
```ts
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.fromString("123"), Option.some(BigDecimal.make(123n, 0)))
assert.deepStrictEqual(BigDecimal.fromString("123.456"), Option.some(BigDecimal.make(123456n, 3)))
assert.deepStrictEqual(BigDecimal.fromString("123.abc"), Option.none())
```

@since 2.0.0
@category constructors

## fromString

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `fromString(= fromString;
const unsafeFromString = s => Option.getOrThrowWith(fromString(s)`

JSDoc:

Parses a numerical `string` into a `BigDecimal`.

@example
```ts
import * as assert from "node:assert"
import { unsafeFromString, make } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeFromString("123"), make(123n, 0))
assert.deepStrictEqual(unsafeFromString("123.456"), make(123456n, 3))
assert.throws(() => unsafeFromString("123.abc"))
```

@since 2.0.0
@category constructors

## unsafeFromString

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `unsafeFromString(= unsafeFromString;
const format = n => {
  const normalized = normalize(n)`

JSDoc:

Formats a given `BigDecimal` as a `string`.

If the scale of the `BigDecimal` is greater than or equal to 16, the `BigDecimal` will
be formatted in scientific notation.

@example
```ts
import * as assert from "node:assert"
import { format, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(format(unsafeFromString("-5")), "-5")
assert.deepStrictEqual(format(unsafeFromString("123.456")), "123.456")
assert.deepStrictEqual(format(unsafeFromString("-0.00000123")), "-0.00000123")
```

@since 2.0.0
@category conversions

## format

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `format(= format;
const toExponential = n => {
  if (isZero(n)`

JSDoc:

Formats a given `BigDecimal` as a `string` in scientific notation.

@example
```ts
import * as assert from "node:assert"
import { toExponential, make } from "effect/BigDecimal"

assert.deepStrictEqual(toExponential(make(123456n, -5)), "1.23456e+10")
```

@since 3.11.0
@category conversions

## toExponential

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `toExponential(= toExponential;
const unsafeToNumber = n => Number(format(n)`

JSDoc:

Converts a `BigDecimal` to a `number`.

This function will produce incorrect results if the `BigDecimal` exceeds the 64-bit range of a `number`.

@example
```ts
import * as assert from "node:assert"
import { unsafeToNumber, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeToNumber(unsafeFromString("123.456")), 123.456)
```

@since 2.0.0
@category conversions

## unsafeToNumber

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `unsafeToNumber(= unsafeToNumber;
const isInteger = n => normalize(n)`

JSDoc:

Checks if a given `BigDecimal` is an integer.

@example
```ts
import * as assert from "node:assert"
import { isInteger, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isInteger(unsafeFromString("0")), true)
assert.deepStrictEqual(isInteger(unsafeFromString("1")), true)
assert.deepStrictEqual(isInteger(unsafeFromString("1.1")), false)
```

@since 2.0.0
@category predicates

## isInteger

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `isInteger(= isInteger;
const isZero = n => n.value === bigint0;
/**
 * Checks if a given `BigDecimal` is negative.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isNegative, unsafeFromString } from "effect/BigDecimal"
 *
 * assert.deepStrictEqual(isNegative(unsafeFromString("-1")`

JSDoc:

Checks if a given `BigDecimal` is `0`.

@example
```ts
import * as assert from "node:assert"
import { isZero, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isZero(unsafeFromString("0")), true)
assert.deepStrictEqual(isZero(unsafeFromString("1")), false)
```

@since 2.0.0
@category predicates

## isNegative

Source: `my-backend/node_modules/effect/dist/cjs/BigDecimal.js`

Signature: `isNegative(= isNegative;
const isPositive = n => n.value > bigint0;
exports.isPositive = isPositive;
const isBigDecimalArgs = args => isBigDecimal(args[0])`

JSDoc:

Checks if a given `BigDecimal` is positive.

@example
```ts
import * as assert from "node:assert"
import { isPositive, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isPositive(unsafeFromString("-1")), false)
assert.deepStrictEqual(isPositive(unsafeFromString("0")), false)
assert.deepStrictEqual(isPositive(unsafeFromString("1")), true)
```

@since 2.0.0
@category predicates

## increment

Source: `my-backend/node_modules/effect/dist/cjs/BigInt.js`

Signature: `increment(= increment;
const decrement = n => n - bigint1;
/**
 * @category instances
 * @since 2.0.0
 */
exports.decrement = decrement;
const Equivalence = exports.Equivalence = equivalence.bigint;
/**
 * @category instances
 * @since 2.0.0
 */
const Order = exports.Order = order.bigint;
/**
 * Returns `true` if the first argument is less than the second, otherwise `false`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { lessThan } from "effect/BigInt"
 *
 * assert.deepStrictEqual(lessThan(2n, 3n)`

JSDoc:

This module provides utility functions and type class instances for working with the `bigint` type in TypeScript.
It includes functions for basic arithmetic operations, as well as type class instances for
`Equivalence` and `Order`.

@module BigInt
@since 2.0.0
@see {@link module:BigDecimal} for more similar operations on `BigDecimal` types
@see {@link module:Number} for more similar operations on `number` types
/

const bigint0 = /*#__PURE__*/BigInt(0);
const bigint1 = /*#__PURE__*/BigInt(1);
const bigint2 = /*#__PURE__*/BigInt(2);
/**
Tests if a value is a `bigint`.

@example
```ts
import * as assert from "node:assert"
import { isBigInt } from "effect/BigInt"

assert.deepStrictEqual(isBigInt(1n), true)
assert.deepStrictEqual(isBigInt(1), false)
```

@category guards
@since 2.0.0
/
const isBigInt = exports.isBigInt = predicate.isBigInt;
/**
Provides an addition operation on `bigint`s.

@example
```ts
import * as assert from "node:assert"
import { sum } from "effect/BigInt"

assert.deepStrictEqual(sum(2n, 3n), 5n)
```

@category math
@since 2.0.0
/
const sum = exports.sum = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self + that);
/**
Provides a multiplication operation on `bigint`s.

@example
```ts
import * as assert from "node:assert"
import { multiply } from "effect/BigInt"

assert.deepStrictEqual(multiply(2n, 3n), 6n)
```

@category math
@since 2.0.0
/
const multiply = exports.multiply = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self * that);
/**
Provides a subtraction operation on `bigint`s.

@example
```ts
import * as assert from "node:assert"
import { subtract } from "effect/BigInt"

assert.deepStrictEqual(subtract(2n, 3n), -1n)
```

@category math
@since 2.0.0
/
const subtract = exports.subtract = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self - that);
/**
Provides a division operation on `bigint`s.

If the dividend is not a multiple of the divisor the result will be a `bigint` value
which represents the integer division rounded down to the nearest integer.

Returns `None` if the divisor is `0n`.

@example
```ts
import * as assert from "node:assert"
import { BigInt, Option } from "effect"

assert.deepStrictEqual(BigInt.divide(6n, 3n), Option.some(2n))
assert.deepStrictEqual(BigInt.divide(6n, 0n), Option.none())
```

@category math
@since 2.0.0
/
const divide = exports.divide = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => that === bigint0 ? Option.none() : Option.some(self / that));
/**
Provides a division operation on `bigint`s.

If the dividend is not a multiple of the divisor the result will be a `bigint` value
which represents the integer division rounded down to the nearest integer.

Throws a `RangeError` if the divisor is `0n`.

@example
```ts
import * as assert from "node:assert"
import { unsafeDivide } from "effect/BigInt"

assert.deepStrictEqual(unsafeDivide(6n, 3n), 2n)
assert.deepStrictEqual(unsafeDivide(6n, 4n), 1n)
```

@category math
@since 2.0.0
/
const unsafeDivide = exports.unsafeDivide = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self / that);
/**
Returns the result of adding `1n` to a given number.

@example
```ts
import * as assert from "node:assert"
import { increment } from "effect/BigInt"

assert.deepStrictEqual(increment(2n), 3n)
```

@category math
@since 2.0.0
/
const increment = n => n + bigint1;
/**
Decrements a number by `1n`.

@example
```ts
import * as assert from "node:assert"
import { decrement } from "effect/BigInt"

assert.deepStrictEqual(decrement(3n), 2n)
```

@category math
@since 2.0.0

## sign

Source: `my-backend/node_modules/effect/dist/cjs/BigInt.js`

Signature: `sign(= sign;
const abs = n => n < bigint0 ? -n : n;
/**
 * Determines the greatest common divisor of two `bigint`s.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { gcd } from "effect/BigInt"
 *
 * assert.deepStrictEqual(gcd(2n, 3n)`

JSDoc:

Returns a function that checks if a given `bigint` is less than or equal to the provided one.

@example
```ts
import * as assert from "node:assert"
import { lessThanOrEqualTo } from "effect/BigInt"

assert.deepStrictEqual(lessThanOrEqualTo(2n, 3n), true)
assert.deepStrictEqual(lessThanOrEqualTo(3n, 3n), true)
assert.deepStrictEqual(lessThanOrEqualTo(4n, 3n), false)
```

@category predicates
@since 2.0.0
/
const lessThanOrEqualTo = exports.lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);
/**
Returns `true` if the first argument is greater than the second, otherwise `false`.

@example
```ts
import * as assert from "node:assert"
import { greaterThan } from "effect/BigInt"

assert.deepStrictEqual(greaterThan(2n, 3n), false)
assert.deepStrictEqual(greaterThan(3n, 3n), false)
assert.deepStrictEqual(greaterThan(4n, 3n), true)
```

@category predicates
@since 2.0.0
/
const greaterThan = exports.greaterThan = /*#__PURE__*/order.greaterThan(Order);
/**
Returns a function that checks if a given `bigint` is greater than or equal to the provided one.

@example
```ts
import * as assert from "node:assert"
import { greaterThanOrEqualTo } from "effect/BigInt"

assert.deepStrictEqual(greaterThanOrEqualTo(2n, 3n), false)
assert.deepStrictEqual(greaterThanOrEqualTo(3n, 3n), true)
assert.deepStrictEqual(greaterThanOrEqualTo(4n, 3n), true)
```

@category predicates
@since 2.0.0
/
const greaterThanOrEqualTo = exports.greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);
/**
Checks if a `bigint` is between a `minimum` and `maximum` value (inclusive).

@example
```ts
import * as assert from "node:assert"
import { BigInt } from "effect"

const between = BigInt.between({ minimum: 0n, maximum: 5n })

assert.deepStrictEqual(between(3n), true)
assert.deepStrictEqual(between(-1n), false)
assert.deepStrictEqual(between(6n), false)
```

@category predicates
@since 2.0.0
/
const between = exports.between = /*#__PURE__*/order.between(Order);
/**
Restricts the given `bigint` to be within the range specified by the `minimum` and `maximum` values.

- If the `bigint` is less than the `minimum` value, the function returns the `minimum` value.
- If the `bigint` is greater than the `maximum` value, the function returns the `maximum` value.
- Otherwise, it returns the original `bigint`.

@example
```ts
import * as assert from "node:assert"
import { BigInt } from "effect"

const clamp = BigInt.clamp({ minimum: 1n, maximum: 5n })

assert.equal(clamp(3n), 3n)
assert.equal(clamp(0n), 1n)
assert.equal(clamp(6n), 5n)
```

@since 2.0.0
/
const clamp = exports.clamp = /*#__PURE__*/order.clamp(Order);
/**
Returns the minimum between two `bigint`s.

@example
```ts
import * as assert from "node:assert"
import { min } from "effect/BigInt"

assert.deepStrictEqual(min(2n, 3n), 2n)
```

@since 2.0.0
/
const min = exports.min = /*#__PURE__*/order.min(Order);
/**
Returns the maximum between two `bigint`s.

@example
```ts
import * as assert from "node:assert"
import { max } from "effect/BigInt"

assert.deepStrictEqual(max(2n, 3n), 3n)
```

@since 2.0.0
/
const max = exports.max = /*#__PURE__*/order.max(Order);
/**
Determines the sign of a given `bigint`.

@example
```ts
import * as assert from "node:assert"
import { sign } from "effect/BigInt"

assert.deepStrictEqual(sign(-5n), -1)
assert.deepStrictEqual(sign(0n), 0)
assert.deepStrictEqual(sign(5n), 1)
```

@category math
@since 2.0.0
/
const sign = n => Order(n, bigint0);
/**
Determines the absolute value of a given `bigint`.

@example
```ts
import * as assert from "node:assert"
import { abs } from "effect/BigInt"

assert.deepStrictEqual(abs(-5n), 5n)
assert.deepStrictEqual(abs(0n), 0n)
assert.deepStrictEqual(abs(5n), 5n)
```

@category math
@since 2.0.0

## unsafeSqrt

Source: `my-backend/node_modules/effect/dist/cjs/BigInt.js`

Signature: `unsafeSqrt(= unsafeSqrt;
const sqrt = n => greaterThanOrEqualTo(n, bigint0)`

JSDoc:

Determines the least common multiple of two `bigint`s.

@example
```ts
import * as assert from "node:assert"
import { lcm } from "effect/BigInt"

assert.deepStrictEqual(lcm(2n, 3n), 6n)
assert.deepStrictEqual(lcm(2n, 4n), 4n)
assert.deepStrictEqual(lcm(16n, 24n), 48n)
```

@category math
@since 2.0.0
/
const lcm = exports.lcm = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self * that / gcd(self, that));
/**
Determines the square root of a given `bigint` unsafely. Throws if the given `bigint` is negative.

@example
```ts
import * as assert from "node:assert"
import { unsafeSqrt } from "effect/BigInt"

assert.deepStrictEqual(unsafeSqrt(4n), 2n)
assert.deepStrictEqual(unsafeSqrt(9n), 3n)
assert.deepStrictEqual(unsafeSqrt(16n), 4n)
```

@category math
@since 2.0.0
/
const unsafeSqrt = n => {
  if (n < bigint0) {
    throw new RangeError("Cannot take the square root of a negative number");
  }
  if (n < bigint2) {
    return n;
  }
  let x = n / bigint2;
  while (x * x > n) {
    x = (n / x + x) / bigint2;
  }
  return x;
};
/**
Determines the square root of a given `bigint` safely. Returns `none` if the given `bigint` is negative.

@example
```ts
import * as assert from "node:assert"
import { BigInt, Option } from "effect"

assert.deepStrictEqual(BigInt.sqrt(4n), Option.some(2n))
assert.deepStrictEqual(BigInt.sqrt(9n), Option.some(3n))
assert.deepStrictEqual(BigInt.sqrt(16n), Option.some(4n))
assert.deepStrictEqual(BigInt.sqrt(-1n), Option.none())
```

@category math
@since 2.0.0

## sqrt

Source: `my-backend/node_modules/effect/dist/cjs/BigInt.js`

Signature: `sqrt(= sqrt;
const sumAll = collection => {
  let out = bigint0;
  for (const n of collection)`

JSDoc:

Takes an `Iterable` of `bigint`s and returns their sum as a single `bigint

@example
```ts
import * as assert from "node:assert"
import { sumAll } from "effect/BigInt"

assert.deepStrictEqual(sumAll([2n, 3n, 4n]), 9n)
```

@category math
@since 2.0.0

## sumAll

Source: `my-backend/node_modules/effect/dist/cjs/BigInt.js`

Signature: `sumAll(= sumAll;
const multiplyAll = collection => {
  let out = bigint1;
  for (const n of collection)`

JSDoc:

Takes an `Iterable` of `bigint`s and returns their multiplication as a single `number`.

@example
```ts
import * as assert from "node:assert"
import { multiplyAll } from "effect/BigInt"

assert.deepStrictEqual(multiplyAll([2n, 3n, 4n]), 24n)
```

@category math
@since 2.0.0

## multiplyAll

Source: `my-backend/node_modules/effect/dist/cjs/BigInt.js`

Signature: `multiplyAll(= multiplyAll;
const toNumber = b => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER)`

JSDoc:

Takes a `bigint` and returns an `Option` of `number`.

If the `bigint` is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`
and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it converts the `bigint`
to a number and returns `Option.some(number)`.

@example
```ts
import * as assert from "node:assert"
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))
assert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())
assert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())
```

@category conversions
@since 2.0.0

## toNumber

Source: `my-backend/node_modules/effect/dist/cjs/BigInt.js`

Signature: `toNumber(= toNumber;
const fromString = s => {
  try {
    return s.trim()`

JSDoc:

Takes a string and returns an `Option` of `bigint`.

If the string is empty or contains characters that cannot be converted into a `bigint`,
it returns `Option.none()`, otherwise, it returns `Option.some(bigint)`.

@example
```ts
import * as assert from "node:assert"
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.fromString("42"), Option.some(BigInt(42)))
assert.deepStrictEqual(BI.fromString(" "), Option.none())
assert.deepStrictEqual(BI.fromString("a"), Option.none())
```

@category conversions
@since 2.4.12

## fromString

Source: `my-backend/node_modules/effect/dist/cjs/BigInt.js`

Signature: `fromString(= fromString;
const fromNumber = n => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER)`

JSDoc:

Takes a number and returns an `Option` of `bigint`.

If the number is outside the safe integer range for JavaScript (`Number.MAX_SAFE_INTEGER`
and `Number.MIN_SAFE_INTEGER`), it returns `Option.none()`. Otherwise, it attempts to
convert the number to a `bigint` and returns `Option.some(bigint)`.

@example
```ts
import * as assert from "node:assert"
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))
assert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())
assert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())
```

@category conversions
@since 2.4.12

## not

Source: `my-backend/node_modules/effect/dist/cjs/Boolean.js`

Signature: `not(= not;
const and = exports.and = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

This module provides utility functions and type class instances for working with the `boolean` type in TypeScript.
It includes functions for basic boolean operations, as well as type class instances for
`Equivalence` and `Order`.

@since 2.0.0
/

/**
Tests if a value is a `boolean`.

@example
```ts
import * as assert from "node:assert"
import { isBoolean } from "effect/Boolean"

assert.deepStrictEqual(isBoolean(true), true)
assert.deepStrictEqual(isBoolean("true"), false)
```

@category guards
@since 2.0.0
/
const isBoolean = exports.isBoolean = predicate.isBoolean;
/**
This function returns the result of either of the given functions depending on the value of the boolean parameter.
It is useful when you have to run one of two functions depending on the boolean value.

@example
```ts
import * as assert from "node:assert"
import { Boolean } from "effect"

assert.deepStrictEqual(Boolean.match(true, { onFalse: () => "It's false!", onTrue: () => "It's true!" }), "It's true!")
```

@category pattern matching
@since 2.0.0
/
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (value, options) => value ? options.onTrue() : options.onFalse());
/**
@category instances
@since 2.0.0
/
const Equivalence = exports.Equivalence = equivalence.boolean;
/**
@category instances
@since 2.0.0
/
const Order = exports.Order = order.boolean;
/**
Negates the given boolean: `!self`

@example
```ts
import * as assert from "node:assert"
import { not } from "effect/Boolean"

assert.deepStrictEqual(not(true), false)
assert.deepStrictEqual(not(false), true)
```

@category combinators
@since 2.0.0
/
const not = self => !self;
/**
Combines two boolean using AND: `self && that`.

@example
```ts
import * as assert from "node:assert"
import { and } from "effect/Boolean"

assert.deepStrictEqual(and(true, true), true)
assert.deepStrictEqual(and(true, false), false)
assert.deepStrictEqual(and(false, true), false)
assert.deepStrictEqual(and(false, false), false)
```

@category combinators
@since 2.0.0

## every

Source: `my-backend/node_modules/effect/dist/cjs/Boolean.js`

Signature: `every(= every;
const some = collection => {
  for (const b of collection)`

JSDoc:

Combines two boolean using NAND: `!(self && that)`.

@example
```ts
import * as assert from "node:assert"
import { nand } from "effect/Boolean"

assert.deepStrictEqual(nand(true, true), false)
assert.deepStrictEqual(nand(true, false), true)
assert.deepStrictEqual(nand(false, true), true)
assert.deepStrictEqual(nand(false, false), true)
```

@category combinators
@since 2.0.0
/
const nand = exports.nand = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => !(self && that));
/**
Combines two boolean using OR: `self || that`.

@example
```ts
import * as assert from "node:assert"
import { or } from "effect/Boolean"

assert.deepStrictEqual(or(true, true), true)
assert.deepStrictEqual(or(true, false), true)
assert.deepStrictEqual(or(false, true), true)
assert.deepStrictEqual(or(false, false), false)
```

@category combinators
@since 2.0.0
/
const or = exports.or = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self || that);
/**
Combines two booleans using NOR: `!(self || that)`.

@example
```ts
import * as assert from "node:assert"
import { nor } from "effect/Boolean"

assert.deepStrictEqual(nor(true, true), false)
assert.deepStrictEqual(nor(true, false), false)
assert.deepStrictEqual(nor(false, true), false)
assert.deepStrictEqual(nor(false, false), true)
```

@category combinators
@since 2.0.0
/
const nor = exports.nor = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => !(self || that));
/**
Combines two booleans using XOR: `(!self && that) || (self && !that)`.

@example
```ts
import * as assert from "node:assert"
import { xor } from "effect/Boolean"

assert.deepStrictEqual(xor(true, true), false)
assert.deepStrictEqual(xor(true, false), true)
assert.deepStrictEqual(xor(false, true), true)
assert.deepStrictEqual(xor(false, false), false)
```

@category combinators
@since 2.0.0
/
const xor = exports.xor = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => !self && that || self && !that);
/**
Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.

@example
```ts
import * as assert from "node:assert"
import { eqv } from "effect/Boolean"

assert.deepStrictEqual(eqv(true, true), true)
assert.deepStrictEqual(eqv(true, false), false)
assert.deepStrictEqual(eqv(false, true), false)
assert.deepStrictEqual(eqv(false, false), true)
```

@category combinators
@since 2.0.0
/
const eqv = exports.eqv = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => !xor(self, that));
/**
Combines two booleans using an implication: `(!self || that)`.

@example
```ts
import * as assert from "node:assert"
import { implies } from "effect/Boolean"

assert.deepStrictEqual(implies(true, true), true)
assert.deepStrictEqual(implies(true, false), false)
assert.deepStrictEqual(implies(false, true), true)
assert.deepStrictEqual(implies(false, false), true)
```

@category combinators
@since 2.0.0
/
const implies = exports.implies = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self ? that : true);
/**
This utility function is used to check if all the elements in a collection of boolean values are `true`.

@example
```ts
import * as assert from "node:assert"
import { every } from "effect/Boolean"

assert.deepStrictEqual(every([true, true, true]), true)
assert.deepStrictEqual(every([true, false, true]), false)
```

@since 2.0.0
/
const every = collection => {
  for (const b of collection) {
    if (!b) {
      return false;
    }
  }
  return true;
};
/**
This utility function is used to check if at least one of the elements in a collection of boolean values is `true`.

@example
```ts
import * as assert from "node:assert"
import { some } from "effect/Boolean"

assert.deepStrictEqual(some([true, false, true]), true)
assert.deepStrictEqual(some([false, false, false]), false)
```

@since 2.0.0

## error

Source: `my-backend/node_modules/effect/dist/cjs/Brand.js`

Signature: `error(= error;
const errors = (...errors)`

JSDoc:

This module provides types and utility functions to create and work with branded types,
which are TypeScript types with an added type tag to prevent accidental usage of a value in the wrong context.

The `refined` and `nominal` functions are both used to create branded types in TypeScript.
The main difference between them is that `refined` allows for validation of the data, while `nominal` does not.

The `nominal` function is used to create a new branded type that has the same underlying type as the input, but with a different name.
This is useful when you want to distinguish between two values of the same type that have different meanings.
The `nominal` function does not perform any validation of the input data.

On the other hand, the `refined` function is used to create a new branded type that has the same underlying type as the input,
but with a different name, and it also allows for validation of the input data.
The `refined` function takes a predicate that is used to validate the input data.
If the input data fails the validation, a `BrandErrors` is returned, which provides information about the specific validation failure.

@since 2.0.0
/

/**
@since 2.0.0
@category symbols
/
const BrandTypeId = exports.BrandTypeId = /*#__PURE__*/Symbol.for("effect/Brand");
/**
@since 2.0.0
@category symbols
/
const RefinedConstructorsTypeId = exports.RefinedConstructorsTypeId = /*#__PURE__*/Symbol.for("effect/Brand/Refined");
/**
Returns a `BrandErrors` that contains a single `RefinementError`.

@since 2.0.0
@category constructors
/
const error = (message, meta) => [{
  message,
  meta
}];
/**
Takes a variable number of `BrandErrors` and returns a single `BrandErrors` that contains all refinement errors.

@since 2.0.0
@category constructors

## nominal

Source: `my-backend/node_modules/effect/dist/cjs/Brand.js`

Signature: `nominal(= nominal;
const all = (...brands)`

JSDoc:

This function returns a `Brand.Constructor` that **does not apply any runtime checks**, it just returns the provided value.
It can be used to create nominal types that allow distinguishing between two values of the same type but with different meanings.

If you also want to perform some validation, see {@link refined}.

**Example**

```ts
import * as assert from "node:assert"
import { Brand } from "effect"

type UserId = number & Brand.Brand<"UserId">

const UserId = Brand.nominal<UserId>()

console.log(UserId(1))
// 1
```

@since 2.0.0
@category constructors
/
const nominal = () => {
  // @ts-expect-error
  return Object.assign(args => args, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: args => Option.some(args),
    either: args => Either.right(args),
    is: _args => true
  });
};
/**
Combines two or more brands together to form a single branded type.
This API is useful when you want to validate that the input data passes multiple brand validators.

**Example**

```ts
import * as assert from "node:assert"
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">
const Int = Brand.refined<Int>(
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)
type Positive = number & Brand.Brand<"Positive">
const Positive = Brand.refined<Positive>(
  (n) => n > 0,
  (n) => Brand.error(`Expected ${n} to be positive`)
)

const PositiveInt = Brand.all(Int, Positive)

console.log(PositiveInt(1))
// 1

assert.throws(() => PositiveInt(1.1))
```

@since 2.0.0
@category combining

## all

Source: `my-backend/node_modules/effect/dist/cjs/Brand.js`

Signature: `all(= all;
const unbranded = exports.unbranded = _Function.unsafeCoerce;
//# sourceMappingURL=Brand.js.map)`

JSDoc:

Retrieves the unbranded value from a `Brand` instance.

@since 3.15.0
@category getters

## empty

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `empty(= empty;
const make = (...as)`

JSDoc:

@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/Chunk");
function copy(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
const emptyArray = [];
/**
Compares the two chunks of equal length using the specified function

@category equivalence
@since 2.0.0
/
const getEquivalence = isEquivalent => Equivalence.make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet(that, i))));
exports.getEquivalence = getEquivalence;
const _equivalence = /*#__PURE__*/getEquivalence(Equal.equals);
const ChunkProto = {
  [TypeId]: {
    _A: _ => _
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  [Equal.symbol](that) {
    return isChunk(that) && _equivalence(this, that);
  },
  [Hash.symbol]() {
    return Hash.cached(this, Hash.array(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray":
        {
          return this.backing.array[Symbol.iterator]();
        }
      case "IEmpty":
        {
          return emptyArray[Symbol.iterator]();
        }
      default:
        {
          return toReadonlyArray(this)[Symbol.iterator]();
        }
    }
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const makeChunk = backing => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty":
      {
        chunk.length = 0;
        chunk.depth = 0;
        chunk.left = chunk;
        chunk.right = chunk;
        break;
      }
    case "IConcat":
      {
        chunk.length = backing.left.length + backing.right.length;
        chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
        chunk.left = backing.left;
        chunk.right = backing.right;
        break;
      }
    case "IArray":
      {
        chunk.length = backing.array.length;
        chunk.depth = 0;
        chunk.left = _empty;
        chunk.right = _empty;
        break;
      }
    case "ISingleton":
      {
        chunk.length = 1;
        chunk.depth = 0;
        chunk.left = _empty;
        chunk.right = _empty;
        break;
      }
    case "ISlice":
      {
        chunk.length = backing.length;
        chunk.depth = backing.chunk.depth + 1;
        chunk.left = _empty;
        chunk.right = _empty;
        break;
      }
  }
  return chunk;
};
/**
Checks if `u` is a `Chunk<unknown>`

@category constructors
@since 2.0.0
/
const isChunk = u => (0, _Predicate.hasProperty)(u, TypeId);
exports.isChunk = isChunk;
const _empty = /*#__PURE__*/makeChunk({
  _tag: "IEmpty"
});
/**
@category constructors
@since 2.0.0
/
const empty = () => _empty;
/**
Builds a `NonEmptyChunk` from an non-empty collection of elements.

@category constructors
@since 2.0.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `make(= make;
const of = a => makeChunk({
  _tag: "ISingleton",
  a
})`

JSDoc:

Builds a `NonEmptyChunk` from a single element.

@category constructors
@since 2.0.0

## of

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `of(= of;
const fromIterable = self => isChunk(self)`

JSDoc:

Creates a new `Chunk` from an iterable collection of values.

@category constructors
@since 2.0.0

## unsafeFromArray

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `unsafeFromArray(= unsafeFromArray;
const unsafeFromNonEmptyArray = self => unsafeFromArray(self)`

JSDoc:

Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty
(`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the
non-empty property is preserved.

@category conversions
@since 2.0.0
/
const toArray = exports.toArray = toArray_;
const toReadonlyArray_ = self => {
  switch (self.backing._tag) {
    case "IEmpty":
      {
        return emptyArray;
      }
    case "IArray":
      {
        return self.backing.array;
      }
    default:
      {
        const arr = new Array(self.length);
        copyToArray(self, arr, 0);
        self.backing = {
          _tag: "IArray",
          array: arr
        };
        self.left = _empty;
        self.right = _empty;
        self.depth = 0;
        return arr;
      }
  }
};
/**
Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is
non-empty (`NonEmptyChunk`), the function will return a
`NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.

@category conversions
@since 2.0.0
/
const toReadonlyArray = exports.toReadonlyArray = toReadonlyArray_;
const reverseChunk = self => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray":
      {
        return makeChunk({
          _tag: "IArray",
          array: RA.reverse(self.backing.array)
        });
      }
    case "IConcat":
      {
        return makeChunk({
          _tag: "IConcat",
          left: reverse(self.backing.right),
          right: reverse(self.backing.left)
        });
      }
    case "ISlice":
      return unsafeFromArray(RA.reverse(toReadonlyArray(self)));
  }
};
/**
Reverses the order of elements in a `Chunk`.
Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.

**Example**

```ts
import { Chunk } from "effect"

const chunk = Chunk.make(1, 2, 3)
const result = Chunk.reverse(chunk)

console.log(result)
// { _id: 'Chunk', values: [ 3, 2, 1 ] }
```

@since 2.0.0
@category elements
/
const reverse = exports.reverse = reverseChunk;
/**
This function provides a safe way to read a value at a particular index from a `Chunk`.

@category elements
@since 2.0.0
/
const get = exports.get = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => index < 0 || index >= self.length ? O.none() : O.some(unsafeGet(self, index)));
/**
Wraps an array into a chunk without copying, unsafe on mutable arrays

@since 2.0.0
@category unsafe
/
const unsafeFromArray = self => self.length === 0 ? empty() : self.length === 1 ? of(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
/**
Wraps an array into a chunk without copying, unsafe on mutable arrays

@since 2.0.0
@category unsafe

## unsafeFromNonEmptyArray

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `unsafeFromNonEmptyArray(= unsafeFromNonEmptyArray;
const unsafeGet = exports.unsafeGet = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Gets an element unsafely, will throw on out of bounds

@since 2.0.0
@category unsafe

## compact

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `compact(= compact;
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Appends the specified element to the end of the `Chunk`.

@category concatenating
@since 2.0.0
/
const append = exports.append = /*#__PURE__*/(0, _Function.dual)(2, (self, a) => appendAll(self, of(a)));
/**
Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.

@category concatenating
@since 2.0.0
/
const prepend = exports.prepend = /*#__PURE__*/(0, _Function.dual)(2, (self, elem) => appendAll(of(elem), self));
/**
Takes the first up to `n` elements from the chunk

@since 2.0.0
/
const take = exports.take = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  if (n <= 0) {
    return _empty;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice":
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            length: n,
            offset: self.backing.offset
          });
        }
      case "IConcat":
        {
          if (n > self.left.length) {
            return makeChunk({
              _tag: "IConcat",
              left: self.left,
              right: take(self.right, n - self.left.length)
            });
          }
          return take(self.left, n);
        }
      default:
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: 0,
            length: n
          });
        }
    }
  }
});
/**
Drops the first up to `n` elements from the chunk

@since 2.0.0
/
const drop = exports.drop = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty;
  } else {
    switch (self.backing._tag) {
      case "ISlice":
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            offset: self.backing.offset + n,
            length: self.backing.length - n
          });
        }
      case "IConcat":
        {
          if (n > self.left.length) {
            return drop(self.right, n - self.left.length);
          }
          return makeChunk({
            _tag: "IConcat",
            left: drop(self.left, n),
            right: self.right
          });
        }
      default:
        {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: n,
            length: self.length - n
          });
        }
    }
  }
});
/**
Drops the last `n` elements.

@since 2.0.0
/
const dropRight = exports.dropRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => take(self, Math.max(0, self.length - n)));
/**
Drops all elements so long as the predicate returns true.

@since 2.0.0
/
const dropWhile = exports.dropWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const arr = toReadonlyArray(self);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop(self, i);
});
/**
Prepends the specified prefix chunk to the beginning of the specified chunk.
If either chunk is non-empty, the result is also a non-empty chunk.

**Example**

```ts
import { Chunk } from "effect"

const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make("a", "b")), Chunk.toArray)

console.log(result)
// [ "a", "b", 1, 2 ]
```

@category concatenating
@since 2.0.0
/
const prependAll = exports.prependAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => appendAll(that, self));
/**
Concatenates two chunks, combining their elements.
If either chunk is non-empty, the result is also a non-empty chunk.

**Example**

```ts
import { Chunk } from "effect"

const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray)

console.log(result)
// [ 1, 2, "a", "b" ]
```

@category concatenating
@since 2.0.0
/
const appendAll = exports.appendAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff = that.depth - self.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
/**
Returns a filtered and mapped subset of the elements.

@since 2.0.0
@category filtering
/
const filterMap = exports.filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => unsafeFromArray(RA.filterMap(self, f)));
/**
Returns a filtered and mapped subset of the elements.

@since 2.0.0
@category filtering
/
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => unsafeFromArray(RA.filter(self, predicate)));
/**
Transforms all elements of the chunk for as long as the specified function returns some value

@since 2.0.0
@category filtering
/
const filterMapWhile = exports.filterMapWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => unsafeFromArray(RA.filterMapWhile(self, f)));
/**
Filter out optional values

@since 2.0.0
@category filtering
/
const compact = self => filterMap(self, _Function.identity);
/**
Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.

@since 2.0.0
@category sequencing

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `isEmpty(= isEmpty;
const isNonEmpty = self => self.length > 0;
/**
 * Returns the first element of this chunk if it exists.
 *
 * @since 2.0.0
 * @category elements
 */
exports.isNonEmpty = isNonEmpty;
const head = exports.head = /*#__PURE__*/get(0)`

JSDoc:

Iterates over each element of a `Chunk` and applies a function to it.

**Details**

This function processes every element of the given `Chunk`, calling the
provided function `f` on each element. It does not return a new value;
instead, it is primarily used for side effects, such as logging or
accumulating data in an external variable.

@since 2.0.0
@category combinators
/
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => toReadonlyArray(self).forEach(f));
/**
Flattens a chunk of chunks into a single chunk by concatenating all chunks.

@since 2.0.0
@category sequencing
/
const flatten = exports.flatten = /*#__PURE__*/flatMap(_Function.identity);
/**
Groups elements in chunks of up to `n` elements.

@since 2.0.0
@category elements
/
const chunksOf = exports.chunksOf = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const gr = [];
  let current = [];
  toReadonlyArray(self).forEach(a => {
    current.push(a);
    if (current.length >= n) {
      gr.push(unsafeFromArray(current));
      current = [];
    }
  });
  if (current.length > 0) {
    gr.push(unsafeFromArray(current));
  }
  return unsafeFromArray(gr);
});
/**
Creates a Chunk of unique values that are included in all given Chunks.

The order and references of result values are determined by the Chunk.

@since 2.0.0
@category elements
/
const intersection = exports.intersection = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => unsafeFromArray(RA.intersection(toReadonlyArray(self), toReadonlyArray(that))));
/**
Determines if the chunk is empty.

@since 2.0.0
@category elements
/
const isEmpty = self => self.length === 0;
/**
Determines if the chunk is not empty.

@since 2.0.0
@category elements

## unsafeHead

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `unsafeHead(= unsafeHead;
const headNonEmpty = exports.headNonEmpty = unsafeHead;
/**
 * Returns the last element of this chunk if it exists.
 *
 * @since 2.0.0
 * @category elements
 */
const last = self => get(self, self.length - 1)`

JSDoc:

Returns the first element of this chunk.

It will throw an error if the chunk is empty.

@since 2.0.0
@category unsafe
/
const unsafeHead = self => unsafeGet(self, 0);
/**
Returns the first element of this non empty chunk.

@since 2.0.0
@category elements

## last

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `last(= last;
const unsafeLast = self => unsafeGet(self, self.length - 1)`

JSDoc:

Returns the last element of this chunk.

It will throw an error if the chunk is empty.

@since 2.0.0
@category unsafe

## unsafeLast

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `unsafeLast(= unsafeLast;
const lastNonEmpty = exports.lastNonEmpty = unsafeLast;
/**
 * Transforms the elements of a chunk using the specified mapping function.
 * If the input chunk is non-empty, the resulting chunk will also be non-empty.
 *
 * **Example**
 *
 * ```ts
 * import { Chunk } from "effect"
 *
 * const result = Chunk.map(Chunk.make(1, 2)`

JSDoc:

Returns the last element of this non empty chunk.

@since 3.4.0
@category elements

## separate

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `separate(= separate;
const size = self => self.length;
/**
 * Sort the elements of a Chunk in increasing order, creating a new Chunk.
 *
 * @since 2.0.0
 * @category sorting
 */
exports.size = size;
const sort = exports.sort = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Statefully maps over the chunk, producing new elements of type `B`.

@since 2.0.0
@category folding
/
const mapAccum = exports.mapAccum = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => {
  const [s1, as] = RA.mapAccum(self, s, f);
  return [s1, unsafeFromArray(as)];
});
/**
Separate elements based on a predicate that also exposes the index of the element.

@category filtering
@since 2.0.0
/
const partition = exports.partition = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => (0, _Function.pipe)(RA.partition(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
/**
Partitions the elements of this chunk into two chunks using f.

@category filtering
@since 2.0.0
/
const partitionMap = exports.partitionMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(RA.partitionMap(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
/**
Partitions the elements of this chunk into two chunks.

@category filtering
@since 2.0.0
/
const separate = self => (0, _Function.pipe)(RA.separate(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);
/**
Retireves the size of the chunk

@since 2.0.0
@category elements

## tail

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `tail(= tail;
const tailNonEmpty = self => drop(self, 1)`

JSDoc:

@since 2.0.0
@category sorting
/
const sortWith = exports.sortWith = /*#__PURE__*/(0, _Function.dual)(3, (self, f, order) => sort(self, Order.mapInput(order, f)));
/**
 Returns two splits of this chunk at the specified index.

@since 2.0.0
@category splitting
/
const splitAt = exports.splitAt = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => [take(self, n), drop(self, n)]);
/**
Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.
The value of `n` must be `>= 1`.

@category splitting
@since 2.0.0
/
const splitNonEmptyAt = exports.splitNonEmptyAt = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [self, empty()] : [take(self, _n), drop(self, _n)];
});
/**
Splits this chunk into `n` equally sized chunks.

@since 2.0.0
@category splitting
/
const split = exports.split = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => chunksOf(self, Math.ceil(self.length / Math.floor(n))));
/**
Splits this chunk on the first element that matches this predicate.
Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.

@category splitting
@since 2.0.0
/
const splitWhere = exports.splitWhere = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt(self, i);
});
/**
Returns every elements after the first.

@since 2.0.0
@category elements
/
const tail = self => self.length > 0 ? O.some(drop(self, 1)) : O.none();
/**
Returns every elements after the first.

@since 2.0.0
@category elements

## tailNonEmpty

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `tailNonEmpty(= tailNonEmpty;
const takeRight = exports.takeRight = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Takes the last `n` elements.

@since 2.0.0
@category elements

## dedupe

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `dedupe(= dedupe;
const dedupeAdjacent = self => unsafeFromArray(RA.dedupeAdjacent(self)`

JSDoc:

Takes all elements so long as the predicate returns true.

@since 2.0.0
@category elements
/
const takeWhile = exports.takeWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
/**
Creates a Chunks of unique values, in order, from all given Chunks.

@since 2.0.0
@category elements
/
const union = exports.union = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => unsafeFromArray(RA.union(toReadonlyArray(self), toReadonlyArray(that))));
/**
Remove duplicates from an array, keeping the first occurrence of an element.

@since 2.0.0
@category elements
/
const dedupe = self => unsafeFromArray(RA.dedupe(toReadonlyArray(self)));
/**
Deduplicates adjacent elements that are identical.

@since 2.0.0
@category filtering

## dedupeAdjacent

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `dedupeAdjacent(= dedupeAdjacent;
const unzip = self => {
  const [left, right] = RA.unzip(self)`

JSDoc:

Takes a `Chunk` of pairs and return two corresponding `Chunk`s.

Note: The function is reverse of `zip`.

@since 2.0.0
@category elements

## unzip

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `unzip(= unzip;
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Zips this chunk pointwise with the specified chunk using the specified combiner.

@since 2.0.0
@category zipping

## range

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `range(= range;
const contains = exports.contains = RA.contains;
/**
 * Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.
 *
 * @category elements
 * @since 2.0.0
 */
const containsWith = exports.containsWith = RA.containsWith;
/**
 * Returns the first element that satisfies the specified
 * predicate, or `None` if no such element exists.
 *
 * @category elements
 * @since 2.0.0
 */
const findFirst = exports.findFirst = RA.findFirst;
/**
 * Return the first index for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const findFirstIndex = exports.findFirstIndex = RA.findFirstIndex;
/**
 * Find the last element for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const findLast = exports.findLast = RA.findLast;
/**
 * Return the last index for which a predicate holds.
 *
 * @category elements
 * @since 2.0.0
 */
const findLastIndex = exports.findLastIndex = RA.findLastIndex;
/**
 * Check if a predicate holds true for every `Chunk` element.
 *
 * @category elements
 * @since 2.0.0
 */
const every = exports.every = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Zips this chunk pointwise with the specified chunk.

@since 2.0.0
@category zipping
/
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));
/**
Delete the element at the specified index, creating a new `Chunk`.

@since 2.0.0
/
const remove = exports.remove = /*#__PURE__*/(0, _Function.dual)(2, (self, i) => {
  if (i < 0 || i >= self.length) return self;
  return unsafeFromArray(RA.remove(toReadonlyArray(self), i));
});
/**
@since 3.16.0
/
const removeOption = exports.removeOption = /*#__PURE__*/(0, _Function.dual)(2, (self, i) => {
  if (i < 0 || i >= self.length) return O.none();
  return O.some(unsafeFromArray(RA.remove(toReadonlyArray(self), i)));
});
/**
@since 2.0.0
/
const modifyOption = exports.modifyOption = /*#__PURE__*/(0, _Function.dual)(3, (self, i, f) => {
  if (i < 0 || i >= self.length) return O.none();
  return O.some(unsafeFromArray(RA.modify(toReadonlyArray(self), i, f)));
});
/**
Apply a function to the element at the specified index, creating a new `Chunk`,
or returning the input if the index is out of bounds.

@since 2.0.0
/
const modify = exports.modify = /*#__PURE__*/(0, _Function.dual)(3, (self, i, f) => O.getOrElse(modifyOption(self, i, f), () => self));
/**
Change the element at the specified index, creating a new `Chunk`,
or returning the input if the index is out of bounds.

@since 2.0.0
/
const replace = exports.replace = /*#__PURE__*/(0, _Function.dual)(3, (self, i, b) => modify(self, i, () => b));
/**
@since 2.0.0
/
const replaceOption = exports.replaceOption = /*#__PURE__*/(0, _Function.dual)(3, (self, i, b) => modifyOption(self, i, () => b));
/**
Return a Chunk of length n with element i initialized with f(i).

**Note**. `n` is normalized to an integer >= 1.

@category constructors
@since 2.0.0
/
const makeBy = exports.makeBy = /*#__PURE__*/(0, _Function.dual)(2, (n, f) => fromIterable(RA.makeBy(n, f)));
/**
Create a non empty `Chunk` containing a range of integers, including both endpoints.

@category constructors
@since 2.0.0
/
const range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : of(start);
// -------------------------------------------------------------------------------------
// re-exports from ReadonlyArray
// -------------------------------------------------------------------------------------
/**
Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.

@category elements
@since 2.0.0

## differenceWith

Source: `my-backend/node_modules/effect/dist/cjs/Chunk.js`

Signature: `differenceWith(= differenceWith;
const difference = exports.difference = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Check if a predicate holds true for some `Chunk` element.

@category elements
@since 2.0.0
/
const some = exports.some = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => RA.fromIterable(self).some(predicate));
/**
Joins the elements together with "sep" in the middle.

@category folding
@since 2.0.0
/
const join = exports.join = RA.join;
/**
@category folding
@since 2.0.0
/
const reduce = exports.reduce = RA.reduce;
/**
@category folding
@since 2.0.0
/
const reduceRight = exports.reduceRight = RA.reduceRight;
/**
Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.
The order and references of result values are determined by the first `Chunk`.

@since 3.2.0
/
const differenceWith = isEquivalent => {
  return (0, _Function.dual)(2, (self, that) => unsafeFromArray(RA.differenceWith(isEquivalent)(that, self)));
};
/**
Creates a `Chunk` of values not included in the other given `Chunk`.
The order and references of result values are determined by the first `Chunk`.

@since 3.2.0

## isCron

Source: `my-backend/node_modules/effect/dist/cjs/Cron.js`

Signature: `isCron(= isCron;
const make = values => {
  const o = Object.create(CronProto)`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
@category symbols
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Cron");
const CronProto = {
  [TypeId]: TypeId,
  [Equal.symbol](that) {
    return isCron(that) && equals(this, that);
  },
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(this.tz), Hash.combine(Hash.array(Arr.fromIterable(this.seconds))), Hash.combine(Hash.array(Arr.fromIterable(this.minutes))), Hash.combine(Hash.array(Arr.fromIterable(this.hours))), Hash.combine(Hash.array(Arr.fromIterable(this.days))), Hash.combine(Hash.array(Arr.fromIterable(this.months))), Hash.combine(Hash.array(Arr.fromIterable(this.weekdays))), Hash.cached(this));
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: Arr.fromIterable(this.seconds),
      minutes: Arr.fromIterable(this.minutes),
      hours: Arr.fromIterable(this.hours),
      days: Arr.fromIterable(this.days),
      months: Arr.fromIterable(this.months),
      weekdays: Arr.fromIterable(this.weekdays)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/**
Checks if a given value is a `Cron` instance.

@since 2.0.0
@category guards
/
const isCron = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
Creates a `Cron` instance.

@since 2.0.0
@category constructors

## ParseError

Source: `my-backend/node_modules/effect/dist/cjs/Cron.js`

Signature: `ParseError(= ParseError;
const isParseError = u => (0, _Predicate.hasProperty)`

JSDoc:

@since 2.0.0
@category symbol
/
const ParseErrorTypeId = exports.ParseErrorTypeId = /*#__PURE__*/Symbol.for("effect/Cron/errors/ParseError");
/**
Represents a checked exception which occurs when decoding fails.

@since 2.0.0
@category models
/
class ParseError extends /*#__PURE__*/Data.TaggedError("CronParseError") {
  /**
@since 2.0.0
/
  [ParseErrorTypeId] = ParseErrorTypeId;
}
/**
Returns `true` if the specified value is an `ParseError`, `false` otherwise.

@since 2.0.0
@category guards

## isParseError

Source: `my-backend/node_modules/effect/dist/cjs/Cron.js`

Signature: `isParseError(= isParseError;
const parse = (cron, tz)`

JSDoc:

Parses a cron expression into a `Cron` instance.

@example
```ts
import * as assert from "node:assert"
import { Cron, Either } from "effect"

// At 04:00 on every day-of-month from 8 through 14.
assert.deepStrictEqual(Cron.parse("0 0 4 8-14 * *"), Either.right(Cron.make({
  seconds: [0],
  minutes: [0],
  hours: [4],
  days: [8, 9, 10, 11, 12, 13, 14],
  months: [],
  weekdays: []
})))
```

@since 2.0.0
@category constructors

## parse

Source: `my-backend/node_modules/effect/dist/cjs/Cron.js`

Signature: `parse(= parse;
const unsafeParse = (cron, tz)`

JSDoc:

Parses a cron expression into a `Cron` instance.

**Details**

This function takes a cron expression as a string and attempts to parse it
into a `Cron` instance. If the expression is valid, the resulting `Cron`
instance will represent the schedule defined by the cron expression.

If the expression is invalid, the function throws a `ParseError`.

You can optionally provide a time zone (`tz`) to interpret the cron
expression in a specific time zone. If no time zone is provided, the cron
expression will use the default time zone.

@example
```ts
import { Cron } from "effect"

// At 04:00 on every day-of-month from 8 through 14.
console.log(Cron.unsafeParse("0 4 8-14 * *"))
// Output:
// {
//   _id: 'Cron',
//   tz: { _id: 'Option', _tag: 'None' },
//   seconds: [ 0 ],
//   minutes: [ 0 ],
//   hours: [ 4 ],
//   days: [
//      8,  9, 10, 11,
//     12, 13, 14
//   ],
//   months: [],
//   weekdays: []
// }
```

@since 2.0.0
@category constructors

## unsafeParse

Source: `my-backend/node_modules/effect/dist/cjs/Cron.js`

Signature: `unsafeParse(= unsafeParse;
const match = (cron, date)`

JSDoc:

Checks if a given `Date` falls within an active `Cron` time window.

@example
```ts
import * as assert from "node:assert"
import { Cron, Either } from "effect"

const cron = Either.getOrThrow(Cron.parse("0 4 8-14 * *"))
assert.deepStrictEqual(Cron.match(cron, new Date("2021-01-08 04:00:00")), true)
assert.deepStrictEqual(Cron.match(cron, new Date("2021-01-08 05:00:00")), false)
```

@throws `IllegalArgumentException` if the given `DateTime.Input` is invalid.

@since 2.0.0

## next

Source: `my-backend/node_modules/effect/dist/cjs/Cron.js`

Signature: `next(= next;
const sequence = function* (cron, startFrom)`

JSDoc:

Returns the next run `Date` for the given `Cron` instance.

Uses the current time as a starting point if no value is provided for `now`.

@example
```ts
import * as assert from "node:assert"
import { Cron, Either } from "effect"

const after = new Date("2021-01-01 00:00:00")
const cron = Either.getOrThrow(Cron.parse("0 4 8-14 * *"))
assert.deepStrictEqual(Cron.next(cron, after), new Date("2021-01-08 04:00:00"))
```

@throws `IllegalArgumentException` if the given `DateTime.Input` is invalid.
@throws `Error` if the next run date cannot be found within 10,000 iterations.

@since 2.0.0
/
const next = (cron, startFrom) => {
  const tz = Option.getOrUndefined(cron.tz);
  const zoned = dateTime.unsafeMakeZoned(startFrom ?? new Date(), {
    timeZone: tz
  });
  const utc = tz !== undefined && dateTime.isTimeZoneNamed(tz) && tz.id === "UTC";
  const adjustDst = utc ? _Function.constVoid : current => {
    const adjusted = dateTime.unsafeMakeZoned(current, {
      timeZone: zoned.zone,
      adjustForTimeZone: true
    }).pipe(dateTime.toDate);
    // TODO: This implementation currently only skips forward when transitioning into daylight savings time.
    const drift = current.getTime() - adjusted.getTime();
    if (drift > 0) {
      current.setTime(current.getTime() + drift);
    }
  };
  const result = dateTime.mutate(zoned, current => {
    current.setUTCSeconds(current.getUTCSeconds() + 1, 0);
    for (let i = 0; i < 10_000; i++) {
      if (cron.seconds.size !== 0) {
        const currentSecond = current.getUTCSeconds();
        const nextSecond = cron.next.second[currentSecond];
        if (nextSecond === undefined) {
          current.setUTCMinutes(current.getUTCMinutes() + 1, cron.first.second);
          adjustDst(current);
          continue;
        }
        if (nextSecond > currentSecond) {
          current.setUTCSeconds(nextSecond);
          adjustDst(current);
          continue;
        }
      }
      if (cron.minutes.size !== 0) {
        const currentMinute = current.getUTCMinutes();
        const nextMinute = cron.next.minute[currentMinute];
        if (nextMinute === undefined) {
          current.setUTCHours(current.getUTCHours() + 1, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
        if (nextMinute > currentMinute) {
          current.setUTCMinutes(nextMinute, cron.first.second);
          adjustDst(current);
          continue;
        }
      }
      if (cron.hours.size !== 0) {
        const currentHour = current.getUTCHours();
        const nextHour = cron.next.hour[currentHour];
        if (nextHour === undefined) {
          current.setUTCDate(current.getUTCDate() + 1);
          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
        if (nextHour > currentHour) {
          current.setUTCHours(nextHour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
      }
      if (cron.weekdays.size !== 0 || cron.days.size !== 0) {
        let a = Infinity;
        let b = Infinity;
        if (cron.weekdays.size !== 0) {
          const currentWeekday = current.getUTCDay();
          const nextWeekday = cron.next.weekday[currentWeekday];
          a = nextWeekday === undefined ? 7 - currentWeekday + cron.first.weekday : nextWeekday - currentWeekday;
        }
        if (cron.days.size !== 0 && a !== 0) {
          const currentDay = current.getUTCDate();
          const nextDay = cron.next.day[currentDay];
          b = nextDay === undefined ? daysInMonth(current) - currentDay + cron.first.day : nextDay - currentDay;
        }
        const addDays = Math.min(a, b);
        if (addDays !== 0) {
          current.setUTCDate(current.getUTCDate() + addDays);
          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
      }
      if (cron.months.size !== 0) {
        const currentMonth = current.getUTCMonth() + 1;
        const nextMonth = cron.next.month[currentMonth];
        if (nextMonth === undefined) {
          current.setUTCFullYear(current.getUTCFullYear() + 1);
          current.setUTCMonth(cron.first.month, cron.first.day);
          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
        if (nextMonth > currentMonth) {
          current.setUTCMonth(nextMonth - 1, cron.first.day);
          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
      }
      return;
    }
    throw new Error("Unable to find next cron date");
  });
  return dateTime.toDateUtc(result);
};
/**
Returns an `IterableIterator` which yields the sequence of `Date`s that match the `Cron` instance.

@since 2.0.0

## sequence

Source: `my-backend/node_modules/effect/dist/cjs/Cron.js`

Signature: `sequence(= sequence;
const Equivalence = exports.Equivalence = /*#__PURE__*/equivalence.make((self, that)`

JSDoc:

@category instances
@since 2.0.0

## unsafeStruct

Source: `my-backend/node_modules/effect/dist/cjs/Data.js`

Signature: `unsafeStruct(= unsafeStruct;
const tuple = (...as)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { Data, Equal } from "effect"

const alice = Data.struct({ name: "Alice", age: 30 })

const bob = Data.struct({ name: "Bob", age: 40 })

assert.deepStrictEqual(Equal.equals(alice, alice), true)
assert.deepStrictEqual(Equal.equals(alice, Data.struct({ name: "Alice", age: 30 })), true)

assert.deepStrictEqual(Equal.equals(alice, { name: "Alice", age: 30 }), false)
assert.deepStrictEqual(Equal.equals(alice, bob), false)
```

@category constructors
@since 2.0.0
/
const struct = exports.struct = internal.struct;
/**
@category constructors
@since 2.0.0
/
const unsafeStruct = as => Object.setPrototypeOf(as, _effectable.StructuralPrototype);
/**
@example
```ts
import * as assert from "node:assert"
import { Data, Equal } from "effect"

const alice = Data.tuple("Alice", 30)

const bob = Data.tuple("Bob", 40)

assert.deepStrictEqual(Equal.equals(alice, alice), true)
assert.deepStrictEqual(Equal.equals(alice, Data.tuple("Alice", 30)), true)

assert.deepStrictEqual(Equal.equals(alice, ["Alice", 30]), false)
assert.deepStrictEqual(Equal.equals(alice, bob), false)
```

@category constructors
@since 2.0.0

## tuple

Source: `my-backend/node_modules/effect/dist/cjs/Data.js`

Signature: `tuple(= tuple;
const array = as => unsafeArray(as.slice(0)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { Data, Equal } from "effect"

const alice = Data.struct({ name: "Alice", age: 30 })
const bob = Data.struct({ name: "Bob", age: 40 })

const persons = Data.array([alice, bob])

assert.deepStrictEqual(
  Equal.equals(
    persons,
    Data.array([
      Data.struct({ name: "Alice", age: 30 }),
      Data.struct({ name: "Bob", age: 40 })
    ])
  ),
  true
)
```

@category constructors
@since 2.0.0

## array

Source: `my-backend/node_modules/effect/dist/cjs/Data.js`

Signature: `array(= array;
const unsafeArray = as => Object.setPrototypeOf(as, internal.ArrayProto)`

JSDoc:

@category constructors
@since 2.0.0

## tagged

Source: `my-backend/node_modules/effect/dist/cjs/Data.js`

Signature: `tagged(= tagged;
const Class = exports.Class = internal.Structural;
/**
 * Provides a Tagged constructor for a Case Class.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { Data, Equal } from "effect"
 *
 * class Person extends Data.TaggedClass("Person")`

JSDoc:

Provides a tagged constructor for the specified `Case`.

@example
```ts
import * as assert from "node:assert"
import { Data } from "effect"

interface Person {
  readonly _tag: "Person" // the tag
  readonly name: string
}

const Person = Data.tagged<Person>("Person")

const mike = Person({ name: "Mike" })

assert.deepEqual(mike, { _tag: "Person", name: "Mike" })
```

@since 2.0.0
@category constructors
/
const tagged = tag => args => {
  const value = args === undefined ? Object.create(_effectable.StructuralPrototype) : struct(args);
  value._tag = tag;
  return value;
};
/**
Provides a constructor for a Case Class.

@example
```ts
import * as assert from "node:assert"
import { Data, Equal } from "effect"

class Person extends Data.Class<{ readonly name: string }> {}

// Creating instances of Person
const mike1 = new Person({ name: "Mike" })
const mike2 = new Person({ name: "Mike" })
const john = new Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)
```

@since 2.0.0
@category constructors

## TaggedClass

Source: `my-backend/node_modules/effect/dist/cjs/Data.js`

Signature: `TaggedClass(= TaggedClass;
const Structural = exports.Structural = internal.Structural;
/**
 * Create a constructor for a tagged union of `Data` structs.
 *
 * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to
 * the constructor.
 *
 * @example
 * ```ts
 * import { Data } from "effect"
 *
 * const { BadRequest, NotFound } = Data.taggedEnum<
 *   | { readonly _tag: "BadRequest"; readonly status: 400; readonly message: string }
 *   | { readonly _tag: "NotFound"; readonly status: 404; readonly message: string }
 * >()`

JSDoc:

@since 2.0.0
@category constructors

## CurrentTimeZone

Source: `my-backend/node_modules/effect/dist/cjs/DateTime.js`

Signature: `CurrentTimeZone(= CurrentTimeZone;
const setZoneCurrent = self => Effect.map(CurrentTimeZone, zone => setZone(self, zone)`

JSDoc:

@since 3.6.0
@category type ids
/
const TypeId = exports.TypeId = Internal.TypeId;
/**
@since 3.6.0
@category type ids
/
const TimeZoneTypeId = exports.TimeZoneTypeId = Internal.TimeZoneTypeId;
// =============================================================================
// guards
// =============================================================================
/**
@since 3.6.0
@category guards
/
const isDateTime = exports.isDateTime = Internal.isDateTime;
/**
@since 3.6.0
@category guards
/
const isTimeZone = exports.isTimeZone = Internal.isTimeZone;
/**
@since 3.6.0
@category guards
/
const isTimeZoneOffset = exports.isTimeZoneOffset = Internal.isTimeZoneOffset;
/**
@since 3.6.0
@category guards
/
const isTimeZoneNamed = exports.isTimeZoneNamed = Internal.isTimeZoneNamed;
/**
@since 3.6.0
@category guards
/
const isUtc = exports.isUtc = Internal.isUtc;
/**
@since 3.6.0
@category guards
/
const isZoned = exports.isZoned = Internal.isZoned;
// =============================================================================
// instances
// =============================================================================
/**
@since 3.6.0
@category instances
/
const Equivalence = exports.Equivalence = Internal.Equivalence;
/**
@since 3.6.0
@category instances
/
const Order = exports.Order = Internal.Order;
/**
@since 3.6.0
/
const clamp = exports.clamp = Internal.clamp;
// =============================================================================
// constructors
// =============================================================================
/**
Create a `DateTime` from a `Date`.

If the `Date` is invalid, an `IllegalArgumentException` will be thrown.

@since 3.6.0
@category constructors
/
const unsafeFromDate = exports.unsafeFromDate = Internal.unsafeFromDate;
/**
Create a `DateTime` from one of the following:

- A `DateTime`
- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)
- The `number` of milliseconds since the Unix epoch
- An object with the parts of a date
- A `string` that can be parsed by `Date.parse`

@since 3.6.0
@category constructors
@example
```ts
import { DateTime } from "effect"

// from Date
DateTime.unsafeMake(new Date())

// from parts
DateTime.unsafeMake({ year: 2024 })

// from string
DateTime.unsafeMake("2024-01-01")
```
/
const unsafeMake = exports.unsafeMake = Internal.unsafeMake;
/**
Create a `DateTime.Zoned` using `DateTime.unsafeMake` and a time zone.

The input is treated as UTC and then the time zone is attached, unless
`adjustForTimeZone` is set to `true`. In that case, the input is treated as
already in the time zone.

@since 3.6.0
@category constructors
@example
```ts
import { DateTime } from "effect"

DateTime.unsafeMakeZoned(new Date(), { timeZone: "Europe/London" })
```
/
const unsafeMakeZoned = exports.unsafeMakeZoned = Internal.unsafeMakeZoned;
/**
Create a `DateTime.Zoned` using `DateTime.make` and a time zone.

The input is treated as UTC and then the time zone is attached.

If the date time input or time zone is invalid, `None` will be returned.

@since 3.6.0
@category constructors
@example
```ts
import { DateTime } from "effect"

DateTime.makeZoned(new Date(), { timeZone: "Europe/London" })
```
/
const makeZoned = exports.makeZoned = Internal.makeZoned;
/**
Create a `DateTime` from one of the following:

- A `DateTime`
- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)
- The `number` of milliseconds since the Unix epoch
- An object with the parts of a date
- A `string` that can be parsed by `Date.parse`

If the input is invalid, `None` will be returned.

@since 3.6.0
@category constructors
@example
```ts
import { DateTime } from "effect"

// from Date
DateTime.make(new Date())

// from parts
DateTime.make({ year: 2024 })

// from string
DateTime.make("2024-01-01")
```
/
const make = exports.make = Internal.make;
/**
Create a `DateTime.Zoned` from a string.

It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.

@since 3.6.0
@category constructors
/
const makeZonedFromString = exports.makeZonedFromString = Internal.makeZonedFromString;
/**
Get the current time using the `Clock` service and convert it to a `DateTime`.

@since 3.6.0
@category constructors
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
})
```
/
const now = exports.now = Internal.now;
/**
Get the current time using the `Clock` service.

@since 3.14.0
@category constructors
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.nowAsDate
})
```
/
const nowAsDate = exports.nowAsDate = Internal.nowAsDate;
/**
Get the current time using `Date.now`.

@since 3.6.0
@category constructors
/
const unsafeNow = exports.unsafeNow = Internal.unsafeNow;
// =============================================================================
// time zones
// =============================================================================
/**
For a `DateTime` returns a new `DateTime.Utc`.

@since 3.13.0
@category time zones
@example
```ts
import { DateTime } from "effect"

const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })

// set as UTC
const utc: DateTime.Utc = DateTime.toUtc(now)
```
/
const toUtc = exports.toUtc = Internal.toUtc;
/**
Set the time zone of a `DateTime`, returning a new `DateTime.Zoned`.

@since 3.6.0
@category time zones
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")

  // set the time zone
  const zoned: DateTime.Zoned = DateTime.setZone(now, zone)
})
```
/
const setZone = exports.setZone = Internal.setZone;
/**
Add a fixed offset time zone to a `DateTime`.

The offset is in milliseconds.

@since 3.6.0
@category time zones
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now

  // set the offset time zone in milliseconds
  const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)
})
```
/
const setZoneOffset = exports.setZoneOffset = Internal.setZoneOffset;
/**
Attempt to create a named time zone from a IANA time zone identifier.

If the time zone is invalid, an `IllegalArgumentException` will be thrown.

@since 3.6.0
@category time zones
/
const zoneUnsafeMakeNamed = exports.zoneUnsafeMakeNamed = Internal.zoneUnsafeMakeNamed;
/**
Create a fixed offset time zone.

@since 3.6.0
@category time zones
/
const zoneMakeOffset = exports.zoneMakeOffset = Internal.zoneMakeOffset;
/**
Create a named time zone from a IANA time zone identifier. If the time zone
is invalid, `None` will be returned.

@since 3.6.0
@category time zones
/
const zoneMakeNamed = exports.zoneMakeNamed = Internal.zoneMakeNamed;
/**
Create a named time zone from a IANA time zone identifier. If the time zone
is invalid, it will fail with an `IllegalArgumentException`.

@since 3.6.0
@category time zones
/
const zoneMakeNamedEffect = exports.zoneMakeNamedEffect = Internal.zoneMakeNamedEffect;
/**
Create a named time zone from the system's local time zone.

@since 3.6.0
@category time zones
/
const zoneMakeLocal = exports.zoneMakeLocal = Internal.zoneMakeLocal;
/**
Try parse a TimeZone from a string

@since 3.6.0
@category time zones
/
const zoneFromString = exports.zoneFromString = Internal.zoneFromString;
/**
Format a `TimeZone` as a string.

@since 3.6.0
@category time zones
@example
```ts
import { DateTime, Effect } from "effect"

// Outputs "+03:00"
DateTime.zoneToString(DateTime.zoneMakeOffset(3 * 60 * 60 * 1000))

// Outputs "Europe/London"
DateTime.zoneToString(DateTime.zoneUnsafeMakeNamed("Europe/London"))
```
/
const zoneToString = exports.zoneToString = Internal.zoneToString;
/**
Set the time zone of a `DateTime` from an IANA time zone identifier. If the
time zone is invalid, `None` will be returned.

@since 3.6.0
@category time zones
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  // set the time zone, returns an Option
  DateTime.setZoneNamed(now, "Europe/London")
})
```
/
const setZoneNamed = exports.setZoneNamed = Internal.setZoneNamed;
/**
Set the time zone of a `DateTime` from an IANA time zone identifier. If the
time zone is invalid, an `IllegalArgumentException` will be thrown.

@since 3.6.0
@category time zones
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  // set the time zone
  DateTime.unsafeSetZoneNamed(now, "Europe/London")
})
```
/
const unsafeSetZoneNamed = exports.unsafeSetZoneNamed = Internal.unsafeSetZoneNamed;
// =============================================================================
// comparisons
// =============================================================================
/**
Calulate the difference between two `DateTime` values, returning the number
of milliseconds the `other` DateTime is from `self`.

If `other` is *after* `self`, the result will be a positive number.

@since 3.6.0
@category comparisons
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns 60000
  DateTime.distance(now, other)
})
```
/
const distance = exports.distance = Internal.distance;
/**
Calulate the difference between two `DateTime` values.

If the `other` DateTime is before `self`, the result will be a negative
`Duration`, returned as a `Left`.

If the `other` DateTime is after `self`, the result will be a positive
`Duration`, returned as a `Right`.

@since 3.6.0
@category comparisons
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns Either.right(Duration.minutes(1))
  DateTime.distanceDurationEither(now, other)

  // returns Either.left(Duration.minutes(1))
  DateTime.distanceDurationEither(other, now)
})
```
/
const distanceDurationEither = exports.distanceDurationEither = Internal.distanceDurationEither;
/**
Calulate the distance between two `DateTime` values.

@since 3.6.0
@category comparisons
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns Duration.minutes(1)
  DateTime.distanceDuration(now, other)
})
```
/
const distanceDuration = exports.distanceDuration = Internal.distanceDuration;
/**
@since 3.6.0
@category comparisons
/
const min = exports.min = Internal.min;
/**
@since 3.6.0
@category comparisons
/
const max = exports.max = Internal.max;
/**
@since 3.6.0
@category comparisons
/
const greaterThan = exports.greaterThan = Internal.greaterThan;
/**
@since 3.6.0
@category comparisons
/
const greaterThanOrEqualTo = exports.greaterThanOrEqualTo = Internal.greaterThanOrEqualTo;
/**
@since 3.6.0
@category comparisons
/
const lessThan = exports.lessThan = Internal.lessThan;
/**
@since 3.6.0
@category comparisons
/
const lessThanOrEqualTo = exports.lessThanOrEqualTo = Internal.lessThanOrEqualTo;
/**
@since 3.6.0
@category comparisons
/
const between = exports.between = Internal.between;
/**
@since 3.6.0
@category comparisons
/
const isFuture = exports.isFuture = Internal.isFuture;
/**
@since 3.6.0
@category comparisons
/
const unsafeIsFuture = exports.unsafeIsFuture = Internal.unsafeIsFuture;
/**
@since 3.6.0
@category comparisons
/
const isPast = exports.isPast = Internal.isPast;
/**
@since 3.6.0
@category comparisons
/
const unsafeIsPast = exports.unsafeIsPast = Internal.unsafeIsPast;
// =============================================================================
// conversions
// =============================================================================
/**
Get the UTC `Date` of a `DateTime`.

@since 3.6.0
@category conversions
/
const toDateUtc = exports.toDateUtc = Internal.toDateUtc;
/**
Convert a `DateTime` to a `Date`, applying the time zone first.

@since 3.6.0
@category conversions
/
const toDate = exports.toDate = Internal.toDate;
/**
Calculate the time zone offset of a `DateTime.Zoned` in milliseconds.

@since 3.6.0
@category conversions
/
const zonedOffset = exports.zonedOffset = Internal.zonedOffset;
/**
Calculate the time zone offset of a `DateTime` in milliseconds.

The offset is formatted as "HH:MM".

@since 3.6.0
@category conversions
/
const zonedOffsetIso = exports.zonedOffsetIso = Internal.zonedOffsetIso;
/**
Get the milliseconds since the Unix epoch of a `DateTime`.

@since 3.6.0
@category conversions
/
const toEpochMillis = exports.toEpochMillis = Internal.toEpochMillis;
/**
Remove the time aspect of a `DateTime`, first adjusting for the time
zone. It will return a `DateTime.Utc` only containing the date.

@since 3.6.0
@category conversions
@example
```ts
import { DateTime } from "effect"

// returns "2024-01-01T00:00:00Z"
DateTime.unsafeMakeZoned("2024-01-01T05:00:00Z", {
  timeZone: "Pacific/Auckland",
  adjustForTimeZone: true
}).pipe(
  DateTime.removeTime,
  DateTime.formatIso
)
```
/
const removeTime = exports.removeTime = Internal.removeTime;
// =============================================================================
// parts
// =============================================================================
/**
Get the different parts of a `DateTime` as an object.

The parts will be time zone adjusted.

@since 3.6.0
@category parts
/
const toParts = exports.toParts = Internal.toParts;
/**
Get the different parts of a `DateTime` as an object.

The parts will be in UTC.

@since 3.6.0
@category parts
/
const toPartsUtc = exports.toPartsUtc = Internal.toPartsUtc;
/**
Get a part of a `DateTime` as a number.

The part will be in the UTC time zone.

@since 3.6.0
@category parts
@example
```ts
import * as assert from "node:assert"
import { DateTime } from "effect"

const now = DateTime.unsafeMake({ year: 2024 })
const year = DateTime.getPartUtc(now, "year")
assert.strictEqual(year, 2024)
```
/
const getPartUtc = exports.getPartUtc = Internal.getPartUtc;
/**
Get a part of a `DateTime` as a number.

The part will be time zone adjusted.

@since 3.6.0
@category parts
@example
```ts
import * as assert from "node:assert"
import { DateTime } from "effect"

const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })
const year = DateTime.getPart(now, "year")
assert.strictEqual(year, 2024)
```
/
const getPart = exports.getPart = Internal.getPart;
/**
Set the different parts of a `DateTime` as an object.

The Date will be time zone adjusted.

@since 3.6.0
@category parts
/
const setParts = exports.setParts = Internal.setParts;
/**
Set the different parts of a `DateTime` as an object.

@since 3.6.0
@category parts
/
const setPartsUtc = exports.setPartsUtc = Internal.setPartsUtc;
// =============================================================================
// current time zone
// =============================================================================
/**
@since 3.11.0
@category current time zone
/
class CurrentTimeZone extends /*#__PURE__*/Context.Tag("effect/DateTime/CurrentTimeZone")() {}
/**
Set the time zone of a `DateTime` to the current time zone, which is
determined by the `CurrentTimeZone` service.

@since 3.6.0
@category current time zone
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now

  // set the time zone to "Europe/London"
  const zoned = yield* DateTime.setZoneCurrent(now)
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```

## setZoneCurrent

Source: `my-backend/node_modules/effect/dist/cjs/DateTime.js`

Signature: `setZoneCurrent(= setZoneCurrent;
const withCurrentZone = exports.withCurrentZone = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Provide the `CurrentTimeZone` to an effect.

@since 3.6.0
@category current time zone
@example
```ts
import { DateTime, Effect } from "effect"

const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")

Effect.gen(function* () {
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZone(zone))
```

## withCurrentZoneLocal

Source: `my-backend/node_modules/effect/dist/cjs/DateTime.js`

Signature: `withCurrentZoneLocal(= withCurrentZoneLocal;
const withCurrentZoneOffset = exports.withCurrentZoneOffset = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Provide the `CurrentTimeZone` to an effect, using the system's local time
zone.

@since 3.6.0
@category current time zone
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneLocal)
```
/
const withCurrentZoneLocal = effect => Effect.provideServiceEffect(effect, CurrentTimeZone, Effect.sync(zoneMakeLocal));
/**
Provide the `CurrentTimeZone` to an effect, using a offset.

@since 3.6.0
@category current time zone
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))
```

## layerCurrentZone

Source: `my-backend/node_modules/effect/dist/cjs/DateTime.js`

Signature: `layerCurrentZone(= layerCurrentZone;
const layerCurrentZoneOffset = offset => Layer.succeed(CurrentTimeZone, Internal.zoneMakeOffset(offset)`

JSDoc:

Provide the `CurrentTimeZone` to an effect using an IANA time zone
identifier.

If the time zone is invalid, it will fail with an `IllegalArgumentException`.

@since 3.6.0
@category current time zone
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the "Europe/London" time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```
/
const withCurrentZoneNamed = exports.withCurrentZoneNamed = /*#__PURE__*/(0, _Function.dual)(2, (effect, zone) => Effect.provideServiceEffect(effect, CurrentTimeZone, zoneMakeNamedEffect(zone)));
/**
Get the current time as a `DateTime.Zoned`, using the `CurrentTimeZone`.

@since 3.6.0
@category current time zone
@example
```ts
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the "Europe/London" time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
```
/
const nowInCurrentZone = exports.nowInCurrentZone = /*#__PURE__*/Effect.flatMap(now, setZoneCurrent);
// =============================================================================
// mapping
// =============================================================================
/**
Modify a `DateTime` by applying a function to a cloned `Date` instance.

The `Date` will first have the time zone applied if possible, and then be
converted back to a `DateTime` within the same time zone.

@since 3.6.0
@category mapping
/
const mutate = exports.mutate = Internal.mutate;
/**
Modify a `DateTime` by applying a function to a cloned UTC `Date` instance.

@since 3.6.0
@category mapping
/
const mutateUtc = exports.mutateUtc = Internal.mutateUtc;
/**
Transform a `DateTime` by applying a function to the number of milliseconds
since the Unix epoch.

@since 3.6.0
@category mapping
@example
```ts
import { DateTime } from "effect"

// add 10 milliseconds
DateTime.unsafeMake(0).pipe(
  DateTime.mapEpochMillis((millis) => millis + 10)
)
```
/
const mapEpochMillis = exports.mapEpochMillis = Internal.mapEpochMillis;
/**
Using the time zone adjusted `Date`, apply a function to the `Date` and
return the result.

@since 3.6.0
@category mapping
@example
```ts
import { DateTime } from "effect"

// get the time zone adjusted date in milliseconds
DateTime.unsafeMakeZoned(0, { timeZone: "Europe/London" }).pipe(
  DateTime.withDate((date) => date.getTime())
)
```
/
const withDate = exports.withDate = Internal.withDate;
/**
Using the time zone adjusted `Date`, apply a function to the `Date` and
return the result.

@since 3.6.0
@category mapping
@example
```ts
import { DateTime } from "effect"

// get the date in milliseconds
DateTime.unsafeMake(0).pipe(
  DateTime.withDateUtc((date) => date.getTime())
)
```
/
const withDateUtc = exports.withDateUtc = Internal.withDateUtc;
/**
@since 3.6.0
@category mapping
/
const match = exports.match = Internal.match;
// =============================================================================
// math
// =============================================================================
/**
Add the given `Duration` to a `DateTime`.

@since 3.6.0
@category math
@example
```ts
import { DateTime } from "effect"

// add 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.addDuration("5 minutes")
)
```
/
const addDuration = exports.addDuration = Internal.addDuration;
/**
Subtract the given `Duration` from a `DateTime`.

@since 3.6.0
@category math
@example
```ts
import { DateTime } from "effect"

// subtract 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.subtractDuration("5 minutes")
)
```
/
const subtractDuration = exports.subtractDuration = Internal.subtractDuration;
/**
Add the given `amount` of `unit`'s to a `DateTime`.

The time zone is taken into account when adding days, weeks, months, and
years.

@since 3.6.0
@category math
@example
```ts
import { DateTime } from "effect"

// add 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.add({ minutes: 5 })
)
```
/
const add = exports.add = Internal.add;
/**
Subtract the given `amount` of `unit`'s from a `DateTime`.

@since 3.6.0
@category math
@example
```ts
import { DateTime } from "effect"

// subtract 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.subtract({ minutes: 5 })
)
```
/
const subtract = exports.subtract = Internal.subtract;
/**
Converts a `DateTime` to the start of the given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

@since 3.6.0
@category math
@example
```ts
import { DateTime } from "effect"

// returns "2024-01-01T00:00:00Z"
DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(
  DateTime.startOf("day"),
  DateTime.formatIso
)
```
/
const startOf = exports.startOf = Internal.startOf;
/**
Converts a `DateTime` to the end of the given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

@since 3.6.0
@category math
@example
```ts
import { DateTime } from "effect"

// returns "2024-01-01T23:59:59.999Z"
DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(
  DateTime.endOf("day"),
  DateTime.formatIso
)
```
/
const endOf = exports.endOf = Internal.endOf;
/**
Converts a `DateTime` to the nearest given `part`.

If the part is `week`, the `weekStartsOn` option can be used to specify the
day of the week that the week starts on. The default is 0 (Sunday).

@since 3.6.0
@category math
@example
```ts
import { DateTime } from "effect"

// returns "2024-01-02T00:00:00Z"
DateTime.unsafeMake("2024-01-01T12:01:00Z").pipe(
  DateTime.nearest("day"),
  DateTime.formatIso
)
```
/
const nearest = exports.nearest = Internal.nearest;
// =============================================================================
// formatting
// =============================================================================
/**
Format a `DateTime` as a string using the `DateTimeFormat` API.

The `timeZone` option is set to the offset of the time zone.

Note: On Node versions < 22, fixed "Offset" zones will set the time zone to
"UTC" and use the adjusted `Date`.

@since 3.6.0
@category formatting
/
const format = exports.format = Internal.format;
/**
Format a `DateTime` as a string using the `DateTimeFormat` API.

It will use the system's local time zone & locale.

@since 3.6.0
@category formatting
/
const formatLocal = exports.formatLocal = Internal.formatLocal;
/**
Format a `DateTime` as a string using the `DateTimeFormat` API.

This forces the time zone to be UTC.

@since 3.6.0
@category formatting
/
const formatUtc = exports.formatUtc = Internal.formatUtc;
/**
Format a `DateTime` as a string using the `DateTimeFormat` API.

@since 3.6.0
@category formatting
/
const formatIntl = exports.formatIntl = Internal.formatIntl;
/**
Format a `DateTime` as a UTC ISO string.

@since 3.6.0
@category formatting
/
const formatIso = exports.formatIso = Internal.formatIso;
/**
Format a `DateTime` as a time zone adjusted ISO date string.

@since 3.6.0
@category formatting
/
const formatIsoDate = exports.formatIsoDate = Internal.formatIsoDate;
/**
Format a `DateTime` as a UTC ISO date string.

@since 3.6.0
@category formatting
/
const formatIsoDateUtc = exports.formatIsoDateUtc = Internal.formatIsoDateUtc;
/**
Format a `DateTime.Zoned` as a ISO string with an offset.

@since 3.6.0
@category formatting
/
const formatIsoOffset = exports.formatIsoOffset = Internal.formatIsoOffset;
/**
Format a `DateTime.Zoned` as a string.

It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.

@since 3.6.0
@category formatting
/
const formatIsoZoned = exports.formatIsoZoned = Internal.formatIsoZoned;
/**
Create a Layer from the given time zone.

@since 3.6.0
@category current time zone
/
const layerCurrentZone = zone => Layer.succeed(CurrentTimeZone, zone);
/**
Create a Layer from the given time zone offset.

@since 3.6.0
@category current time zone

## layerCurrentZoneOffset

Source: `my-backend/node_modules/effect/dist/cjs/DateTime.js`

Signature: `layerCurrentZoneOffset(= layerCurrentZoneOffset;
const layerCurrentZoneNamed = zoneId => Layer.effect(CurrentTimeZone, Internal.zoneMakeNamedEffect(zoneId)`

JSDoc:

Create a Layer from the given IANA time zone identifier.

@since 3.6.0
@category current time zone

## layerCurrentZoneNamed

Source: `my-backend/node_modules/effect/dist/cjs/DateTime.js`

Signature: `layerCurrentZoneNamed(= layerCurrentZoneNamed;
const layerCurrentZoneLocal = exports.layerCurrentZoneLocal = /*#__PURE__*/Layer.sync(CurrentTimeZone, zoneMakeLocal)`

JSDoc:

Create a Layer from the systems local time zone.

@since 3.6.0
@category current time zone

## empty

Source: `my-backend/node_modules/effect/dist/cjs/Differ.js`

Signature: `empty(= empty;
const diff = exports.diff = /*#__PURE__*/Dual.dual(3, (self, oldValue, newValue)`

JSDoc:

@since 2.0.0
@category symbol
/
const TypeId = exports.TypeId = internal.DifferTypeId;
const ChunkPatchTypeId = ChunkPatch.ChunkPatchTypeId;
const ContextPatchTypeId = ContextPatch.ContextPatchTypeId;
const HashMapPatchTypeId = HashMapPatch.HashMapPatchTypeId;
const HashSetPatchTypeId = HashSetPatch.HashSetPatchTypeId;
const OrPatchTypeId = OrPatch.OrPatchTypeId;
const ReadonlyArrayPatchTypeId = ReadonlyArrayPatch.ReadonlyArrayPatchTypeId;
/**
An empty patch that describes no changes.

@since 2.0.0
@category patch
/
const empty = self => self.empty;
/**
@since 2.0.0
@category patch

## decode

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `decode(= decode;
const decodeUnknown = exports.decodeUnknown = /*#__PURE__*/Option.liftThrowable(decode)`

JSDoc:

@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/Duration");
const bigint0 = /*#__PURE__*/BigInt(0);
const bigint24 = /*#__PURE__*/BigInt(24);
const bigint60 = /*#__PURE__*/BigInt(60);
const bigint1e3 = /*#__PURE__*/BigInt(1_000);
const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);
const bigint1e9 = /*#__PURE__*/BigInt(1_000_000_000);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
/**
@since 2.0.0
/
const decode = input => {
  if (isDuration(input)) {
    return input;
  } else if ((0, _Predicate.isNumber)(input)) {
    return millis(input);
  } else if ((0, _Predicate.isBigInt)(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(_Predicate.isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1_000_000_000)) + BigInt(Math.round(input[1])));
  } else if ((0, _Predicate.isString)(input)) {
    const match = DURATION_REGEX.exec(input);
    if (match) {
      const [_, valueStr, unit] = match;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
/**
@since 2.5.0

## isDuration

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `isDuration(= isDuration;
const isFinite = self => self.value._tag !== "Infinity";
/**
 * @since 3.5.0
 * @category guards
 */
exports.isFinite = isFinite;
const isZero = self => {
  switch (self.value._tag)`

JSDoc:

@since 2.0.0
@category guards
/
const isDuration = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
@since 2.0.0
@category guards

## isZero

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `isZero(= isZero;
const zero = exports.zero = /*#__PURE__*/make(0)`

JSDoc:

@since 2.0.0
@category constructors

## nanos

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `nanos(= nanos;
const micros = micros => make(micros * bigint1e3)`

JSDoc:

@since 2.0.0
@category constructors
/
const infinity = exports.infinity = /*#__PURE__*/make(Infinity);
/**
@since 2.0.0
@category constructors
/
const nanos = nanos => make(nanos);
/**
@since 2.0.0
@category constructors

## micros

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `micros(= micros;
const millis = millis => make(millis)`

JSDoc:

@since 2.0.0
@category constructors

## millis

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `millis(= millis;
const seconds = seconds => make(seconds * 1000)`

JSDoc:

@since 2.0.0
@category constructors

## seconds

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `seconds(= seconds;
const minutes = minutes => make(minutes * 60_000)`

JSDoc:

@since 2.0.0
@category constructors

## minutes

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `minutes(= minutes;
const hours = hours => make(hours * 3_600_000)`

JSDoc:

@since 2.0.0
@category constructors

## hours

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `hours(= hours;
const days = days => make(days * 86_400_000)`

JSDoc:

@since 2.0.0
@category constructors

## days

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `days(= days;
const weeks = weeks => make(weeks * 604_800_000)`

JSDoc:

@since 2.0.0
@category constructors

## weeks

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `weeks(= weeks;
const toMillis = self => match(self, {
  onMillis: millis => millis,
  onNanos: nanos => Number(nanos)`

JSDoc:

@since 2.0.0
@category getters

## toMillis

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `toMillis(= toMillis;
const toSeconds = self => match(self, {
  onMillis: millis => millis / 1_000,
  onNanos: nanos => Number(nanos)`

JSDoc:

@since 2.0.0
@category getters

## toSeconds

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `toSeconds(= toSeconds;
const toMinutes = self => match(self, {
  onMillis: millis => millis / 60_000,
  onNanos: nanos => Number(nanos)`

JSDoc:

@since 3.8.0
@category getters

## toMinutes

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `toMinutes(= toMinutes;
const toHours = self => match(self, {
  onMillis: millis => millis / 3_600_000,
  onNanos: nanos => Number(nanos)`

JSDoc:

@since 3.8.0
@category getters

## toHours

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `toHours(= toHours;
const toDays = self => match(self, {
  onMillis: millis => millis / 86_400_000,
  onNanos: nanos => Number(nanos)`

JSDoc:

@since 3.8.0
@category getters

## toDays

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `toDays(= toDays;
const toWeeks = self => match(self, {
  onMillis: millis => millis / 604_800_000,
  onNanos: nanos => Number(nanos)`

JSDoc:

@since 3.8.0
@category getters

## toWeeks

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `toWeeks(= toWeeks;
const toNanos = self => {
  const _self = decode(self)`

JSDoc:

Get the duration in nanoseconds as a bigint.

If the duration is infinite, returns `Option.none()`

@since 2.0.0
@category getters

## toNanos

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `toNanos(= toNanos;
const unsafeToNanos = self => {
  const _self = decode(self)`

JSDoc:

Get the duration in nanoseconds as a bigint.

If the duration is infinite, it throws an error.

@since 2.0.0
@category getters

## unsafeToNanos

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `unsafeToNanos(= unsafeToNanos;
const toHrTime = self => {
  const _self = decode(self)`

JSDoc:

@since 2.0.0
@category getters

## toHrTime

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `toHrTime(= toHrTime;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 2.0.0
@category pattern matching

## parts

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `parts(= parts;
const format = self => {
  const duration = decode(self)`

JSDoc:

@since 2.0.0
@category pattern matching
/
const matchWith = exports.matchWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1_000_000));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1_000_000));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
/**
@category instances
@since 2.0.0
/
const Order = exports.Order = /*#__PURE__*/order.make((self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that ? -1 : self > that ? 1 : 0,
  onNanos: (self, that) => self < that ? -1 : self > that ? 1 : 0
}));
/**
Checks if a `Duration` is between a `minimum` and `maximum` value.

@category predicates
@since 2.0.0
/
const between = exports.between = /*#__PURE__*/order.between(/*#__PURE__*/order.mapInput(Order, decode));
/**
@category instances
@since 2.0.0
/
const Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self === that,
  onNanos: (self, that) => self === that
});
exports.Equivalence = Equivalence;
const _min = /*#__PURE__*/order.min(Order);
/**
@since 2.0.0
/
const min = exports.min = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => _min(decode(self), decode(that)));
const _max = /*#__PURE__*/order.max(Order);
/**
@since 2.0.0
@category order
/
const max = exports.max = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => _max(decode(self), decode(that)));
const _clamp = /*#__PURE__*/order.clamp(Order);
/**
@since 2.0.0
@category order
/
const clamp = exports.clamp = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => _clamp(decode(self), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
/**
@since 2.4.19
@category math
/
const divide = exports.divide = /*#__PURE__*/(0, _Function.dual)(2, (self, by) => match(self, {
  onMillis: millis => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return Option.none();
    }
    return Option.some(make(millis / by));
  },
  onNanos: nanos => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return Option.none();
    }
    try {
      return Option.some(make(nanos / BigInt(by)));
    } catch {
      return Option.none();
    }
  }
}));
/**
@since 2.4.19
@category math
/
const unsafeDivide = exports.unsafeDivide = /*#__PURE__*/(0, _Function.dual)(2, (self, by) => match(self, {
  onMillis: millis => make(millis / by),
  onNanos: nanos => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make(nanos / BigInt(by));
  }
}));
/**
@since 2.0.0
@category math
/
const times = exports.times = /*#__PURE__*/(0, _Function.dual)(2, (self, times) => match(self, {
  onMillis: millis => make(millis * times),
  onNanos: nanos => make(nanos * BigInt(times))
}));
/**
@since 2.0.0
@category math
/
const subtract = exports.subtract = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => make(self - that),
  onNanos: (self, that) => make(self - that)
}));
/**
@since 2.0.0
@category math
/
const sum = exports.sum = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => make(self + that),
  onNanos: (self, that) => make(self + that)
}));
/**
@since 2.0.0
@category predicates
/
const lessThan = exports.lessThan = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that,
  onNanos: (self, that) => self < that
}));
/**
@since 2.0.0
@category predicates
/
const lessThanOrEqualTo = exports.lessThanOrEqualTo = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self <= that,
  onNanos: (self, that) => self <= that
}));
/**
@since 2.0.0
@category predicates
/
const greaterThan = exports.greaterThan = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self > that,
  onNanos: (self, that) => self > that
}));
/**
@since 2.0.0
@category predicates
/
const greaterThanOrEqualTo = exports.greaterThanOrEqualTo = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self >= that,
  onNanos: (self, that) => self >= that
}));
/**
@since 2.0.0
@category predicates
/
const equals = exports.equals = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => Equivalence(decode(self), decode(that)));
/**
Converts a `Duration` to its parts.

@since 3.8.0
@category conversions
/
const parts = self => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos = unsafeToNanos(duration);
  const ms = nanos / bigint1e6;
  const sec = ms / bigint1e3;
  const min = sec / bigint60;
  const hr = min / bigint60;
  const days = hr / bigint24;
  return {
    days: Number(days),
    hours: Number(hr % bigint24),
    minutes: Number(min % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos % bigint1e6)
  };
};
/**
Converts a `Duration` to a human readable string.

@since 2.0.0
@category conversions
@example
```ts
import { Duration } from "effect"

Duration.format(Duration.millis(1000)) // "1s"
Duration.format(Duration.millis(1001)) // "1s 1ms"
```

## format

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `format(= format;
const unsafeFormatIso = self => {
  const duration = decode(self)`

JSDoc:

Formats a Duration into an ISO8601 duration string.

Months are assumed to be 30 days and years are assumed to be 365 days.

Milliseconds and nanoseconds are expressed as fractional seconds.

@example
```ts
import { Duration } from "effect"

Duration.unsafeFormatIso(Duration.days(1)) // => "P1D"
Duration.unsafeFormatIso(Duration.minutes(90)) // => "PT1H30M"
Duration.unsafeFormatIso(Duration.millis(1500)) // => "PT1.5S"
```

@throws `RangeError` If the duration is not finite.

@since 3.13.0
@category conversions

## unsafeFormatIso

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `unsafeFormatIso(= unsafeFormatIso;
const formatIso = self => {
  const duration = decode(self)`

JSDoc:

Formats a Duration into an ISO8601 duration string.

Months are assumed to be 30 days and years are assumed to be 365 days.

Returns `Option.none()` if the duration is infinite.

@example
```ts
import { Duration, Option } from "effect"

Duration.formatIso(Duration.days(1)) // => Option.some("P1D")
Duration.formatIso(Duration.minutes(90)) // => Option.some("PT1H30M")
Duration.formatIso(Duration.millis(1500)) // => Option.some("PT1.5S")
Duration.formatIso(Duration.infinity) // => Option.none()
```

@since 3.13.0
@category conversions

## formatIso

Source: `my-backend/node_modules/effect/dist/cjs/Duration.js`

Signature: `formatIso(= formatIso;
const fromIso = iso => {
  const result = DURATION_ISO_REGEX.exec(iso)`

JSDoc:

Parses an ISO8601 duration string into a `Duration`.

Months are assumed to be 30 days and years are assumed to be 365 days.

@example
```ts
import { Duration, Option } from "effect"

Duration.fromIso("P1D") // => Option.some(Duration.days(1))
Duration.fromIso("PT1H") // => Option.some(Duration.hours(1))
Duration.fromIso("PT1M") // => Option.some(Duration.minutes(1))
Duration.fromIso("PT1.5S") // => Option.some(Duration.seconds(1.5))
```

@since 3.13.0
@category conversions

## logWithLevel

Source: `my-backend/node_modules/effect/dist/cjs/Effect.js`

Signature: `logWithLevel(= logWithLevel;
const logTrace = exports.logTrace = effect.logTrace;
/**
 * Logs messages at the DEBUG log level.
 *
 * **Details**
 *
 * This function logs messages at the DEBUG level, which is typically used for
 * diagnosing application behavior during development. DEBUG messages provide
 * less detailed information than TRACE logs but are still not shown by default.
 * To view these logs, adjust the log level using `Logger.withMinimumLogLevel`.
 *
 * **Example**
 *
 * ```ts
 * import { Effect, Logger, LogLevel } from "effect"
 *
 * const program = Effect.logDebug("message1")`

JSDoc:

@since 2.0.0
@category Symbols
/
const EffectTypeId = exports.EffectTypeId = core.EffectTypeId;
/**
Checks if a given value is an `Effect` value.

**When to Use**

This function can be useful for checking the type of a value before
attempting to operate on it as an `Effect` value. For example, you could use
`Effect.isEffect` to check the type of a value before using it as an argument
to a function that expects an `Effect` value.

@since 2.0.0
@category Guards
/
const isEffect = exports.isEffect = core.isEffect;
/**
Returns an effect that caches its result for a specified `Duration`,
known as "timeToLive" (TTL).

**Details**

This function is used to cache the result of an effect for a specified amount
of time. This means that the first time the effect is evaluated, its result
is computed and stored.

If the effect is evaluated again within the specified `timeToLive`, the
cached result will be used, avoiding recomputation.

After the specified duration has passed, the cache expires, and the effect
will be recomputed upon the next evaluation.

**When to Use**

Use this function when you have an effect that involves costly operations or
computations, and you want to avoid repeating them within a short time frame.

It's ideal for scenarios where the result of an effect doesn't change
frequently and can be reused for a specified duration.

By caching the result, you can improve efficiency and reduce unnecessary
computations, especially in performance-critical applications.

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* Effect.sleep("100 millis")
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
// Output:
// expensive task...
// result 1
// result 1
// expensive task...
// result 2
```

@see {@link cached} for a similar function that caches the result
indefinitely.
@see {@link cachedInvalidateWithTTL} for a similar function that includes an
additional effect for manually invalidating the cached value.

@since 2.0.0
@category Caching
/
const cachedWithTTL = exports.cachedWithTTL = circular.cached;
/**
Caches an effect's result for a specified duration and allows manual
invalidation before expiration.

**Details**

This function behaves similarly to {@link cachedWithTTL} by caching the
result of an effect for a specified period of time. However, it introduces an
additional feature: it provides an effect that allows you to manually
invalidate the cached result before it naturally expires.

This gives you more control over the cache, allowing you to refresh the
result when needed, even if the original cache has not yet expired.

Once the cache is invalidated, the next time the effect is evaluated, the
result will be recomputed, and the cache will be refreshed.

**When to Use**

Use this function when you have an effect whose result needs to be cached for
a certain period, but you also want the option to refresh the cache manually
before the expiration time.

This is useful when you need to ensure that the cached data remains valid for
a certain period but still want to invalidate it if the underlying data
changes or if you want to force a recomputation.

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(
    expensiveTask,
    "1 hour"
  )
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* invalidate
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
// Output:
// expensive task...
// result 1
// result 1
// expensive task...
// result 2
```

@see {@link cached} for a similar function that caches the result
indefinitely.
@see {@link cachedWithTTL} for a similar function that caches the result for
a specified duration but does not include an effect for manual invalidation.

@since 2.0.0
@category Caching
/
const cachedInvalidateWithTTL = exports.cachedInvalidateWithTTL = circular.cachedInvalidateWithTTL;
/**
Returns an effect that lazily computes a result and caches it for subsequent
evaluations.

**Details**

This function wraps an effect and ensures that its result is computed only
once. Once the result is computed, it is cached, meaning that subsequent
evaluations of the same effect will return the cached result without
re-executing the logic.

**When to Use**

Use this function when you have an expensive or time-consuming operation that
you want to avoid repeating. The first evaluation will compute the result,
and all following evaluations will immediately return the cached value,
improving performance and reducing unnecessary work.

**Example**

```ts
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  console.log("non-cached version:")
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  console.log("cached version:")
  const cached = yield* Effect.cached(expensiveTask)
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
// Output:
// non-cached version:
// expensive task...
// result 1
// expensive task...
// result 2
// cached version:
// expensive task...
// result 3
// result 3
```

@see {@link cachedWithTTL} for a similar function that includes a
time-to-live duration for the cached value.
@see {@link cachedInvalidateWithTTL} for a similar function that includes an
additional effect for manually invalidating the cached value.

@since 2.0.0
@category Caching
/
const cached = exports.cached = effect.memoize;
/**
Returns a memoized version of a function with effects, reusing results for
the same inputs.

**Details**

This function creates a memoized version of a given function that performs an
effect. Memoization ensures that once a result is computed for a specific
input, it is stored and reused for subsequent calls with the same input,
reducing the need to recompute the result.

The function can optionally take an `Equivalence` parameter to
determine how inputs are compared for caching purposes.

**When to Use**

Use this function when you have a function that performs an effect and you
want to avoid recomputing the result for the same input multiple times.

It's ideal for functions that produce deterministic results based on their
inputs, and you want to improve performance by caching the output.

This is particularly useful in scenarios where the function involves
expensive calculations or operations that should be avoided after the first
execution with the same parameters.

**Example**

```ts
import { Effect, Random } from "effect"

const program = Effect.gen(function* () {
  const randomNumber = (n: number) => Random.nextIntBetween(1, n)
  console.log("non-memoized version:")
  console.log(yield* randomNumber(10))
  console.log(yield* randomNumber(10))

  console.log("memoized version:")
  const memoized = yield* Effect.cachedFunction(randomNumber)
  console.log(yield* memoized(10))
  console.log(yield* memoized(10))
})

Effect.runFork(program)
// Example Output:
// non-memoized version:
// 2
// 8
// memoized version:
// 5
// 5
```

@since 2.0.0
@category Caching
/
const cachedFunction = exports.cachedFunction = circular.cachedFunction;
/**
Returns an effect that executes only once, regardless of how many times it's
called.

**Details**

This function ensures that a specific effect is executed only a single time,
no matter how many times it is invoked. The result of the effect will be
cached, and subsequent calls to the effect will immediately return the cached
result without re-executing the original logic.

**When to Use**

Use this function when you need to perform a task only once, regardless of
how many times the effect is triggered. It's particularly useful when you
have initialization tasks, logging, or other one-time actions that should not
be repeated. This can help optimize performance and avoid redundant actions.

**Example**

```ts
import { Effect, Console } from "effect"

const program = Effect.gen(function* () {
  const task1 = Console.log("task1")
  yield* Effect.repeatN(task1, 2)
  const task2 = yield* Effect.once(Console.log("task2"))
  yield* Effect.repeatN(task2, 2)
})

Effect.runFork(program)
// Output:
// task1
// task1
// task1
// task2
```

@since 2.0.0
@category Caching
/
const once = exports.once = effect.once;
/**
Combines multiple effects into one, returning results based on the input
structure.

**Details**

Use this function when you need to run multiple effects and combine their
results into a single output. It supports tuples, iterables, structs, and
records, making it flexible for different input types.

For instance, if the input is a tuple:

```ts skip-type-checking
//          a tuple of effects
//         
Effect.all([effect1, effect2, ...])
```

the effects are executed sequentially, and the result is a new effect
containing the results as a tuple. The results in the tuple match the order
of the effects passed to `Effect.all`.

**Concurrency**

You can control the execution order (e.g., sequential vs. concurrent) using
the `concurrency` option.

**Short-Circuiting Behavior**

This function stops execution on the first error it encounters, this is
called "short-circuiting". If any effect in the collection fails, the
remaining effects will not run, and the error will be propagated. To change
this behavior, you can use the `mode` option, which allows all effects to run
and collect results as `Either` or `Option`.

**The `mode` option**

The `{ mode: "either" }` option changes the behavior of `Effect.all` to
ensure all effects run, even if some fail. Instead of stopping on the first
failure, this mode collects both successes and failures, returning an array
of `Either` instances where each result is either a `Right` (success) or a
`Left` (failure).

Similarly, the `{ mode: "validate" }` option uses `Option` to indicate
success or failure. Each effect returns `None` for success and `Some` with
the error for failure.

**Example** (Combining Effects in Tuples)

```ts
import { Effect, Console } from "effect"

const tupleOfEffects = [
  Effect.succeed(42).pipe(Effect.tap(Console.log)),
  Effect.succeed("Hello").pipe(Effect.tap(Console.log))
] as const

//       Effect<[number, string], never, never>
//      
const resultsAsTuple = Effect.all(tupleOfEffects)

Effect.runPromise(resultsAsTuple).then(console.log)
// Output:
// 42
// Hello
// [ 42, 'Hello' ]
```

**Example** (Combining Effects in Iterables)

```ts
import { Effect, Console } from "effect"

const iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(
  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))
)

//       Effect<number[], never, never>
//      
const resultsAsArray = Effect.all(iterableOfEffects)

Effect.runPromise(resultsAsArray).then(console.log)
// Output:
// 1
// 2
// 3
// [ 1, 2, 3 ]
```

**Example** (Combining Effects in Structs)

```ts
import { Effect, Console } from "effect"

const structOfEffects = {
  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
  b: Effect.succeed("Hello").pipe(Effect.tap(Console.log))
}

//       Effect<{ a: number; b: string; }, never, never>
//      
const resultsAsStruct = Effect.all(structOfEffects)

Effect.runPromise(resultsAsStruct).then(console.log)
// Output:
// 42
// Hello
// { a: 42, b: 'Hello' }
```

**Example** (Combining Effects in Records)

```ts
import { Effect, Console } from "effect"

const recordOfEffects: Record<string, Effect.Effect<number>> = {
  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),
  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))
}

//       Effect<{ [x: string]: number; }, never, never>
//      
const resultsAsRecord = Effect.all(recordOfEffects)

Effect.runPromise(resultsAsRecord).then(console.log)
// Output:
// 1
// 2
// { key1: 1, key2: 2 }
```

**Example** (Short-Circuiting Behavior)

```ts
import { Effect, Console } from "effect"

const program = Effect.all([
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  // Won't execute due to earlier failure
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
])

Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }
// }
```

**Example** (Collecting Results with `mode: "either"`)

```ts
import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "either" })

Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: [
//     { _id: 'Either', _tag: 'Right', right: 'Task1' },
//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },
//     { _id: 'Either', _tag: 'Right', right: 'Task3' }
//   ]
// }
```

**Example** (Collecting Results with `mode: "validate"`)

```ts
import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "validate" })

Effect.runPromiseExit(program).then((result) => console.log("%o", result))
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [
//       { _id: 'Option', _tag: 'None' },
//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },
//       { _id: 'Option', _tag: 'None' }
//     ]
//   }
// }
```

@see {@link forEach} for iterating over elements and applying an effect.
@see {@link allWith} for a data-last version of this function.

@since 2.0.0
@category Collecting
/
const all = exports.all = fiberRuntime.all;
/**
A data-last version of {@link all}, designed for use in pipelines.

**When to Use**

This function enables you to combine multiple effects and customize execution
options such as concurrency levels. This version is useful in functional
pipelines where you first define your data and then apply operations to it.

**Example**

```ts
import { Effect, pipe } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)

const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = pipe(
  [task1, task2],
  // Run both effects concurrently using the concurrent option
  Effect.allWith({ concurrency: 2 })
)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#3 message="task2 done"
// timestamp=... level=INFO fiber=#2 message="task1 done"
// [ 1, 'hello' ]
```

@since 2.0.0
@category Collecting
/
const allWith = exports.allWith = fiberRuntime.allWith;
/**
Evaluates and runs each effect in the iterable, collecting only the
successful results while discarding failures.

**Details**

This function function processes an iterable of effects and runs each one. If
an effect is successful, its result is collected; if it fails, the result is
discarded. This ensures that only successful outcomes are kept.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

**Example**

```ts
import { Effect } from "effect"

const tasks = [
  Effect.succeed(1),
  Effect.fail("Error 1"),
  Effect.succeed(2),
  Effect.fail("Error 2")
]

const program = Effect.gen(function*() {
  const successfulResults = yield* Effect.allSuccesses(tasks)
  console.log(successfulResults)
})

Effect.runFork(program)
// Output: [1, 2]

```

@since 2.0.0
@category Collecting
/
const allSuccesses = exports.allSuccesses = fiberRuntime.allSuccesses;
/**
Drops elements until the effectful predicate returns `true`.

**Details**

This function processes a collection of elements and uses an effectful
predicate to determine when to stop dropping elements. It drops elements from
the beginning of the collection until the predicate returns `true`.

The predicate is a function that takes an element and its index in the
collection and returns an effect that evaluates to a boolean.

Once the predicate returns `true`, the remaining elements of the collection
are returned.

**Note**: The first element for which the predicate returns `true` is also
dropped.

**When to Use**

This function allows you to conditionally skip over a part of the collection
based on some criteria defined in the predicate.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.dropUntil(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [5, 6]
```

@see {@link dropWhile} for a similar function that drops elements while the
predicate returns `true`.

@since 2.0.0
@category Collecting
/
const dropUntil = exports.dropUntil = effect.dropUntil;
/**
Drops elements as long as the predicate returns `true`.

**Details**

This function processes a collection of elements and uses a predicate to
decide whether to drop an element.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

As long as the predicate returns `true`, elements will continue to be dropped
from the collection.

Once the predicate returns `false`, the remaining elements are kept.

**When to Use**

This function allows you to discard elements from the start of a collection
based on a condition, and only keep the rest when the condition no longer
holds.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n <= 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.dropWhile(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [4, 5, 6]
```

@see {@link dropUntil} for a similar function that drops elements until the
predicate returns `true`.

@since 2.0.0
@category Collecting
/
const dropWhile = exports.dropWhile = effect.dropWhile;
/**
Takes elements from a collection until the effectful predicate returns
`true`.

**Details**

This function processes a collection of elements and uses an effectful
predicate to decide when to stop taking elements. The elements are taken from
the beginning of the collection until the predicate returns `true`.

The predicate is a function that takes an element and its index in the
collection, and returns an effect that resolves to a boolean.

Once the predicate returns `true`, the remaining elements of the collection
are discarded, and the function stops taking more elements.

**Note**: The first element for which the predicate returns `true` is also
included in the result.

**When to Use**

Use this function when you want to conditionally take elements from a
collection based on a dynamic condition. For example, you may want to collect
numbers from a list until a certain threshold is reached, or gather items
until a specific condition is met.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.takeUntil(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [ 1, 2, 3, 4 ]
```

@see {@link takeWhile} for a similar function that takes elements while the
predicate returns `true`.

@since 2.0.0
@category Collecting
/
const takeUntil = exports.takeUntil = effect.takeUntil;
/**
Takes elements as long as the predicate returns `true`.

**Details**

This function processes a collection of elements and uses a predicate to
decide whether to take an element.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

As long as the predicate returns `true`, elements will continue to be taken
from the collection.

Once the predicate returns `false`, the remaining elements are discarded.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n <= 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.takeWhile(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [1, 2, 3]
```

@see {@link takeUntil} for a similar function that takes elements until the predicate returns `true`.

@since 2.0.0
@category Collecting
/
const takeWhile = exports.takeWhile = effect.takeWhile;
/**
Determines whether all elements of the iterable satisfy the effectful
predicate.

**Details**

This function checks whether every element in a given collection (an
iterable) satisfies a condition defined by an effectful predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function will process each element and return `true` if all elements
satisfy the predicate; otherwise, it returns `false`.

**When to Use**

This function is useful when you need to verify that all items in a
collection meet certain criteria, even when the evaluation of each item
involves effects, such as asynchronous checks or complex computations.

**Example**

```ts
import { Effect } from "effect"

const numbers = [2, 4, 6, 8]
const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)

const program = Effect.gen(function*() {
  const allEven = yield* Effect.every(numbers, predicate)
  console.log(allEven)
})

Effect.runFork(program)
// Output: true
```

@see {@link exists} for a similar function that returns a boolean indicating
whether **any** element satisfies the predicate.

@since 2.0.0
@category Condition Checking
/
const every = exports.every = effect.every;
/**
Determines whether any element of the iterable satisfies the effectual
predicate.

**Details**

This function checks whether any element in a given collection (an iterable)
satisfies a condition defined by an effectful predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function will process each element, and if any element satisfies the
predicate (returns `true`), the function will immediately return `true`.

If none of the elements satisfy the condition, it will return `false`.

**When to Use**

This function allows you to quickly check for a condition in a collection
without having to manually iterate over it.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4]
const predicate = (n: number, i: number) => Effect.succeed(n > 2)

const program = Effect.gen(function*() {
  const hasLargeNumber = yield* Effect.exists(numbers, predicate)
  console.log(hasLargeNumber)
})

Effect.runFork(program)
// Output: true
```

@see {@link every} for a similar function that checks if **all** elements
satisfy the predicate.

@since 2.0.0
@category Condition Checking
/
const exists = exports.exists = fiberRuntime.exists;
/**
Filters an iterable using the specified effectful predicate.

**Details**

This function filters a collection (an iterable) by applying an effectful
predicate.

The predicate is a function that takes an element and its index, and it
returns an effect that evaluates to a boolean.

The function processes each element in the collection and keeps only those
that satisfy the condition defined by the predicate.

**Options**

You can also adjust the behavior with options such as concurrency, batching,
or whether to negate the condition.

**When to Use**

This function allows you to selectively keep or remove elements based on a
condition that may involve asynchronous or side-effect-causing operations.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)

const program = Effect.gen(function*() {
  const result = yield* Effect.filter(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [2, 4]
```

@since 2.0.0
@category Filtering
/
const filter = exports.filter = fiberRuntime.filter;
/**
Filters and maps elements sequentially in one operation.

This function processes each element one by one. It applies a function that
returns an `Option` to each element. If the function returns `Some`, the
element is kept; if it returns `None`, the element is removed. The operation
is done sequentially for each element.

**Example**

```ts
import { Console, Effect, Option } from "effect"

const task = (n: number) =>
  Effect.succeed(n).pipe(
    Effect.delay(1000 - (n * 100)),
    Effect.tap(Console.log(`task${n} done`))
  )

const program = Effect.filterMap(
  [task(1), task(2), task(3), task(4)],
  (n) => n % 2 === 0 ? Option.some(n) : Option.none()
)

Effect.runPromise(program).then(console.log)
// Output:
// task1 done
// task2 done
// task3 done
// task4 done
// [ 2, 4 ]
```

@since 2.0.0
@category Filtering
/
const filterMap = exports.filterMap = effect.filterMap;
/**
Returns the first element that satisfies the effectful predicate.

**Details**

This function processes a collection of elements and applies an effectful
predicate to each element.

The predicate is a function that takes an element and its index in the
collection, and it returns an effect that evaluates to a boolean.

The function stops as soon as it finds the first element for which the
predicate returns `true` and returns that element wrapped in an `Option`.

If no element satisfies the predicate, the result will be `None`.

**When to Use**

This function allows you to efficiently find an element that meets a specific
condition, even when the evaluation involves effects like asynchronous
operations or side effects.

**Example**

```ts
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.findFirst(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: { _id: 'Option', _tag: 'Some', value: 4 }
```

@since 2.0.0
@category Collecting
/
const findFirst = exports.findFirst = effect.findFirst;
/**
Executes an effectful operation for each element in an `Iterable`.

**Details**

This function applies a provided operation to each element in the iterable,
producing a new effect that returns an array of results.

If any effect fails, the iteration stops immediately (short-circuiting), and
the error is propagated.

**Concurrency**

The `concurrency` option controls how many operations are performed
concurrently. By default, the operations are performed sequentially.

**Discarding Results**

If the `discard` option is set to `true`, the intermediate results are not
collected, and the final result of the operation is `void`.

**Example** (Applying Effects to Iterable Elements)

```ts
import { Effect, Console } from "effect"

const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>
  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at index 0
// Currently at index 1
// Currently at index 2
// Currently at index 3
// Currently at index 4
// [ 2, 4, 6, 8, 10 ]
```

**Example** (Discarding Results)

```ts
import { Effect, Console } from "effect"

// Apply effects but discard the results
const result = Effect.forEach(
  [1, 2, 3, 4, 5],
  (n, index) =>
    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),
  { discard: true }
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at index 0
// Currently at index 1
// Currently at index 2
// Currently at index 3
// Currently at index 4
// undefined
```

@see {@link all} for combining multiple effects into one.

@since 2.0.0
@category Looping
/
const forEach = exports.forEach = fiberRuntime.forEach;
/**
Returns the first element of the iterable if the collection is non-empty, or
fails with the error `NoSuchElementException` if the collection is empty.

**When to Use**

This function is useful when you need to retrieve the first item from a
collection and want to handle the case where the collection might be empty
without causing an unhandled exception.

**Example**

```ts
import { Effect } from "effect"

// Simulate an async operation
const fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))

const program = Effect.gen(function*() {
  const firstElement = yield* Effect.head(fetchNumbers)
  console.log(firstElement)
})

Effect.runFork(program)
// Output: 1
```

@since 2.0.0
@category Collecting
/
const head = exports.head = effect.head;
/**
Merges an `Iterable<Effect<A, E, R>>` to a single effect.

**Details**

This function takes an iterable of effects and combines them into a single
effect. It does this by iterating over each effect in the collection and
applying a function that accumulates results into a "zero" value, which
starts with an initial value and is updated with each effect's success.

The provided function `f` is called for each element in the iterable,
allowing you to specify how to combine the results.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

**Example**

```ts
import { Effect } from "effect"

const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]
const add = (sum: number, value: number, i: number) => sum + value
const zero = 0

const program = Effect.gen(function*() {
  const total = yield* Effect.mergeAll(numbers, zero, add)
  console.log(total)
})

Effect.runFork(program)
// Output: 6
```

@since 2.0.0
@category Collecting
/
const mergeAll = exports.mergeAll = fiberRuntime.mergeAll;
/**
Processes an iterable and applies an effectful function to each element,
categorizing the results into successes and failures.

**Details**

This function processes each element in the provided iterable by applying an
effectful function to it. The results are then categorized into two separate
lists: one for failures and another for successes. This separation allows you
to handle the two categories differently. Failures are collected in a list
without interrupting the processing of the remaining elements, so the
operation continues even if some elements fail. This is particularly useful
when you need to handle both successful and failed results separately,
without stopping the entire process on encountering a failure.

**When to Use**

Use this function when you want to process a collection of items and handle
errors or failures without interrupting the processing of other items. It's
useful when you need to distinguish between successful and failed results and
process them separately, for example, when logging errors while continuing to
work with valid data. The function ensures that failures are captured, while
successes are processed normally.

**Example**

```ts
import { Effect } from "effect"

//       Effect<[string[], number[]], never, never>
//      
const program = Effect.partition([0, 1, 2, 3, 4], (n) => {
  if (n % 2 === 0) {
    return Effect.succeed(n)
  } else {
    return Effect.fail(`${n} is not even`)
  }
})

Effect.runPromise(program).then(console.log, console.error)
// Output:
// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]
```

@see {@link validateAll} for a function that either collects all failures or all successes.
@see {@link validateFirst} for a function that stops at the first success.

@since 2.0.0
@category Error Accumulation
/
const partition = exports.partition = fiberRuntime.partition;
/**
Reduces an `Iterable<A>` using an effectual function `f`, working
sequentially from left to right.

**Details**

This function takes an iterable and applies a function `f` to each element in
the iterable. The function works sequentially, starting with an initial value
`zero` and then combining it with each element in the collection. The
provided function `f` is called for each element in the iterable, allowing
you to accumulate a result based on the current value and the element being
processed.

**When to Use**

The function is often used for operations like summing a collection of
numbers or combining results from multiple tasks. It ensures that operations
are performed one after the other, maintaining the order of the elements.

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduce(
  [1, 2, 3, 4],
  0,
  (acc, id, i) =>
    processOrder(id)
      .pipe(Effect.map((order) => acc + order.price))
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// Order 4 processed
// 1000
```

@see {@link reduceWhile} for a similar function that stops the process based on a predicate.
@see {@link reduceRight} for a similar function that works from right to left.

@since 2.0.0
@category Collecting
/
const reduce = exports.reduce = effect.reduce;
/**
Reduces an `Iterable<A>` using an effectual function `body`, working
sequentially from left to right, stopping the process early when the
predicate `while` is not satisfied.

**Details**

This function processes a collection of elements, applying a function `body`
to reduce them to a single value, starting from the first element. It checks
the value of the accumulator against a predicate (`while`). If at any point
the predicate returns `false`, the reduction stops, and the accumulated
result is returned.

**When to Use**

Use this function when you need to reduce a collection of elements, but only
continue the process as long as a certain condition holds true. For example,
if you want to sum values in a list but stop as soon as the sum exceeds a
certain threshold, you can use this function.

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceWhile(
  [1, 2, 3, 4],
  0,
  {
    body: (acc, id, i) =>
      processOrder(id)
        .pipe(Effect.map((order) => acc + order.price)),
    while: (acc) => acc < 500
  }
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// 600
```

@since 2.0.0
@category Collecting
/
const reduceWhile = exports.reduceWhile = effect.reduceWhile;
/**
Reduces an `Iterable<A>` using an effectual function `f`, working
sequentially from right to left.

**Details**

This function takes an iterable and applies a function `f` to each element in
the iterable. The function works sequentially, starting with an initial value
`zero` and then combining it with each element in the collection. The
provided function `f` is called for each element in the iterable, allowing
you to accumulate a result based on the current value and the element being
processed.

**When to Use**

The function is often used for operations like summing a collection of
numbers or combining results from multiple tasks. It ensures that operations
are performed one after the other, maintaining the order of the elements.

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceRight(
  [1, 2, 3, 4],
  0,
  (id, acc, i) =>
    processOrder(id)
      .pipe(Effect.map((order) => acc + order.price))
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 4 processed
// Order 3 processed
// Order 2 processed
// Order 1 processed
// 1000
```

@see {@link reduce} for a similar function that works from left to right.

@since 2.0.0
@category Collecting
/
const reduceRight = exports.reduceRight = effect.reduceRight;
/**
Reduces an `Iterable<Effect<A, E, R>>` to a single effect.

**Details**

This function processes a collection of effects and combines them into one
single effect. It starts with an initial effect (`zero`) and applies a
function `f` to each element in the collection.

**Options**

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

**Example**

```ts
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceEffect(
  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],
  Effect.succeed(0),
  (acc, order, i) => acc + order.price
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// Order 4 processed
// 1000
```

@since 2.0.0
@category Collecting
/
const reduceEffect = exports.reduceEffect = fiberRuntime.reduceEffect;
/**
Replicates the given effect `n` times.

**Details**

This function takes an effect and replicates it a specified number of times
(`n`). The result is an array of `n` effects, each of which is identical to
the original effect.

**Example**

```ts
import { Console, Effect } from "effect"

const task = Effect.succeed("Hello, World!").pipe(
  Effect.tap(Console.log)
)

const program = Effect.gen(function*() {
  // Replicate the task 3 times
  const tasks = Effect.replicate(task, 3)
  for (const t of tasks) {
    // Run each task
    yield* t
  }
})

Effect.runFork(program)
// Output:
// Hello, World!
// Hello, World!
// Hello, World!
```

@since 2.0.0
/
const replicate = exports.replicate = fiberRuntime.replicate;
/**
Performs this effect the specified number of times and collects the results.

**Details**

This function repeats an effect multiple times and collects the results into
an array. You specify how many times to execute the effect, and it runs that
many times, either in sequence or concurrently depending on the provided
options.

**Options**

If the `discard` option is set to `true`, the intermediate results are not
collected, and the final result of the operation is `void`.

The function also allows you to customize how the effects are handled by
specifying options such as concurrency, batching, and how finalizers behave.
These options provide flexibility in running the effects concurrently or
adjusting other execution details.

**Example**

```ts
import { Console, Effect } from "effect"

let counter = 0

const task = Effect.sync(() => ++counter).pipe(
  Effect.tap(() => Console.log(`Task completed`))
)

const program = Effect.gen(function*() {
  // Replicate the task 3 times and collect the results
  const results = yield* Effect.replicateEffect(task, 3)
  yield* Console.log(`Results: ${results.join(", ")}`)
})

Effect.runFork(program)
// Output:
// Task completed
// Task completed
// Task completed
// Results: 1, 2, 3
```

@since 2.0.0
@category Collecting
/
const replicateEffect = exports.replicateEffect = fiberRuntime.replicateEffect;
/**
Applies an effectful operation to each element in a collection while
collecting both successes and failures.

**Details**

This function allows you to apply an effectful operation to every item in a
collection.

Unlike {@link forEach}, which would stop at the first error, this function
continues processing all elements, accumulating both successes and failures.

**When to Use**

Use this function when you want to process every item in a collection, even
if some items fail. This is particularly useful when you need to perform
operations on all elements without halting due to an error.

Keep in mind that if there are any failures, **all successes will be lost**,
so this function is not suitable when you need to keep the successful results
in case of errors.

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number[], [string, ...string[]], never>
//      
const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {
  if (n < 4) {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  } else {
    return Effect.fail(`${n} is not less that 4`)
  }
})

Effect.runPromiseExit(program).then(console.log)
// Output:
// item 1
// item 2
// item 3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [ '4 is not less that 4', '5 is not less that 4' ]
//   }
// }
```

@see {@link forEach} for a similar function that stops at the first error.
@see {@link partition} when you need to separate successes and failures
instead of losing successes with errors.

@since 2.0.0
@category Error Accumulation
/
const validateAll = exports.validateAll = fiberRuntime.validateAll;
/**
This function is similar to {@link validateAll} but with a key difference: it
returns the first successful result or all errors if none of the operations
succeed.

**Details**

This function processes a collection of elements and applies an effectful
operation to each. Unlike {@link validateAll}, which accumulates both
successes and failures, `Effect.validateFirst` stops and returns the first
success it encounters. If no success occurs, it returns all accumulated
errors. This can be useful when you are interested in the first successful
result and want to avoid processing further once a valid result is found.

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number, string[], never>
//      
const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {
  if (n < 4) {
    return Effect.fail(`${n} is not less that 4`)
  } else {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  }
})

Effect.runPromise(program).then(console.log, console.error)
// Output:
// item 4
// 4
```

@see {@link validateAll} for a similar function that accumulates all results.
@see {@link firstSuccessOf} for a similar function that processes multiple
effects and returns the first successful one or the last error.

@since 2.0.0
@category Error Accumulation
/
const validateFirst = exports.validateFirst = fiberRuntime.validateFirst;
/**
Creates an `Effect` from a callback-based asynchronous function.

**Details**

The `resume` function:
- Must be called exactly once. Any additional calls will be ignored.
- Can return an optional `Effect` that will be run if the `Fiber` executing
  this `Effect` is interrupted. This can be useful in scenarios where you
  need to handle resource cleanup if the operation is interrupted.
- Can receive an `AbortSignal` to handle interruption if needed.

The `FiberId` of the fiber that may complete the async callback may also be
specified using the `blockingOn` argument. This is called the "blocking
fiber" because it suspends the fiber executing the `async` effect (i.e.
semantically blocks the fiber from making progress). Specifying this fiber id
in cases where it is known will improve diagnostics, but not affect the
behavior of the returned effect.

**When to Use**

Use `Effect.async` when dealing with APIs that use callback-style instead of
`async/await` or `Promise`.

**Example** (Wrapping a Callback API)

```ts
import { Effect } from "effect"
import * as NodeFS from "node:fs"

const readFile = (filename: string) =>
  Effect.async<Buffer, Error>((resume) => {
    NodeFS.readFile(filename, (error, data) => {
      if (error) {
        // Resume with a failed Effect if an error occurs
        resume(Effect.fail(error))
      } else {
        // Resume with a succeeded Effect if successful
        resume(Effect.succeed(data))
      }
    })
  })

//       Effect<Buffer, Error, never>
//      
const program = readFile("example.txt")
```

**Example** (Handling Interruption with Cleanup)

```ts
import { Effect, Fiber } from "effect"
import * as NodeFS from "node:fs"

// Simulates a long-running operation to write to a file
const writeFileWithCleanup = (filename: string, data: string) =>
  Effect.async<void, Error>((resume) => {
    const writeStream = NodeFS.createWriteStream(filename)

    // Start writing data to the file
    writeStream.write(data)

    // When the stream is finished, resume with success
    writeStream.on("finish", () => resume(Effect.void))

    // In case of an error during writing, resume with failure
    writeStream.on("error", (err) => resume(Effect.fail(err)))

    // Handle interruption by returning a cleanup effect
    return Effect.sync(() => {
      console.log(`Cleaning up ${filename}`)
      NodeFS.unlinkSync(filename)
    })
  })

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(
    writeFileWithCleanup("example.txt", "Some long data...")
  )
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber) // This will trigger the cleanup
})

// Run the program
Effect.runPromise(program)
// Output:
// Cleaning up example.txt
```

**Example** (Handling Interruption with AbortSignal)

```ts
import { Effect, Fiber } from "effect"

// A task that supports interruption using AbortSignal
const interruptibleTask = Effect.async<void, Error>((resume, signal) => {
  // Handle interruption
  signal.addEventListener("abort", () => {
    console.log("Abort signal received")
    clearTimeout(timeoutId)
  })

  // Simulate a long-running task
  const timeoutId = setTimeout(() => {
    console.log("Operation completed")
    resume(Effect.void)
  }, 2000)
})

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(interruptibleTask)
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber)
})

// Run the program
Effect.runPromise(program)
// Output:
// Abort signal received
```

@since 2.0.0
@category Creating Effects
/
const async = exports.async = core.async;
/**
A variant of {@link async} where the registration function may return an `Effect`.

@since 2.0.0
@category Creating Effects
/
const asyncEffect = exports.asyncEffect = runtime_.asyncEffect;
/**
Low level constructor that enables for custom stack tracing cutpoints.

It is meant to be called with a bag of instructions that become available in
the "this" of the effect.

**Example**

```ts
import { Effect } from "effect"

const throwingFunction = () => { throw new Error() }
const blowUp = Effect.custom(throwingFunction, function() {
  return Effect.succeed(this.effect_instruction_i0())
})
```

@since 2.0.0
@category Creating Effects
/
const custom = exports.custom = core.custom;
/**
@since 2.0.0
@category Creating Effects
/
const withFiberRuntime = exports.withFiberRuntime = core.withFiberRuntime;
/**
Creates an `Effect` that represents a recoverable error.

**When to Use**

Use this function to explicitly signal an error in an `Effect`. The error
will keep propagating unless it is handled. You can handle the error with
functions like {@link catchAll} or {@link catchTag}.

**Example** (Creating a Failed Effect)

```ts
import { Effect } from "effect"

//       Effect<never, Error, never>
//      
const failure = Effect.fail(
  new Error("Operation failed due to network error")
)
```

@see {@link succeed} to create an effect that represents a successful value.

@since 2.0.0
@category Creating Effects
/
const fail = exports.fail = core.fail;
/**
Creates an `Effect` that fails with the specified error, evaluated lazily.

@since 2.0.0
@category Creating Effects
/
const failSync = exports.failSync = core.failSync;
/**
Creates an `Effect` that fails with the specified `Cause`.

@since 2.0.0
@category Creating Effects
/
const failCause = exports.failCause = core.failCause;
/**
Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.

@since 2.0.0
@category Creating Effects
/
const failCauseSync = exports.failCauseSync = core.failCauseSync;
/**
Creates an effect that terminates a fiber with a specified error.

**Details**

This function is used to signal a defect, which represents a critical and
unexpected error in the code. When invoked, it produces an effect that does
not handle the error and instead terminates the fiber.

The error channel of the resulting effect is of type `never`, indicating that
it cannot recover from this failure.

**When to Use**

Use this function when encountering unexpected conditions in your code that
should not be handled as regular errors but instead represent unrecoverable
defects.

**Example** (Terminating on Division by Zero with a Specified Error)

```ts
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.die(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = divide(1, 0)

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: Cannot divide by zero
//   ...stack trace...
```

@see {@link dieSync} for a variant that throws a specified error, evaluated
lazily.
@see {@link dieMessage} for a variant that throws a `RuntimeException` with a
message.

@since 2.0.0
@category Creating Effects
/
const die = exports.die = core.die;
/**
Creates an effect that terminates a fiber with a `RuntimeException`
containing the specified message.

**Details**

This function is used to signal a defect, representing a critical and
unexpected error in the code. When invoked, it produces an effect that
terminates the fiber with a `RuntimeException` carrying the given message.

The resulting effect has an error channel of type `never`, indicating it does
not handle or recover from the error.

**When to Use**

Use this function when you want to terminate a fiber due to an unrecoverable
defect and include a clear explanation in the message.

**Example** (Terminating on Division by Zero with a Specified Message)

```ts
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.dieMessage("Cannot divide by zero")
    : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = divide(1, 0)

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) RuntimeException: Cannot divide by zero
//   ...stack trace...
```

@see {@link die} for a variant that throws a specified error.
@see {@link dieSync} for a variant that throws a specified error, evaluated
lazily.

@since 2.0.0
@category Creating Effects
/
const dieMessage = exports.dieMessage = core.dieMessage;
/**
Creates an effect that dies with the specified error, evaluated lazily.

**Details**

This function allows you to create an effect that will terminate with a fatal error.
The error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.

@see {@link die} if you don't need to evaluate the error lazily.

@since 2.0.0
@category Creating Effects
/
const dieSync = exports.dieSync = core.dieSync;
/**
Provides a way to write effectful code using generator functions, simplifying
control flow and error handling.

**When to Use**

`Effect.gen` allows you to write code that looks and behaves like synchronous
code, but it can handle asynchronous tasks, errors, and complex control flow
(like loops and conditions). It helps make asynchronous code more readable
and easier to manage.

The generator functions work similarly to `async/await` but with more
explicit control over the execution of effects. You can `yield*` values from
effects and return the final result at the end.

**Example**

```ts
import { Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))

export const program = Effect.gen(function* () {
  const transactionAmount = yield* fetchTransactionAmount
  const discountRate = yield* fetchDiscountRate
  const discountedAmount = yield* applyDiscount(
    transactionAmount,
    discountRate
  )
  const finalAmount = addServiceCharge(discountedAmount)
  return `Final amount to charge: ${finalAmount}`
})
```

@since 2.0.0
@category Creating Effects
/
const gen = exports.gen = core.gen;
/**
An effect that that runs indefinitely and never produces any result. The
moral equivalent of `while(true) {}`, only without the wasted CPU cycles.

**When to Use**

It could be useful for long-running background tasks or to simulate waiting
behavior without actually consuming resources. This effect is ideal for cases
where you want to keep the program alive or in a certain state without
performing any active work.

@since 2.0.0
@category Creating Effects
/
const never = exports.never = core.never;
/**
Ensures the `Option` is `None`, returning `void`. Otherwise, raises a
`NoSuchElementException`.

**Details**

This function checks if the provided `Option` is `None`. If it is, it returns
an effect that produces no result (i.e., `void`). If the `Option` is not
`None` (i.e., it contains a value), the function will raise a
`NoSuchElementException` error.

**When to Use**

This is useful when you want to ensure that a certain value is absent (i.e.,
`None`) before continuing execution, and to handle cases where the value is
unexpectedly present.

@since 2.0.0
/
const none = exports.none = effect.none;
/**
Creates an `Effect` that represents an asynchronous computation guaranteed to
succeed.

**Details**

The provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error
will be treated as a "defect".

This defect is not a standard error but indicates a flaw in the logic that
was expected to be error-free. You can think of it similar to an unexpected
crash in the program, which can be further managed or logged using tools like
{@link catchAllDefect}.

**Interruptions**

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

**When to Use**

Use this function when you are sure the operation will not reject.

**Example** (Delayed Message)

```ts
import { Effect } from "effect"

const delay = (message: string) =>
  Effect.promise<string>(
    () =>
      new Promise((resolve) => {
        setTimeout(() => {
          resolve(message)
        }, 2000)
      })
  )

//       Effect<string, never, never>
//      
const program = delay("Async operation completed successfully!")
```

@see {@link tryPromise} for a version that can handle failures.

@since 2.0.0
@category Creating Effects
/
const promise = exports.promise = effect.promise;
/**
Creates an `Effect` that always succeeds with a given value.

**When to Use**

Use this function when you need an effect that completes successfully with a
specific value without any errors or external dependencies.

**Example** (Creating a Successful Effect)

```ts
import { Effect } from "effect"

// Creating an effect that represents a successful scenario
//
//       Effect<number, never, never>
//      
const success = Effect.succeed(42)
```

@see {@link fail} to create an effect that represents a failure.

@since 2.0.0
@category Creating Effects
/
const succeed = exports.succeed = core.succeed;
/**
Returns an effect which succeeds with `None`.

**When to Use**

Use this function when you need to represent the absence of a value in your
code, especially when working with optional data. This can be helpful when
you want to indicate that no result is available without throwing an error or
performing additional logic.

@see {@link succeedSome} to create an effect that succeeds with a `Some` value.

@since 2.0.0
@category Creating Effects
/
const succeedNone = exports.succeedNone = effect.succeedNone;
/**
Returns an effect which succeeds with the value wrapped in a `Some`.

@see {@link succeedNone} for a similar function that returns `None` when the value is absent.

@since 2.0.0
@category Creating Effects
/
const succeedSome = exports.succeedSome = effect.succeedSome;
/**
Delays the creation of an `Effect` until it is actually needed.

**Details**

The `Effect.suspend` function takes a thunk that represents the effect and
wraps it in a suspended effect. This means the effect will not be created
until it is explicitly needed, which is helpful in various scenarios:
- **Lazy Evaluation**: Helps optimize performance by deferring computations,
  especially when the effect might not be needed, or when its computation is
  expensive. This also ensures that any side effects or scoped captures are
  re-executed on each invocation.
- **Handling Circular Dependencies**: Useful in managing circular
  dependencies, such as recursive functions that need to avoid eager
  evaluation to prevent stack overflow.
- **Unifying Return Types**: Can help TypeScript unify return types in
  situations where multiple branches of logic return different effects,
  simplifying type inference.

**When to Use**

Use this function when you need to defer the evaluation of an effect until it
is required. This is particularly useful for optimizing expensive
computations, managing circular dependencies, or resolving type inference
issues.

**Example** (Lazy Evaluation with Side Effects)

```ts
import { Effect } from "effect"

let i = 0

const bad = Effect.succeed(i++)

const good = Effect.suspend(() => Effect.succeed(i++))

console.log(Effect.runSync(bad)) // Output: 0
console.log(Effect.runSync(bad)) // Output: 0

console.log(Effect.runSync(good)) // Output: 1
console.log(Effect.runSync(good)) // Output: 2
```

**Example** (Recursive Fibonacci)

```ts
import { Effect } from "effect"

const blowsUp = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(1)
    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)

console.log(Effect.runSync(blowsUp(32)))
// crash: JavaScript heap out of memory

const allGood = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(1)
    : Effect.zipWith(
        Effect.suspend(() => allGood(n - 1)),
        Effect.suspend(() => allGood(n - 2)),
        (a, b) => a + b
      )

console.log(Effect.runSync(allGood(32)))
// Output: 3524578
```

**Example** (Using Effect.suspend to Help TypeScript Infer Types)

```ts
import { Effect } from "effect"

//   Without suspend, TypeScript may struggle with type inference.
//   Inferred type:
//     (a: number, b: number) =>
//       Effect<never, Error, never> | Effect<number, never, never>
const withoutSuspend = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//   Using suspend to unify return types.
//   Inferred type:
//     (a: number, b: number) => Effect<number, Error, never>
const withSuspend = (a: number, b: number) =>
  Effect.suspend(() =>
    b === 0
      ? Effect.fail(new Error("Cannot divide by zero"))
      : Effect.succeed(a / b)
  )
```

@since 2.0.0
@category Creating Effects
/
const suspend = exports.suspend = core.suspend;
/**
Creates an `Effect` that represents a synchronous side-effectful computation.

**Details**

The provided function (`thunk`) must not throw errors; if it does, the error
will be treated as a "defect".

This defect is not a standard error but indicates a flaw in the logic that
was expected to be error-free. You can think of it similar to an unexpected
crash in the program, which can be further managed or logged using tools like
{@link catchAllDefect}.

**When to Use**

Use this function when you are sure the operation will not fail.

**Example** (Logging a Message)

```ts
import { Effect } from "effect"

const log = (message: string) =>
  Effect.sync(() => {
    console.log(message) // side effect
  })

//       Effect<void, never, never>
//      
const program = log("Hello, World!")
```

@see {@link try_ | try} for a version that can handle failures.

@since 2.0.0
@category Creating Effects
/
const sync = exports.sync = core.sync;
const _void = exports.void = core.void;
/**
@since 2.0.0
@category Creating Effects
/
const yieldNow = exports.yieldNow = core.yieldNow;
const _catch = exports.catch = effect._catch;
/**
Handles all errors in an effect by providing a fallback effect.

**Details**

This function catches any errors that may occur during the execution of an
effect and allows you to handle them by specifying a fallback effect. This
ensures that the program continues without failing by recovering from errors
using the provided fallback logic.

**Note**: This function only handles recoverable errors. It will not recover
from unrecoverable defects.

**Example** (Providing Recovery Logic for Recoverable Errors)

```ts
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = program.pipe(
  Effect.catchAll((error) =>
    Effect.succeed(`Recovering from ${error._tag}`)
  )
)
```

@see {@link catchAllCause} for a version that can recover from both
recoverable and unrecoverable errors.

@since 2.0.0
@category Error handling
/
const catchAll = exports.catchAll = core.catchAll;
/**
Handles both recoverable and unrecoverable errors by providing a recovery
effect.

**When to Use**

The `catchAllCause` function allows you to handle all errors, including
unrecoverable defects, by providing a recovery effect. The recovery logic is
based on the `Cause` of the error, which provides detailed information about
the failure.

**When to Recover from Defects**

Defects are unexpected errors that typically shouldn't be recovered from, as
they often indicate serious issues. However, in some cases, such as
dynamically loaded plugins, controlled recovery might be needed.

**Example** (Recovering from All Errors)

```ts
import { Cause, Effect } from "effect"

// Define an effect that may fail with a recoverable or unrecoverable error
const program = Effect.fail("Something went wrong!")

// Recover from all errors by examining the cause
const recovered = program.pipe(
  Effect.catchAllCause((cause) =>
    Cause.isFailure(cause)
      ? Effect.succeed("Recovered from a regular error")
      : Effect.succeed("Recovered from a defect")
  )
)

Effect.runPromise(recovered).then(console.log)
// Output: "Recovered from a regular error"
```

@since 2.0.0
@category Error handling
/
const catchAllCause = exports.catchAllCause = core.catchAllCause;
/**
Recovers from all defects using a provided recovery function.

**When to Use**

There is no sensible way to recover from defects. This method should be used
only at the boundary between Effect and an external system, to transmit
information on a defect for diagnostic or explanatory purposes.

**Details**

`catchAllDefect` allows you to handle defects, which are unexpected errors
that usually cause the program to terminate. This function lets you recover
from these defects by providing a function that handles the error. However,
it does not handle expected errors (like those from {@link fail}) or
execution interruptions (like those from {@link interrupt}).

**When to Recover from Defects**

Defects are unexpected errors that typically shouldn't be recovered from, as
they often indicate serious issues. However, in some cases, such as
dynamically loaded plugins, controlled recovery might be needed.

**Example** (Handling All Defects)

```ts
import { Effect, Cause, Console } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.catchAllDefect(task, (defect) => {
  if (Cause.isRuntimeException(defect)) {
    return Console.log(
      `RuntimeException defect caught: ${defect.message}`
    )
  }
  return Console.log("Unknown defect caught.")
})

// We get an Exit.Success because we caught all defects
Effect.runPromiseExit(program).then(console.log)
// Output:
// RuntimeException defect caught: Boom!
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: undefined
// }
```

@since 2.0.0
@category Error handling
/
const catchAllDefect = exports.catchAllDefect = effect.catchAllDefect;
/**
Recovers from specific errors based on a predicate.

**When to Use**

`catchIf` works similarly to {@link catchSome}, but it allows you to
recover from errors by providing a predicate function. If the predicate
matches the error, the recovery effect is applied. This function doesn't
alter the error type, so the resulting effect still carries the original
error type unless a user-defined type guard is used to narrow the type.

**Example** (Catching Specific Errors with a Predicate)

```ts
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, ValidationError, never>
//      
const recovered = program.pipe(
  Effect.catchIf(
    // Only handle HttpError errors
    (error) => error._tag === "HttpError",
    () => Effect.succeed("Recovering from HttpError")
  )
)
```

@since 2.0.0
@category Error handling
/
const catchIf = exports.catchIf = core.catchIf;
/**
Catches and recovers from specific types of errors, allowing you to attempt
recovery only for certain errors.

**Details**

`catchSome` lets you selectively catch and handle errors of certain
types by providing a recovery effect for specific errors. If the error
matches a condition, recovery is attempted; if not, it doesn't affect the
program. This function doesn't alter the error type, meaning the error type
remains the same as in the original effect.

**Example** (Handling Specific Errors with Effect.catchSome)

```ts
import { Effect, Random, Option } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, HttpError | ValidationError, never>
//      
const recovered = program.pipe(
  Effect.catchSome((error) => {
    // Only handle HttpError errors
    if (error._tag === "HttpError") {
      return Option.some(Effect.succeed("Recovering from HttpError"))
    } else {
      return Option.none()
    }
  })
)
```

@see {@link catchIf} for a version that allows you to recover from errors based on a predicate.

@since 2.0.0
@category Error handling
/
const catchSome = exports.catchSome = core.catchSome;
/**
Recovers from specific causes using a provided partial function.

@see {@link catchSome} for a version that allows you to recover from errors.
@see {@link catchSomeDefect} for a version that allows you to recover from defects.

@since 2.0.0
@category Error handling
/
const catchSomeCause = exports.catchSomeCause = effect.catchSomeCause;
/**
Recovers from specific defects using a provided partial function.

**Details**

`catchSomeDefect` allows you to handle specific defects, which are
unexpected errors that can cause the program to stop. It uses a partial
function to catch only certain defects and ignores others. The function does
not handle expected errors (such as those caused by {@link fail}) or
interruptions in execution (like those caused by {@link interrupt}).

This function provides a way to handle certain types of defects while
allowing others to propagate and cause failure in the program.

**Note**: There is no sensible way to recover from defects. This method
should be used only at the boundary between Effect and an external system, to
transmit information on a defect for diagnostic or explanatory purposes.

**How the Partial Function Works**

The function provided to `catchSomeDefect` acts as a filter and a handler for defects:
- It receives the defect as an input.
- If the defect matches a specific condition (e.g., a certain error type), the function returns
  an `Option.some` containing the recovery logic.
- If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.

**Example** (Handling Specific Defects)

```ts
import { Effect, Cause, Option, Console } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.catchSomeDefect(task, (defect) => {
  if (Cause.isIllegalArgumentException(defect)) {
    return Option.some(
      Console.log(
        `Caught an IllegalArgumentException defect: ${defect.message}`
      )
    )
  }
  return Option.none()
})

// Since we are only catching IllegalArgumentException
// we will get an Exit.Failure because we simulated a runtime error.
Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: { _tag: 'RuntimeException' }
//   }
// }
```

@since 2.0.0
@category Error handling
/
const catchSomeDefect = exports.catchSomeDefect = effect.catchSomeDefect;
/**
Catches and handles specific errors by their `_tag` field, which is used as a
discriminator.

**When to Use**

`catchTag` is useful when your errors are tagged with a readonly `_tag` field
that identifies the error type. You can use this function to handle specific
error types by matching the `_tag` value. This allows for precise error
handling, ensuring that only specific errors are caught and handled.

The error type must have a readonly `_tag` field to use `catchTag`. This
field is used to identify and match errors.

**Example** (Handling Errors by Tag)

```ts
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, ValidationError, never>
//      
const recovered = program.pipe(
  // Only handle HttpError errors
  Effect.catchTag("HttpError", (_HttpError) =>
    Effect.succeed("Recovering from HttpError")
  )
)
```

@see {@link catchTags} for a version that allows you to handle multiple error
types at once.

@since 2.0.0
@category Error handling
/
const catchTag = exports.catchTag = effect.catchTag;
/**
Handles multiple errors in a single block of code using their `_tag` field.

**When to Use**

`catchTags` is a convenient way to handle multiple error types at
once. Instead of using {@link catchTag} multiple times, you can pass an
object where each key is an error type's `_tag`, and the value is the handler
for that specific error. This allows you to catch and recover from multiple
error types in a single call.

The error type must have a readonly `_tag` field to use `catchTag`. This
field is used to identify and match errors.

**Example** (Handling Multiple Tagged Error Types at Once)

```ts
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = program.pipe(
  Effect.catchTags({
    HttpError: (_HttpError) =>
      Effect.succeed(`Recovering from HttpError`),
    ValidationError: (_ValidationError) =>
      Effect.succeed(`Recovering from ValidationError`)
  })
)
```

@since 2.0.0
@category Error handling
/
const catchTags = exports.catchTags = effect.catchTags;
/**
Retrieves the cause of a failure in an effect.

**Details**

This function allows you to expose the detailed cause of an effect, which
includes a more precise representation of failures, such as error messages
and defects.

**When to Use**

This function is helpful when you need to inspect the cause of a failure in
an effect, giving you more information than just the error message. It can be
used to log, handle, or analyze failures in more detail, including
distinguishing between different types of defects (e.g., runtime exceptions,
interruptions, etc.).

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<void, never, never>
//      
const recovered = Effect.gen(function* () {
  const cause = yield* Effect.cause(program)
  yield* Console.log(cause)
})
```

@since 2.0.0
@category Error handling
/
const cause = exports.cause = effect.cause;
/**
Runs an effect repeatedly until it succeeds, ignoring errors.

**Details**

This function takes an effect and runs it repeatedly until the effect
successfully completes. If the effect fails, it will ignore the error and
retry the operation. This is useful when you need to perform a task that may
fail occasionally, but you want to keep trying until it eventually succeeds.
It works by repeatedly executing the effect until it no longer throws an
error.

**When to Use**

Use this function when you want to retry an operation multiple times until it
succeeds. It is helpful in cases where the operation may fail temporarily
(e.g., a network request), and you want to keep trying without handling or
worrying about the errors.

**Example**

```ts
import { Effect } from "effect"

let counter = 0

const effect = Effect.try(() => {
  counter++
  if (counter < 3) {
    console.log("running effect")
    throw new Error("error")
  } else {
    console.log("effect done")
    return "some result"
  }
})

const program = Effect.eventually(effect)

Effect.runPromise(program).then(console.log)
// Output:
// running effect
// running effect
// effect done
// some result
```

@since 2.0.0
@category Error handling
/
const eventually = exports.eventually = effect.eventually;
/**
Discards both the success and failure values of an effect.

**When to Use**

`ignore` allows you to run an effect without caring about its result, whether
it succeeds or fails. This is useful when you only care about the side
effects of the effect and do not need to handle or process its outcome.

**Example** (Using Effect.ignore to Discard Values)

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const task = Effect.fail("Uh oh!").pipe(Effect.as(5))

//       Effect<void, never, never>
//      
const program = Effect.ignore(task)
```

@see {@link ignoreLogged} to log failures while ignoring them.

@since 2.0.0
@category Error handling
/
const ignore = exports.ignore = effect.ignore;
/**
Ignores the result of an effect but logs any failures.

**Details**

This function takes an effect and returns a new effect that ignores whether
the original effect succeeds or fails. However, if the effect fails, it will
log the failure at the Debug level, so you can keep track of any issues that
arise.

**When to Use**

This is useful in scenarios where you want to continue with your program
regardless of the result of the effect, but you still want to be aware of
potential failures that may need attention later.

@since 2.0.0
@category Error handling
/
const ignoreLogged = exports.ignoreLogged = effect.ignoreLogged;
/**
Combines all errors from concurrent operations into a single error.

**Details**

This function is used when you have multiple operations running at the same
time, and you want to capture all the errors that occur across those
operations. Instead of handling each error separately, it combines all the
errors into one unified error.

**When to Use**

When using this function, any errors that occur in the concurrently running
operations will be grouped together into a single error. This helps simplify
error handling in cases where you don't need to differentiate between each
failure, but simply want to know that multiple failures occurred.

**Example**

```ts
import { Effect } from "effect"

const fail1 = Effect.fail("Oh uh!")
const fail2 = Effect.fail("Oh no!")
const die = Effect.dieMessage("Boom!")

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: "unbounded"
}).pipe(Effect.asVoid, Effect.parallelErrors)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
// }
```

@since 2.0.0
@category Error handling
/
const parallelErrors = exports.parallelErrors = effect.parallelErrors;
/**
Transforms an effect to expose detailed error causes.

**Details**

This function enhances an effect by providing detailed information about any
error, defect, or interruption that may occur during its execution. It
modifies the error channel of the effect so that it includes a full cause of
the failure, wrapped in a `Cause<E>` type.

After applying this function, you can use operators like {@link catchAll} and
{@link catchTags} to handle specific types of errors.

If you no longer need the detailed cause information, you can revert the
changes using {@link unsandbox} to return to the original error-handling
behavior.

**Example**

```ts
import { Effect, Console } from "effect"

//       Effect<string, Error, never>
//      
const task = Effect.fail(new Error("Oh uh!")).pipe(
  Effect.as("primary result")
)

//       Effect<string, Cause<Error>, never>
//      
const sandboxed = Effect.sandbox(task)

const program = Effect.catchTags(sandboxed, {
  Die: (cause) =>
    Console.log(`Caught a defect: ${cause.defect}`).pipe(
      Effect.as("fallback result on defect")
    ),
  Interrupt: (cause) =>
    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(
      Effect.as("fallback result on fiber interruption")
    ),
  Fail: (cause) =>
    Console.log(`Caught a defect: ${cause.error}`).pipe(
      Effect.as("fallback result on failure")
    )
})

// Restore the original error handling with unsandbox
const main = Effect.unsandbox(program)

Effect.runPromise(main).then(console.log)
// Output:
// Caught a defect: Oh uh!
// fallback result on failure
```

@see {@link unsandbox} to restore the original error handling.

@since 2.0.0
@category Error handling
/
const sandbox = exports.sandbox = effect.sandbox;
/**
Retries a failing effect based on a defined retry policy.

**Details**

The `Effect.retry` function takes an effect and a {@link Schedule} policy,
and will automatically retry the effect if it fails, following the rules of
the policy.

If the effect ultimately succeeds, the result will be returned.

If the maximum retries are exhausted and the effect still fails, the failure
is propagated.

**When to Use**

This can be useful when dealing with intermittent failures, such as network
issues or temporary resource unavailability. By defining a retry policy, you
can control the number of retries, the delay between them, and when to stop
retrying.

**Example** (Retrying with a Fixed Delay)

```ts
import { Effect, Schedule } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Define a repetition policy using a fixed delay between retries
const policy = Schedule.fixed("100 millis")

const repeated = Effect.retry(task, policy)

Effect.runPromise(repeated).then(console.log)
// Output:
// failure
// failure
// failure
// success
// yay!
```

**Example** (Retrying a Task up to 5 times)

```ts
import { Effect } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Retry the task up to 5 times
Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)
// Output:
// failure
// failure
// failure
// success
```

**Example** (Retrying Until a Specific Condition is Met)

```ts
import { Effect } from "effect"

let count = 0

// Define an effect that simulates varying error on each invocation
const action = Effect.failSync(() => {
  console.log(`Action called ${++count} time(s)`)
  return `Error ${count}`
})

// Retry the action until a specific condition is met
const program = Effect.retry(action, {
  until: (err) => err === "Error 3"
})

Effect.runPromiseExit(program).then(console.log)
// Output:
// Action called 1 time(s)
// Action called 2 time(s)
// Action called 3 time(s)
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }
// }
```

@see {@link retryOrElse} for a version that allows you to run a fallback.
@see {@link repeat} if your retry condition is based on successful outcomes rather than errors.

@since 2.0.0
@category Error handling
/
const retry = exports.retry = schedule_.retry_combined;
/**
Apply an `ExecutionPlan` to the effect, which allows you to fallback to
different resources in case of failure.

@since 3.16.0
@category Error handling
@experimental
/
const withExecutionPlan = exports.withExecutionPlan = internalExecutionPlan.withExecutionPlan;
/**
Retries a failing effect and runs a fallback effect if retries are exhausted.

**Details**

The `Effect.retryOrElse` function attempts to retry a failing effect multiple
times according to a defined {@link Schedule} policy.

If the retries are exhausted and the effect still fails, it runs a fallback
effect instead.

**When to Use**

This function is useful when you want to handle failures gracefully by
specifying an alternative action after repeated failures.

**Example** (Retrying with Fallback)

```ts
import { Effect, Schedule, Console } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Retry the task with a delay between retries and a maximum of 2 retries
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")

// If all retries fail, run the fallback effect
const repeated = Effect.retryOrElse(
  task,
  policy,
  // fallback
  () => Console.log("orElse").pipe(Effect.as("default value"))
)

Effect.runPromise(repeated).then(console.log)
// Output:
// failure
// failure
// failure
// orElse
// default value
```

@see {@link retry} for a version that does not run a fallback effect.

@since 2.0.0
@category Error handling
/
const retryOrElse = exports.retryOrElse = schedule_.retryOrElse_Effect;
const try_ = exports.try = effect.try_;
/**
Returns an effect that maps its success using the specified side-effecting
`try` function, converting any errors into typed failed effects using the
`catch` function.

@see {@link tryPromise} for a version that works with asynchronous computations.

@since 2.0.0
@category Error handling
/
const tryMap = exports.tryMap = effect.tryMap;
/**
Returns an effect that maps its success using the specified side-effecting
`try` function, converting any promise rejections into typed failed effects
using the `catch` function.

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

@see {@link tryMap} for a version that works with synchronous computations.

@since 2.0.0
@category Error handling
/
const tryMapPromise = exports.tryMapPromise = effect.tryMapPromise;
/**
Creates an `Effect` that represents an asynchronous computation that might
fail.

**When to Use**

In situations where you need to perform asynchronous operations that might
fail, such as fetching data from an API, you can use the `tryPromise`
constructor. This constructor is designed to handle operations that could
throw exceptions by capturing those exceptions and transforming them into
manageable errors.

**Error Handling**

There are two ways to handle errors with `tryPromise`:

1. If you don't provide a `catch` function, the error is caught and the
   effect fails with an `UnknownException`.
2. If you provide a `catch` function, the error is caught and the `catch`
   function maps it to an error of type `E`.

**Interruptions**

An optional `AbortSignal` can be provided to allow for interruption of the
wrapped `Promise` API.

**Example** (Fetching a TODO Item)

```ts
import { Effect } from "effect"

const getTodo = (id: number) =>
  // Will catch any errors and propagate them as UnknownException
  Effect.tryPromise(() =>
    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
  )

//       Effect<Response, UnknownException, never>
//      
const program = getTodo(1)
```

**Example** (Custom Error Handling)

```ts
import { Effect } from "effect"

const getTodo = (id: number) =>
  Effect.tryPromise({
    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),
    // remap the error
    catch: (unknown) => new Error(`something went wrong ${unknown}`)
  })

//       Effect<Response, Error, never>
//      
const program = getTodo(1)
```

@see {@link promise} if the effectful computation is asynchronous and does not throw errors.

@since 2.0.0
@category Creating Effects
/
const tryPromise = exports.tryPromise = effect.tryPromise;
/**
The `unsandbox` function is used to revert an effect that has been
sandboxed by {@link sandbox}. When you apply `unsandbox`, the
effect's error channel is restored to its original state, without the
detailed `Cause<E>` information. This means that any underlying causes of
errors, defects, or fiber interruptions are no longer exposed in the error
channel.

This function is useful when you want to remove the detailed error tracking
provided by `sandbox` and return to the standard error handling for
your effect. Once unsandboxed, the effect behaves as if `sandbox` was
never applied.

@see {@link sandbox} to expose the full cause of failures, defects, or interruptions.

@since 2.0.0
@category Error handling
/
const unsandbox = exports.unsandbox = effect.unsandbox;
/**
Allows interruption of the current fiber, even in uninterruptible regions.

**Details**

This effect checks whether any other fibers are attempting to interrupt the
current fiber. If so, it allows the current fiber to perform a
self-interruption.

**When to Use**

This is useful in situations where you want to allow interruption to happen
even in regions of the code that are normally uninterruptible.

@since 2.0.0
@category Interruption
/
const allowInterrupt = exports.allowInterrupt = effect.allowInterrupt;
/**
Checks if interruption is allowed and executes a callback accordingly.

**Details**

This function checks the current interrupt status of the running fiber. It
then calls the provided callback, passing a boolean indicating whether
interruption is allowed.

**When to Use**

This is useful for handling specific logic based on whether the current
operation can be interrupted, such as when performing asynchronous operations
or handling cancellation.

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.checkInterruptible((isInterruptible) => {
    if (isInterruptible) {
      return Console.log("You can interrupt this operation.")
    } else {
      return Console.log("This operation cannot be interrupted.")
    }
  })
})

Effect.runPromise(program)
// Output: You can interrupt this operation.

Effect.runPromise(program.pipe(Effect.uninterruptible))
// Output: This operation cannot be interrupted.

```

 @since 2.0.0
@category Interruption
/
const checkInterruptible = exports.checkInterruptible = core.checkInterruptible;
/**
Provides a way to handle timeouts in uninterruptible effects, allowing them
to continue in the background while the main control flow proceeds with the
timeout error.

**Details**

The `disconnect` function allows an uninterruptible effect to continue
running in the background, while enabling the main control flow to
immediately recognize a timeout condition. This is useful when you want to
avoid blocking the program due to long-running tasks, especially when those
tasks do not need to affect the flow of the rest of the program.

Without `disconnect`, an uninterruptible effect will ignore the
timeout and continue executing until it completes. The timeout error will
only be assessed after the effect finishes, which can cause delays in
recognizing a timeout.

With `disconnect`, the uninterruptible effect proceeds in the
background while the main program flow can immediately handle the timeout
error or trigger alternative logic. This enables faster timeout handling
without waiting for the completion of the long-running task.

**Example**

```ts
import { Effect } from "effect"

const longRunningTask = Effect.gen(function* () {
  console.log("Start heavy processing...")
  yield* Effect.sleep("5 seconds") // Simulate a long process
  console.log("Heavy processing done.")
  return "Data processed"
})

const timedEffect = longRunningTask.pipe(
  Effect.uninterruptible,
  // Allows the task to finish in the background if it times out
  Effect.disconnect,
  Effect.timeout("1 second")
)

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start heavy processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
// Heavy processing done.
```

@see {@link timeout} for a version that interrupts the effect.
@see {@link uninterruptible} for creating an uninterruptible effect.

@since 2.0.0
@category Interruption
/
const disconnect = exports.disconnect = fiberRuntime.disconnect;
/**
Represents an effect that interrupts the current fiber.

**Details**

This effect models the explicit interruption of the fiber in which it runs.
When executed, it causes the fiber to stop its operation immediately,
capturing the interruption details such as the fiber's ID and its start time.
The resulting interruption can be observed in the `Exit` type if the effect
is run with functions like {@link runPromiseExit}.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function* () {
  console.log("start")
  yield* Effect.sleep("2 seconds")
  yield* Effect.interrupt
  console.log("done")
  return "some result"
})

Effect.runPromiseExit(program).then(console.log)
// Output:
// start
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Interrupt',
//     fiberId: {
//       _id: 'FiberId',
//       _tag: 'Runtime',
//       id: 0,
//       startTimeMillis: ...
//     }
//   }
// }
```

@since 2.0.0
@category Interruption
/
const interrupt = exports.interrupt = core.interrupt;
/**
@since 2.0.0
@category Interruption
/
const interruptWith = exports.interruptWith = core.interruptWith;
/**
Marks an effect as interruptible.

@since 2.0.0
@category Interruption
/
const interruptible = exports.interruptible = core.interruptible;
/**
This function behaves like {@link interruptible}, but it also provides a
`restore` function. This function can be used to restore the interruptibility
of any specific region of code.

@since 2.0.0
@category Interruption
/
const interruptibleMask = exports.interruptibleMask = core.interruptibleMask;
/**
Registers a cleanup effect to run when an effect is interrupted.

**Details**

This function allows you to specify an effect to run when the fiber is
interrupted. This effect will be executed when the fiber is interrupted,
allowing you to perform cleanup or other actions.

**Example** (Running a Cleanup Action on Interruption)

```ts
import { Console, Effect } from "effect"

// This handler is executed when the fiber is interrupted
const handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))

const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)

Effect.runFork(success)
// Output:
// Task completed

const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)

Effect.runFork(failure)
// Output:
// Task failed

const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed
```

@since 2.0.0
@category Interruption
/
const onInterrupt = exports.onInterrupt = core.onInterrupt;
/**
Marks an effect as uninterruptible.

@since 2.0.0
@category Interruption
/
const uninterruptible = exports.uninterruptible = core.uninterruptible;
/**
This function behaves like {@link uninterruptible}, but it also provides a
`restore` function. This function can be used to restore the interruptibility
of any specific region of code.

@since 2.0.0
@category Interruption
/
const uninterruptibleMask = exports.uninterruptibleMask = core.uninterruptibleMask;
/**
Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`
or failing with specified error if the predicate fails

**Example**

```ts
import { Effect } from "effect"

const isPositive = (n: number): boolean => n > 0

// succeeds with `1`
Effect.liftPredicate(1, isPositive, n => `${n} is not positive`)

// fails with `"0 is not positive"`
Effect.liftPredicate(0, isPositive, n => `${n} is not positive`)
```

@category Condition Checking
@since 3.4.0
/
const liftPredicate = exports.liftPredicate = effect.liftPredicate;
/**
Replaces the value inside an effect with a constant value.

**Details**

This function allows you to ignore the original value inside an effect and
replace it with a constant value.

**When to Use**

It is useful when you no longer need the value produced by an effect but want
to ensure that the effect completes successfully with a specific constant
result instead. For instance, you can replace the value produced by a
computation with a predefined value, ignoring what was calculated before.

**Example** (Replacing a Value)

```ts
import { pipe, Effect } from "effect"

// Replaces the value 5 with the constant "new value"
const program = pipe(Effect.succeed(5), Effect.as("new value"))

Effect.runPromise(program).then(console.log)
// Output: "new value"
```

@since 2.0.0
@category Mapping
/
const as = exports.as = core.as;
/**
This function maps the success value of an `Effect` value to a `Some` value
in an `Option` value. If the original `Effect` value fails, the returned
`Effect` value will also fail.

@category Mapping
@since 2.0.0
/
const asSome = exports.asSome = effect.asSome;
/**
This function maps the error value of an `Effect` value to a `Some` value
in an `Option` value. If the original `Effect` value succeeds, the returned
`Effect` value will also succeed.

@category Mapping
@since 2.0.0
/
const asSomeError = exports.asSomeError = effect.asSomeError;
/**
This function maps the success value of an `Effect` value to `void`. If the
original `Effect` value succeeds, the returned `Effect` value will also
succeed. If the original `Effect` value fails, the returned `Effect` value
will fail with the same error.

@since 2.0.0
@category Mapping
/
const asVoid = exports.asVoid = core.asVoid;
/**
Swaps the success and error channels of an effect.

**Details**

This function reverses the flow of an effect by swapping its success and
error channels. The success value becomes an error, and the error value
becomes a success.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<string, number, never>
//      
const flipped = Effect.flip(program)
```

@since 2.0.0
@category Mapping
/
const flip = exports.flip = core.flip;
/**
Swaps the error/value parameters, applies the function `f` and flips the
parameters back

@since 2.0.0
@category Mapping
/
const flipWith = exports.flipWith = effect.flipWith;
/**
Transforms the value inside an effect by applying a function to it.

**Syntax**

```ts skip-type-checking
const mappedEffect = pipe(myEffect, Effect.map(transformation))
// or
const mappedEffect = Effect.map(myEffect, transformation)
// or
const mappedEffect = myEffect.pipe(Effect.map(transformation))
```

**Details**

`map` takes a function and applies it to the value contained within an
effect, creating a new effect with the transformed value.

It's important to note that effects are immutable, meaning that the original
effect is not modified. Instead, a new effect is returned with the updated
value.

**Example** (Adding a Service Charge)

```ts
import { pipe, Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.map(addServiceCharge)
)

Effect.runPromise(finalAmount).then(console.log)
// Output: 101
```

@see {@link mapError} for a version that operates on the error channel.
@see {@link mapBoth} for a version that operates on both channels.
@see {@link flatMap} or {@link andThen} for a version that can return a new effect.

@since 2.0.0
@category Mapping
/
const map = exports.map = core.map;
/**
Applies a stateful transformation to each element of a collection, producing
new elements along with an updated state.

**When to Use**

Use `mapAccum` when you need to process each element of a collection while
keeping track of some state across iterations.

**Details**

`mapAccum` takes an initial state (`initial`) and a function (`f`) that is
applied to each element. This function returns a new state and a transformed
element. The final effect produces both the accumulated state and the
transformed collection.

If the input collection is a non-empty array, the return type will match the
input collection type.

**Example**

```ts
import { Effect } from "effect"

// Define an initial state and a transformation function
const initialState = 0

const transformation = (state: number, element: string) =>
  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])

// Apply mapAccum to transform an array of strings
const program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)

Effect.runPromise(program).then(([finalState, transformedCollection]) => {
  console.log(finalState)
  console.log(transformedCollection)
})
// Output:
// 6
// [ 'A', 'BB', 'CCC' ]
```

@since 2.0.0
@category Mapping
/
const mapAccum = exports.mapAccum = effect.mapAccum;
/**
Applies transformations to both the success and error channels of an effect.

**Details**

This function takes two map functions as arguments: one for the error channel
and one for the success channel. You can use it when you want to modify both
the error and the success values without altering the overall success or
failure status of the effect.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//       Effect<boolean, Error, never>
//      
const modified = Effect.mapBoth(simulatedTask, {
  onFailure: (message) => new Error(message),
  onSuccess: (n) => n > 0
})
```

@see {@link map} for a version that operates on the success channel.
@see {@link mapError} for a version that operates on the error channel.

@since 2.0.0
@category Mapping
/
const mapBoth = exports.mapBoth = core.mapBoth;
/**
Transforms or modifies the error produced by an effect without affecting its
success value.

**When to Use**

This function is helpful when you want to enhance the error with additional
information, change the error type, or apply custom error handling while
keeping the original behavior of the effect's success values intact. It only
operates on the error channel and leaves the success channel unchanged.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//       Effect<number, Error, never>
//      
const mapped = Effect.mapError(
  simulatedTask,
  (message) => new Error(message)
)
```

@see {@link map} for a version that operates on the success channel.
@see {@link mapBoth} for a version that operates on both channels.
@see {@link orElseFail} if you want to replace the error with a new one.

@since 2.0.0
@category Mapping
/
const mapError = exports.mapError = core.mapError;
/**
Maps the cause of failure of an effect using a specified function.

@see {@link sandbox} for a version that exposes the full cause of failures, defects, or interruptions.
@see {@link catchAllCause} for a version that can recover from all types of defects.

@since 2.0.0
@category Mapping
/
const mapErrorCause = exports.mapErrorCause = effect.mapErrorCause;
/**
Combines both success and error channels of an effect into a single outcome.

**Details**

This function transforms an effect that may fail into one that always returns
a value, where both success and failure outcomes are handled as values in the
success channel.

**When to Use**

This can be useful when you want to continue execution regardless of the
error type and still capture both successful results and errors as part of
the outcome.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, string, never>
//      
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//       Effect<number | string, never, never>
//      
const recovered = Effect.merge(program)
```

@since 2.0.0
@category Mapping
/
const merge = exports.merge = effect.merge;
/**
Returns a new effect with the boolean value of this effect negated.

@since 2.0.0
@category Mapping
/
const negate = exports.negate = effect.negate;
/**
Creates a scoped resource using an `acquire` and `release` effect.

**Details**

This function helps manage resources by combining two `Effect` values: one
for acquiring the resource and one for releasing it.

`acquireRelease` does the following:

  1. Ensures that the effect that acquires the resource will not be
     interrupted. Note that acquisition may still fail due to internal
     reasons (such as an uncaught exception).
  2. Ensures that the `release` effect will not be interrupted, and will be
     executed as long as the acquisition effect successfully acquires the
     resource.

If the `acquire` function succeeds, the `release` function is added to the
list of finalizers for the scope. This ensures that the release will happen
automatically when the scope is closed.

Both `acquire` and `release` run uninterruptibly, meaning they cannot be
interrupted while they are executing.

Additionally, the `release` function can be influenced by the exit value when
the scope closes, allowing for custom handling of how the resource is
released based on the execution outcome.

**When to Use**

This function is used to ensure that an effect that represents the
acquisition of a resource (for example, opening a file, launching a thread,
etc.) will not be interrupted, and that the resource will always be released
when the `Effect` completes execution.

**Example** (Defining a Simple Resource)

```ts
import { Effect } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

// Create the resource management workflow
//
//       Effect<MyResource, Error, Scope>
//      
const resource = Effect.acquireRelease(acquire, release)
```

@see {@link acquireUseRelease} for a version that automatically handles the scoping of resources.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const acquireRelease = exports.acquireRelease = fiberRuntime.acquireRelease;
/**
Creates a scoped resource with an interruptible acquire action.

**Details**

This function is similar to {@link acquireRelease}, but it allows the
acquisition of the resource to be interrupted. The `acquire` effect, which
represents the process of obtaining the resource, can be interrupted if
necessary.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const acquireReleaseInterruptible = exports.acquireReleaseInterruptible = fiberRuntime.acquireReleaseInterruptible;
/**
Many real-world operations involve working with resources that must be released when no longer needed, such as:

- Database connections
- File handles
- Network requests

This function ensures that a resource is:

1. **Acquired** properly.
2. **Used** for its intended purpose.
3. **Released** even if an error occurs.

**Example** (Automatically Managing Resource Lifetime)

```ts
import { Effect, Console } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

const use = (res: MyResource) => Console.log(`content is ${res.contents}`)

//       Effect<void, Error, never>
//      
const program = Effect.acquireUseRelease(acquire, use, release)

Effect.runPromise(program)
// Output:
// Resource acquired
// content is lorem ipsum
// Resource released
```

@since 2.0.0
@category Scoping, Resources & Finalization
/
const acquireUseRelease = exports.acquireUseRelease = core.acquireUseRelease;
/**
Ensures a finalizer is added to the scope of the calling effect, guaranteeing
it runs when the scope is closed.

**Details**

This function adds a finalizer that will execute whenever the scope of the
effect is closed, regardless of whether the effect succeeds, fails, or is
interrupted. The finalizer receives the `Exit` value of the effect's scope,
allowing it to react differently depending on how the effect concludes.

Finalizers are a reliable way to manage resource cleanup, ensuring that
resources such as file handles, network connections, or database transactions
are properly closed even in the event of an unexpected interruption or error.

Finalizers operate in conjunction with Effect's scoped resources. If an
effect with a finalizer is wrapped in a scope, the finalizer will execute
automatically when the scope ends.

**Example** (Adding a Finalizer on Success)

```ts
import { Effect, Console } from "effect"

//       Effect<string, never, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return "some result"
})

// Wrapping the effect in a scope
//
//       Effect<string, never, never>
//      
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Success
// { _id: 'Exit', _tag: 'Success', value: 'some result' }
```

**Example** (Adding a Finalizer on Failure)

```ts
import { Effect, Console } from "effect"

//       Effect<never, string, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.fail("Uh oh!")
})

// Wrapping the effect in a scope
//
//       Effect<never, string, never>
//      
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Failure
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }
```

**Example** (Adding a Finalizer on Interruption)

```ts
import { Effect, Console } from "effect"

//       Effect<never, never, Scope>
//      
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.interrupt
})

// Wrapping the effect in a scope
//
//       Effect<never, never, never>
//      
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Failure
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Interrupt',
//     fiberId: {
//       _id: 'FiberId',
//       _tag: 'Runtime',
//       id: 0,
//       startTimeMillis: ...
//     }
//   }
// }
```

@see {@link onExit} for attaching a finalizer directly to an effect.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const addFinalizer = exports.addFinalizer = fiberRuntime.addFinalizer;
/**
Guarantees the execution of a finalizer when an effect starts execution.

**Details**

This function allows you to specify a `finalizer` effect that will always be
run once the effect starts execution, regardless of whether the effect
succeeds, fails, or is interrupted.

**When to Use**

This is useful when you need to ensure that certain cleanup or final steps
are executed in all cases, such as releasing resources or performing
necessary logging.

While this function provides strong guarantees about executing the finalizer,
it is considered a low-level tool, which may not be ideal for more complex
resource management. For higher-level resource management with automatic
acquisition and release, see the {@link acquireRelease} family of functions.
For use cases where you need access to the result of an effect, consider
using {@link onExit}.

**Example** (Running a Finalizer in All Outcomes)

```ts
import { Console, Effect } from "effect"

// Define a cleanup effect
const handler = Effect.ensuring(Console.log("Cleanup completed"))

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed
// Cleanup completed

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed
```

@see {@link onExit} for a version that provides access to the result of an
effect.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const ensuring = exports.ensuring = fiberRuntime.ensuring;
/**
Ensures a cleanup effect runs whenever the calling effect fails, providing
the failure cause to the cleanup effect.

**Details**

This function allows you to attach a cleanup effect that runs whenever the
calling effect fails. The cleanup effect receives the cause of the failure,
allowing you to perform actions such as logging, releasing resources, or
executing additional recovery logic based on the error. The cleanup effect
will execute even if the failure is due to interruption.

Importantly, the cleanup effect itself is uninterruptible, ensuring that it
completes regardless of external interruptions.

**Example** (Running Cleanup Only on Failure)

```ts
import { Console, Effect } from "effect"

// This handler logs the failure cause when the effect fails
const handler = Effect.onError((cause) =>
  Console.log(`Cleanup completed: ${cause}`)
)

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed: Error: some error

// Define a failing effect
const defect = Console.log("Task failed with defect").pipe(
  Effect.andThen(Effect.die("Boom!")),
  handler
)

Effect.runFork(defect)
// Output:
// Task failed with defect
// Cleanup completed: Error: Boom!

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed: All fibers interrupted without errors.
```

@see {@link ensuring} for attaching a cleanup effect that runs on both success and failure.
@see {@link onExit} for attaching a cleanup effect that runs on all possible exits.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const onError = exports.onError = core.onError;
/**
Guarantees that a cleanup function runs regardless of whether the effect
succeeds, fails, or is interrupted.

**Details**

This function ensures that a provided cleanup function is executed after the
effect completes, regardless of the outcome. The cleanup function is given
the `Exit` value of the effect, which provides detailed information about the
result:
- If the effect succeeds, the `Exit` contains the success value.
- If the effect fails, the `Exit` contains the error or failure cause.
- If the effect is interrupted, the `Exit` reflects the interruption.

The cleanup function is guaranteed to run uninterruptibly, ensuring reliable
resource management even in complex or high-concurrency scenarios.

**Example** (Running a Cleanup Function with the Effects Result)

```ts
import { Console, Effect, Exit } from "effect"

// Define a cleanup effect that logs the result
const handler = Effect.onExit((exit) =>
  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)
)

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed
// Cleanup completed: some result

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed: Error: some error

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed: All fibers interrupted without errors.
```

@since 2.0.0
@category Scoping, Resources & Finalization
/
const onExit = exports.onExit = core.onExit;
/**
Ensures that finalizers are run concurrently when the scope of an effect is
closed.

**Details**

This function modifies the behavior of finalizers within a scoped workflow to
allow them to run concurrently when the scope is closed.

By default, finalizers are executed sequentially in reverse order of their
addition, but this function changes that behavior to execute all finalizers
concurrently.

**When to Use**

Running finalizers concurrently can improve performance when multiple
independent cleanup tasks need to be performed. However, it requires that
these tasks do not depend on the order of execution or introduce race
conditions.

**Example**

```ts
import { Console, Effect } from "effect"

// Define a program that adds multiple finalizers
const program = Effect.gen(function*() {
  yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))
  yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))
  yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))
  return "some result"
})

// Modify the program to ensure finalizers run in parallel
const modified = program.pipe(Effect.parallelFinalizers)

const runnable = Effect.scoped(modified)

Effect.runFork(runnable)
// Output:
// Finalizer 2 executed
// Finalizer 3 executed
// Finalizer 1 executed
```

@see {@link sequentialFinalizers} for a version that ensures finalizers are run sequentially.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const parallelFinalizers = exports.parallelFinalizers = fiberRuntime.parallelFinalizers;
/**
Ensures that finalizers are run sequentially in reverse order of their
addition.

**Details**

This function modifies the behavior of finalizers within a scoped workflow to
ensure they are run sequentially in reverse order when the scope is closed.

By default, finalizers are executed sequentially, so this only changes the
behavior if the scope is configured to run finalizers concurrently.

@see {@link parallelFinalizers} for a version that ensures finalizers are run concurrently.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const sequentialFinalizers = exports.sequentialFinalizers = fiberRuntime.sequentialFinalizers;
/**
Applies a custom execution strategy to finalizers within a scoped workflow.

**Details**

This function allows you to control how finalizers are executed in a scope by
applying a specified `ExecutionStrategy`. The `strategy` can dictate whether
finalizers run (e.g., sequentially or in parallel).

Additionally, the function provides a `restore` operation, which ensures that
the effect passed to it is executed under the default execution strategy.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const finalizersMask = exports.finalizersMask = fiberRuntime.finalizersMask;
/**
Provides access to the current scope in a scoped workflow.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const scope = exports.scope = fiberRuntime.scope;
/**
Accesses the current scope and uses it to perform the specified effect.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const scopeWith = exports.scopeWith = fiberRuntime.scopeWith;
/**
Creates a `Scope`, passes it to the specified effectful function, and closes
the scope when the effect completes (whether through success, failure, or
interruption).

@since 3.11.0
@category Scoping, Resources & Finalization
/
const scopedWith = exports.scopedWith = fiberRuntime.scopedWith;
/**
Scopes all resources used in an effect to the lifetime of the effect.

**Details**

This function ensures that all resources used within an effect are tied to
its lifetime. Finalizers for these resources are executed automatically when
the effect completes, whether through success, failure, or interruption. This
guarantees proper resource cleanup without requiring explicit management.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const scoped = exports.scoped = fiberRuntime.scopedEffect;
/**
Scopes all resources acquired by one effect to the lifetime of another
effect.

**Details**

This function allows you to scope the resources acquired by one effect
(`self`) to the lifetime of another effect (`use`). This ensures that the
resources are cleaned up as soon as the `use` effect completes, regardless of
how the `use` effect ends (success, failure, or interruption).

**Example**

```ts
import { Console, Effect } from "effect"

const acquire = Console.log("Acquiring resource").pipe(
  Effect.as(1),
  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
)
const use = (resource: number) => Console.log(`Using resource: ${resource}`)

const program = acquire.pipe(Effect.using(use))

Effect.runFork(program)
// Output:
// Acquiring resource
// Using resource: 1
// Releasing resource
```

@see {@link scopedWith} Manage scoped operations with a temporary scope.

@since 2.0.0
@category Scoping, Resources & Finalization
/
const using = exports.using = fiberRuntime.using;
/**
Returns the result of the effect and a finalizer to close its scope.

**Details**

This function allows you to retrieve both the result of an effect and a
finalizer that can be used to manually close its scope. This is useful for
workflows where you need early access to the result while retaining control
over the resource cleanup process.

**Example**

```ts
import { Console, Effect } from "effect"

const acquire = Console.log("Acquiring resource").pipe(
  Effect.as(1),
  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
)
const program = Effect.gen(function*() {
  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)
  console.log(`Using resource: ${resource}`)
  yield* Effect.sleep("1 second")
  yield* finalizer
})

Effect.runFork(program.pipe(Effect.scoped))
// Output:
// Acquiring resource
// Using resource: 1
// Releasing resource
```

@since 2.0.0
@category Scoping, Resources & Finalization
/
const withEarlyRelease = exports.withEarlyRelease = fiberRuntime.withEarlyRelease;
/**
Returns a new effect that will not succeed with its value before first
waiting for the end of all child fibers forked by the effect.

@since 2.0.0
@category Supervision & Fibers
/
const awaitAllChildren = exports.awaitAllChildren = circular.awaitAllChildren;
/**
Returns a new workflow that will not supervise any fibers forked by this
workflow.

@since 2.0.0
@category Supervision & Fibers
/
const daemonChildren = exports.daemonChildren = fiberRuntime.daemonChildren;
/**
Constructs an effect with information about the current `Fiber`.

@since 2.0.0
@category Supervision & Fibers
/
const descriptor = exports.descriptor = effect.descriptor;
/**
Constructs an effect based on information about the current `Fiber`.

@since 2.0.0
@category Supervision & Fibers
/
const descriptorWith = exports.descriptorWith = effect.descriptorWith;
/**
Returns a new workflow that executes this one and captures the changes in
`FiberRef` values.

@since 2.0.0
@category Supervision & Fibers
/
const diffFiberRefs = exports.diffFiberRefs = effect.diffFiberRefs;
/**
Acts on the children of this fiber (collected into a single fiber),
guaranteeing the specified callback will be invoked, whether or not this
effect succeeds.

@since 2.0.0
@category Supervision & Fibers
/
const ensuringChild = exports.ensuringChild = circular.ensuringChild;
/**
Acts on the children of this fiber, guaranteeing the specified callback
will be invoked, whether or not this effect succeeds.

@since 2.0.0
@category Supervision & Fibers
/
const ensuringChildren = exports.ensuringChildren = circular.ensuringChildren;
/**
@since 2.0.0
@category Supervision & Fibers
/
const fiberId = exports.fiberId = core.fiberId;
/**
@since 2.0.0
@category Supervision & Fibers
/
const fiberIdWith = exports.fiberIdWith = core.fiberIdWith;
/**
Creates a new fiber to run an effect concurrently.

**Details**

This function takes an effect and forks it into a separate fiber, allowing it
to run concurrently without blocking the original effect. The new fiber
starts execution immediately after being created, and the fiber object is
returned immediately without waiting for the effect to begin. This is useful
when you want to run tasks concurrently while continuing other tasks in the
parent fiber.

The forked fiber is attached to the parent fiber's scope. This means that
when the parent fiber terminates, the child fiber will also be terminated
automatically. This feature, known as "auto supervision," ensures that no
fibers are left running unintentionally. If you prefer not to have this auto
supervision behavior, you can use {@link forkDaemon} or {@link forkIn}.

**When to Use**

Use this function when you need to run an effect concurrently without
blocking the current execution flow. For example, you might use it to launch
background tasks or concurrent computations. However, working with fibers can
be complex, so before using this function directly, you might want to explore
higher-level functions like {@link raceWith}, {@link zip}, or others that can
manage concurrency for you.

**Example**

```ts
import { Effect } from "effect"

const fib = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(n)
    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

//       Effect<RuntimeFiber<number, never>, never, never>
//      
const fib10Fiber = Effect.fork(fib(10))
```

@see {@link forkWithErrorHandler} for a version that allows you to handle errors.

@since 2.0.0
@category Supervision & Fibers
/
const fork = exports.fork = fiberRuntime.fork;
/**
Creates a long-running background fiber that is independent of its parent.

**Details**

This function creates a "daemon" fiber that runs in the background and is not
tied to the lifecycle of its parent fiber. Unlike normal fibers that stop
when the parent fiber terminates, a daemon fiber will continue running until
the global scope closes or the fiber completes naturally. This makes it
useful for tasks that need to run in the background independently, such as
periodic logging, monitoring, or background data processing.

**Example** (Creating a Daemon Fiber)

```ts
import { Effect, Console, Schedule } from "effect"

// Daemon fiber that logs a message repeatedly every second
const daemon = Effect.repeat(
  Console.log("daemon: still running!"),
  Schedule.fixed("1 second")
)

const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Daemon fiber running independently
  yield* Effect.forkDaemon(daemon)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

Effect.runFork(parent)
// Output:
// parent: started!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// parent: finished!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// ...etc...
```

@since 2.0.0
@category Supervision & Fibers
/
const forkDaemon = exports.forkDaemon = fiberRuntime.forkDaemon;
/**
Returns an effect that forks all of the specified values, and returns a
composite fiber that produces a list of their results, in order.

@since 2.0.0
@category Supervision & Fibers
/
const forkAll = exports.forkAll = circular.forkAll;
/**
Forks an effect in a specific scope, allowing finer control over its
execution.

**Details**

There are some cases where we need more fine-grained control, so we want to
fork a fiber in a specific scope. We can use the `Effect.forkIn` operator
which takes the target scope as an argument.

The fiber will be interrupted when the scope is closed.

**Example** (Forking a Fiber in a Specific Scope)

In this example, the child fiber is forked into the outerScope,
allowing it to outlive the inner scope but still be terminated
when the outerScope is closed.

```ts
import { Console, Effect, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log("child: still running!"),
  Schedule.fixed("1 second")
)

const program = Effect.scoped(
  Effect.gen(function* () {
    yield* Effect.addFinalizer(() =>
      Console.log("The outer scope is about to be closed!")
    )

    // Capture the outer scope
    const outerScope = yield* Effect.scope

    // Create an inner scope
    yield* Effect.scoped(
      Effect.gen(function* () {
        yield* Effect.addFinalizer(() =>
          Console.log("The inner scope is about to be closed!")
        )
        // Fork the child fiber in the outer scope
        yield* Effect.forkIn(child, outerScope)
        yield* Effect.sleep("3 seconds")
      })
    )

    yield* Effect.sleep("5 seconds")
  })
)

Effect.runFork(program)
// Output:
// child: still running!
// child: still running!
// child: still running!
// The inner scope is about to be closed!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// The outer scope is about to be closed!
```

@since 2.0.0
@category Supervision & Fibers
/
const forkIn = exports.forkIn = circular.forkIn;
/**
Forks a fiber in a local scope, ensuring it outlives its parent.

**Details**

This function is used to create fibers that are tied to a local scope,
meaning they are not dependent on their parent fiber's lifecycle. Instead,
they will continue running until the scope they were created in is closed.
This is particularly useful when you need a fiber to run independently of the
parent fiber, but still want it to be terminated when the scope ends.

Fibers created with this function are isolated from the parent fibers
termination, so they can run for a longer period. This behavior is different
from fibers created with {@link fork}, which are terminated when the parent fiber
terminates. With `forkScoped`, the child fiber will keep running until the
local scope ends, regardless of the state of the parent fiber.

**Example** (Forking a Fiber in a Local Scope)

In this example, the child fiber continues to run beyond the lifetime of the parent fiber.
The child fiber is tied to the local scope and will be terminated only when the scope ends.

```ts
import { Effect, Console, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log("child: still running!"),
  Schedule.fixed("1 second")
)

//       Effect<void, never, Scope>
//      
const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Child fiber attached to local scope
  yield* Effect.forkScoped(child)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

// Program runs within a local scope
const program = Effect.scoped(
  Effect.gen(function* () {
    console.log("Local scope started!")
    yield* Effect.fork(parent)
    // Scope lasts for 5 seconds
    yield* Effect.sleep("5 seconds")
    console.log("Leaving the local scope!")
  })
)

Effect.runFork(program)
// Output:
// Local scope started!
// parent: started!
// child: still running!
// child: still running!
// child: still running!
// parent: finished!
// child: still running!
// child: still running!
// Leaving the local scope!
```

@since 2.0.0
@category Supervision & Fibers
/
const forkScoped = exports.forkScoped = circular.forkScoped;
/**
Like {@link fork} but handles an error with the provided handler.

@since 2.0.0
@category Supervision & Fibers
/
const forkWithErrorHandler = exports.forkWithErrorHandler = fiberRuntime.forkWithErrorHandler;
/**
Creates an `Effect` value that represents the exit value of the specified
fiber.

@see {@link fromFiberEffect} for creating an effect from a fiber obtained from an effect.

@since 2.0.0
@category Supervision & Fibers
/
const fromFiber = exports.fromFiber = circular.fromFiber;
/**
Creates an `Effect` value that represents the exit value of a fiber obtained
from an effect.

@see {@link fromFiber} for creating an effect from a fiber.

@since 2.0.0
@category Supervision & Fibers
/
const fromFiberEffect = exports.fromFiberEffect = circular.fromFiberEffect;
/**
Supervises child fibers by reporting them to a specified supervisor.

**Details**

This function takes a supervisor as an argument and returns an effect where
all child fibers forked within it are supervised by the provided supervisor.
This enables you to capture detailed information about these child fibers,
such as their status, through the supervisor.

**Example** (Monitoring Fiber Count)

```ts
import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"

// Main program that monitors fibers while calculating a Fibonacci number
const program = Effect.gen(function* () {
  // Create a supervisor to track child fibers
  const supervisor = yield* Supervisor.track

  // Start a Fibonacci calculation, supervised by the supervisor
  const fibFiber = yield* fib(20).pipe(
    Effect.supervised(supervisor),
    // Fork the Fibonacci effect into a fiber
    Effect.fork
  )

  // Define a schedule to periodically monitor the fiber count every 500ms
  const policy = Schedule.spaced("500 millis").pipe(
    Schedule.whileInputEffect((_) =>
      Fiber.status(fibFiber).pipe(
        // Continue while the Fibonacci fiber is not done
        Effect.andThen((status) => status !== FiberStatus.done)
      )
    )
  )

  // Start monitoring the fibers, using the supervisor to track the count
  const monitorFiber = yield* monitorFibers(supervisor).pipe(
    // Repeat the monitoring according to the schedule
    Effect.repeat(policy),
    // Fork the monitoring into its own fiber
    Effect.fork
  )

  // Join the monitor and Fibonacci fibers to ensure they complete
  yield* Fiber.join(monitorFiber)
  const result = yield* Fiber.join(fibFiber)

  console.log(`fibonacci result: ${result}`)
})

// Function to monitor and log the number of active fibers
const monitorFibers = (
  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>
): Effect.Effect<void> =>
  Effect.gen(function* () {
    const fibers = yield* supervisor.value // Get the current set of fibers
    console.log(`number of fibers: ${fibers.length}`)
  })

// Recursive Fibonacci calculation, spawning fibers for each recursive step
const fib = (n: number): Effect.Effect<number> =>
  Effect.gen(function* () {
    if (n <= 1) {
      return 1
    }
    yield* Effect.sleep("500 millis") // Simulate work by delaying

    // Fork two fibers for the recursive Fibonacci calls
    const fiber1 = yield* Effect.fork(fib(n - 2))
    const fiber2 = yield* Effect.fork(fib(n - 1))

    // Join the fibers to retrieve their results
    const v1 = yield* Fiber.join(fiber1)
    const v2 = yield* Fiber.join(fiber2)

    return v1 + v2 // Combine the results
  })

Effect.runPromise(program)
// Output:
// number of fibers: 0
// number of fibers: 2
// number of fibers: 6
// number of fibers: 14
// number of fibers: 30
// number of fibers: 62
// number of fibers: 126
// number of fibers: 254
// number of fibers: 510
// number of fibers: 1022
// number of fibers: 2034
// number of fibers: 3795
// number of fibers: 5810
// number of fibers: 6474
// number of fibers: 4942
// number of fibers: 2515
// number of fibers: 832
// number of fibers: 170
// number of fibers: 18
// number of fibers: 0
// fibonacci result: 10946
```

@since 2.0.0
@category Supervision & Fibers
/
const supervised = exports.supervised = circular.supervised;
/**
Transplants specified effects so that when those effects fork other
effects, the forked effects will be governed by the scope of the fiber that
executes this effect.

This can be used to "graft" deep grandchildren onto a higher-level scope,
effectively extending their lifespans into the parent scope.

@since 2.0.0
@category Supervision & Fibers
/
const transplant = exports.transplant = core.transplant;
/**
@since 2.0.0
@category Supervision & Fibers
/
const withConcurrency = exports.withConcurrency = core.withConcurrency;
/**
Sets the provided scheduler for usage in the wrapped effect

@since 2.0.0
@category Scheduler
/
const withScheduler = exports.withScheduler = Scheduler.withScheduler;
/**
Sets the scheduling priority used when yielding

@since 2.0.0
@category Scheduler
/
const withSchedulingPriority = exports.withSchedulingPriority = core.withSchedulingPriority;
/**
Sets the maximum number of operations before yield by the default schedulers

@since 2.0.0
@category Scheduler
/
const withMaxOpsBeforeYield = exports.withMaxOpsBeforeYield = core.withMaxOpsBeforeYield;
/**
Retrieves the `Clock` service from the context.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  const clock = yield* Effect.clock
  const currentTime = yield* clock.currentTimeMillis
  console.log(`Current time in milliseconds: ${currentTime}`)
})

Effect.runFork(program)
// Example Output:
// Current time in milliseconds: 1735484796134
```

@since 2.0.0
@category Clock
/
const clock = exports.clock = effect.clock;
/**
Retrieves the `Clock` service from the context and provides it to the
specified effectful function.

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.clockWith((clock) =>
  clock.currentTimeMillis.pipe(
    Effect.map((currentTime) => `Current time is: ${currentTime}`),
    Effect.tap(Console.log)
  )
)

Effect.runFork(program)
// Example Output:
// Current time is: 1735484929744
```

@since 2.0.0
@category Clock
/
const clockWith = exports.clockWith = effect.clockWith;
/**
Sets the implementation of the `Clock` service to the specified value and
restores it to its original value when the scope is closed.

@since 2.0.0
@category Clock
/
const withClockScoped = exports.withClockScoped = fiberRuntime.withClockScoped;
/**
Executes the specified workflow with the specified implementation of the
`Clock` service.

@since 2.0.0
@category Clock
/
const withClock = exports.withClock = defaultServices.withClock;
/**
Retreives the `Console` service from the context

@since 2.0.0
@category Console
/
const console = exports.console = console_.console;
/**
Retreives the `Console` service from the context and provides it to the
specified effectful function.

@since 2.0.0
@category Console
/
const consoleWith = exports.consoleWith = console_.consoleWith;
/**
Sets the implementation of the console service to the specified value and
restores it to its original value when the scope is closed.

@since 2.0.0
@category Creating Effects
/
const withConsoleScoped = exports.withConsoleScoped = console_.withConsoleScoped;
/**
Executes the specified workflow with the specified implementation of the
console service.

@since 2.0.0
@category Console
/
const withConsole = exports.withConsole = console_.withConsole;
/**
Delays the execution of an effect by a specified `Duration`.

**Details

This function postpones the execution of the provided effect by the specified
duration. The duration can be provided in various formats supported by the
`Duration` module.

Internally, this function does not block the thread; instead, it uses an
efficient, non-blocking mechanism to introduce the delay.

**Example**

```ts
import { Console, Effect } from "effect"

const task = Console.log("Task executed")

const program = Console.log("start").pipe(
  Effect.andThen(
    // Delays the log message by 2 seconds
    task.pipe(Effect.delay("2 seconds"))
  )
)

Effect.runFork(program)
// Output:
// start
// Task executed
```

@since 2.0.0
@category Delays & Timeouts
/
const delay = exports.delay = effect.delay;
/**
Suspends the execution of an effect for a specified `Duration`.

**Details**

This function pauses the execution of an effect for a given duration. It is
asynchronous, meaning that it does not block the fiber executing the effect.
Instead, the fiber is suspended during the delay period and can resume once
the specified time has passed.

The duration can be specified using various formats supported by the
`Duration` module, such as a string (`"2 seconds"`) or numeric value
representing milliseconds.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  console.log("Starting task...")
  yield* Effect.sleep("3 seconds") // Waits for 3 seconds
  console.log("Task completed!")
})

Effect.runFork(program)
// Output:
// Starting task...
// Task completed!
```

@since 2.0.0
@category Delays & Timeouts
/
const sleep = exports.sleep = effect.sleep;
/**
Executes an effect and measures the time it takes to complete.

**Details**

This function wraps the provided effect and returns a new effect that, when
executed, performs the original effect and calculates its execution duration.

The result of the new effect includes both the execution time (as a
`Duration`) and the original effect's result. This is useful for monitoring
performance or gaining insights into the time taken by specific operations.

The original effect's behavior (success, failure, or interruption) remains
unchanged, and the timing information is provided alongside the result in a
tuple.

**Example**

```ts
import { Duration, Effect } from "effect"

const task = Effect.gen(function*() {
  yield* Effect.sleep("2 seconds") // Simulates some work
  return "some result"
})

const timedTask = task.pipe(Effect.timed)

const program = Effect.gen(function*() {
  const [duration, result] = yield* timedTask
  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)
})

Effect.runFork(program)
// Output: Task completed in 2003.749125 ms with result: some result
```

@since 2.0.0
@category Delays & Timeouts
/
const timed = exports.timed = effect.timed;
/**
Executes an effect and measures its execution time using a custom clock.

**Details**

This function extends the functionality of {@link timed} by allowing you to
specify a custom clock for measuring the execution duration. The provided
effect (`nanoseconds`) represents the clock and should return the current
time in nanoseconds. The timing information is computed using this custom
clock instead of the default system clock.

@since 2.0.0
@category Delays & Timeouts
/
const timedWith = exports.timedWith = effect.timedWith;
/**
Adds a time limit to an effect, triggering a timeout if the effect exceeds
the duration.

**Details**

This function allows you to enforce a time limit on the execution of an
effect. If the effect does not complete within the given duration, it fails
with a `TimeoutException`. This is useful for preventing tasks from hanging
indefinitely, especially in scenarios where responsiveness or resource limits
are critical.

The returned effect will either:
- Succeed with the original effect's result if it completes within the
  specified duration.
- Fail with a `TimeoutException` if the time limit is exceeded.

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
```

@see {@link timeoutFail} for a version that raises a custom error.
@see {@link timeoutFailCause} for a version that raises a custom defect.
@see {@link timeoutTo} for a version that allows specifying both success and
timeout handlers.

@since 2.0.0
@category Delays & Timeouts
/
const timeout = exports.timeout = circular.timeout;
/**
Gracefully handles timeouts by returning an `Option` that represents either
the result or a timeout.

**Details**

This function wraps the outcome of an effect in an `Option` type. If the
effect completes within the specified duration, it returns a `Some`
containing the result. If the effect times out, it returns a `None`. Unlike
other timeout methods, this approach does not raise errors or exceptions;
instead, it allows you to treat timeouts as a regular outcome, simplifying
the logic for handling delays.

**When to Use**

This is useful when you want to handle timeouts without causing the program
to fail, making it easier to manage situations where you expect tasks might
take too long but want to continue executing other tasks.

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const timedOutEffect = Effect.all([
  task.pipe(Effect.timeoutOption("3 seconds")),
  task.pipe(Effect.timeoutOption("1 second"))
])

Effect.runPromise(timedOutEffect).then(console.log)
// Output:
// Start processing...
// Processing complete.
// Start processing...
// [
//   { _id: 'Option', _tag: 'Some', value: 'Result' },
//   { _id: 'Option', _tag: 'None' }
// ]
```

@see {@link timeout} for a version that raises a `TimeoutException`.
@see {@link timeoutFail} for a version that raises a custom error.
@see {@link timeoutFailCause} for a version that raises a custom defect.
@see {@link timeoutTo} for a version that allows specifying both success and
timeout handlers.

@since 3.1.0
@category Delays & Timeouts
/
const timeoutOption = exports.timeoutOption = circular.timeoutOption;
/**
Specifies a custom error to be produced when a timeout occurs.

**Details**

This function allows you to handle timeouts in a customized way by defining a
specific error to be raised when an effect exceeds the given duration. Unlike
default timeout behaviors that use generic exceptions, this function gives
you the flexibility to specify a meaningful error type that aligns with your
application's needs.

When you apply this function, you provide:
- A `duration`: The time limit for the effect.
- An `onTimeout` function: A lazy evaluation function that generates the
  custom error if the timeout occurs.

If the effect completes within the time limit, its result is returned
normally. Otherwise, the `onTimeout` function is triggered, and its output is
used as the error for the effect.

**Example**

```ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

class MyTimeoutError {
  readonly _tag = "MyTimeoutError"
}

const program = task.pipe(
  Effect.timeoutFail({
    duration: "1 second",
    onTimeout: () => new MyTimeoutError() // Custom timeout error
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: MyTimeoutError { _tag: 'MyTimeoutError' }
//   }
// }
```

@see {@link timeout} for a version that raises a `TimeoutException`.
@see {@link timeoutFailCause} for a version that raises a custom defect.
@see {@link timeoutTo} for a version that allows specifying both success and
timeout handlers.

@since 2.0.0
@category Delays & Timeouts
/
const timeoutFail = exports.timeoutFail = circular.timeoutFail;
/**
Specifies a custom defect to be thrown when a timeout occurs.

**Details**

This function allows you to handle timeouts as exceptional cases by
generating a custom defect when an effect exceeds the specified duration. You
provide:
- A `duration`: The time limit for the effect.
- An `onTimeout` function: A lazy evaluation function that generates the
  custom defect (typically created using `Cause.die`).

If the effect completes within the time limit, its result is returned
normally. Otherwise, the custom defect is triggered, and the effect fails
with that defect.

**When to Use**

This is especially useful when you need to treat timeouts as critical
failures in your application and wish to include meaningful information in
the defect.

**Example**

```ts
import { Effect, Cause } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutFailCause({
    duration: "1 second",
    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
// }
```

@see {@link timeout} for a version that raises a `TimeoutException`.
@see {@link timeoutFail} for a version that raises a custom error.
@see {@link timeoutTo} for a version that allows specifying both success and
timeout handlers.

@since 2.0.0
@category Delays & Timeouts
/
const timeoutFailCause = exports.timeoutFailCause = circular.timeoutFailCause;
/**
Provides custom behavior for successful and timed-out operations.

**Details**

This function allows you to define distinct outcomes for an effect depending
on whether it completes within a specified time frame or exceeds the timeout
duration. You can provide:
- `onSuccess`: A handler for processing the result of the effect if it
  completes successfully within the time limit.
- `onTimeout`: A handler for generating a result when the effect times out.
- `duration`: The maximum allowed time for the effect to complete.

**When to Use**

Unlike {@link timeout}, which raises an exception for timeouts, this function
gives you full control over the behavior for both success and timeout
scenarios. It is particularly useful when you want to encapsulate timeouts
and successes into a specific data structure, like an `Either` type, to
represent these outcomes in a meaningful way.

**Example**

```ts
import { Effect, Either } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutTo({
    duration: "1 second",
    onSuccess: (result): Either.Either<string, string> =>
      Either.right(result),
    onTimeout: (): Either.Either<string, string> =>
      Either.left("Timed out!")
  })
)

Effect.runPromise(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: "Either",
//   _tag: "Left",
//   left: "Timed out!"
// }
```

@see {@link timeout} for a version that raises a `TimeoutException`.
@see {@link timeoutFail} for a version that raises a custom error.
@see {@link timeoutFailCause} for a version that raises a custom defect.

@since 2.0.0
@category Delays & Timeouts
/
const timeoutTo = exports.timeoutTo = circular.timeoutTo;
/**
Allows working with the default configuration provider.

**Details**

This function retrieves the default configuration provider and passes it to
the provided function, which can use it to perform computations or retrieve
configuration values. The function can return an effect that leverages the
configuration provider for its operations.

@since 2.0.0
@category Config
/
const configProviderWith = exports.configProviderWith = defaultServices.configProviderWith;
/**
Executes an effect using a specific configuration provider.

**Details**

This function lets you run an effect with a specified configuration provider.
The custom provider will override the default configuration provider for the
duration of the effect's execution.

**When to Use**

This is particularly useful when you need to use a different set of
configuration values or sources for specific parts of your application.

**Example**

```ts
import { Config, ConfigProvider, Effect } from "effect"

const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(
  new Map([["custom-key", "custom-value"]])
)

const program = Effect.withConfigProvider(customProvider)(
  Effect.gen(function*() {
    const value = yield* Config.string("custom-key")
    console.log(`Config value: ${value}`)
  })
)

Effect.runPromise(program)
// Output:
// Config value: custom-value
```

@since 2.0.0
@category Config
/
const withConfigProvider = exports.withConfigProvider = defaultServices.withConfigProvider;
/**
Sets a configuration provider within a scope.

**Details**

This function sets the configuration provider to a specified value and
ensures that it is restored to its original value when the scope is closed.

@since 2.0.0
@category Config
/
const withConfigProviderScoped = exports.withConfigProviderScoped = fiberRuntime.withConfigProviderScoped;
/**
Accesses the full context of the effect.

**Details**

This function provides the ability to access the entire context required by
an effect. The context is a container that holds dependencies or environment
values needed by an effect to run. By using this function, you can retrieve
and work with the context directly within an effect.

@since 2.0.0
@category Context
/
const context = exports.context = core.context;
/**
Accesses the context and applies a transformation function.

**Details**

This function retrieves the context of the effect and applies a pure
transformation function to it. The result of the transformation is then
returned within the effect.

@see {@link contextWithEffect} for a version that allows effectful transformations.

@since 2.0.0
@category Context
/
const contextWith = exports.contextWith = effect.contextWith;
/**
Accesses the context and performs an effectful transformation.

**Details**

This function retrieves the context and allows you to transform it
effectually using another effect. It is useful when the transformation
involves asynchronous or effectful operations.

@see {@link contextWith} for a version that allows pure transformations.

@since 2.0.0
@category Context
/
const contextWithEffect = exports.contextWithEffect = core.contextWithEffect;
/**
Provides part of the required context while leaving the rest unchanged.

**Details**

This function allows you to transform the context required by an effect,
providing part of the context and leaving the rest to be fulfilled later.

**Example**

```ts
import { Context, Effect } from "effect"

class Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}
class Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}

const program = Effect.gen(function*() {
  const service1 = yield* Service1
  console.log(service1.port)
  const service2 = yield* Service2
  console.log(service2.connection)
  return "some result"
})

//       Effect<string, never, Service2>
//      
const programWithService1 = Effect.mapInputContext(
  program,
  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })
)

const runnable = programWithService1.pipe(
  Effect.provideService(Service2, { connection: "localhost" }),
  Effect.provideService(Service1, { port: 3001 })
)

Effect.runPromise(runnable)
// Output:
// 3000
// localhost
```

@since 2.0.0
@category Context
/
const mapInputContext = exports.mapInputContext = core.mapInputContext;
/**
Provides necessary dependencies to an effect, removing its environmental
requirements.

**Details**

This function allows you to supply the required environment for an effect.
The environment can be provided in the form of one or more `Layer`s, a
`Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is
provided, the effect can run without requiring external dependencies.

You can compose layers to create a modular and reusable way of setting up the
environment for effects. For example, layers can be used to configure
databases, logging services, or any other required dependencies.

**Example**

```ts
import { Context, Effect, Layer } from "effect"

class Database extends Context.Tag("Database")<
  Database,
  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }
>() {}

const DatabaseLive = Layer.succeed(
  Database,
  {
    // Simulate a database query
    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))
  }
)

//       Effect<unknown[], never, Database>
//      
const program = Effect.gen(function*() {
  const database = yield* Database
  const result = yield* database.query("SELECT * FROM users")
  return result
})

//       Effect<unknown[], never, never>
//      
const runnable = Effect.provide(program, DatabaseLive)

Effect.runPromise(runnable).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"
// []
```

@see {@link provideService} for providing a service to an effect.

@since 2.0.0
@category Context
/
const provide = exports.provide = layer.effect_provide;
/**
Provides an implementation for a service in the context of an effect.

**Details**

This function allows you to supply a specific implementation for a service
required by an effect. Services are typically defined using `Context.Tag`,
which acts as a unique identifier for the service. By using this function,
you link the service to its concrete implementation, enabling the effect to
execute successfully without additional requirements.

For example, you can use this function to provide a random number generator,
a logger, or any other service your effect depends on. Once the service is
provided, all parts of the effect that rely on the service will automatically
use the implementation you supplied.

**Example**

```ts
import { Effect, Context } from "effect"

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

// Using the service
const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// Providing the implementation
//
//       Effect<void, never, never>
//      
const runnable = Effect.provideService(program, Random, {
  next: Effect.sync(() => Math.random())
})

// Run successfully
Effect.runPromise(runnable)
// Example Output:
// random number: 0.8241872233134417
```

@see {@link provide} for providing multiple layers to an effect.

@since 2.0.0
@category Context
/
const provideService = exports.provideService = effect.provideService;
/**
Dynamically provides an implementation for a service using an effect.

**Details**

This function allows you to provide an implementation for a service
dynamically by using another effect. The provided effect is executed to
produce the service implementation, which is then made available to the
consuming effect. This is particularly useful when the service implementation
itself requires asynchronous or resource-intensive initialization.

For example, you can use this function to lazily initialize a database
connection or fetch configuration values from an external source before
making the service available to your effect.

@since 2.0.0
@category Context
/
const provideServiceEffect = exports.provideServiceEffect = effect.provideServiceEffect;
/**
Creates a function that uses a service from the context to produce a value.

@see {@link serviceFunctionEffect} for a version that returns an effect.

@since 2.0.0
@category Context
/
const serviceFunction = exports.serviceFunction = effect.serviceFunction;
/**
Creates a function that uses a service from the context to produce an effect.

@see {@link serviceFunction} for a version that returns a value.

@since 2.0.0
@category Context
/
const serviceFunctionEffect = exports.serviceFunctionEffect = effect.serviceFunctionEffect;
/**
@since 2.0.0
@category Context
/
const serviceFunctions = exports.serviceFunctions = effect.serviceFunctions;
/**
@since 2.0.0
@category Context
/
const serviceConstants = exports.serviceConstants = effect.serviceConstants;
/**
@since 2.0.0
@category Context
/
const serviceMembers = exports.serviceMembers = effect.serviceMembers;
/**
Retrieves an optional service from the context as an `Option`.

**Details**

This function retrieves a service from the context and wraps it in an
`Option`. If the service is available, it returns a `Some` containing the
service. If the service is not found, it returns a `None`. This approach is
useful when you want to handle the absence of a service gracefully without
causing an error.

**When to Use**

Use this function when:
- You need to access a service that may or may not be present in the context.
- You want to handle the absence of a service using the `Option` type instead
  of throwing an error.

@see {@link serviceOptional} for a version that throws an error if the service is missing.

@since 2.0.0
@category Context
/
const serviceOption = exports.serviceOption = effect.serviceOption;
/**
Retrieves a service from the context, throwing an error if it is missing.

**Details**

This function retrieves a required service from the context. If the service
is available, it returns the service. If the service is missing, it throws a
`NoSuchElementException`, which can be handled using Effect's error-handling
mechanisms. This is useful for services that are critical to the execution of
your effect.

@see {@link serviceOption} for a version that returns an `Option` instead of throwing an error.

@since 2.0.0
@category Context
/
const serviceOptional = exports.serviceOptional = effect.serviceOptional;
/**
Updates a service in the context with a new implementation.

**Details**

This function modifies the existing implementation of a service in the
context. It retrieves the current service, applies the provided
transformation function `f`, and replaces the old service with the
transformed one.

**When to Use**

This is useful for adapting or extending a service's behavior during the
execution of an effect.

@since 2.0.0
@category Context
/
const updateService = exports.updateService = effect.updateService;
/**
The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

@see {@link bind}
@see {@link bindTo}
@see {@link let_ let}

@category Do notation
@since 2.0.0
/
const Do = exports.Do = effect.Do;
/**
The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

@see {@link Do}
@see {@link bindTo}
@see {@link let_ let}

@category Do notation
@since 2.0.0
/
const bind = exports.bind = effect.bind;
/**
`bindAll` combines `all` with `bind`. It is useful
when you want to concurrently run multiple effects and then combine their
results in a Do notation pipeline.

**Example**

```ts
import * as assert from "node:assert"
import { Effect, Either, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bindAll(({ x }) => ({
    a: Effect.succeed(x),
    b: Effect.fail("oops"),
  }), { concurrency: 2, mode: "either" })
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })
```

@category Do notation
@since 3.7.0
/
const bindAll = exports.bindAll = circular.bindAll;
/**
The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

**Example**

```ts
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
```

@see {@link Do}
@see {@link bind}
@see {@link let_ let}

@category Do notation
@since 2.0.0
/
const bindTo = exports.bindTo = effect.bindTo;
const let_ = exports.let = effect.let_;
/**
Encapsulates the result of an effect in an `Option`.

**Details**

This function wraps the outcome of an effect in an `Option` type. If the
original effect succeeds, the success value is wrapped in `Option.some`. If
the effect fails, the failure is converted to `Option.none`.

This is particularly useful for scenarios where you want to represent the
absence of a value explicitly, without causing the resulting effect to fail.
The resulting effect has an error type of `never`, meaning it cannot fail
directly. However, unrecoverable errors, also referred to as defects, are
not captured and will still result in failure.

**Example** (Using Effect.option to Handle Errors)

```ts
import { Effect } from "effect"

const maybe1 = Effect.option(Effect.succeed(1))

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'Some', value: 1 }
// }

const maybe2 = Effect.option(Effect.fail("Uh oh!"))

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'None' }
// }

const maybe3 = Effect.option(Effect.die("Boom!"))

Effect.runPromiseExit(maybe3).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }
// }
```

@see {@link either} for a version that uses `Either` instead.
@see {@link exit} for a version that encapsulates both recoverable errors and defects in an `Exit`.

@since 2.0.0
@category Outcome Encapsulation
/
const option = exports.option = effect.option;
/**
Encapsulates both success and failure of an `Effect` into an `Either` type.

**Details**

This function converts an effect that may fail into an effect that always
succeeds, wrapping the outcome in an `Either` type. The result will be
`Either.Left` if the effect fails, containing the recoverable error, or
`Either.Right` if it succeeds, containing the result.

Using this function, you can handle recoverable errors explicitly without
causing the effect to fail. This is particularly useful in scenarios where
you want to chain effects and manage both success and failure in the same
logical flow.

It's important to note that unrecoverable errors, often referred to as
"defects," are still thrown and not captured within the `Either` type. Only
failures that are explicitly represented as recoverable errors in the effect
are encapsulated.

The resulting effect cannot fail directly because all recoverable failures
are represented inside the `Either` type.

**Example**

```ts
import { Effect, Either, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//       Effect<string, HttpError | ValidationError, never>
//      
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//       Effect<string, never, never>
//      
const recovered = Effect.gen(function* () {
  //       Either<string, HttpError | ValidationError>
  //      
  const failureOrSuccess = yield* Effect.either(program)
  return Either.match(failureOrSuccess, {
    onLeft: (error) => `Recovering from ${error._tag}`,
    onRight: (value) => value // Do nothing in case of success
  })
})
```

@see {@link option} for a version that uses `Option` instead.
@see {@link exit} for a version that encapsulates both recoverable errors and defects in an `Exit`.

@since 2.0.0
@category Outcome Encapsulation
/
const either = exports.either = core.either;
/**
Encapsulates both success and failure of an `Effect` using the `Exit` type.

**Details**

This function converts an effect into one that always succeeds, wrapping its
outcome in the `Exit` type. The `Exit` type provides explicit handling of
both success (`Exit.Success`) and failure (`Exit.Failure`) cases, including
defects (unrecoverable errors).

Unlike {@link either} or {@link option}, this function also encapsulates
defects, which are typically unrecoverable and would otherwise terminate the
effect. With the `Exit` type, defects are represented in `Exit.Failure`,
allowing for detailed introspection and structured error handling.

This makes the resulting effect robust and incapable of direct failure (its
error type is `never`). It is particularly useful for workflows where all
outcomes, including unexpected defects, must be managed and analyzed.

**Example**

```ts
import { Effect, Cause, Console, Exit } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.gen(function* () {
  const exit = yield* Effect.exit(task)
  if (Exit.isFailure(exit)) {
    const cause = exit.cause
    if (
      Cause.isDieType(cause) &&
      Cause.isRuntimeException(cause.defect)
    ) {
      yield* Console.log(
        `RuntimeException defect caught: ${cause.defect.message}`
      )
    } else {
      yield* Console.log("Unknown failure caught.")
    }
  }
})

// We get an Exit.Success because we caught all failures
Effect.runPromiseExit(program).then(console.log)
// Output:
// RuntimeException defect caught: Boom!
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: undefined
// }
```

@see {@link option} for a version that uses `Option` instead.
@see {@link either} for a version that uses `Either` instead.

@since 2.0.0
@category Outcome Encapsulation
/
const exit = exports.exit = core.exit;
/**
Converts an `Effect` into an operation that completes a `Deferred` with its result.

**Details**

The `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`
is completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is
completed with the success value. If the effect fails, the `Deferred` is completed with the
failure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.

**Example**

```ts
import { Deferred, Effect } from "effect"

// Define an effect that succeeds
const successEffect = Effect.succeed(42)

const program = Effect.gen(function*() {
  // Create a deferred
  const deferred = yield* Deferred.make<number, string>()

  // Complete the deferred using the successEffect
  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)

  // Access the value of the deferred
  const value = yield* Deferred.await(deferred)
  console.log(value)

  return isCompleted
})

Effect.runPromise(program).then(console.log)
// Output:
// 42
// true
```

@since 2.0.0
@category Synchronization Utilities
/
const intoDeferred = exports.intoDeferred = core.intoDeferred;
const if_ = exports.if = core.if_;
/**
Filters an effect, dying with a custom defect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect dies with a custom defect
generated by the `orDieWith` function.

**When to Use**

This is useful for enforcing constraints on values and treating violations as
fatal program errors.

@since 2.0.0
@category Filtering
/
const filterOrDie = exports.filterOrDie = effect.filterOrDie;
/**
Filters an effect, dying with a custom message if the predicate fails.

**Details**

This function works like {@link filterOrDie} but allows you to specify a
custom error message to describe the reason for the failure. The message is
included in the defect when the predicate evaluates to `false`.

@since 2.0.0
@category Filtering
/
const filterOrDieMessage = exports.filterOrDieMessage = effect.filterOrDieMessage;
/**
Filters an effect, providing an alternative effect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, it executes the `orElse` effect instead. The
`orElse` effect can produce an alternative value or perform additional
computations.

@since 2.0.0
@category Filtering
/
const filterOrElse = exports.filterOrElse = effect.filterOrElse;
/**
Filters an effect, failing with a custom error if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect fails with a custom error
generated by the `orFailWith` function.

**When to Use**

This is useful for enforcing constraints and treating violations as
recoverable errors.

**Providing a Guard**

In addition to the filtering capabilities discussed earlier, you have the
option to further refine and narrow down the type of the success channel by
providing a [user-defined type
guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).
Let's explore this concept through an example:

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterOrFail with a custom type guard to ensure user is not null
  Effect.filterOrFail(
    (user): user is User => user !== null, // Type guard
    () => new Error("Unauthorized")
  ),
  // 'user' now has the type `User` (not `User | null`)
  Effect.andThen((user) => user.name)
)
```

@since 2.0.0
@category Filtering
/
const filterOrFail = exports.filterOrFail = effect.filterOrFail;
/**
Filters an effect with an effectful predicate, falling back to an alternative
effect if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect falls back to the `orElse`
effect. The `orElse` effect can produce an alternative value or perform
additional computations.

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterEffectOrElse with an effectful predicate
  Effect.filterEffectOrElse({
    predicate: (user) => Effect.succeed(user !== null),
    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))
  }),
)
```

@since 3.13.0
@category Filtering
/
const filterEffectOrElse = exports.filterEffectOrElse = core.filterEffectOrElse;
/**
Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.

**Details**

This function applies a predicate to the result of an effect. If the
predicate evaluates to `false`, the effect fails with a custom error
generated by the `orFailWith` function.

**When to Use**

This is useful for enforcing constraints and treating violations as
recoverable errors.

**Example**

```ts
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterEffectOrFail with an effectful predicate
  Effect.filterEffectOrFail({
    predicate: (user) => Effect.succeed(user !== null),
    orFailWith: () => new Error("Unauthorized")
  }),
)
```

@since 3.13.0
@category Filtering
/
const filterEffectOrFail = exports.filterEffectOrFail = core.filterEffectOrFail;
/**
Executes an effect only if the condition is `false`.

@see {@link unlessEffect} for a version that allows the condition to be an effect.
@see {@link when} for a version that executes the effect when the condition is `true`.

@since 2.0.0
@category Conditional Operators
/
const unless = exports.unless = effect.unless;
/**
Conditionally execute an effect based on the result of another effect.

@see {@link unless} for a version that allows the condition to be a boolean.
@see {@link whenEffect} for a version that executes the effect when the condition is `true`.

@since 2.0.0
@category Conditional Operators
/
const unlessEffect = exports.unlessEffect = effect.unlessEffect;
/**
Conditionally executes an effect based on a boolean condition.

**Details**

This function allows you to run an effect only if a given condition evaluates
to `true`. If the condition is `true`, the effect is executed, and its result
is wrapped in an `Option.some`. If the condition is `false`, the effect is
skipped, and the result is `Option.none`.

**When to Use**

This function is useful for scenarios where you need to dynamically decide
whether to execute an effect based on runtime logic, while also representing
the skipped case explicitly.

**Example** (Conditional Effect Execution)

```ts
import { Effect, Option } from "effect"

const validateWeightOption = (
  weight: number
): Effect.Effect<Option.Option<number>> =>
  // Conditionally execute the effect if the weight is non-negative
  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))

// Run with a valid weight
Effect.runPromise(validateWeightOption(100)).then(console.log)
// Output:
// {
//   _id: "Option",
//   _tag: "Some",
//   value: 100
// }

// Run with an invalid weight
Effect.runPromise(validateWeightOption(-5)).then(console.log)
// Output:
// {
//   _id: "Option",
//   _tag: "None"
// }
```

@see {@link whenEffect} for a version that allows the condition to be an effect.
@see {@link unless} for a version that executes the effect when the condition is `false`.

@since 2.0.0
@category Conditional Operators
/
const when = exports.when = effect.when;
/**
Conditionally executes an effect based on the result of another effect.

**Details**

This function allows you to run an effect only if a conditional effect
evaluating to a boolean resolves to `true`. If the conditional effect
evaluates to `true`, the specified effect is executed, and its result is
wrapped in `Option.some`. If the conditional effect evaluates to `false`, the
effect is skipped, and the result is `Option.none`.

**When to Use**

This function is particularly useful when the decision to execute an effect
depends on the result of another effect, such as a random value, a
user-provided input, or a network request result.

**Example** (Using an Effect as a Condition)

```ts
import { Effect, Random } from "effect"

const randomIntOption = Random.nextInt.pipe(
  Effect.whenEffect(Random.nextBoolean)
)

console.log(Effect.runSync(randomIntOption))
// Example Output:
// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }
```

@see {@link when} for a version that allows the condition to be a boolean.
@see {@link unlessEffect} for a version that executes the effect when the condition is `false`.

@since 2.0.0
@category Conditional Operators
/
const whenEffect = exports.whenEffect = core.whenEffect;
/**
Executes an effect conditionally based on the value of a `FiberRef` that
satisfies a predicate.

**Details**

This function enables you to execute an effect only when the value of a
specified `FiberRef` meets a certain condition defined by a predicate. If the
value satisfies the predicate, the effect is executed, and the result is
wrapped in an `Option.some`. If the predicate is not satisfied, the effect is
skipped, and the result is `Option.none`. In both cases, the current value of
the `FiberRef` is included in the result.

@since 2.0.0
@category Conditional Operators
/
const whenFiberRef = exports.whenFiberRef = effect.whenFiberRef;
/**
Executes an effect conditionally based on the value of a `Ref` that satisfies
a predicate.

**Details**

This function allows you to execute an effect only when the value of a
specified `Ref` meets a condition defined by a predicate. If the value
satisfies the predicate, the effect is executed, and the result is wrapped in
an `Option.some`. If the predicate is not satisfied, the effect is skipped,
and the result is `Option.none`. In both cases, the current value of the
`Ref` is included in the result.

@since 2.0.0
@category Conditional Operators
/
const whenRef = exports.whenRef = effect.whenRef;
/**
Chains effects to produce new `Effect` instances, useful for combining
operations that depend on previous results.

**Syntax**

```ts skip-type-checking
const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
// or
const flatMappedEffect = Effect.flatMap(myEffect, transformation)
// or
const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))
```

**Details**

`flatMap` lets you sequence effects so that the result of one effect can be
used in the next step. It is similar to `flatMap` used with arrays but works
specifically with `Effect` instances, allowing you to avoid deeply nested
effect structures.

Since effects are immutable, `flatMap` always returns a new effect instead of
changing the original one.

**When to Use**

Use `flatMap` when you need to chain multiple effects, ensuring that each
step produces a new `Effect` while flattening any nested effects that may
occur.

**Example**

```ts
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Chaining the fetch and discount application using `flatMap`
const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
// Output: 95
```

@see {@link tap} for a version that ignores the result of the effect.

@since 2.0.0
@category Sequencing
/
const flatMap = exports.flatMap = core.flatMap;
/**
Chains two actions, where the second action can depend on the result of the
first.

**Syntax**

```ts skip-type-checking
const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))
// or
const transformedEffect = Effect.andThen(myEffect, anotherEffect)
// or
const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))
```

**When to Use**

Use `andThen` when you need to run multiple actions in sequence, with the
second action depending on the result of the first. This is useful for
combining effects or handling computations that must happen in order.

**Details**

The second action can be:

- A constant value (similar to {@link as})
- A function returning a value (similar to {@link map})
- A `Promise`
- A function returning a `Promise`
- An `Effect`
- A function returning an `Effect` (similar to {@link flatMap})

**Note:** `andThen` works well with both `Option` and `Either` types,
treating them as effects.

**Example** (Applying a Discount Based on Fetched Amount)

```ts
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Using Effect.map and Effect.flatMap
const result1 = pipe(
  fetchTransactionAmount,
  Effect.map((amount) => amount * 2),
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result1).then(console.log)
// Output: 190

// Using Effect.andThen
const result2 = pipe(
  fetchTransactionAmount,
  Effect.andThen((amount) => amount * 2),
  Effect.andThen((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result2).then(console.log)
// Output: 190
```

@since 2.0.0
@category Sequencing
/
const andThen = exports.andThen = core.andThen;
/**
@since 2.0.0
@category Sequencing
/
const flatten = exports.flatten = core.flatten;
/**
Races two effects and returns the result of the first successful one.

**Details**

This function takes two effects and runs them concurrently. The first effect
that successfully completes will determine the result of the race, and the
other effect will be interrupted.

If neither effect succeeds, the function will fail with a `Cause`
containing all the errors.

**When to Use**

This is useful when you want to run two effects concurrently, but only care
about the first one to succeed. It is commonly used in cases like timeouts,
retries, or when you want to optimize for the faster response without
worrying about the other effect.

**Handling Success or Failure with Either**

If you want to handle the result of whichever task completes first, whether
it succeeds or fails, you can use the `Effect.either` function. This function
wraps the result in an `Either` type, allowing you to see if the result
was a success (`Right`) or a failure (`Left`).

**Example** (Both Tasks Succeed)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runFork(program)
// Output:
// task1 done
// task2 interrupted
```

**Example** (One Task Fails, One Succeeds)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runFork(program)
// Output:
// task2 done
```

**Example** (Both Tasks Fail)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Parallel',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
//   }
// }
```

**Example** (Handling Success or Failure with Either)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

// Run both tasks concurrently, wrapping the result
// in Either to capture success or failure
const program = Effect.race(Effect.either(task1), Effect.either(task2))

Effect.runPromise(program).then(console.log)
// Output:
// task2 interrupted
// { _id: 'Either', _tag: 'Left', left: 'task1' }
```

@see {@link raceAll} for a version that handles multiple effects.
@see {@link raceFirst} for a version that returns the result of the first effect to complete.

@since 2.0.0
@category Racing
/
const race = exports.race = fiberRuntime.race;
/**
Races multiple effects and returns the first successful result.

**Details**

This function runs multiple effects concurrently and returns the result of
the first one to succeed. If one effect succeeds, the others will be
interrupted.

If none of the effects succeed, the function will fail with the last error
encountered.

**When to Use**

This is useful when you want to race multiple effects, but only care about
the first one to succeed. It is commonly used in cases like timeouts,
retries, or when you want to optimize for the faster response without
worrying about the other effects.

**Example** (All Tasks Succeed)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.succeed("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runFork(program)
// Output:
// task1 done
// task2 interrupted
// task3 interrupted
```

**Example** (One Task Fails, Two Tasks Succeed)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.succeed("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runFork(program)
// Output:
// task3 done
// task2 interrupted
```

**Example** (All Tasks Fail)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.fail("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
// }
```

@see {@link race} for a version that handles only two effects.

@since 2.0.0
@category Racing
/
const raceAll = exports.raceAll = fiberRuntime.raceAll;
/**
Races two effects and returns the result of the first one to complete.

**Details**

This function takes two effects and runs them concurrently, returning the
result of the first one that completes, regardless of whether it succeeds or
fails.

**When to Use**

This function is useful when you want to race two operations, and you want to
proceed with whichever one finishes first, regardless of whether it succeeds
or fails.

**Disconnecting Effects**

The `Effect.raceFirst` function safely interrupts the loser effect once the other completes, but it will not resume until the loser is cleanly terminated.

If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:

```ts skip-type-checking
Effect.raceFirst(task1, task2)
```

You can use:

```ts skip-type-checking
Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))
```

This allows both effects to complete independently while still terminating the losing effect in the background.

**Example** (Both Tasks Succeed)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// task2 interrupted
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }
```

**Example** (One Task Fails, One Succeeds)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task2 interrupted
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }
// }
```

**Example** (Using Effect.disconnect for Quicker Return)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

// Race the two tasks with disconnect to allow quicker return
const program = Effect.raceFirst(
  Effect.disconnect(task1),
  Effect.disconnect(task2)
).pipe(Effect.tap(Console.log("more work...")))

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }
// task2 interrupted
```

@since 2.0.0
@category Racing
/
const raceFirst = exports.raceFirst = circular.raceFirst;
/**
Races two effects and calls a finisher when the first one completes.

**Details**

This function runs two effects concurrently and calls a specified finisher
function once one of the effects completes, regardless of whether it succeeds
or fails.

The finisher functions for each effect allow you to handle the results of
each effect as soon as they complete.

The function takes two finisher callbacks, one for each effect, and allows
you to specify how to handle the result of the race.

**When to Use**

This function is useful when you need to react to the completion of either
effect without waiting for both to finish. It can be used whenever you want
to take action based on the first available result.

**Example** (Handling Results of Concurrent Tasks)

```ts
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceWith(task1, task2, {
  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),
  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)
})

Effect.runFork(program)
// Output:
// task1 done
// task1 exited with {
//   "_id": "Exit",
//   "_tag": "Success",
//   "value": "task1"
// }
// task2 interrupted
```

@since 2.0.0
@category Racing
/
const raceWith = exports.raceWith = fiberRuntime.raceWith;
/**
Summarizes a effect by computing some value before and after execution, and
then combining the values to produce a summary, together with the result of
execution.

@since 2.0.0
@category Sequencing
/
const summarized = exports.summarized = effect.summarized;
/**
Runs a side effect with the result of an effect without changing the original
value.

**Details**

This function works similarly to `flatMap`, but it ignores the result of the
function passed to it. The value from the previous effect remains available
for the next part of the chain. Note that if the side effect fails, the
entire chain will fail too.

**When to Use**

Use this function when you want to perform a side effect, like logging or
tracking, without modifying the main value. This is useful when you need to
observe or record an action but want the original value to be passed to the
next step.

**Example** (Logging a step in a pipeline)

```ts
import { Console, Effect, pipe } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  // Log the fetched transaction amount
  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),
  // `amount` is still available!
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
// Output:
// Apply a discount to: 100
// 95
```

@see {@link flatMap} for a version that allows you to change the value.

@since 2.0.0
@category Sequencing
/
const tap = exports.tap = core.tap;
/**
Allows you to inspect both success and failure outcomes of an effect and
perform side effects for each.

**Details**

This function enables you to handle both success and failure cases
separately, without modifying the main effect's result. It is particularly
useful for scenarios where you need to log, monitor, or perform additional
actions depending on whether the effect succeeded or failed.

When the effect succeeds, the `onSuccess` handler is executed with the
success value. When the effect fails, the `onFailure` handler is executed
with the failure value. Both handlers can include side effects such as
logging or analytics, and neither modifies the original effect's output.

If either the success or failure handler fails, the overall effect will also
fail.

**Example**

```ts
import { Effect, Random, Console } from "effect"

// Simulate a task that might fail
const task = Effect.filterOrFail(
  Random.nextRange(-1, 1),
  (n) => n >= 0,
  () => "random number is negative"
)

// Use tapBoth to log both success and failure outcomes
const tapping = Effect.tapBoth(task, {
  onFailure: (error) => Console.log(`failure: ${error}`),
  onSuccess: (randomNumber) =>
    Console.log(`random number: ${randomNumber}`)
})

Effect.runFork(tapping)
// Example Output:
// failure: random number is negative
```

@since 2.0.0
@category Sequencing
/
const tapBoth = exports.tapBoth = effect.tapBoth;
/**
Inspect severe errors or defects (non-recoverable failures) in an effect.

**Details**

This function is specifically designed to handle and inspect defects, which
are critical failures in your program, such as unexpected runtime exceptions
or system-level errors. Unlike normal recoverable errors, defects typically
indicate serious issues that cannot be addressed through standard error
handling.

When a defect occurs in an effect, the function you provide to this function
will be executed, allowing you to log, monitor, or handle the defect in some
way. Importantly, this does not alter the main result of the effect. If no
defect occurs, the effect behaves as if this function was not used.

**Example**

```ts
import { Effect, Console } from "effect"

// Simulate a task that fails with a recoverable error
const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")

// tapDefect won't log anything because NetworkError is not a defect
const tapping1 = Effect.tapDefect(task1, (cause) =>
  Console.log(`defect: ${cause}`)
)

Effect.runFork(tapping1)
// No Output

// Simulate a severe failure in the system
const task2: Effect.Effect<number, string> = Effect.dieMessage(
  "Something went wrong"
)

// Log the defect using tapDefect
const tapping2 = Effect.tapDefect(task2, (cause) =>
  Console.log(`defect: ${cause}`)
)

Effect.runFork(tapping2)
// Output:
// defect: RuntimeException: Something went wrong
//   ... stack trace ...
```

@since 2.0.0
@category Sequencing
/
const tapDefect = exports.tapDefect = effect.tapDefect;
/**
Execute a side effect on failure without modifying the original effect.

**Details**

This function allows you to inspect and react to the failure of an effect by
executing an additional effect. The failure value is passed to the provided
function, enabling you to log it, track it, or perform any other operation.
Importantly, the original failure remains intact and is re-propagated, so the
effect's behavior is unchanged.

The side effect you provide is only executed when the effect fails. If the
effect succeeds, the function is ignored, and the success value is propagated
as usual.

**Example**

```ts
import { Effect, Console } from "effect"

// Simulate a task that fails with an error
const task: Effect.Effect<number, string> = Effect.fail("NetworkError")

// Use tapError to log the error message when the task fails
const tapping = Effect.tapError(task, (error) =>
  Console.log(`expected error: ${error}`)
)

Effect.runFork(tapping)
// Output:
// expected error: NetworkError
```

@since 2.0.0
@category Sequencing
/
const tapError = exports.tapError = effect.tapError;
/**
Inspect errors matching a specific tag without altering the original effect.

**Details**

This function allows you to inspect and handle specific error types based on
their `_tag` property. It is particularly useful in applications where errors
are modeled with tagged types (e.g., union types with discriminating tags).
By targeting errors with a specific `_tag`, you can log or perform actions on
them while leaving the error channel and overall effect unchanged.

If the error doesn't match the specified tag, this function does nothing, and
the effect proceeds as usual.

**Example**

```ts
import { Effect, Console } from "effect"

class NetworkError {
  readonly _tag = "NetworkError"
  constructor(readonly statusCode: number) {}
}

class ValidationError {
  readonly _tag = "ValidationError"
  constructor(readonly field: string) {}
}

// Create a task that fails with a NetworkError
const task: Effect.Effect<number, NetworkError | ValidationError> =
  Effect.fail(new NetworkError(504))

// Use tapErrorTag to inspect only NetworkError types and log the status code
const tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>
  Console.log(`expected error: ${error.statusCode}`)
)

Effect.runFork(tapping)
// Output:
// expected error: 504
```

@since 2.0.0
@category Sequencing
/
const tapErrorTag = exports.tapErrorTag = effect.tapErrorTag;
/**
Inspect the complete cause of an error, including failures and defects.

**Details**

This function provides access to the full cause of an error, including both
recoverable failures and irrecoverable defects. It allows you to handle, log,
or monitor specific error causes without modifying the result of the effect.
The full `Cause` object encapsulates the error and its contextual
information, making it useful for debugging and understanding failure
scenarios in complex workflows.

The effect itself is not modified, and any errors or defects remain in the
error channel of the original effect.

**Example**

```ts
import { Effect, Console } from "effect"

// Create a task that fails with a NetworkError
const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")

const tapping1 = Effect.tapErrorCause(task1, (cause) =>
  Console.log(`error cause: ${cause}`)
)

Effect.runFork(tapping1)
// Output:
// error cause: Error: NetworkError

// Simulate a severe failure in the system
const task2: Effect.Effect<number, string> = Effect.dieMessage(
  "Something went wrong"
)

const tapping2 = Effect.tapErrorCause(task2, (cause) =>
  Console.log(`error cause: ${cause}`)
)

Effect.runFork(tapping2)
// Output:
// error cause: RuntimeException: Something went wrong
//   ... stack trace ...
```

@since 2.0.0
@category Sequencing
/
const tapErrorCause = exports.tapErrorCause = effect.tapErrorCause;
/**
Repeats an effect indefinitely until an error occurs.

**Details**

This function executes an effect repeatedly in an infinite loop. Each
iteration is executed sequentially, and the loop continues until the first
error occurs. If the effect succeeds, it starts over from the beginning. If
the effect fails, the error is propagated, and the loop stops.

Be cautious when using this function, as it will run indefinitely unless an
error interrupts it. This makes it suitable for long-running processes or
continuous polling tasks, but you should ensure proper error handling or
combine it with other operators like `timeout` or `schedule` to prevent
unintentional infinite loops.

@since 2.0.0
@category Repetition / Recursion
/
const forever = exports.forever = effect.forever;
/**
Repeatedly updates a state through an effectful operation until a condition
is no longer met.

**Details**

This function provides a way to implement effectful loops, similar to a
`while` loop in JavaScript.

```ts skip-type-checking
let result = initial

while (options.while(result)) {
  result = options.body(result)
}

return result
```

It starts with an initial state, checks a
condition (`while`), and executes a body operation to update the state if the
condition evaluates to `true`. The process repeats until the condition
returns `false`.

The state is passed between iterations, allowing the body operation to modify
it dynamically. The final state after the loop ends is returned as the result
of the effect.

**When to Use**

This is particularly useful for scenarios where looping logic involves
asynchronous or side-effectful operations, such as polling or iterative
computations that depend on external factors.

**Example** (Effectful Iteration)

```ts
import { Effect } from "effect"

const result = Effect.iterate(
  // Initial result
  1,
  {
    // Condition to continue iterating
    while: (result) => result <= 5,
    // Operation to change the result
    body: (result) => Effect.succeed(result + 1)
  }
)

Effect.runPromise(result).then(console.log)
// Output: 6
```

@since 2.0.0
@category Looping
/
const iterate = exports.iterate = effect.iterate;
/**
Repeatedly executes a loop with a state, collecting results or discarding
them based on configuration.

**Details**

This function performs an effectful loop, starting with an initial state and
iterating as long as the `while` condition evaluates to `true`, similar to a
`while` loop in JavaScript.

```ts skip-type-checking
let state = initial
const result = []

while (options.while(state)) {
  result.push(options.body(state)) // Perform the effectful operation
  state = options.step(state) // Update the state
}

return result
```

During each iteration, the `step` function updates the state, and the `body`
effect is executed.

The results of the body effect can be collected in an array or discarded
based on the `discard` option.

**Discarding Intermediate Results**

- If `discard` is `false` or not provided, the intermediate results are
  collected into an array and returned as the final result.
- If `discard` is `true`, the intermediate results are ignored, and the
  effect returns `void`.

**When to Use**

This is useful for implementing loops where you need to perform effectful
computations repeatedly, such as processing items in a list, generating
values, or performing iterative updates.

**Example** (Looping with Collected Results)

```ts
import { Effect } from "effect"

// A loop that runs 5 times, collecting each iteration's result
const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Effect.succeed(state)
  }
)

Effect.runPromise(result).then(console.log)
// Output: [1, 2, 3, 4, 5]
```

**Example** (Loop with Discarded Results)

```ts
import { Effect, Console } from "effect"

const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Console.log(`Currently at state ${state}`),
    // Discard intermediate results
    discard: true
  }
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at state 1
// Currently at state 2
// Currently at state 3
// Currently at state 4
// Currently at state 5
// undefined
```

@since 2.0.0
@category Looping
/
const loop = exports.loop = effect.loop;
/**
Repeats an effect based on a specified schedule or until the first failure.

**Details**

This function executes an effect repeatedly according to the given schedule.
Each repetition occurs after the initial execution of the effect, meaning
that the schedule determines the number of additional repetitions. For
example, using `Schedule.once` will result in the effect being executed twice
(once initially and once as part of the repetition).

If the effect succeeds, it is repeated according to the schedule. If it
fails, the repetition stops immediately, and the failure is returned.

The schedule can also specify delays between repetitions, making it useful
for tasks like retrying operations with backoff, periodic execution, or
performing a series of dependent actions.

You can combine schedules for more advanced repetition logic, such as adding
delays, limiting recursions, or dynamically adjusting based on the outcome of
each execution.

**Example** (Success Example)

```ts
import { Effect, Schedule, Console } from "effect"

const action = Console.log("success")
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
```

**Example** (Failure Example)

```ts
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async<string, string>((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

Effect.runPromiseExit(program).then(console.log)
```

@since 2.0.0
@category Repetition / Recursion
/
const repeat = exports.repeat = schedule_.repeat_combined;
/**
Repeats an effect a specified number of times or until the first failure.

**Details**

This function executes an effect initially and then repeats it the specified
number of times, as long as it succeeds. For example, calling
`repeatN(action, 2)` will execute `action` once initially and then repeat it
two additional times if there are no failures.

If the effect fails during any repetition, the failure is returned, and no
further repetitions are attempted.

**When to Use**

This function is useful for tasks that need to be retried a fixed number of
times or for performing repeated actions without requiring a schedule.

**Example**

```ts
import { Effect, Console } from "effect"

const action = Console.log("success")
const program = Effect.repeatN(action, 2)

Effect.runPromise(program)
```

@since 2.0.0
@category Repetition / Recursion
/
const repeatN = exports.repeatN = effect.repeatN;
/**
Repeats an effect with a schedule, handling failures using a custom handler.

**Details**

This function allows you to execute an effect repeatedly based on a specified
schedule. If the effect fails at any point, a custom failure handler is
invoked. The handler is provided with both the failure value and the output
of the schedule at the time of failure. This enables advanced error recovery
or alternative fallback logic while maintaining flexibility in how
repetitions are handled.

For example, using a schedule with `recurs(2)` will allow for two additional
repetitions after the initial execution, provided the effect succeeds. If a
failure occurs during any iteration, the failure handler is invoked to handle
the situation.

**Example**

```ts
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async<string, string>((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

const policy = Schedule.addDelay(
  Schedule.recurs(2), // Repeat for a maximum of 2 times
  () => "100 millis" // Add a delay of 100 milliseconds between repetitions
)

const program = Effect.repeatOrElse(action, policy, () =>
  Effect.sync(() => {
    console.log("orElse")
    return count - 1
  })
)

Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
```

@since 2.0.0
@category Repetition / Recursion
/
const repeatOrElse = exports.repeatOrElse = schedule_.repeatOrElse_Effect;
/**
Repeats an effect based on a specified schedule.

**Details**

This function allows you to execute an effect repeatedly according to a given
schedule. The schedule determines the timing and number of repetitions. Each
repetition can also depend on the decision of the schedule, providing
flexibility for complex workflows. This function does not modify the effect's
success or failure; it only controls its repetition.

For example, you can use a schedule that recurs a specific number of times,
adds delays between repetitions, or customizes repetition behavior based on
external inputs. The effect runs initially and is repeated according to the
schedule.

@see {@link scheduleFrom} for a variant that allows the schedule's decision
to depend on the result of this effect.

@since 2.0.0
@category Repetition / Recursion
/
const schedule = exports.schedule = schedule_.schedule_Effect;
/**
Runs an effect repeatedly on a new fiber according to a given schedule.

**Details**

This function starts the provided effect on a new fiber and runs it
repeatedly based on the specified schedule. The repetitions are managed by
the schedule's rules, which define the timing and number of iterations. The
fiber is attached to the current scope, meaning it is automatically managed
and cleaned up when the scope is closed.

The function returns a `RuntimeFiber` that allows you to monitor or interact
with the running fiber.

**When to Use**

This is particularly useful for concurrent execution of scheduled tasks or
when you want to continue processing without waiting for the repetitions to
complete.

@since 2.0.0
@category Repetition / Recursion
/
const scheduleForked = exports.scheduleForked = schedule_.scheduleForked;
/**
Runs an effect repeatedly according to a schedule, starting from a specified
input value.

**Details**

This function allows you to repeatedly execute an effect based on a schedule.
The schedule starts with the given `initial` input value, which is passed to
the first execution. Subsequent executions of the effect are controlled by
the schedule's rules, using the output of the previous iteration as the input
for the next one.

The returned effect will complete when the schedule ends or the effect fails,
propagating the error.

@since 2.0.0
@category Repetition / Recursion
/
const scheduleFrom = exports.scheduleFrom = schedule_.scheduleFrom_Effect;
/**
@since 2.0.0
@category Repetition / Recursion
/
const whileLoop = exports.whileLoop = core.whileLoop;
/**
Returns a collection of all `FiberRef` values for the fiber running this
effect.

@since 2.0.0
@category Fiber Refs
/
const getFiberRefs = exports.getFiberRefs = effect.fiberRefs;
/**
Inherits values from all `FiberRef` instances into current fiber.

@since 2.0.0
@category Fiber Refs
/
const inheritFiberRefs = exports.inheritFiberRefs = effect.inheritFiberRefs;
/**
@since 2.0.0
@category Fiber Refs
/
const locally = exports.locally = core.fiberRefLocally;
/**
@since 2.0.0
@category Fiber Refs
/
const locallyWith = exports.locallyWith = core.fiberRefLocallyWith;
/**
@since 2.0.0
@category Fiber Refs
/
const locallyScoped = exports.locallyScoped = fiberRuntime.fiberRefLocallyScoped;
/**
@since 2.0.0
@category Fiber Refs
/
const locallyScopedWith = exports.locallyScopedWith = fiberRuntime.fiberRefLocallyScopedWith;
/**
Applies the specified changes to the `FiberRef` values for the fiber
running this workflow.

@since 2.0.0
@category Fiber Refs
/
const patchFiberRefs = exports.patchFiberRefs = effect.patchFiberRefs;
/**
Sets the `FiberRef` values for the fiber running this effect to the values
in the specified collection of `FiberRef` values.

@since 2.0.0
@category Fiber Refs
/
const setFiberRefs = exports.setFiberRefs = effect.setFiberRefs;
/**
Updates the `FiberRef` values for the fiber running this effect using the
specified function.

@since 2.0.0
@category Fiber Refs
/
const updateFiberRefs = exports.updateFiberRefs = effect.updateFiberRefs;
/**
Checks if an effect has failed.

**Details**

This function evaluates whether an effect has resulted in a failure. It
returns a boolean value wrapped in an effect, with `true` indicating the
effect failed and `false` otherwise.

The resulting effect cannot fail (`never` in the error channel) but retains
the context of the original effect.

**Example**

```ts
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

console.log(Effect.runSync(Effect.isFailure(failure)))
// Output: true

const defect = Effect.dieMessage("BOOM!")

Effect.runSync(Effect.isFailure(defect))
// throws: BOOM!
```

@since 2.0.0
@category Condition Checking
/
const isFailure = exports.isFailure = effect.isFailure;
/**
Checks if an effect has succeeded.

**Details**

This function evaluates whether an effect has resulted in a success. It
returns a boolean value wrapped in an effect, with `true` indicating the
effect succeeded and `false` otherwise.

The resulting effect cannot fail (`never` in the error channel) but retains
the context of the original effect.

@since 2.0.0
@category Condition Checking
/
const isSuccess = exports.isSuccess = effect.isSuccess;
/**
Handles both success and failure cases of an effect without performing side
effects.

**Details**

`match` lets you define custom handlers for both success and failure
scenarios. You provide separate functions to handle each case, allowing you
to process the result if the effect succeeds, or handle the error if the
effect fails.

**When to Use**

This is useful for structuring your code to respond differently to success or
failure without triggering side effects.

**Example** (Handling Both Success and Failure Cases)

```ts
import { Effect } from "effect"

const success: Effect.Effect<number, Error> = Effect.succeed(42)

const program1 = Effect.match(success, {
  onFailure: (error) => `failure: ${error.message}`,
  onSuccess: (value) => `success: ${value}`
})

// Run and log the result of the successful effect
Effect.runPromise(program1).then(console.log)
// Output: "success: 42"

const failure: Effect.Effect<number, Error> = Effect.fail(
  new Error("Uh oh!")
)

const program2 = Effect.match(failure, {
  onFailure: (error) => `failure: ${error.message}`,
  onSuccess: (value) => `success: ${value}`
})

// Run and log the result of the failed effect
Effect.runPromise(program2).then(console.log)
// Output: "failure: Uh oh!"
```

@see {@link matchEffect} if you need to perform side effects in the handlers.

@since 2.0.0
@category Matching
/
const match = exports.match = effect.match;
/**
Handles failures by matching the cause of failure.

**Details**

The `matchCause` function allows you to handle failures with access to the
full cause of the failure within a fiber.

**When to Use**

This is useful for differentiating between different types of errors, such as
regular failures, defects, or interruptions. You can provide specific
handling logic for each failure type based on the cause.

**Example** (Handling Different Failure Causes)

```ts
import { Effect } from "effect"

const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")

const program = Effect.matchCause(task, {
  onFailure: (cause) => {
    switch (cause._tag) {
      case "Fail":
        // Handle standard failure
        return `Fail: ${cause.error.message}`
      case "Die":
        // Handle defects (unexpected errors)
        return `Die: ${cause.defect}`
      case "Interrupt":
        // Handle interruption
        return `${cause.fiberId} interrupted!`
    }
    // Fallback for other causes
    return "failed due to other causes"
  },
  onSuccess: (value) =>
    // task completes successfully
    `succeeded with ${value} value`
})

Effect.runPromise(program).then(console.log)
// Output: "Die: Uh oh!"
```

@see {@link matchCauseEffect} if you need to perform side effects in the
handlers.
@see {@link match} if you don't need to handle the cause of the failure.

@since 2.0.0
@category Matching
/
const matchCause = exports.matchCause = core.matchCause;
/**
Handles failures with access to the cause and allows performing side effects.

**Details**

The `matchCauseEffect` function works similarly to {@link matchCause}, but it
also allows you to perform additional side effects based on the failure
cause. This function provides access to the complete cause of the failure,
making it possible to differentiate between various failure types, and allows
you to respond accordingly while performing side effects (like logging or
other operations).

**Example** (Handling Different Failure Causes with Side Effects)

```ts
import { Effect, Console } from "effect"

const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")

const program = Effect.matchCauseEffect(task, {
  onFailure: (cause) => {
    switch (cause._tag) {
      case "Fail":
        // Handle standard failure with a logged message
        return Console.log(`Fail: ${cause.error.message}`)
      case "Die":
        // Handle defects (unexpected errors) by logging the defect
        return Console.log(`Die: ${cause.defect}`)
      case "Interrupt":
        // Handle interruption and log the fiberId that was interrupted
        return Console.log(`${cause.fiberId} interrupted!`)
    }
    // Fallback for other causes
    return Console.log("failed due to other causes")
  },
  onSuccess: (value) =>
    // Log success if the task completes successfully
    Console.log(`succeeded with ${value} value`)
})

Effect.runPromise(program)
// Output: "Die: Uh oh!"
```

@see {@link matchCause} if you don't need side effects and only want to handle the result or failure.
@see {@link matchEffect} if you don't need to handle the cause of the failure.

@since 2.0.0
@category Matching
/
const matchCauseEffect = exports.matchCauseEffect = core.matchCauseEffect;
/**
Handles both success and failure cases of an effect, allowing for additional
side effects.

**Details**

The `matchEffect` function is similar to {@link match}, but it enables you to
perform side effects in the handlers for both success and failure outcomes.

**When to Use**

This is useful when you need to execute additional actions, like logging or
notifying users, based on whether an effect succeeds or fails.

**Example** (Handling Both Success and Failure Cases with Side Effects)

```ts
import { Effect } from "effect"

const success: Effect.Effect<number, Error> = Effect.succeed(42)
const failure: Effect.Effect<number, Error> = Effect.fail(
  new Error("Uh oh!")
)

const program1 = Effect.matchEffect(success, {
  onFailure: (error) =>
    Effect.succeed(`failure: ${error.message}`).pipe(
      Effect.tap(Effect.log)
    ),
  onSuccess: (value) =>
    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program1))
// Output:
// timestamp=... level=INFO fiber=#0 message="success: 42"
// success: 42

const program2 = Effect.matchEffect(failure, {
  onFailure: (error) =>
    Effect.succeed(`failure: ${error.message}`).pipe(
      Effect.tap(Effect.log)
    ),
  onSuccess: (value) =>
    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program2))
// Output:
// timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"
// failure: Uh oh!
```

@see {@link match} if you don't need side effects and only want to handle the
result or failure.

@since 2.0.0
@category Matching
/
const matchEffect = exports.matchEffect = core.matchEffect;
/**
Logs one or more messages or error causes at the current log level.

**Details**

This function provides a simple way to log messages or error causes during
the execution of your effects. By default, logs are recorded at the `INFO`
level, but this can be adjusted using other logging utilities
(`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,
can be logged in a single call. When logging `Cause` instances, detailed
error information is included in the log output.

The log output includes useful metadata like the current timestamp, log
level, and fiber ID, making it suitable for debugging and tracking purposes.
This function does not interrupt or alter the effect's execution flow.

**Example**

```ts
import { Cause, Effect } from "effect"

const program = Effect.log(
  "message1",
  "message2",
  Cause.die("Oh no!"),
  Cause.die("Oh uh!")
)

Effect.runFork(program)
// Output:
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!
// Error: Oh uh!"
```

@since 2.0.0
@category Logging
/
const log = exports.log = effect.log;
/**
Logs messages or error causes at a specified log level.

**Details**

This function allows you to log one or more messages or error causes while
specifying the desired log level (e.g., DEBUG, INFO, ERROR). It provides
flexibility in categorizing logs based on their importance or severity,
making it easier to filter logs during debugging or production monitoring.

**Example**

```ts
import { Cause, Effect, LogLevel } from "effect"

const program = Effect.logWithLevel(
  LogLevel.Error,
  "Critical error encountered",
  Cause.die("System failure!")
)

Effect.runFork(program)
// Output:
// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause="Error: System failure!"
```

@since 2.0.0
@category Logging
/
const logWithLevel = (level, ...message) => effect.logWithLevel(level)(...message);
/**
Logs messages at the TRACE log level.

**Details**

This function logs the specified messages at the TRACE level. TRACE logs are
typically used for very detailed diagnostic information. These messages are
not displayed by default. To view them, you must adjust the logging
configuration by setting the minimum log level to `LogLevel.Trace` using
`Logger.withMinimumLogLevel`.

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))

Effect.runFork(program)
// timestamp=... level=TRACE fiber=#0 message=message1
```

@since 2.0.0
@category Logging

## transposeOption

Source: `my-backend/node_modules/effect/dist/cjs/Effect.js`

Signature: `transposeOption(= transposeOption;
const transposeMapOption = exports.transposeMapOption = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Logs messages at the INFO log level.

**Details**

This function logs messages at the INFO level, suitable for general
application events or operational messages. INFO logs are shown by default
and are commonly used for highlighting normal, non-error operations.

@since 2.0.0
@category Logging
/
const logInfo = exports.logInfo = effect.logInfo;
/**
Logs messages at the WARNING log level.

**Details**

This function logs messages at the WARNING level, suitable for highlighting
potential issues that are not errors but may require attention. These
messages indicate that something unexpected occurred or might lead to errors
in the future.

@since 2.0.0
@category Logging
/
const logWarning = exports.logWarning = effect.logWarning;
/**
Logs messages at the ERROR log level.

**Details**

This function logs messages at the ERROR level, suitable for reporting
application errors or failures. These logs are typically used for unexpected
issues that need immediate attention.

@since 2.0.0
@category Logging
/
const logError = exports.logError = effect.logError;
/**
Logs messages at the FATAL log level.

**Details**

This function logs messages at the FATAL level, suitable for reporting
critical errors that cause the application to terminate or stop functioning.
These logs are typically used for unrecoverable errors that require immediate
attention.

@since 2.0.0
@category Logging
/
const logFatal = exports.logFatal = effect.logFatal;
/**
Adds a log span to an effect for tracking and logging its execution duration.

**Details**

This function wraps an effect with a log span, providing performance
monitoring and debugging capabilities. The log span tracks the duration of
the wrapped effect and logs it with the specified label. This is particularly
useful when analyzing time-sensitive operations or understanding the
execution time of specific tasks in your application.

The logged output will include the label and the total time taken for the
operation. The span information is included in the log metadata, making it
easy to trace performance metrics in logs.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.sleep("1 second")
  yield* Effect.log("The job is finished!")
}).pipe(Effect.withLogSpan("myspan"))

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms
```

@since 2.0.0
@category Logging
/
const withLogSpan = exports.withLogSpan = effect.withLogSpan;
/**
Adds custom annotations to log entries generated within an effect.

**Details**

This function allows you to enhance log messages by appending additional
context in the form of key-value pairs. These annotations are included in
every log message created during the execution of the effect, making the logs
more informative and easier to trace.

The annotations can be specified as a single key-value pair or as a record of
multiple key-value pairs. This is particularly useful for tracking
operations, debugging, or associating specific metadata with logs for better
observability.

The annotated key-value pairs will appear alongside the log message in the
output.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("message1")
  yield* Effect.log("message2")
}).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234
// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234
```

@see {@link annotateLogsScoped} to add log annotations with a limited scope.

@since 2.0.0
@category Logging
/
const annotateLogs = exports.annotateLogs = effect.annotateLogs;
/**
Adds log annotations with a limited scope to enhance contextual logging.

**Details**

This function allows you to apply key-value annotations to log entries
generated within a specific scope of your effect computations. The
annotations are restricted to the defined `Scope`, ensuring that they are
only applied to logs produced during that scope. Once the scope ends, the
annotations are automatically removed, making it easier to manage
context-specific logging without affecting other parts of your application.

The annotations can be provided as a single key-value pair or as a record of
multiple key-value pairs. This flexibility enables fine-grained control over
the additional metadata included in logs for specific tasks or operations.

**Example**

```ts
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("no annotations")
  yield* Effect.annotateLogsScoped({ key: "value" })
  yield* Effect.log("message1") // Annotation is applied to this log
  yield* Effect.log("message2") // Annotation is applied to this log
}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message="no annotations"
// timestamp=... level=INFO fiber=#0 message=message1 key=value
// timestamp=... level=INFO fiber=#0 message=message2 key=value
// timestamp=... level=INFO fiber=#0 message="no annotations again"
```

@see {@link annotateLogs} to add custom annotations to log entries generated within an effect.

@since 3.1.0
@category Logging
/
const annotateLogsScoped = exports.annotateLogsScoped = fiberRuntime.annotateLogsScoped;
/**
Retrieves the current log annotations for the current scope.

**Details**

This function provides access to the log annotations associated with the
current scope. Log annotations are key-value pairs that provide additional
context to log entries. They are often used to add metadata such as tags,
identifiers, or extra debugging information to logs.

By using this function, you can inspect or utilize the annotations applied to
the current scope, making it easier to trace and debug specific sections of
your application.

@see {@link annotateLogs} to add custom annotations to log entries generated within an effect.
@see {@link annotateLogsScoped} to add log annotations with a limited scope.

@since 2.0.0
@category Logging
/
const logAnnotations = exports.logAnnotations = effect.logAnnotations;
/**
Configures whether child fibers will log unhandled errors and at what log
level.

**Details**

This function allows you to control whether unhandled errors from child
fibers are logged and to specify the log level for these errors. By default,
unhandled errors are reported via the logger. However, using this function,
you can choose to suppress these logs by passing `Option.none` or adjust the
log level to a specific severity, such as `Error`, `Warning`, or `Info`.

This configuration is scoped to the effect it is applied to, meaning the
changes only apply to the child fibers created within that effect's context.
It is especially useful when you want to reduce noise in logs or prioritize
certain types of errors.

**Example**

```ts
import { Effect, Fiber, LogLevel, Option } from "effect"

const program = Effect.gen(function*() {
  const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))
  yield* Fiber.join(fiber)
})

Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))
// Output:
// timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"
```

@since 2.0.0
@category Logging
/
const withUnhandledErrorLogLevel = exports.withUnhandledErrorLogLevel = core.withUnhandledErrorLogLevel;
/**
Conditionally executes an effect based on the specified log level and currently enabled log level.

**Details**

This function runs the provided effect only if the specified log level is
enabled. If the log level is enabled, the effect is executed and its result
is wrapped in `Some`. If the log level is not enabled, the effect is not
executed and `None` is returned.

This function is useful for conditionally executing logging-related effects
or other operations that depend on the current log level configuration.

**Example**

```ts
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`
  yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`
}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));

Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message2
```

@see {@link FiberRef.currentMinimumLogLevel} to retrieve the current minimum log level.

@since 3.13.0
@category Logging
/
const whenLogLevel = exports.whenLogLevel = fiberRuntime.whenLogLevel;
/**
Converts an effect's failure into a fiber termination, removing the error
from the effect's type.

**Details**

The `orDie` function is used when you encounter errors that you do not want
to handle or recover from. It removes the error type from the effect and
ensures that any failure will terminate the fiber. This is useful for
propagating failures as defects, signaling that they should not be handled
within the effect.

**When to Use*

Use `orDie` when failures should be treated as unrecoverable defects and no
error handling is required.

**Example** (Propagating an Error as a Defect)

```ts
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = Effect.orDie(divide(1, 0))

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: Cannot divide by zero
//   ...stack trace...
```

@see {@link orDieWith} if you need to customize the error.

@since 2.0.0
@category Converting Failures to Defects
/
const orDie = exports.orDie = core.orDie;
/**
Converts an effect's failure into a fiber termination with a custom error.

**Details**

The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping
function to transform the error before terminating the fiber. This is useful for cases where
you want to include a more detailed or user-friendly error when the failure is propagated
as a defect.

**When to Use**

Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize
the error for clarity or debugging purposes.

**Example** (Customizing Defect)

```ts
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//       Effect<number, never, never>
//      
const program = Effect.orDieWith(
  divide(1, 0),
  (error) => new Error(`defect: ${error.message}`)
)

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: defect: Cannot divide by zero
//   ...stack trace...
```

@see {@link orDie} if you don't need to customize the error.

@since 2.0.0
@category Converting Failures to Defects
/
const orDieWith = exports.orDieWith = core.orDieWith;
/**
Attempts one effect, and if it fails, falls back to another effect.

**Details**

This function allows you to try executing an effect, and if it fails
(produces an error), a fallback effect is executed instead. The fallback
effect is defined as a lazy argument, meaning it will only be evaluated if
the first effect fails. This provides a way to recover from errors by
specifying an alternative path of execution.

The error type of the resulting effect will be that of the fallback effect,
as the first effect's error is replaced when the fallback is executed.

**Example**

```ts
import { Effect } from "effect"

const success = Effect.succeed("success")
const failure = Effect.fail("failure")
const fallback = Effect.succeed("fallback")

// Try the success effect first, fallback is not used
const program1 = Effect.orElse(success, () => fallback)
console.log(Effect.runSync(program1))
// Output: "success"

// Try the failure effect first, fallback is used
const program2 = Effect.orElse(failure, () => fallback)
console.log(Effect.runSync(program2))
// Output: "fallback"
```

@see {@link catchAll} if you need to access the error in the fallback effect.

@since 2.0.0
@category Fallback
/
const orElse = exports.orElse = core.orElse;
/**
Replaces the failure of an effect with a custom failure value.

**Details**

This function allows you to handle the failure of an effect by replacing it
with a predefined failure value. If the effect fails, the new failure value
provided by the `evaluate` function will be returned instead of the original
failure. If the effect succeeds, the original success value is returned
unchanged.

**When to Use**

This is particularly useful when you want to standardize error handling or
provide a consistent failure value for specific operations. It simplifies
error management by ensuring that all failures are replaced with a controlled
alternative.

**Example**

```ts
import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseFail(validate(-1), () => "invalid age")

console.log(Effect.runSyncExit(program))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }
// }
```

@see {@link mapError} if you need to access the error to transform it.

@since 2.0.0
@category Fallback
/
const orElseFail = exports.orElseFail = effect.orElseFail;
/**
Ensures the effect always succeeds by replacing failures with a default
success value.

**Details**

This function transforms an effect that may fail into one that cannot fail by
replacing any failure with a provided success value. If the original effect
fails, the failure is "swallowed," and the specified success value is
returned instead. If the original effect succeeds, its value remains
unchanged.

**When to Use**

This is especially useful for providing default values in case of failure,
ensuring that an effect always completes successfully. By using this
function, you can avoid the need for complex error handling and guarantee a
fallback result.

**Example**

```ts
import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseSucceed(validate(-1), () => 18)

console.log(Effect.runSyncExit(program))
// Output:
// { _id: 'Exit', _tag: 'Success', value: 18 }
```

@since 2.0.0
@category Fallback
/
const orElseSucceed = exports.orElseSucceed = effect.orElseSucceed;
/**
Runs a sequence of effects and returns the result of the first successful
one.

**Details**

This function allows you to execute a collection of effects in sequence,
stopping at the first success. If an effect succeeds, its result is
immediately returned, and no further effects in the sequence are executed.
However, if all the effects fail, the function will return the error of the
last effect.

The execution is sequential, meaning that effects are evaluated one at a time
in the order they are provided. This ensures predictable behavior and avoids
unnecessary computations.

If the collection of effects is empty, an `IllegalArgumentException` is
thrown, indicating that the operation is invalid without any effects to try.

**When to Use**

This is particularly useful when you have multiple fallback strategies or
alternative sources to obtain a result, such as attempting multiple APIs,
retrieving configurations, or accessing resources in a prioritized manner.

**Example**

```ts
import { Effect, Console } from "effect"

interface Config {
  host: string
  port: number
  apiKey: string
}

// Create a configuration object with sample values
const makeConfig = (name: string): Config => ({
  host: `${name}.example.com`,
  port: 8080,
  apiKey: "12345-abcde"
})

// Simulate retrieving configuration from a remote node
const remoteConfig = (name: string): Effect.Effect<Config, Error> =>
  Effect.gen(function* () {
    // Simulate node3 being the only one with available config
    if (name === "node3") {
      yield* Console.log(`Config for ${name} found`)
      return makeConfig(name)
    } else {
      yield* Console.log(`Unavailable config for ${name}`)
      return yield* Effect.fail(new Error(`Config not found for ${name}`))
    }
  })

// Define the master configuration and potential fallback nodes
const masterConfig = remoteConfig("master")
const nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)

// Attempt to find a working configuration,
// starting with the master and then falling back to other nodes
const config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])

// Run the effect to retrieve the configuration
const result = Effect.runSync(config)

console.log(result)
// Output:
// Unavailable config for master
// Unavailable config for node1
// Unavailable config for node2
// Config for node3 found
// { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }
```

@since 2.0.0
@category Fallback
/
const firstSuccessOf = exports.firstSuccessOf = effect.firstSuccessOf;
/**
Retrieves the `Random` service from the context.

@since 2.0.0
@category Random
/
const random = exports.random = effect.random;
/**
Retrieves the `Random` service from the context and uses it to run the
specified effect.

@since 2.0.0
@category Random
/
const randomWith = exports.randomWith = defaultServices.randomWith;
/**
Executes the specified effect with the specified implementation of the
`Random` service.

@since 2.0.0
@category Random
/
const withRandom = exports.withRandom = defaultServices.withRandom;
/**
Sets the implementation of the `Random` service to the specified value and
restores it to its original value when the scope is closed.

@since 2.0.0
@category Random
/
const withRandomScoped = exports.withRandomScoped = fiberRuntime.withRandomScoped;
/**
Returns an effect that accesses the runtime, which can be used to (unsafely)
execute tasks.

**When to Use**

This is useful for integration with legacy code that must call back into
Effect code.

@since 2.0.0
@category Runtime
/
const runtime = exports.runtime = runtime_.runtime;
/**
Retrieves an effect that succeeds with the current runtime flags, which
govern behavior and features of the runtime system.

@since 2.0.0
@category Runtime
/
const getRuntimeFlags = exports.getRuntimeFlags = core.runtimeFlags;
/**
@since 2.0.0
@category Runtime
/
const patchRuntimeFlags = exports.patchRuntimeFlags = core.updateRuntimeFlags;
/**
@since 2.0.0
@category Runtime
/
const withRuntimeFlagsPatch = exports.withRuntimeFlagsPatch = core.withRuntimeFlags;
/**
@since 2.0.0
@category Runtime
/
const withRuntimeFlagsPatchScoped = exports.withRuntimeFlagsPatchScoped = fiberRuntime.withRuntimeFlagsScoped;
/**
Tags each metric in an effect with specific key-value pairs.

**Details**

This function allows you to tag all metrics in an effect with a set of
key-value pairs or a single key-value pair. Tags help you add metadata to
metrics, making it easier to filter and categorize them in monitoring
systems. The provided tags will apply to all metrics generated within the
effect's scope.

@since 2.0.0
@category Metrics
/
const tagMetrics = exports.tagMetrics = effect.tagMetrics;
/**
Adds labels to metrics within an effect using `MetricLabel` objects.

**Details**

This function allows you to label metrics using `MetricLabel` objects. Labels
help add structured metadata to metrics for categorization and filtering in
monitoring systems. The provided labels will apply to all metrics within the
effect's execution.

@since 2.0.0
@category Metrics
/
const labelMetrics = exports.labelMetrics = effect.labelMetrics;
/**
Tags metrics within a scope with a specific key-value pair.

**Details**

This function tags all metrics within a scope with the provided key-value
pair. Once the scope is closed, the tag is automatically removed. This is
useful for applying temporary context-specific tags to metrics during scoped
operations.

@since 2.0.0
@category Metrics
/
const tagMetricsScoped = exports.tagMetricsScoped = fiberRuntime.tagMetricsScoped;
/**
Adds labels to metrics within a scope using `MetricLabel` objects.

**Details**

This function allows you to apply labels to all metrics generated within a
specific scope using an array of `MetricLabel` objects. These labels provide
additional metadata to metrics, which can be used for categorization,
filtering, or monitoring purposes. The labels are scoped and will be removed
automatically once the scope is closed, ensuring they are only applied
temporarily within the defined context.

@since 2.0.0
@category Metrics
/
const labelMetricsScoped = exports.labelMetricsScoped = fiberRuntime.labelMetricsScoped;
/**
Retrieves the metric labels associated with the current scope.

@since 2.0.0
@category Metrics
/
const metricLabels = exports.metricLabels = core.metricLabels;
/**
Associates a metric with the current effect, updating it as the effect progresses.

@since 2.0.0
@category Metrics
/
const withMetric = exports.withMetric = effect.withMetric;
/**
Unsafely creates a new Semaphore.

@since 2.0.0
@category Semaphore
/
const unsafeMakeSemaphore = exports.unsafeMakeSemaphore = circular.unsafeMakeSemaphore;
/**
Creates a new semaphore with the specified number of permits.

**Details**

This function initializes a semaphore that controls concurrent access to a
shared resource. The number of permits determines how many tasks can access
the resource concurrently.

**Example**

```ts
import { Effect } from "effect"

// Create a semaphore with 3 permits
const mutex = Effect.makeSemaphore(3)
```

@since 2.0.0
@category Semaphore
/
const makeSemaphore = exports.makeSemaphore = circular.makeSemaphore;
/**
@category Latch
@since 3.8.0
/
const unsafeMakeLatch = exports.unsafeMakeLatch = circular.unsafeMakeLatch;
/**
Creates a new `Latch`, starting in the specified state.

**Details**

This function initializes a `Latch` safely, ensuring proper runtime
guarantees. By default, the latch starts in the closed state.

**Example**

```ts
import { Console, Effect } from "effect"

const program = Effect.gen(function*() {
  // Create a latch, starting in the closed state
  const latch = yield* Effect.makeLatch(false)

  // Fork a fiber that logs "open sesame" when the latch is opened
  const fiber = yield* Console.log("open sesame").pipe(
    latch.whenOpen,
    Effect.fork
  )

  yield* Effect.sleep("1 second")

  // Open the latch
  yield* latch.open
  yield* fiber.await
})

Effect.runFork(program)
// Output: open sesame (after 1 second)
```

@category Latch
@since 3.8.0
/
const makeLatch = exports.makeLatch = circular.makeLatch;
/**
Runs an effect in the background, returning a fiber that can be observed or
interrupted.

Unless you specifically need a `Promise` or synchronous operation, `runFork`
is a good default choice.

**Details**

This function is the foundational way to execute an effect in the background.
It creates a "fiber," a lightweight, cooperative thread of execution that can
be observed (to access its result), interrupted, or joined. Fibers are useful
for concurrent programming and allow effects to run independently of the main
program flow.

Once the effect is running in a fiber, you can monitor its progress, cancel
it if necessary, or retrieve its result when it completes. If the effect
fails, the fiber will propagate the failure, which you can observe and
handle.

**When to Use**

Use this function when you need to run an effect in the background,
especially if the effect is long-running or performs periodic tasks. It's
suitable for tasks that need to run independently but might still need
observation or management, like logging, monitoring, or scheduled tasks.

This function is ideal if you don't need the result immediately or if the
effect is part of a larger concurrent workflow.

**Example** (Running an Effect in the Background)

```ts
import { Effect, Console, Schedule, Fiber } from "effect"

//       Effect<number, never, never>
//      
const program = Effect.repeat(
  Console.log("running..."),
  Schedule.spaced("200 millis")
)

//       RuntimeFiber<number, never>
//      
const fiber = Effect.runFork(program)

setTimeout(() => {
  Effect.runFork(Fiber.interrupt(fiber))
}, 500)
```

@since 2.0.0
@category Running Effects
/
const runFork = exports.runFork = runtime_.unsafeForkEffect;
/**
Executes an effect asynchronously and handles the result using a callback.

**Details**

This function runs an effect asynchronously and passes the result (`Exit`) to
a specified callback. The callback is invoked with the outcome of the effect:
- On success, the callback receives the successful result.
- On failure, the callback receives the failure information.

**When to Use**

This function is effectful and should only be invoked at the edges of your
program.

@since 2.0.0
@category Running Effects
/
const runCallback = exports.runCallback = runtime_.unsafeRunEffect;
/**
Executes an effect and returns the result as a `Promise`.

**Details**

This function runs an effect and converts its result into a `Promise`. If the
effect succeeds, the `Promise` will resolve with the successful result. If
the effect fails, the `Promise` will reject with an error, which includes the
failure details of the effect.

The optional `options` parameter allows you to pass an `AbortSignal` for
cancellation, enabling more fine-grained control over asynchronous tasks.

**When to Use**

Use this function when you need to execute an effect and work with its result
in a promise-based system, such as when integrating with third-party
libraries that expect `Promise` results.

**Example** (Running a Successful Effect as a Promise)

```ts
import { Effect } from "effect"

Effect.runPromise(Effect.succeed(1)).then(console.log)
// Output: 1
```

**Example** (Handling a Failing Effect as a Rejected Promise)

```ts
import { Effect } from "effect"

Effect.runPromise(Effect.fail("my error")).catch(console.error)
// Output:
// (FiberFailure) Error: my error
```

@see {@link runPromiseExit} for a version that returns an `Exit` type instead
of rejecting.

@since 2.0.0
@category Running Effects
/
const runPromise = exports.runPromise = runtime_.unsafeRunPromiseEffect;
/**
Runs an effect and returns a `Promise` that resolves to an `Exit`,
representing the outcome.

**Details**

This function executes an effect and resolves to an `Exit` object. The `Exit`
type provides detailed information about the result of the effect:
- If the effect succeeds, the `Exit` will be of type `Success` and include
  the value produced by the effect.
- If the effect fails, the `Exit` will be of type `Failure` and contain a
  `Cause` object, detailing the failure.

Using this function allows you to examine both successful results and failure
cases in a unified way, while still leveraging `Promise` for handling the
asynchronous behavior of the effect.

**When to Use**

Use this function when you need to understand the outcome of an effect,
whether it succeeded or failed, and want to work with this result using
`Promise` syntax. This is particularly useful when integrating with systems
that rely on promises but need more detailed error handling than a simple
rejection.

**Example** (Handling Results as Exit)

```ts
import { Effect } from "effect"

// Execute a successful effect and get the Exit result as a Promise
Effect.runPromiseExit(Effect.succeed(1)).then(console.log)
// Output:
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: 1
// }

// Execute a failing effect and get the Exit result as a Promise
Effect.runPromiseExit(Effect.fail("my error")).then(console.log)
// Output:
// {
//   _id: "Exit",
//   _tag: "Failure",
//   cause: {
//     _id: "Cause",
//     _tag: "Fail",
//     failure: "my error"
//   }
// }
```

@since 2.0.0
@category Running Effects
/
const runPromiseExit = exports.runPromiseExit = runtime_.unsafeRunPromiseExitEffect;
/**
Executes an effect synchronously, running it immediately and returning the
result.

**Details**

This function evaluates the provided effect synchronously, returning its
result directly. It is ideal for effects that do not fail or include
asynchronous operations. If the effect does fail or involves async tasks, it
will throw an error. Execution stops at the point of failure or asynchronous
operation, making it unsuitable for effects that require asynchronous
handling.

**Important**: Attempting to run effects that involve asynchronous operations
or failures will result in exceptions being thrown, so use this function with
care for purely synchronous and error-free effects.

**When to Use**

Use this function when:
- You are sure that the effect will not fail or involve asynchronous
  operations.
- You need a direct, synchronous result from the effect.
- You are working within a context where asynchronous effects are not
  allowed.

Avoid using this function for effects that can fail or require asynchronous
handling. For such cases, consider using {@link runPromise} or
{@link runSyncExit}.

**Example** (Synchronous Logging)

```ts
import { Effect } from "effect"

const program = Effect.sync(() => {
  console.log("Hello, World!")
  return 1
})

const result = Effect.runSync(program)
// Output: Hello, World!

console.log(result)
// Output: 1
```

**Example** (Incorrect Usage with Failing or Async Effects)

```ts
import { Effect } from "effect"

try {
  // Attempt to run an effect that fails
  Effect.runSync(Effect.fail("my error"))
} catch (e) {
  console.error(e)
}
// Output:
// (FiberFailure) Error: my error

try {
  // Attempt to run an effect that involves async work
  Effect.runSync(Effect.promise(() => Promise.resolve(1)))
} catch (e) {
  console.error(e)
}
// Output:
// (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work
```

@see {@link runSyncExit} for a version that returns an `Exit` type instead of
throwing an error.

@since 2.0.0
@category Running Effects
/
const runSync = exports.runSync = runtime_.unsafeRunSyncEffect;
/**
Runs an effect synchronously and returns the result as an `Exit` type.

**Details**

This function executes the provided effect synchronously and returns an `Exit`
type that encapsulates the outcome of the effect:
- If the effect succeeds, the result is wrapped in a `Success`.
- If the effect fails, it returns a `Failure` containing a `Cause` that explains
  the failure.

If the effect involves asynchronous operations, this function will return a `Failure`
with a `Die` cause, indicating that it cannot resolve the effect synchronously.
This makes the function suitable for use only with effects that are synchronous
in nature.

**When to Use**

Use this function when:
- You want to handle both success and failure outcomes in a structured way using the `Exit` type.
- You are working with effects that are purely synchronous and do not involve asynchronous operations.
- You need to debug or inspect failures, including their causes, in a detailed manner.

Avoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.

**Example** (Handling Results as Exit)

```ts
import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.succeed(1)))
// Output:
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: 1
// }

console.log(Effect.runSyncExit(Effect.fail("my error")))
// Output:
// {
//   _id: "Exit",
//   _tag: "Failure",
//   cause: {
//     _id: "Cause",
//     _tag: "Fail",
//     failure: "my error"
//   }
// }
```

**Example** (Asynchronous Operation Resulting in Die)

```ts
import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
//       fiber: [FiberRuntime],
//       _tag: 'AsyncFiberException',
//       name: 'AsyncFiberException'
//     }
//   }
// }
```

@since 2.0.0
@category Running Effects
/
const runSyncExit = exports.runSyncExit = runtime_.unsafeRunSyncExitEffect;
/**
Combines multiple effects and accumulates both successes and failures.

**Details**

This function allows you to combine multiple effects, continuing through all
effects even if some of them fail. Unlike other functions that stop execution
upon encountering an error, this function collects all errors into a `Cause`.
The final result includes all successes and the accumulated failures.

By default, effects are executed sequentially, but you can control
concurrency and batching behavior using the `options` parameter. This
provides flexibility in scenarios where you want to maximize performance or
ensure specific ordering.

**Example**

```ts
import { Effect, Console } from "effect"

const task1 = Console.log("task1").pipe(Effect.as(1))
const task2 = Effect.fail("Oh uh!").pipe(Effect.as(2))
const task3 = Console.log("task2").pipe(Effect.as(3))
const task4 = Effect.fail("Oh no!").pipe(Effect.as(4))

const program = task1.pipe(
  Effect.validate(task2),
  Effect.validate(task3),
  Effect.validate(task4)
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1
// task2
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Sequential',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }
//   }
// }
```

@see {@link zip} for a version that stops at the first error.

@since 2.0.0
@category Error Accumulation
/
const validate = exports.validate = fiberRuntime.validate;
/**
Sequentially combines two effects using a specified combiner function while
accumulating errors.

**Details**

This function combines two effects, `self` and `that`, into a single effect
by applying the provided combiner function to their results. If both effects
succeed, the combiner function is applied to their results to produce the
final value. If either effect fails, the failures are accumulated into a
combined `Cause`.

By default, effects are executed sequentially. However, the execution mode
can be controlled using the `options` parameter to enable concurrency,
batching, or customized finalizer behavior.

@since 2.0.0
@category Error Accumulation
/
const validateWith = exports.validateWith = fiberRuntime.validateWith;
/**
Combines two effects into a single effect, producing a tuple of their
results.

**Details**

This function combines two effects, `self` and `that`, into one. It executes
the first effect (`self`) and then the second effect (`that`), collecting
their results into a tuple. Both effects must succeed for the resulting
effect to succeed. If either effect fails, the entire operation fails.

By default, the effects are executed sequentially. If the `concurrent` option
is set to `true`, the effects will run concurrently, potentially improving
performance for independent operations.

**Example** (Combining Two Effects Sequentially)

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Combine the two effects together
//
//       Effect<[number, string], never, never>
//      
const program = Effect.zip(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// [ 1, 'hello' ]
```

**Example** (Combining Two Effects Concurrently)

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Run both effects concurrently using the concurrent option
const program = Effect.zip(task1, task2, { concurrent: true })

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task2 done"
// timestamp=... level=INFO fiber=#0 message="task1 done"
// [ 1, 'hello' ]
```

@see {@link zipWith} for a version that combines the results with a custom
function.
@see {@link validate} for a version that accumulates errors.

@since 2.0.0
@category Zipping
/
const zip = exports.zip = fiberRuntime.zipOptions;
/**
Executes two effects sequentially, returning the result of the first effect
and ignoring the result of the second.

**Details**

This function allows you to run two effects in sequence, where the result of
the first effect is preserved, and the result of the second effect is
discarded. By default, the two effects are executed sequentially. If you need
them to run concurrently, you can pass the `{ concurrent: true }` option.

The second effect will always be executed, even though its result is ignored.
This makes it useful for cases where you want to execute an effect for its
side effects while keeping the result of another effect.

**When to Use**

Use this function when you are only interested in the result of the first
effect but still need to run the second effect for its side effects, such as
logging or performing a cleanup action.

**Example**

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = Effect.zipLeft(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// 1
```

@see {@link zipRight} for a version that returns the result of the second
effect.

@since 2.0.0
@category Zipping
/
const zipLeft = exports.zipLeft = fiberRuntime.zipLeftOptions;
/**
Executes two effects sequentially, returning the result of the second effect
while ignoring the result of the first.

**Details**

This function allows you to run two effects in sequence, keeping the result
of the second effect and discarding the result of the first. By default, the
two effects are executed sequentially. If you need them to run concurrently,
you can pass the `{ concurrent: true }` option.

The first effect will always be executed, even though its result is ignored.
This makes it useful for scenarios where the first effect is needed for its
side effects, but only the result of the second effect is important.

**When to Use**

Use this function when you are only interested in the result of the second
effect but still need to run the first effect for its side effects, such as
initialization or setup tasks.

**Example**

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = Effect.zipRight(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// hello
```

@see {@link zipLeft} for a version that returns the result of the first
effect.

@since 2.0.0
@category Zipping
/
const zipRight = exports.zipRight = fiberRuntime.zipRightOptions;
/**
Combines two effects sequentially and applies a function to their results to
produce a single value.

**Details**

This function runs two effects in sequence (or concurrently, if the `{
concurrent: true }` option is provided) and combines their results using a
provided function. Unlike {@link zip}, which returns a tuple of the results,
this function processes the results with a custom function to produce a
single output.

**Example** (Combining Effects with a Custom Function)

```ts
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const task3 = Effect.zipWith(
  task1,
  task2,
  // Combines results into a single value
  (number, string) => number + string.length
)

Effect.runPromise(task3).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#3 message="task1 done"
// timestamp=... level=INFO fiber=#2 message="task2 done"
// 6
```

@since 2.0.0
@category Zipping
/
const zipWith = exports.zipWith = fiberRuntime.zipWithOptions;
/**
Applies the function produced by one effect to the value produced by another effect.

**Details**

This function combines two effects:
- The first effect produces a function of type `(a: A) => B`.
- The second effect produces a value of type `A`.

Once both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.

@since 2.0.0
/
const ap = exports.ap = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(self, that, (f, a) => f(a)));
/**
@category Requests & Batching
@since 2.0.0
/
const blocked = exports.blocked = core.blocked;
/**
@category Requests & Batching
@since 2.0.0
/
const runRequestBlock = exports.runRequestBlock = core.runRequestBlock;
/**
@category Requests & Batching
@since 2.0.0
/
const step = exports.step = core.step;
/**
@since 2.0.0
@category Requests & Batching
/
const request = exports.request = /*#__PURE__*/(0, _Function.dual)(args => Request.isRequest(args[0]), query.fromRequest);
/**
@since 2.0.0
@category Requests & Batching
/
const cacheRequestResult = exports.cacheRequestResult = query.cacheRequest;
/**
@since 2.0.0
@category Requests & Batching
/
const withRequestBatching = exports.withRequestBatching = core.withRequestBatching;
/**
@since 2.0.0
@category Requests & Batching
/
const withRequestCaching = exports.withRequestCaching = query.withRequestCaching;
/**
@since 2.0.0
@category Requests & Batching
/
const withRequestCache = exports.withRequestCache = query.withRequestCache;
/**
@since 2.0.0
@category Tracing
/
const tracer = exports.tracer = effect.tracer;
/**
@since 2.0.0
@category Tracing
/
const tracerWith = exports.tracerWith = defaultServices.tracerWith;
/**
@since 2.0.0
@category Tracing
/
const withTracer = exports.withTracer = defaultServices.withTracer;
/**
@since 2.0.0
@category Tracing
/
const withTracerScoped = exports.withTracerScoped = fiberRuntime.withTracerScoped;
/**
Disable the tracer for the given Effect.

**Example**

```ts
import { Effect } from "effect"

Effect.succeed(42).pipe(
  Effect.withSpan("my-span"),
  // the span will not be registered with the tracer
  Effect.withTracerEnabled(false)
)
```

@since 2.0.0
@category Tracing
/
const withTracerEnabled = exports.withTracerEnabled = core.withTracerEnabled;
/**
@since 2.0.0
@category Tracing
/
const withTracerTiming = exports.withTracerTiming = core.withTracerTiming;
/**
Adds annotations to each span in the effect for enhanced traceability.

**Details**

This function lets you attach key-value annotations to all spans generated
during the execution of an effect. Annotations provide additional context,
such as metadata or labels, which can help you understand and debug
asynchronous workflows more effectively.

You can either pass a single key-value pair or a record of key-value pairs to
annotate the spans. These annotations can then be visualized in tracing tools
that support span annotations.

@since 2.0.0
@category Tracing
/
const annotateSpans = exports.annotateSpans = effect.annotateSpans;
/**
Adds annotations to the currently active span for traceability.

**Details**

This function adds key-value annotations to the currently active span in the
effect's trace. These annotations help provide more context about the
operation being executed at a specific point in time. Unlike
{@link annotateSpans}, which applies to all spans in an effect, this function
focuses solely on the active span.

You can either pass a single key-value pair or a record of key-value pairs to
annotate the span. These annotations are useful for adding metadata to
operations, especially in systems with detailed observability requirements.

@since 2.0.0
@category Tracing
/
const annotateCurrentSpan = exports.annotateCurrentSpan = effect.annotateCurrentSpan;
/**
@since 2.0.0
@category Tracing
/
const currentSpan = exports.currentSpan = effect.currentSpan;
/**
@since 2.0.0
@category Tracing
/
const currentParentSpan = exports.currentParentSpan = effect.currentParentSpan;
/**
@since 2.0.0
@category Tracing
/
const spanAnnotations = exports.spanAnnotations = effect.spanAnnotations;
/**
@since 2.0.0
@category Tracing
/
const spanLinks = exports.spanLinks = effect.spanLinks;
/**
For all spans in this effect, add a link with the provided span.

@since 2.0.0
@category Tracing
/
const linkSpans = exports.linkSpans = effect.linkSpans;
/**
Add span links to the current span.

@since 3.14.0
@category Tracing
/
const linkSpanCurrent = exports.linkSpanCurrent = effect.linkSpanCurrent;
/**
Create a new span for tracing.

@since 2.0.0
@category Tracing
/
const makeSpan = exports.makeSpan = effect.makeSpan;
/**
Create a new span for tracing, and automatically close it when the Scope
finalizes.

The span is not added to the current span stack, so no child spans will be
created for it.

@since 2.0.0
@category Tracing
/
const makeSpanScoped = exports.makeSpanScoped = fiberRuntime.makeSpanScoped;
/**
Create a new span for tracing, and automatically close it when the effect
completes.

The span is not added to the current span stack, so no child spans will be
created for it.

@since 2.0.0
@category Tracing
/
const useSpan = exports.useSpan = effect.useSpan;
/**
Wraps the effect with a new span for tracing.

@since 2.0.0
@category Tracing
/
const withSpan = exports.withSpan = effect.withSpan;
/**
Wraps a function that returns an effect with a new span for tracing.

**Example**

```ts
import { Effect } from "effect"

const getTodo = Effect.functionWithSpan({
  body: (id: number) => Effect.succeed(`Got todo ${id}!`),
  options: (id) => ({
    name: `getTodo-${id}`,
    attributes: { id }
  })
})
```

@since 3.2.0
@category Tracing
/
const functionWithSpan = exports.functionWithSpan = effect.functionWithSpan;
/**
Wraps the effect with a new span for tracing.

The span is ended when the Scope is finalized.

@since 2.0.0
@category Tracing
/
const withSpanScoped = exports.withSpanScoped = fiberRuntime.withSpanScoped;
/**
Adds the provided span to the current span stack.

@since 2.0.0
@category Tracing
/
const withParentSpan = exports.withParentSpan = effect.withParentSpan;
/**
Safely handles nullable values by creating an effect that fails for `null` or
`undefined`.

**Details**

This function ensures that an input value is non-null and non-undefined
before processing it. If the value is valid, the effect succeeds with the
value. If the value is `null` or `undefined`, the effect fails with a
`NoSuchElementException`. This is particularly useful for avoiding
null-related errors by clearly separating valid values from invalid ones in
effectful computations.

The failure with `NoSuchElementException` allows you to explicitly handle
cases where a value is expected but not provided, leading to safer and more
predictable code.

**When to Use**

Use this function when working with values that may be `null` or `undefined`
and you want to ensure that only non-null values are processed. It helps
enforce null-safety and makes error handling more explicit.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, NoSuchElementException, never>
//      
const maybe1 = Effect.fromNullable(1)

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// { _id: 'Exit', _tag: 'Success', value: 1 }

//       Effect<number, NoSuchElementException, never>
//      
const maybe2 = Effect.fromNullable(null as number | null)

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'NoSuchElementException' }
//   }
// }
```

@since 2.0.0
@category Optional Wrapping & Unwrapping
/
const fromNullable = exports.fromNullable = effect.fromNullable;
/**
Converts an effect that may fail with a `NoSuchElementException` into an
effect that succeeds with an `Option`.

**Details**

This function transforms an effect that might fail with
`Cause.NoSuchElementException` into an effect that succeeds with an `Option`
type. If the original effect succeeds, its value is wrapped in `Option.some`.
If it fails specifically due to a `NoSuchElementException`, the failure is
mapped to `Option.none`. Other types of failures remain unchanged and are
passed through as they are.

This is useful when working with effects where you want to gracefully handle
the absence of a value while preserving other potential failures.

**When to Use**

Use this function when you need to handle missing values as `Option.none`
rather than throwing or propagating errors like `NoSuchElementException`.
Its ideal for scenarios where you want to explicitly represent optionality
in a type-safe way while retaining other failure information.

**Example**

```ts
import { Effect } from "effect"

//       Effect<number, NoSuchElementException, never>
//      
const maybe1 = Effect.fromNullable(1)

//       Effect<Option<number>, never, never>
//      
const option1 = Effect.optionFromOptional(maybe1)

Effect.runPromise(option1).then(console.log)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

//       Effect<number, NoSuchElementException, never>
//      
const maybe2 = Effect.fromNullable(null as number | null)

//       Effect<Option<number>, never, never>
//      
const option2 = Effect.optionFromOptional(maybe2)

Effect.runPromise(option2).then(console.log)
// Output: { _tag: 'None' }
```

@since 2.0.0
@category Optional Wrapping & Unwrapping
/
const optionFromOptional = exports.optionFromOptional = effect.optionFromOptional;
/**
Converts an `Option` of an `Effect` into an `Effect` of an `Option`.

**Details**

This function transforms an `Option<Effect<A, E, R>>` into an
`Effect<Option<A>, E, R>`. If the `Option` is `None`, the resulting `Effect`
will immediately succeed with a `None` value. If the `Option` is `Some`, the
inner `Effect` will be executed, and its result wrapped in a `Some`.

**Example**

```ts
import { Effect, Option } from "effect"

//       Option<Effect<number, never, never>>
//      
const maybe = Option.some(Effect.succeed(42))

//       Effect<Option<number>, never, never>
//      
const result = Effect.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }
```

@since 3.13.0
@category Optional Wrapping & Unwrapping
/
const transposeOption = self => {
  return option_.isNone(self) ? succeedNone : map(self.value, option_.some);
};
/**
Applies an `Effect` on an `Option` and transposes the result.

**Details**

If the `Option` is `None`, the resulting `Effect` will immediately succeed with a `None` value.
If the `Option` is `Some`, the effectful operation will be executed on the inner value, and its result wrapped in a `Some`.

@example
```ts
import { Effect, Option, pipe } from "effect"

//           Effect<Option<number>, never, never>>
//          
const noneResult = pipe(
  Option.none(),
  Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed
)
console.log(Effect.runSync(noneResult))
// Output: { _id: 'Option', _tag: 'None' }

//           Effect<Option<number>, never, never>>
//          
const someSuccessResult = pipe(
  Option.some(42),
  Effect.transposeMapOption((value) => Effect.succeed(value * 2))
)
console.log(Effect.runSync(someSuccessResult))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }
```

@since 3.14.0
@category Optional Wrapping & Unwrapping

## Tag

Source: `my-backend/node_modules/effect/dist/cjs/Effect.js`

Signature: `Tag(= Tag;
const Service = function ()`

JSDoc:

Creates a unique tag for a dependency, embedding the service's methods as
static properties.

**Details**

This function allows you to define a `Tag` for a service or dependency in
your application. The `Tag` not only acts as an identifier but also provides
direct access to the service's methods via static properties. This makes it
easier to access and use the service in your code without manually managing
contexts.

In the example below, the fields of the service (in this case, the `notify`
method) are turned into static properties of the Notifications class, making
it easier to access them.

**Example**

```ts
import { Effect } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {}

// Create an effect that depends on the Notifications service
const action = Notifications.notify("Hello, world!")
```

@since 2.0.0
@category Context
/
const Tag = id => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, _context.TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "use", {
    get() {
      return body => core.andThen(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
/**
Simplifies the creation and management of services in Effect by defining both
a `Tag` and a `Layer`.

**Details**

This function allows you to streamline the creation of services by combining
the definition of a `Context.Tag` and a `Layer` in a single step. It supports
various ways of providing the service implementation:
- Using an `effect` to define the service dynamically.
- Using `sync` or `succeed` to define the service statically.
- Using `scoped` to create services with lifecycle management.

It also allows you to specify dependencies for the service, which will be
provided automatically when the service is used. Accessors can be optionally
generated for the service, making it more convenient to use.

**Example**

```ts
import { Effect } from 'effect';

class Prefix extends Effect.Service<Prefix>()("Prefix", {
 sync: () => ({ prefix: "PRE" })
}) {}

class Logger extends Effect.Service<Logger>()("Logger", {
 accessors: true,
 effect: Effect.gen(function* () {
   const { prefix } = yield* Prefix
   return {
     info: (message: string) =>
       Effect.sync(() => {
         console.log(`[${prefix}][${message}]`)
       })
   }
 }),
 dependencies: [Prefix.Default]
}) {}
```

@since 3.9.0
@category Context
@experimental might be up for breaking changes

## Service

Source: `my-backend/node_modules/effect/dist/cjs/Effect.js`

Signature: `Service(= Service;
const fn = function (nameOrBody, ...pipeables)`

JSDoc:

The `Effect.fn` function allows you to create traced functions that return an
effect. It provides two key features:

- **Stack traces with location details** if an error occurs.
- **Automatic span creation** for tracing when a span name is provided.

If a span name is passed as the first argument, the function's execution is
tracked using that name. If no name is provided, stack tracing still works,
but spans are not created.

A function can be defined using either:

- A generator function, allowing the use of `yield*` for effect composition.
- A regular function that returns an `Effect`.

**Example** (Creating a Traced Function with a Span Name)

```ts
import { Effect } from "effect"

const myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {
  yield* Effect.annotateCurrentSpan("n", n) // Attach metadata to the span
  console.log(`got: ${n}`)
  yield* Effect.fail(new Error("Boom!")) // Simulate failure
})

Effect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))
// Output:
// got: 100
// timestamp=... level=ERROR fiber=#0 cause="Error: Boom!
//     at <anonymous> (/.../index.ts:6:22) <= Raise location
//     at myspan (/.../index.ts:3:23)  <= Definition location
//     at myspan (/.../index.ts:9:16)" <= Call location
```

`Effect.fn` automatically creates spans. The spans capture information about
the function execution, including metadata and error details.

**Example** (Exporting Spans to the Console)

```ts skip-type-checking
import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from "@opentelemetry/sdk-trace-base"

const myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {
  yield* Effect.annotateCurrentSpan("n", n)
  console.log(`got: ${n}`)
  yield* Effect.fail(new Error("Boom!"))
})

const program = myfunc(100)

const NodeSdkLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  // Export span data to the console
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

Effect.runFork(program.pipe(Effect.provide(NodeSdkLive)))
// Output:
// got: 100
// {
//   resource: {
//     attributes: {
//       'service.name': 'example',
//       'telemetry.sdk.language': 'nodejs',
//       'telemetry.sdk.name': '@effect/opentelemetry',
//       'telemetry.sdk.version': '1.30.1'
//     }
//   },
//   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },
//   traceId: '22801570119e57a6e2aacda3dec9665b',
//   parentId: undefined,
//   traceState: undefined,
//   name: 'myspan',
//   id: '7af530c1e01bc0cb',
//   kind: 0,
//   timestamp: 1741182277518402.2,
//   duration: 4300.416,
//   attributes: {
//     n: 100,
//     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\n' +
//       'at <anonymous> (/.../index.ts:14:17)'
//   },
//   status: { code: 2, message: 'Boom!' },
//   events: [
//     {
//       name: 'exception',
//       attributes: {
//         'exception.type': 'Error',
//         'exception.message': 'Boom!',
//         'exception.stacktrace': 'Error: Boom!\n' +
//           '    at <anonymous> (/.../index.ts:11:22)\n' +
//           '    at myspan (/.../index.ts:8:23)\n' +
//           '    at myspan (/.../index.ts:14:17)'
//       },
//       time: [ 1741182277, 522702583 ],
//       droppedAttributesCount: 0
//     }
//   ],
//   links: []
// }
```

`Effect.fn` also acts as a pipe function, allowing you to create a pipeline
after the function definition using the effect returned by the generator
function as the starting value of the pipeline.

**Example** (Creating a Traced Function with a Delay)

```ts
import { Effect } from "effect"

const myfunc = Effect.fn(
  function* (n: number) {
    console.log(`got: ${n}`)
    yield* Effect.fail(new Error("Boom!"))
  },
  // You can access both the created effect and the original arguments
  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)
)

Effect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))
// Output:
// got: 100
// timestamp=... level=ERROR fiber=#0 cause="Error: Boom! (<= after 1 second)
```

@see {@link fnUntraced} for a version of this function that doesn't add a span.

@since 3.11.0
@category Tracing

## Class

Source: `my-backend/node_modules/effect/dist/cjs/Effectable.js`

Signature: `Class(= Class;
class StructuralClass extends StructuralBase {}
exports.StructuralClass = StructuralClass;
//# sourceMappingURL=Effectable.js.map)`

JSDoc:

@since 2.0.0
@category type ids
/
const EffectTypeId = exports.EffectTypeId = internal.EffectTypeId;
/**
@since 2.0.0
@category type ids
/
const StreamTypeId = exports.StreamTypeId = internal.StreamTypeId;
/**
@since 2.0.0
@category type ids
/
const SinkTypeId = exports.SinkTypeId = internal.SinkTypeId;
/**
@since 2.0.0
@category type ids
/
const ChannelTypeId = exports.ChannelTypeId = internal.ChannelTypeId;
/**
@since 2.0.0
@category prototypes
/
const EffectPrototype = exports.EffectPrototype = internal.EffectPrototype;
/**
@since 2.0.0
@category prototypes
/
const CommitPrototype = exports.CommitPrototype = internal.CommitPrototype;
/**
@since 2.0.0
@category prototypes
/
const StructuralCommitPrototype = exports.StructuralCommitPrototype = internal.StructuralCommitPrototype;
const Base = internal.Base;
const StructuralBase = internal.StructuralBase;
/**
@since 2.0.0
@category constructors
/
class Class extends Base {}
/**
@since 2.0.0
@category constructors

## getEquivalence

Source: `my-backend/node_modules/effect/dist/cjs/Either.js`

Signature: `getEquivalence(= getEquivalence;
const mapBoth = exports.mapBoth = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 2.0.0
/

/**
@category symbols
@since 2.0.0
/
const TypeId = exports.TypeId = either.TypeId;
/**
Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
of this structure.

@category constructors
@since 2.0.0
/
const right = exports.right = either.right;
const void_ = exports.void = /*#__PURE__*/right(void 0);
/**
Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
structure.

@category constructors
@since 2.0.0
/
const left = exports.left = either.left;
/**
Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use
the provided default as a `Left`.

@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))
assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))
```

@category constructors
@since 2.0.0
/
const fromNullable = exports.fromNullable = /*#__PURE__*/(0, _Function.dual)(2, (self, onNullable) => self == null ? left(onNullable(self)) : right(self));
/**
@example
```ts
import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))
assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))
```

@category constructors
@since 2.0.0
/
const fromOption = exports.fromOption = either.fromOption;
const try_ = evaluate => {
  if ((0, _Predicate.isFunction)(evaluate)) {
    try {
      return right(evaluate());
    } catch (e) {
      return left(e);
    }
  } else {
    try {
      return right(evaluate.try());
    } catch (e) {
      return left(evaluate.catch(e));
    }
  }
};
exports.try = try_;
/**
Tests if a value is a `Either`.

@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isEither(Either.right(1)), true)
assert.deepStrictEqual(Either.isEither(Either.left("a")), true)
assert.deepStrictEqual(Either.isEither({ right: 1 }), false)
```

@category guards
@since 2.0.0
/
const isEither = exports.isEither = either.isEither;
/**
Determine if a `Either` is a `Left`.

@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)
assert.deepStrictEqual(Either.isLeft(Either.left("a")), true)
```

@category guards
@since 2.0.0
/
const isLeft = exports.isLeft = either.isLeft;
/**
Determine if a `Either` is a `Right`.

@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isRight(Either.right(1)), true)
assert.deepStrictEqual(Either.isRight(Either.left("a")), false)
```

@category guards
@since 2.0.0
/
const isRight = exports.isRight = either.isRight;
/**
Converts a `Either` to an `Option` discarding the `Left`.

@example
```ts
import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))
assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())
```

@category getters
@since 2.0.0
/
const getRight = exports.getRight = either.getRight;
/**
Converts a `Either` to an `Option` discarding the value.

@example
```ts
import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())
assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))
```

@category getters
@since 2.0.0
/
const getLeft = exports.getLeft = either.getLeft;
/**
@category equivalence
@since 2.0.0
/
const getEquivalence = ({
  left,
  right
}) => Equivalence.make((x, y) => isLeft(x) ? isLeft(y) && left(x.left, y.left) : isRight(y) && right(x.right, y.right));
/**
@category mapping
@since 2.0.0

## all

Source: `my-backend/node_modules/effect/dist/cjs/Either.js`

Signature: `all(= all;
const flip = self => isLeft(self)`

JSDoc:

Maps the `Left` side of an `Either` value to a new `Either` value.

@category mapping
@since 2.0.0
/
const mapLeft = exports.mapLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isLeft(self) ? left(f(self.left)) : right(self.right));
/**
Maps the `Right` side of an `Either` value to a new `Either` value.

@category mapping
@since 2.0.0
/
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isRight(self) ? right(f(self.right)) : left(self.left));
/**
Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,
if the value is a `Right` the inner value is applied to the `onRight` function.

@example
```ts
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`

const onRight = (value: number): string => `Ok: ${value}`

assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')
assert.deepStrictEqual(
  pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),
  'strings: string 1, string 2'
)
```

@category pattern matching
@since 2.0.0
/
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onLeft,
  onRight
}) => isLeft(self) ? onLeft(self.left) : onRight(self.right));
/**
Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`
or `Left` of the result of the provided function if the predicate returns false

@example
```ts
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const isPositive = (n: number): boolean => n > 0
const isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)

assert.deepStrictEqual(
  isPositiveEither(1),
  Either.right(1)
)
assert.deepStrictEqual(
  isPositiveEither(0),
  Either.left("0 is not positive")
)
```

@category lifting
@since 3.4.0
/
const liftPredicate = exports.liftPredicate = /*#__PURE__*/(0, _Function.dual)(3, (a, predicate, orLeftWith) => predicate(a) ? right(a) : left(orLeftWith(a)));
/**
Filter the right value with the provided function.
If the predicate fails, set the left value with the result of the provided function.

@example
```ts
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const isPositive = (n: number): boolean => n > 0

assert.deepStrictEqual(
  pipe(
    Either.right(1),
    Either.filterOrLeft(isPositive, n => `${n} is not positive`)
  ),
  Either.right(1)
)
assert.deepStrictEqual(
  pipe(
    Either.right(0),
    Either.filterOrLeft(isPositive, n => `${n} is not positive`)
  ),
  Either.left("0 is not positive")
)
```

@since 2.0.0
@category filtering & conditionals
/
const filterOrLeft = exports.filterOrLeft = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, orLeftWith) => flatMap(self, r => predicate(r) ? right(r) : left(orLeftWith(r))));
/**
@category getters
@since 2.0.0
/
const merge = exports.merge = /*#__PURE__*/match({
  onLeft: _Function.identity,
  onRight: _Function.identity
});
/**
Returns the wrapped value if it's a `Right` or a default value if is a `Left`.

@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + "!"), 1)
assert.deepStrictEqual(Either.getOrElse(Either.left("not a number"), (error) => error + "!"), "not a number!")
```

@category getters
@since 2.0.0
/
const getOrElse = exports.getOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, onLeft) => isLeft(self) ? onLeft(self.left) : self.right);
/**
@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)
assert.deepStrictEqual(Either.getOrNull(Either.left("a")), null)
```

@category getters
@since 2.0.0
/
const getOrNull = exports.getOrNull = /*#__PURE__*/getOrElse(_Function.constNull);
/**
@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)
assert.deepStrictEqual(Either.getOrUndefined(Either.left("a")), undefined)
```

@category getters
@since 2.0.0
/
const getOrUndefined = exports.getOrUndefined = /*#__PURE__*/getOrElse(_Function.constUndefined);
/**
Extracts the value of an `Either` or throws if the `Either` is `Left`.

If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.

@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(
  Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),
  1
)
assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error('Unexpected Left')))
```

@category getters
@since 2.0.0
/
const getOrThrowWith = exports.getOrThrowWith = /*#__PURE__*/(0, _Function.dual)(2, (self, onLeft) => {
  if (isRight(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
// TODO(4.0): by default should throw `L` (i.e getOrThrowWith with the identity function)
/**
Extracts the value of an `Either` or throws if the `Either` is `Left`.

The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.

@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)
assert.throws(() => Either.getOrThrow(Either.left("error")))
```

@throws `Error("getOrThrow called on a Left")`

@category getters
@since 2.0.0
/
const getOrThrow = exports.getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error("getOrThrow called on a Left"));
/**
Returns `self` if it is a `Right` or `that` otherwise.

@category error handling
@since 2.0.0
/
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isLeft(self) ? that(self.left) : right(self.right));
/**
@category sequencing
@since 2.0.0
/
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isLeft(self) ? left(self.left) : f(self.right));
/**
Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.

@category sequencing
@since 2.0.0
/
const andThen = exports.andThen = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flatMap(self, a => {
  const b = (0, _Predicate.isFunction)(f) ? f(a) : f;
  return isEither(b) ? b : right(b);
}));
/**
@category zipping
@since 2.0.0
/
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => flatMap(self, r => map(that, r2 => f(r, r2))));
/**
@category combining
@since 2.0.0
/
const ap = exports.ap = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(self, that, (f, a) => f(a)));
/**
Takes a structure of `Either`s and returns an `Either` of values with the same structure.

- If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.
- If a struct is supplied, then the returned `Either` will contain a struct with the same keys.
- If an iterable is supplied, then the returned `Either` will contain an array.

@example
```ts
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))
assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right("hello") }), Either.right({ right: 1, b: "hello" }))
assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left("error") }), Either.left("error"))
```

@category combining
@since 2.0.0
/
// @ts-expect-error
const all = input => {
  if (Symbol.iterator in input) {
    const out = [];
    for (const e of input) {
      if (isLeft(e)) {
        return e;
      }
      out.push(e.right);
    }
    return right(out);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const e = input[key];
    if (isLeft(e)) {
      return e;
    }
    out[key] = e.right;
  }
  return right(out);
};
/**
Returns an `Either` that swaps the error/success cases. This allows you to
use all methods on the error channel, possibly before flipping back.

@since 2.0.0
@category mapping

## gen

Source: `my-backend/node_modules/effect/dist/cjs/Either.js`

Signature: `gen(= gen;
const Do = exports.Do = /*#__PURE__*/right({})`

JSDoc:

@category generators
@since 2.0.0
/
const gen = (...args) => {
  const f = args.length === 1 ? args[0] : args[1].bind(args[0]);
  const iterator = f(adapter);
  let state = iterator.next();
  while (!state.done) {
    const current = Gen.isGenKind(state.value) ? state.value.value : Gen.yieldWrapGet(state.value);
    if (isLeft(current)) {
      return current;
    }
    state = iterator.next(current.right);
  }
  return right(state.value);
};
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

@example
```ts
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

@see {@link bind}
@see {@link bindTo}
@see {@link let_ let}

@category do notation
@since 2.0.0

## transposeOption

Source: `my-backend/node_modules/effect/dist/cjs/Either.js`

Signature: `transposeOption(= transposeOption;
const transposeMapOption = exports.transposeMapOption = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

@example
```ts
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

@see {@link Do}
@see {@link bindTo}
@see {@link let_ let}

@category do notation
@since 2.0.0
/
const bind = exports.bind = /*#__PURE__*/doNotation.bind(map, flatMap);
/**
The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values

@example
```ts
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))
```

@see {@link Do}
@see {@link bind}
@see {@link let_ let}

@category do notation
@since 2.0.0
/
const bindTo = exports.bindTo = /*#__PURE__*/doNotation.bindTo(map);
const let_ = exports.let = /*#__PURE__*/doNotation.let_(map);
/**
Converts an `Option` of an `Either` into an `Either` of an `Option`.

**Details**

This function transforms an `Option<Either<A, E>>` into an
`Either<Option<A>, E>`. If the `Option` is `None`, the resulting `Either`
will be a `Right` with a `None` value. If the `Option` is `Some`, the
inner `Either` will be executed, and its result wrapped in a `Some`.

@example
```ts
import { Effect, Either, Option } from "effect"

//       Option<Either<number, never>>
//      
const maybe = Option.some(Either.right(42))

//       Either<Option<number>, never, never>
//      
const result = Either.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }
```

@since 3.14.0
@category Optional Wrapping & Unwrapping
/
const transposeOption = self => {
  return option_.isNone(self) ? right(option_.none) : map(self.value, option_.some);
};
/**
Applies an `Either` on an `Option` and transposes the result.

**Details**

If the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.
If the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.

@example
```ts
import { Either, Option, pipe } from "effect"

//           Either<Option<number>, never>>
//          
const noneResult = pipe(
  Option.none(),
  Either.transposeMapOption(() => Either.right(42)) // will not be executed
)
console.log(noneResult)
// Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }

//           Either<Option<number>, never>>
//          
const someRightResult = pipe(
  Option.some(42),
  Either.transposeMapOption((value) => Either.right(value * 2))
)
console.log(someRightResult)
// Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }
```

@since 3.15.0
@category Optional Wrapping & Unwrapping

## encodeBase64

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `encodeBase64(= encodeBase64;
const decodeBase64 = str => Base64.decode(str)`

JSDoc:

This module provides encoding & decoding functionality for:

- base64 (RFC4648)
- base64 (URL)
- hex

@since 2.0.0
/

/**
Encodes the given value into a base64 (RFC4648) `string`.

@category encoding
@since 2.0.0
/
const encodeBase64 = input => typeof input === "string" ? Base64.encode(Common.encoder.encode(input)) : Base64.encode(input);
/**
Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.

@category decoding
@since 2.0.0

## decodeBase64

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `decodeBase64(= decodeBase64;
const decodeBase64String = str => Either.map(decodeBase64(str)`

JSDoc:

Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.

@category decoding
@since 2.0.0

## decodeBase64String

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `decodeBase64String(= decodeBase64String;
const encodeBase64Url = input => typeof input === "string" ? Base64Url.encode(Common.encoder.encode(input)`

JSDoc:

Encodes the given value into a base64 (URL) `string`.

@category encoding
@since 2.0.0

## encodeBase64Url

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `encodeBase64Url(= encodeBase64Url;
const decodeBase64Url = str => Base64Url.decode(str)`

JSDoc:

Decodes a base64 (URL) encoded `string` into a `Uint8Array`.

@category decoding
@since 2.0.0

## decodeBase64Url

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `decodeBase64Url(= decodeBase64Url;
const decodeBase64UrlString = str => Either.map(decodeBase64Url(str)`

JSDoc:

Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.

@category decoding
@since 2.0.0

## decodeBase64UrlString

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `decodeBase64UrlString(= decodeBase64UrlString;
const encodeHex = input => typeof input === "string" ? Hex.encode(Common.encoder.encode(input)`

JSDoc:

Encodes the given value into a hex `string`.

@category encoding
@since 2.0.0

## encodeHex

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `encodeHex(= encodeHex;
const decodeHex = str => Hex.decode(str)`

JSDoc:

Decodes a hex encoded `string` into a `Uint8Array`.

@category decoding
@since 2.0.0

## decodeHex

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `decodeHex(= decodeHex;
const decodeHexString = str => Either.map(decodeHex(str)`

JSDoc:

Decodes a hex encoded `string` into a UTF-8 `string`.

@category decoding
@since 2.0.0

## decodeHexString

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `decodeHexString(= decodeHexString;
const encodeUriComponent = str => Either.try({
  try: ()`

JSDoc:

Encodes a UTF-8 `string` into a URI component `string`.

@category encoding
@since 3.12.0

## encodeUriComponent

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `encodeUriComponent(= encodeUriComponent;
const decodeUriComponent = str => Either.try({
  try: ()`

JSDoc:

Decodes a URI component `string` into a UTF-8 `string`.

@category decoding
@since 3.12.0

## decodeUriComponent

Source: `my-backend/node_modules/effect/dist/cjs/Encoding.js`

Signature: `decodeUriComponent(= decodeUriComponent;
const DecodeExceptionTypeId = exports.DecodeExceptionTypeId = Common.DecodeExceptionTypeId;
/**
 * Creates a checked exception which occurs when decoding fails.
 *
 * @since 2.0.0
 * @category errors
 */
const DecodeException = exports.DecodeException = Common.DecodeException;
/**
 * Returns `true` if the specified value is an `DecodeException`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
const isDecodeException = exports.isDecodeException = Common.isDecodeException;
/**
 * @since 3.12.0
 * @category symbols
 */
const EncodeExceptionTypeId = exports.EncodeExceptionTypeId = Common.EncodeExceptionTypeId;
/**
 * Creates a checked exception which occurs when encoding fails.
 *
 * @since 3.12.0
 * @category errors
 */
const EncodeException = exports.EncodeException = Common.EncodeException;
/**
 * Returns `true` if the specified value is an `EncodeException`, `false` otherwise.
 *
 * @since 3.12.0
 * @category refinements
 */
const isEncodeException = exports.isEncodeException = Common.isEncodeException;
//# sourceMappingURL=Encoding.js.map)`

JSDoc:

@since 2.0.0
@category symbols

## isEqual

Source: `my-backend/node_modules/effect/dist/cjs/Equal.js`

Signature: `isEqual(= isEqual;
const equivalence = ()`

JSDoc:

@since 2.0.0
@category symbols
/
const symbol = exports.symbol = /*#__PURE__*/Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return self => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (Hash.hash(self) === Hash.hash(that) && self[symbol](that)) {
          return true;
        } else {
          return _Utils.structuralRegionState.enabled && _Utils.structuralRegionState.tester ? _Utils.structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (_Utils.structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            // @ts-expect-error
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return _Utils.structuralRegionState.tester ? _Utils.structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return _Utils.structuralRegionState.tester ? _Utils.structuralRegionState.tester(self, that) : false;
    }
  }
  return _Utils.structuralRegionState.enabled && _Utils.structuralRegionState.tester ? _Utils.structuralRegionState.tester(self, that) : false;
}
/**
@since 2.0.0
@category guards
/
const isEqual = u => (0, _Predicate.hasProperty)(u, symbol);
/**
@since 2.0.0
@category instances

## strict

Source: `my-backend/node_modules/effect/dist/cjs/Equivalence.js`

Signature: `strict(= strict;
const string = exports.string = /*#__PURE__*/strict()`

JSDoc:

This module provides an implementation of the `Equivalence` type class, which defines a binary relation
that is reflexive, symmetric, and transitive. In other words, it defines a notion of equivalence between values of a certain type.
These properties are also known in mathematics as an "equivalence relation".

@since 2.0.0
/

/**
@category constructors
@since 2.0.0
/
const make = isEquivalent => (self, that) => self === that || isEquivalent(self, that);
exports.make = make;
const isStrictEquivalent = (x, y) => x === y;
/**
Return an `Equivalence` that uses strict equality (===) to compare values.

@since 2.0.0
@category constructors
/
const strict = () => isStrictEquivalent;
/**
@category instances
@since 2.0.0

## combineAll

Source: `my-backend/node_modules/effect/dist/cjs/Equivalence.js`

Signature: `combineAll(= combineAll;
const mapInput = exports.mapInput = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category instances
@since 2.0.0
/
const number = exports.number = /*#__PURE__*/strict();
/**
@category instances
@since 2.0.0
/
const boolean = exports.boolean = /*#__PURE__*/strict();
/**
@category instances
@since 2.0.0
/
const bigint = exports.bigint = /*#__PURE__*/strict();
/**
@category instances
@since 2.0.0
/
const symbol = exports.symbol = /*#__PURE__*/strict();
/**
@category combining
@since 2.0.0
/
const combine = exports.combine = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make((x, y) => self(x, y) && that(x, y)));
/**
@category combining
@since 2.0.0
/
const combineMany = exports.combineMany = /*#__PURE__*/(0, _Function.dual)(2, (self, collection) => make((x, y) => {
  if (!self(x, y)) {
    return false;
  }
  for (const equivalence of collection) {
    if (!equivalence(x, y)) {
      return false;
    }
  }
  return true;
}));
const isAlwaysEquivalent = (_x, _y) => true;
/**
@category combining
@since 2.0.0
/
const combineAll = collection => combineMany(isAlwaysEquivalent, collection);
/**
@category mapping
@since 2.0.0

## all

Source: `my-backend/node_modules/effect/dist/cjs/Equivalence.js`

Signature: `all(= all;
const productMany = (self, collection)`

JSDoc:

@category instances
@since 2.0.0
/
const Date = exports.Date = /*#__PURE__*/mapInput(number, date => date.getTime());
/**
@category combining
@since 2.0.0
/
const product = exports.product = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)));
/**
@category combining
@since 2.0.0
/
const all = collection => {
  return make((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const equivalence of collection) {
      if (collectionLength >= len) {
        break;
      }
      if (!equivalence(x[collectionLength], y[collectionLength])) {
        return false;
      }
      collectionLength++;
    }
    return true;
  });
};
/**
@category combining
@since 2.0.0

## productMany

Source: `my-backend/node_modules/effect/dist/cjs/Equivalence.js`

Signature: `productMany(= productMany;
const tuple = (...elements)`

JSDoc:

Similar to `Promise.all` but operates on `Equivalence`s.

```ts skip-type-checking
[Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>
```

Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
by applying each `Equivalence` to the corresponding element of the tuple.

@category combinators
@since 2.0.0

## tuple

Source: `my-backend/node_modules/effect/dist/cjs/Equivalence.js`

Signature: `tuple(= tuple;
const array = item => make((self, that)`

JSDoc:

Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.

@category combinators
@since 2.0.0

## array

Source: `my-backend/node_modules/effect/dist/cjs/Equivalence.js`

Signature: `array(= array;
const struct = fields => {
  const keys = Object.keys(fields)`

JSDoc:

Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
by applying each `Equivalence` to the corresponding property of the struct.

@category combinators
@since 2.0.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/FiberHandle.js`

Signature: `make(= make;
const makeRuntime = ()`

JSDoc:

@since 2.0.0
@categories type ids
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/FiberHandle");
/**
@since 2.0.0
@categories refinements
/
const isFiberHandle = u => Predicate.hasProperty(u, TypeId);
exports.isFiberHandle = isFiberHandle;
const Proto = {
  [TypeId]: TypeId,
  toString() {
    return Inspectable.format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const unsafeMake = deferred => {
  const self = Object.create(Proto);
  self.state = {
    _tag: "Open",
    fiber: undefined
  };
  self.deferred = deferred;
  return self;
};
/**
A FiberHandle can be used to store a single fiber.
When the associated Scope is closed, the contained fiber will be interrupted.

You can add a fiber to the handle using `FiberHandle.run`, and the fiber will
be automatically removed from the FiberHandle when it completes.

@example
```ts
import { Effect, FiberHandle } from "effect"

Effect.gen(function*() {
  const handle = yield* FiberHandle.make()

  // run some effects
  yield* FiberHandle.run(handle, Effect.never)
  // this will interrupt the previous fiber
  yield* FiberHandle.run(handle, Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fiber will be interrupted when the scope is closed
)
```

@since 2.0.0
@categories constructors
/
const make = () => Effect.acquireRelease(Effect.map(Deferred.make(), deferred => unsafeMake(deferred)), handle => Effect.withFiberRuntime(parent => {
  const state = handle.state;
  if (state._tag === "Closed") return Effect.void;
  handle.state = {
    _tag: "Closed"
  };
  return state.fiber ? Effect.intoDeferred(Effect.asVoid(Fiber.interruptAs(state.fiber, FiberId.combine(parent.id(), internalFiberId))), handle.deferred) : Deferred.done(handle.deferred, Exit.void);
}));
/**
Create an Effect run function that is backed by a FiberHandle.

@since 2.0.0
@categories constructors

## makeRuntime

Source: `my-backend/node_modules/effect/dist/cjs/FiberHandle.js`

Signature: `makeRuntime(= makeRuntime;
const makeRuntimePromise = ()`

JSDoc:

Create an Effect run function that is backed by a FiberHandle.

@since 3.13.0
@categories constructors

## unsafeGet

Source: `my-backend/node_modules/effect/dist/cjs/FiberHandle.js`

Signature: `unsafeGet(= unsafeGet;
const get = self => Effect.suspend(()`

JSDoc:

Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.
If a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.

@since 2.0.0
@categories combinators
/
const unsafeSet = exports.unsafeSet = /*#__PURE__*/(0, _Function.dual)(args => isFiberHandle(args[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));
    return;
  } else if (self.state.fiber !== undefined) {
    if (options?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));
      return;
    } else if (self.state.fiber === fiber) {
      return;
    }
    self.state.fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));
    self.state.fiber = undefined;
  }
  self.state.fiber = fiber;
  fiber.addObserver(exit => {
    if (self.state._tag === "Open" && fiber === self.state.fiber) {
      self.state.fiber = undefined;
    }
    if (Exit.isFailure(exit) && (options?.propagateInterruption === true ? !isInternalInterruption(exit.cause) : !Cause.isInterruptedOnly(exit.cause))) {
      Deferred.unsafeDone(self.deferred, exit);
    }
  });
});
/**
Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.
If a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.

@since 2.0.0
@categories combinators
/
const set = exports.set = /*#__PURE__*/(0, _Function.dual)(args => isFiberHandle(args[0]), (self, fiber, options) => Effect.fiberIdWith(fiberId => Effect.sync(() => unsafeSet(self, fiber, {
  interruptAs: fiberId,
  onlyIfMissing: options?.onlyIfMissing,
  propagateInterruption: options?.propagateInterruption
}))));
/**
Retrieve the fiber from the FiberHandle.

@since 2.0.0
@categories combinators
/
const unsafeGet = self => self.state._tag === "Closed" ? Option.none() : Option.fromNullable(self.state.fiber);
/**
Retrieve the fiber from the FiberHandle.

@since 2.0.0
@categories combinators

## get

Source: `my-backend/node_modules/effect/dist/cjs/FiberHandle.js`

Signature: `get(= get;
const clear = self => Effect.uninterruptibleMask(restore => Effect.withFiberRuntime(fiber => {
  if (self.state._tag === "Closed" || self.state.fiber === undefined)`

JSDoc:

@since 2.0.0
@categories combinators

## runtime

Source: `my-backend/node_modules/effect/dist/cjs/FiberHandle.js`

Signature: `runtime(= runtime;
const runtimePromise = self => ()`

JSDoc:

Run an Effect and add the forked fiber to the FiberHandle.
When the fiber completes, it will be removed from the FiberHandle.

@since 2.0.0
@categories combinators
/
const run = function () {
  const self = arguments[0];
  if (Effect.isEffect(arguments[1])) {
    return runImpl(self, arguments[1], arguments[2]);
  }
  const options = arguments[1];
  return effect => runImpl(self, effect, options);
};
exports.run = run;
const runImpl = (self, effect, options) => Effect.fiberIdWith(fiberId => {
  if (self.state._tag === "Closed") {
    return Effect.interrupt;
  } else if (self.state.fiber !== undefined && options?.onlyIfMissing === true) {
    return Effect.sync(constInterruptedFiber);
  }
  return Effect.tap(Effect.forkDaemon(effect), fiber => unsafeSet(self, fiber, {
    ...options,
    interruptAs: fiberId
  }));
});
/**
Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.

@example
```ts
import { Context, Effect, FiberHandle } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const handle = yield* FiberHandle.make()
  const run = yield* FiberHandle.runtime(handle)<Users>()

  // run an effect and set the fiber in the handle
  run(Effect.andThen(Users, _ => _.getAll))

  // this will interrupt the previous fiber
  run(Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fiber will be interrupted when the scope is closed
)
```

@since 2.0.0
@categories combinators
/
const runtime = self => () => Effect.map(Effect.runtime(), runtime => {
  const runFork = Runtime.runFork(runtime);
  return (effect, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber();
    } else if (self.state.fiber !== undefined && options?.onlyIfMissing === true) {
      return constInterruptedFiber();
    }
    const fiber = runFork(effect, options);
    unsafeSet(self, fiber, options);
    return fiber;
  };
});
/**
Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.

The returned run function will return Promise's that will resolve when the
fiber completes.

@since 3.13.0
@categories combinators

## runtimePromise

Source: `my-backend/node_modules/effect/dist/cjs/FiberHandle.js`

Signature: `runtimePromise(= runtimePromise;
const join = self => Deferred.await(self.deferred)`

JSDoc:

If any of the Fiber's in the handle terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

@since 2.0.0
@categories combinators
@example
```ts
import { Effect, FiberHandle } from "effect";

Effect.gen(function* (_) {
  const handle = yield* _(FiberHandle.make());
  yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberHandle.join(handle));
});
```

## join

Source: `my-backend/node_modules/effect/dist/cjs/FiberHandle.js`

Signature: `join(= join;
const awaitEmpty = self => Effect.suspend(()`

JSDoc:

Wait for the fiber in the FiberHandle to complete.

@since 3.13.0
@categories combinators

## make

Source: `my-backend/node_modules/effect/dist/cjs/FiberMap.js`

Signature: `make(= make;
const makeRuntime = ()`

JSDoc:

@since 2.0.0
@categories type ids
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/FiberMap");
/**
@since 2.0.0
@categories refinements
/
const isFiberMap = u => Predicate.hasProperty(u, TypeId);
exports.isFiberMap = isFiberMap;
const Proto = {
  [TypeId]: TypeId,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return Iterable.empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return Inspectable.format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const unsafeMake = (backing, deferred) => {
  const self = Object.create(Proto);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
/**
A FiberMap can be used to store a collection of fibers, indexed by some key.
When the associated Scope is closed, all fibers in the map will be interrupted.

You can add fibers to the map using `FiberMap.set` or `FiberMap.run`, and the fibers will
be automatically removed from the FiberMap when they complete.

@example
```ts
import { Effect, FiberMap } from "effect"

Effect.gen(function*() {
  const map = yield* FiberMap.make<string>()

  // run some effects and add the fibers to the map
  yield* FiberMap.run(map, "fiber a", Effect.never)
  yield* FiberMap.run(map, "fiber b", Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

@since 2.0.0
@categories constructors
/
const make = () => Effect.acquireRelease(Effect.map(Deferred.make(), deferred => unsafeMake(MutableHashMap.empty(), deferred)), map => Effect.withFiberRuntime(parent => {
  const state = map.state;
  if (state._tag === "Closed") return Effect.void;
  map.state = {
    _tag: "Closed"
  };
  return Fiber.interruptAllAs(Iterable.map(state.backing, ([, fiber]) => fiber), FiberId.combine(parent.id(), internalFiberId)).pipe(Effect.intoDeferred(map.deferred));
}));
/**
Create an Effect run function that is backed by a FiberMap.

@since 2.0.0
@categories constructors

## makeRuntime

Source: `my-backend/node_modules/effect/dist/cjs/FiberMap.js`

Signature: `makeRuntime(= makeRuntime;
const makeRuntimePromise = ()`

JSDoc:

Create an Effect run function that is backed by a FiberMap.

@since 3.13.0
@categories constructors

## runtime

Source: `my-backend/node_modules/effect/dist/cjs/FiberMap.js`

Signature: `runtime(= runtime;
const runtimePromise = self => ()`

JSDoc:

Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.
If the key already exists in the FiberMap, the previous fiber will be interrupted.

@since 2.0.0
@categories combinators
/
const unsafeSet = exports.unsafeSet = /*#__PURE__*/(0, _Function.dual)(args => isFiberMap(args[0]), (self, key, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));
    return;
  }
  const previous = MutableHashMap.get(self.state.backing, key);
  if (previous._tag === "Some") {
    if (options?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));
      return;
    } else if (previous.value === fiber) {
      return;
    }
    previous.value.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));
  }
  MutableHashMap.set(self.state.backing, key, fiber);
  fiber.addObserver(exit => {
    if (self.state._tag === "Closed") {
      return;
    }
    const current = MutableHashMap.get(self.state.backing, key);
    if (Option.isSome(current) && fiber === current.value) {
      MutableHashMap.remove(self.state.backing, key);
    }
    if (Exit.isFailure(exit) && (options?.propagateInterruption === true ? !isInternalInterruption(exit.cause) : !Cause.isInterruptedOnly(exit.cause))) {
      Deferred.unsafeDone(self.deferred, exit);
    }
  });
});
/**
Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.
If the key already exists in the FiberMap, the previous fiber will be interrupted.

@since 2.0.0
@categories combinators
/
const set = exports.set = /*#__PURE__*/(0, _Function.dual)(args => isFiberMap(args[0]), (self, key, fiber, options) => Effect.fiberIdWith(fiberId => Effect.sync(() => unsafeSet(self, key, fiber, {
  ...options,
  interruptAs: fiberId
}))));
/**
Retrieve a fiber from the FiberMap.

@since 2.0.0
@categories combinators
/
const unsafeGet = exports.unsafeGet = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => self.state._tag === "Closed" ? Option.none() : MutableHashMap.get(self.state.backing, key));
/**
Retrieve a fiber from the FiberMap.

@since 2.0.0
@categories combinators
/
const get = exports.get = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => Effect.suspend(() => unsafeGet(self, key)));
/**
Check if a key exists in the FiberMap.

@since 2.0.0
@categories combinators
/
const unsafeHas = exports.unsafeHas = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => self.state._tag === "Closed" ? false : MutableHashMap.has(self.state.backing, key));
/**
Check if a key exists in the FiberMap.

@since 2.0.0
@categories combinators
/
const has = exports.has = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => Effect.sync(() => unsafeHas(self, key)));
/**
Remove a fiber from the FiberMap, interrupting it if it exists.

@since 2.0.0
@categories combinators
/
const remove = exports.remove = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => Effect.withFiberRuntime(removeFiber => {
  if (self.state._tag === "Closed") {
    return Effect.void;
  }
  const fiber = MutableHashMap.get(self.state.backing, key);
  if (fiber._tag === "None") {
    return Effect.void;
  }
  // will be removed by the observer
  return Fiber.interruptAs(fiber.value, FiberId.combine(removeFiber.id(), internalFiberId));
}));
/**
@since 2.0.0
@categories combinators
/
const clear = self => Effect.withFiberRuntime(clearFiber => {
  if (self.state._tag === "Closed") {
    return Effect.void;
  }
  return Effect.forEach(self.state.backing, ([, fiber]) =>
  // will be removed by the observer
  Fiber.interruptAs(fiber, FiberId.combine(clearFiber.id(), internalFiberId)));
});
exports.clear = clear;
const constInterruptedFiber = /*#__PURE__*/function () {
  let fiber = undefined;
  return () => {
    if (fiber === undefined) {
      fiber = Effect.runFork(Effect.interrupt);
    }
    return fiber;
  };
}();
/**
Run an Effect and add the forked fiber to the FiberMap.
When the fiber completes, it will be removed from the FiberMap.

@since 2.0.0
@categories combinators
/
const run = function () {
  const self = arguments[0];
  if (Effect.isEffect(arguments[2])) {
    return runImpl(self, arguments[1], arguments[2], arguments[3]);
  }
  const key = arguments[1];
  const options = arguments[2];
  return effect => runImpl(self, key, effect, options);
};
exports.run = run;
const runImpl = (self, key, effect, options) => Effect.fiberIdWith(fiberId => {
  if (self.state._tag === "Closed") {
    return Effect.interrupt;
  } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {
    return Effect.sync(constInterruptedFiber);
  }
  return Effect.tap(Effect.forkDaemon(effect), fiber => unsafeSet(self, key, fiber, {
    ...options,
    interruptAs: fiberId
  }));
});
/**
Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.

@example
```ts
import { Context, Effect, FiberMap } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const map = yield* FiberMap.make<string>()
  const run = yield* FiberMap.runtime(map)<Users>()

  // run some effects and add the fibers to the map
  run("effect-a", Effect.andThen(Users, _ => _.getAll))
  run("effect-b", Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

@since 2.0.0
@categories combinators
/
const runtime = self => () => Effect.map(Effect.runtime(), runtime => {
  const runFork = Runtime.runFork(runtime);
  return (key, effect, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber();
    } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {
      return constInterruptedFiber();
    }
    const fiber = runFork(effect, options);
    unsafeSet(self, key, fiber, options);
    return fiber;
  };
});
/**
Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.

@since 3.13.0
@categories combinators

## runtimePromise

Source: `my-backend/node_modules/effect/dist/cjs/FiberMap.js`

Signature: `runtimePromise(= runtimePromise;
const size = self => Effect.sync(()`

JSDoc:

@since 2.0.0
@categories combinators

## size

Source: `my-backend/node_modules/effect/dist/cjs/FiberMap.js`

Signature: `size(= size;
const join = self => Deferred.await(self.deferred)`

JSDoc:

Join all fibers in the FiberMap. If any of the Fiber's in the map terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

@since 2.0.0
@categories combinators
@example
```ts
import { Effect, FiberMap } from "effect";

Effect.gen(function* (_) {
  const map = yield* _(FiberMap.make());
  yield* _(FiberMap.set(map, "a", Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberMap.join(map));
});
```

## join

Source: `my-backend/node_modules/effect/dist/cjs/FiberMap.js`

Signature: `join(= join;
const awaitEmpty = self => Effect.whileLoop({
  while: ()`

JSDoc:

Wait for the FiberMap to be empty.

@since 3.13.0
@categories combinators

## make

Source: `my-backend/node_modules/effect/dist/cjs/FiberSet.js`

Signature: `make(= make;
const makeRuntime = ()`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
@categories type ids
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/FiberSet");
/**
@since 2.0.0
@categories refinements
/
const isFiberSet = u => Predicate.hasProperty(u, TypeId);
exports.isFiberSet = isFiberSet;
const Proto = {
  [TypeId]: TypeId,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return Iterable.empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return Inspectable.format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const unsafeMake = (backing, deferred) => {
  const self = Object.create(Proto);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
/**
A FiberSet can be used to store a collection of fibers.
When the associated Scope is closed, all fibers in the set will be interrupted.

You can add fibers to the set using `FiberSet.add` or `FiberSet.run`, and the fibers will
be automatically removed from the FiberSet when they complete.

@example
```ts
import { Effect, FiberSet } from "effect"

Effect.gen(function*() {
  const set = yield* FiberSet.make()

  // run some effects and add the fibers to the set
  yield* FiberSet.run(set, Effect.never)
  yield* FiberSet.run(set, Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

@since 2.0.0
@categories constructors
/
const make = () => Effect.acquireRelease(Effect.map(Deferred.make(), deferred => unsafeMake(new Set(), deferred)), set => Effect.withFiberRuntime(parent => {
  const state = set.state;
  if (state._tag === "Closed") return Effect.void;
  set.state = {
    _tag: "Closed"
  };
  const fibers = state.backing;
  return Fiber.interruptAllAs(fibers, FiberId.combine(parent.id(), internalFiberId)).pipe(Effect.intoDeferred(set.deferred));
}));
/**
Create an Effect run function that is backed by a FiberSet.

@since 2.0.0
@categories constructors

## makeRuntime

Source: `my-backend/node_modules/effect/dist/cjs/FiberSet.js`

Signature: `makeRuntime(= makeRuntime;
const makeRuntimePromise = ()`

JSDoc:

Create an Effect run function that is backed by a FiberSet.

@since 3.13.0
@categories constructors

## runtime

Source: `my-backend/node_modules/effect/dist/cjs/FiberSet.js`

Signature: `runtime(= runtime;
const runtimePromise = self => ()`

JSDoc:

Add a fiber to the FiberSet. When the fiber completes, it will be removed.

@since 2.0.0
@categories combinators
/
const unsafeAdd = exports.unsafeAdd = /*#__PURE__*/(0, _Function.dual)(args => isFiberSet(args[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId));
    return;
  } else if (self.state.backing.has(fiber)) {
    return;
  }
  self.state.backing.add(fiber);
  fiber.addObserver(exit => {
    if (self.state._tag === "Closed") {
      return;
    }
    self.state.backing.delete(fiber);
    if (Exit.isFailure(exit) && (options?.propagateInterruption === true ? !isInternalInterruption(exit.cause) : !Cause.isInterruptedOnly(exit.cause))) {
      Deferred.unsafeDone(self.deferred, exit);
    }
  });
});
/**
Add a fiber to the FiberSet. When the fiber completes, it will be removed.

@since 2.0.0
@categories combinators
/
const add = exports.add = /*#__PURE__*/(0, _Function.dual)(args => isFiberSet(args[0]), (self, fiber, options) => Effect.fiberIdWith(fiberId => Effect.sync(() => unsafeAdd(self, fiber, {
  ...options,
  interruptAs: fiberId
}))));
/**
@since 2.0.0
@categories combinators
/
const clear = self => Effect.withFiberRuntime(clearFiber => {
  if (self.state._tag === "Closed") {
    return Effect.void;
  }
  return Effect.forEach(self.state.backing, fiber =>
  // will be removed by the observer
  Fiber.interruptAs(fiber, FiberId.combine(clearFiber.id(), internalFiberId)));
});
exports.clear = clear;
const constInterruptedFiber = /*#__PURE__*/function () {
  let fiber = undefined;
  return () => {
    if (fiber === undefined) {
      fiber = Effect.runFork(Effect.interrupt);
    }
    return fiber;
  };
}();
/**
Fork an Effect and add the forked fiber to the FiberSet.
When the fiber completes, it will be removed from the FiberSet.

@since 2.0.0
@categories combinators
/
const run = function () {
  const self = arguments[0];
  if (!Effect.isEffect(arguments[1])) {
    const options = arguments[1];
    return effect => runImpl(self, effect, options);
  }
  return runImpl(self, arguments[1], arguments[2]);
};
exports.run = run;
const runImpl = (self, effect, options) => Effect.fiberIdWith(fiberId => {
  if (self.state._tag === "Closed") {
    return Effect.sync(constInterruptedFiber);
  }
  return Effect.tap(Effect.forkDaemon(effect), fiber => unsafeAdd(self, fiber, {
    ...options,
    interruptAs: fiberId
  }));
});
/**
Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.

@example
```ts
import { Context, Effect, FiberSet } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const set = yield* FiberSet.make()
  const run = yield* FiberSet.runtime(set)<Users>()

  // run some effects and add the fibers to the set
  run(Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)
```

@since 2.0.0
@categories combinators
/
const runtime = self => () => Effect.map(Effect.runtime(), runtime => {
  const runFork = Runtime.runFork(runtime);
  return (effect, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber();
    }
    const fiber = runFork(effect, options);
    unsafeAdd(self, fiber);
    return fiber;
  };
});
/**
Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.

The returned run function will return Promise's.

@since 3.13.0
@categories combinators

## runtimePromise

Source: `my-backend/node_modules/effect/dist/cjs/FiberSet.js`

Signature: `runtimePromise(= runtimePromise;
const size = self => Effect.sync(()`

JSDoc:

@since 2.0.0
@categories combinators

## size

Source: `my-backend/node_modules/effect/dist/cjs/FiberSet.js`

Signature: `size(= size;
const join = self => Deferred.await(self.deferred)`

JSDoc:

Join all fibers in the FiberSet. If any of the Fiber's in the set terminate with a failure,
the returned Effect will terminate with the first failure that occurred.

@since 2.0.0
@categories combinators
@example
```ts
import { Effect, FiberSet } from "effect";

Effect.gen(function* (_) {
  const set = yield* _(FiberSet.make());
  yield* _(FiberSet.add(set, Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberSet.join(set));
});
```

## join

Source: `my-backend/node_modules/effect/dist/cjs/FiberSet.js`

Signature: `join(= join;
const awaitEmpty = self => Effect.whileLoop({
  while: ()`

JSDoc:

Wait until the fiber set is empty.

@since 3.13.0
@categories combinators

## isFunction

Source: `my-backend/node_modules/effect/dist/cjs/Function.js`

Signature: `isFunction(= isFunction;
const dual = function (arity, body)`

JSDoc:

Tests if a value is a `function`.

@example
```ts
import * as assert from "node:assert"
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)
assert.deepStrictEqual(isFunction("function"), false)
```

@category guards
@since 2.0.0
/
const isFunction = input => typeof input === "function";
/**
Creates a function that can be used in a data-last (aka `pipe`able) or
data-first style.

The first parameter to `dual` is either the arity of the uncurried function
or a predicate that determines if the function is being used in a data-first
or data-last style.

Using the arity is the most common use case, but there are some cases where
you may want to use a predicate. For example, if you have a function that
takes an optional argument, you can use a predicate to determine if the
function is being used in a data-first or data-last style.

You can pass either the arity of the uncurried function or a predicate
which determines if the function is being used in a data-first or
data-last style.

**Example** (Using arity to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(2, (self, that) => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using call signatures to define the overloads)

```ts
import { dual, pipe } from "effect/Function"

const sum: {
  (that: number): (self: number) => number
  (self: number, that: number): number
} = dual(2, (self: number, that: number): number => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using a predicate to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(
  (args) => args.length === 2,
  (self, that) => self + that
)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

@since 2.0.0

## dual

Source: `my-backend/node_modules/effect/dist/cjs/Function.js`

Signature: `dual(= dual;
const apply = (...a)`

JSDoc:

Apply a function to given values.

@example
```ts
import * as assert from "node:assert"
import { pipe, apply } from "effect/Function"
import { length } from "effect/String"

assert.deepStrictEqual(pipe(length, apply("hello")), 5)
```

@since 2.0.0

## apply

Source: `my-backend/node_modules/effect/dist/cjs/Function.js`

Signature: `apply(= apply;
const identity = a => a;
/**
 * A function that ensures that the type of an expression matches some type,
 * without changing the resulting type of that expression.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { satisfies } from "effect/Function"
 *
 * const test1 = satisfies<number>()`

JSDoc:

The identity function, i.e. A function that returns its input argument.

@example
```ts
import * as assert from "node:assert"
import { identity } from "effect/Function"

assert.deepStrictEqual(identity(5), 5)
```

@since 2.0.0

## satisfies

Source: `my-backend/node_modules/effect/dist/cjs/Function.js`

Signature: `satisfies(= satisfies;
const unsafeCoerce = exports.unsafeCoerce = identity;
/**
 * Creates a constant value that never changes.
 *
 * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)`

JSDoc:

Casts the result to the specified type.

@example
```ts
import * as assert from "node:assert"
import { unsafeCoerce, identity } from "effect/Function"

assert.deepStrictEqual(unsafeCoerce, identity)
```

@since 2.0.0

## constant

Source: `my-backend/node_modules/effect/dist/cjs/Function.js`

Signature: `constant(= constant;
const constTrue = exports.constTrue = /*#__PURE__*/constant(true)`

JSDoc:

A thunk that returns always `true`.

@example
```ts
import * as assert from "node:assert"
import { constTrue } from "effect/Function"

assert.deepStrictEqual(constTrue(), true)
```

@since 2.0.0

## flip

Source: `my-backend/node_modules/effect/dist/cjs/Function.js`

Signature: `flip(= flip;
const compose = exports.compose = /*#__PURE__*/dual(2, (ab, bc)`

JSDoc:

A thunk that returns always `false`.

@example
```ts
import * as assert from "node:assert"
import { constFalse } from "effect/Function"

assert.deepStrictEqual(constFalse(), false)
```

@since 2.0.0
/
const constFalse = exports.constFalse = /*#__PURE__*/constant(false);
/**
A thunk that returns always `null`.

@example
```ts
import * as assert from "node:assert"
import { constNull } from "effect/Function"

assert.deepStrictEqual(constNull(), null)
```

@since 2.0.0
/
const constNull = exports.constNull = /*#__PURE__*/constant(null);
/**
A thunk that returns always `undefined`.

@example
```ts
import * as assert from "node:assert"
import { constUndefined } from "effect/Function"

assert.deepStrictEqual(constUndefined(), undefined)
```

@since 2.0.0
/
const constUndefined = exports.constUndefined = /*#__PURE__*/constant(undefined);
/**
A thunk that returns always `void`.

@example
```ts
import * as assert from "node:assert"
import { constVoid } from "effect/Function"

assert.deepStrictEqual(constVoid(), undefined)
```

@since 2.0.0
/
const constVoid = exports.constVoid = constUndefined;
/**
Reverses the order of arguments for a curried function.

@example
```ts
import * as assert from "node:assert"
import { flip } from "effect/Function"

const f = (a: number) => (b: string) => a - b.length

assert.deepStrictEqual(flip(f)('aaa')(2), -1)
```

@since 2.0.0
/
const flip = f => (...b) => (...a) => f(...a)(...b);
/**
Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.
The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.

@example
```ts
import * as assert from "node:assert"
import { compose } from "effect/Function"

const increment = (n: number) => n + 1;
const square = (n: number) => n * n;

assert.strictEqual(compose(increment, square)(2), 9);
```

@since 2.0.0

## absurd

Source: `my-backend/node_modules/effect/dist/cjs/Function.js`

Signature: `absurd(= absurd;
const tupled = f => a => f(...a)`

JSDoc:

The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,
meaning that it should be impossible for this code to be executed.

This function is particularly useful when it's necessary to specify that certain cases are impossible.

@since 2.0.0
/
const absurd = _ => {
  throw new Error("Called `absurd` function which should be uncallable");
};
/**
Creates a   version of this function: instead of `n` arguments, it accepts a single tuple argument.

@example
```ts
import * as assert from "node:assert"
import { tupled } from "effect/Function"

const sumTupled = tupled((x: number, y: number): number => x + y)

assert.deepStrictEqual(sumTupled([1, 2]), 3)
```

@since 2.0.0

## tupled

Source: `my-backend/node_modules/effect/dist/cjs/Function.js`

Signature: `tupled(= tupled;
const untupled = f => (...a)`

JSDoc:

Inverse function of `tupled`

@example
```ts
import * as assert from "node:assert"
import { untupled } from "effect/Function"

const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])

assert.deepStrictEqual(getFirst(1, 2), 1)
```

@since 2.0.0

## hash

Source: `my-backend/node_modules/effect/dist/cjs/Hash.js`

Signature: `hash(= hash;
const random = self => {
  if (!randomHashCache.has(self)`

JSDoc:

@since 2.0.0
/

/** @internal */
const randomHashCache = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap());
/**
@since 2.0.0
@category symbols
/
const symbol = exports.symbol = /*#__PURE__*/Symbol.for("effect/Hash");
/**
@since 2.0.0
@category hashing
/
const hash = self => {
  if (_Utils.structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object":
      {
        if (self === null) {
          return string("null");
        } else if (self instanceof Date) {
          return hash(self.toISOString());
        } else if (self instanceof URL) {
          return hash(self.href);
        } else if (isHash(self)) {
          return self[symbol]();
        } else {
          return random(self);
        }
      }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
/**
@since 2.0.0
@category hashing

## random

Source: `my-backend/node_modules/effect/dist/cjs/Hash.js`

Signature: `random(= random;
const combine = b => self => self * 53 ^ b;
/**
 * @since 2.0.0
 * @category hashing
 */
exports.combine = combine;
const optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;
/**
 * @since 2.0.0
 * @category guards
 */
exports.optimize = optimize;
const isHash = u => (0, _Predicate.hasProperty)`

JSDoc:

@since 2.0.0
@category hashing

## isHash

Source: `my-backend/node_modules/effect/dist/cjs/Hash.js`

Signature: `isHash(= isHash;
const number = n => {
  if (n !== n || n === Infinity)`

JSDoc:

@since 2.0.0
@category hashing

## number

Source: `my-backend/node_modules/effect/dist/cjs/Hash.js`

Signature: `number(= number;
const string = str => {
  let h = 5381,
    i = str.length;
  while (i)`

JSDoc:

@since 2.0.0
@category hashing

## string

Source: `my-backend/node_modules/effect/dist/cjs/Hash.js`

Signature: `string(= string;
const structureKeys = (o, keys)`

JSDoc:

@since 2.0.0
@category hashing

## structureKeys

Source: `my-backend/node_modules/effect/dist/cjs/Hash.js`

Signature: `structureKeys(= structureKeys;
const structure = o => structureKeys(o, Object.keys(o)`

JSDoc:

@since 2.0.0
@category hashing

## structure

Source: `my-backend/node_modules/effect/dist/cjs/Hash.js`

Signature: `structure(= structure;
const array = arr => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++)`

JSDoc:

@since 2.0.0
@category hashing

## array

Source: `my-backend/node_modules/effect/dist/cjs/Hash.js`

Signature: `array(= array;
const cached = function ()`

JSDoc:

@since 2.0.0
@category hashing

## toValues

Source: `my-backend/node_modules/effect/dist/cjs/HashMap.js`

Signature: `toValues(= toValues;
const entries = exports.entries = HM.entries;
/**
 * Returns an `Array<[K, V]>` of the entries within the `HashMap`.
 *
 * @since 2.0.0
 * @category getters
 */
const toEntries = self => Array.from(entries(self)`

JSDoc:

@since 2.0.0
/

const TypeId = HM.HashMapTypeId;
/**
@since 2.0.0
@category refinements
/
const isHashMap = exports.isHashMap = HM.isHashMap;
/**
Creates a new `HashMap`.

@since 2.0.0
@category constructors
/
const empty = exports.empty = HM.empty;
/**
Constructs a new `HashMap` from an array of key/value pairs.

@since 2.0.0
@category constructors
/
const make = exports.make = HM.make;
/**
Creates a new `HashMap` from an iterable collection of key/value pairs.

@since 2.0.0
@category constructors
/
const fromIterable = exports.fromIterable = HM.fromIterable;
/**
Checks if the `HashMap` contains any entries.

@since 2.0.0
@category elements
/
const isEmpty = exports.isEmpty = HM.isEmpty;
/**
Safely lookup the value for the specified key in the `HashMap` using the
internal hashing function.

@since 2.0.0
@category elements
/
const get = exports.get = HM.get;
/**
Lookup the value for the specified key in the `HashMap` using a custom hash.

@since 2.0.0
@category elements
/
const getHash = exports.getHash = HM.getHash;
/**
Unsafely lookup the value for the specified key in the `HashMap` using the
internal hashing function.

@since 2.0.0
@category unsafe
/
const unsafeGet = exports.unsafeGet = HM.unsafeGet;
/**
Checks if the specified key has an entry in the `HashMap`.

@since 2.0.0
@category elements
/
const has = exports.has = HM.has;
/**
Checks if the specified key has an entry in the `HashMap` using a custom
hash.

@since 2.0.0
@category elements
/
const hasHash = exports.hasHash = HM.hasHash;
/**
Checks if an element matching the given predicate exists in the given `HashMap`.

@example
```ts
import { HashMap } from "effect"

const hm = HashMap.make([1, 'a'])
HashMap.hasBy(hm, (value, key) => value === 'a' && key === 1); // -> true
HashMap.hasBy(hm, (value) => value === 'b'); // -> false

```

@since 3.16.0
@category elements
/
const hasBy = exports.hasBy = HM.hasBy;
/**
Sets the specified key to the specified value using the internal hashing
function.

@since 2.0.0
/
const set = exports.set = HM.set;
/**
Returns an `IterableIterator` of the keys within the `HashMap`.

@since 2.0.0
@category getters
/
const keys = exports.keys = HM.keys;
/**
Returns a `HashSet` of keys within the `HashMap`.

@since 2.0.0
@category getter
/
const keySet = exports.keySet = keySet_.keySet;
/**
Returns an `IterableIterator` of the values within the `HashMap`.

@since 2.0.0
@category getters
/
const values = exports.values = HM.values;
/**
Returns an `Array` of the values within the `HashMap`.

@since 3.13.0
@category getters
/
const toValues = self => Array.from(values(self));
/**
Returns an `IterableIterator` of the entries within the `HashMap`.

@since 2.0.0
@category getters

## toEntries

Source: `my-backend/node_modules/effect/dist/cjs/HashMap.js`

Signature: `toEntries(= toEntries;
const size = exports.size = HM.size;
/**
 * Marks the `HashMap` as mutable.
 *
 * @since 2.0.0
 */
const beginMutation = exports.beginMutation = HM.beginMutation;
/**
 * Marks the `HashMap` as immutable.
 *
 * @since 2.0.0
 */
const endMutation = exports.endMutation = HM.endMutation;
/**
 * Mutates the `HashMap` within the context of the provided function.
 *
 * @since 2.0.0
 */
const mutate = exports.mutate = HM.mutate;
/**
 * Set or remove the specified key in the `HashMap` using the specified
 * update function. The value of the specified key will be computed using the
 * provided hash.
 *
 * The update function will be invoked with the current value of the key if it
 * exists, or `None` if no such value exists.
 *
 * @since 2.0.0
 */
const modifyAt = exports.modifyAt = HM.modifyAt;
/**
 * Alter the value of the specified key in the `HashMap` using the specified
 * update function. The value of the specified key will be computed using the
 * provided hash.
 *
 * The update function will be invoked with the current value of the key if it
 * exists, or `None` if no such value exists.
 *
 * This function will always either update or insert a value into the `HashMap`.
 *
 * @since 2.0.0
 */
const modifyHash = exports.modifyHash = HM.modifyHash;
/**
 * Updates the value of the specified key within the `HashMap` if it exists.
 *
 * @since 2.0.0
 */
const modify = exports.modify = HM.modify;
/**
 * Performs a union of this `HashMap` and that `HashMap`.
 *
 * @since 2.0.0
 */
const union = exports.union = HM.union;
/**
 * Remove the entry for the specified key in the `HashMap` using the internal
 * hashing function.
 *
 * @since 2.0.0
 */
const remove = exports.remove = HM.remove;
/**
 * Removes all entries in the `HashMap` which have the specified keys.
 *
 * @since 2.0.0
 */
const removeMany = exports.removeMany = HM.removeMany;
/**
 * Maps over the entries of the `HashMap` using the specified function.
 *
 * @since 2.0.0
 * @category mapping
 */
const map = exports.map = HM.map;
/**
 * Chains over the entries of the `HashMap` using the specified function.
 *
 * **NOTE**: the hash and equal of both maps have to be the same.
 *
 * @since 2.0.0
 * @category sequencing
 */
const flatMap = exports.flatMap = HM.flatMap;
/**
 * Applies the specified function to the entries of the `HashMap`.
 *
 * @since 2.0.0
 * @category traversing
 */
const forEach = exports.forEach = HM.forEach;
/**
 * Reduces the specified state over the entries of the `HashMap`.
 *
 * @since 2.0.0
 * @category folding
 */
const reduce = exports.reduce = HM.reduce;
/**
 * Filters entries out of a `HashMap` using the specified predicate.
 *
 * @since 2.0.0
 * @category filtering
 */
const filter = exports.filter = HM.filter;
/**
 * Filters out `None` values from a `HashMap` of `Options`s.
 *
 * @since 2.0.0
 * @category filtering
 */
const compact = exports.compact = HM.compact;
/**
 * Maps over the entries of the `HashMap` using the specified partial function
 * and filters out `None` values.
 *
 * @since 2.0.0
 * @category filtering
 */
const filterMap = exports.filterMap = HM.filterMap;
/**
 * Returns the first element that satisfies the specified
 * predicate, or `None` if no such element exists.
 *
 * @category elements
 * @since 2.0.0
 */
const findFirst = exports.findFirst = HM.findFirst;
/**
 * Checks if any entry in a hashmap meets a specific condition.
 *
 * @since 3.13.0
 * @category elements
 */
const some = exports.some = HM.some;
/**
 * Checks if all entries in a hashmap meets a specific condition.
 *
 * @param self - The hashmap to check.
 * @param predicate - The condition to test entries (value, key)`

JSDoc:

Returns the number of entries within the `HashMap`.

@since 2.0.0
@category getters

## toValues

Source: `my-backend/node_modules/effect/dist/cjs/HashSet.js`

Signature: `toValues(= toValues;
const size = exports.size = HS.size;
/**
 * Creates a new mutable version of the `HashSet`
 *
 * When a `HashSet` is mutable, operations like {@link add} and {@link remove}
 * modify the data structure in place instead of creating a new one, which is
 * more efficient when performing multiple operations.
 *
 * @memberof HashSet
 * @since 2.0.0
 * @example
 *
 * ```ts
 * import { HashSet } from "effect"
 * import assert from "node:assert/strict"
 *
 * const UPPER_BOUND = 10_000
 *
 * const immutableSet = HashSet.empty<number>()`

JSDoc:

# HashSet

An immutable `HashSet` provides a collection of unique values with efficient
lookup, insertion and removal. Once created, a `HashSet` cannot be modified;
any operation that would alter the set instead returns a new `HashSet` with
the changes. This immutability offers benefits like predictable state
management and easier reasoning about your code.

## What Problem Does It Solve?

`HashSet` solves the problem of maintaining an unsorted collection where each
value appears exactly once, with fast operations for checking membership and
adding/removing values.

## When to Use

Use `HashSet` when you need:

- A collection with no duplicate values
- Efficient membership testing (**`O(1)`** average complexity)
- Set operations like union, intersection, and difference
- An immutable data structure that preserves functional programming patterns

## Advanced Features

HashSet provides operations for:

- Transforming sets with map and flatMap
- Filtering elements with filter
- Combining sets with union, intersection and difference
- Performance optimizations via mutable operations in controlled contexts

## Performance Characteristics

- **Lookup** operations ({@link module:HashSet.has}): **`O(1)`** average time
  complexity
- **Insertion** operations ({@link module:HashSet.add}): **`O(1)`** average time
  complexity
- **Removal** operations ({@link module:HashSet.remove}): **`O(1)`** average
  time complexity
- **Set** operations ({@link module:HashSet.union},
  {@link module:HashSet.intersection}): **`O(n)`** where n is the size of the
  smaller set
- **Iteration**: **`O(n)`** where n is the size of the set

The HashSet data structure implements the following traits:

- {@link Iterable}: allows iterating over the values in the set
- {@link Equal}: allows comparing two sets for value-based equality
- {@link Pipeable}: allows chaining operations with the pipe operator
- {@link Inspectable}: allows inspecting the contents of the set

## Operations Reference

| Category     | Operation                           | Description                                 | Complexity |
| ------------ | ----------------------------------- | ------------------------------------------- | ---------- |
| constructors | {@link module:HashSet.empty}        | Creates an empty HashSet                    | O(1)       |
| constructors | {@link module:HashSet.fromIterable} | Creates a HashSet from an iterable          | O(n)       |
| constructors | {@link module:HashSet.make}         | Creates a HashSet from multiple values      | O(n)       |
|              |                                     |                                             |            |
| elements     | {@link module:HashSet.has}          | Checks if a value exists in the set         | O(1) avg   |
| elements     | {@link module:HashSet.some}         | Checks if any element satisfies a predicate | O(n)       |
| elements     | {@link module:HashSet.every}        | Checks if all elements satisfy a predicate  | O(n)       |
| elements     | {@link module:HashSet.isSubset}     | Checks if a set is a subset of another      | O(n)       |
|              |                                     |                                             |            |
| getters      | {@link module:HashSet.values}       | Gets an iterator of all values              | O(1)       |
| getters      | {@link module:HashSet.toValues}     | Gets an array of all values                 | O(n)       |
| getters      | {@link module:HashSet.size}         | Gets the number of elements                 | O(1)       |
|              |                                     |                                             |            |
| mutations    | {@link module:HashSet.add}          | Adds a value to the set                     | O(1) avg   |
| mutations    | {@link module:HashSet.remove}       | Removes a value from the set                | O(1) avg   |
| mutations    | {@link module:HashSet.toggle}       | Toggles a value's presence                  | O(1) avg   |
|              |                                     |                                             |            |
| operations   | {@link module:HashSet.difference}   | Computes set difference (A - B)             | O(n)       |
| operations   | {@link module:HashSet.intersection} | Computes set intersection (A  B)           | O(n)       |
| operations   | {@link module:HashSet.union}        | Computes set union (A  B)                  | O(n)       |
|              |                                     |                                             |            |
| mapping      | {@link module:HashSet.map}          | Transforms each element                     | O(n)       |
|              |                                     |                                             |            |
| sequencing   | {@link module:HashSet.flatMap}      | Transforms and flattens elements            | O(n)       |
|              |                                     |                                             |            |
| traversing   | {@link module:HashSet.forEach}      | Applies a function to each element          | O(n)       |
|              |                                     |                                             |            |
| folding      | {@link module:HashSet.reduce}       | Reduces the set to a single value           | O(n)       |
|              |                                     |                                             |            |
| filtering    | {@link module:HashSet.filter}       | Keeps elements that satisfy a predicate     | O(n)       |
|              |                                     |                                             |            |
| partitioning | {@link module:HashSet.partition}    | Splits into two sets by a predicate         | O(n)       |

## Notes

### Composability with the Effect Ecosystem:

This `HashSet` is designed to work seamlessly within the Effect ecosystem. It
implements the {@link Iterable}, {@link Equal}, {@link Pipeable}, and
{@link Inspectable} traits from Effect. This ensures compatibility with other
Effect data structures and functionalities. For example, you can easily use
Effect's `pipe` method to chain operations on the `HashSet`.

**Equality of Elements with Effect's {@link Equal `Equal`} Trait:**

This `HashSet` relies on Effect's {@link Equal} trait to determine the
uniqueness of elements within the set. The way equality is checked depends on
the type of the elements:

- **Primitive Values:** For primitive JavaScript values like strings, numbers,
  booleans, `null`, and `undefined`, equality is determined by their value
  (similar to the `===` operator).
- **Objects and Custom Types:** For objects and other custom types, equality is
  determined by whether those types implement the {@link Equal} interface
  themselves. If an element type implements `Equal`, the `HashSet` will
  delegate to that implementation to perform the equality check. This allows
  you to define custom logic for determining when two instances of your
  objects should be considered equal based on their properties, rather than
  just their object identity.

```ts
import { Equal, Hash, HashSet } from "effect"

class Person implements Equal.Equal {
  constructor(
    readonly id: number, // Unique identifier
    readonly name: string,
    readonly age: number
  ) {}

  // Define equality based on id, name, and age
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Person) {
      return (
        Equal.equals(this.id, that.id) &&
        Equal.equals(this.name, that.name) &&
        Equal.equals(this.age, that.age)
      )
    }
    return false
  }

  // Generate a hash code based on the unique id
  [Hash.symbol](): number {
    return Hash.hash(this.id)
  }
}

// Creating a HashSet with objects that implement the Equal interface
const set = HashSet.empty().pipe(
  HashSet.add(new Person(1, "Alice", 30)),
  HashSet.add(new Person(1, "Alice", 30))
)

// HashSet recognizes them as equal, so only one element is stored
console.log(HashSet.size(set))
// Output: 1
```

**Simplifying Equality and Hashing with `Data` and `Schema`:**

Effect's {@link Data} and {@link Schema `Schema.Data`} modules offer powerful
ways to automatically handle the implementation of both the {@link Equal} and
{@link Hash} traits for your custom data structures.

- **`Data` Module:** By using constructors like `Data.struct`, `Data.tuple`,
  `Data.array`, or `Data.case` to define your data types, Effect
  automatically generates the necessary implementations for value-based
  equality and consistent hashing. This significantly reduces boilerplate and
  ensures correctness.

```ts
import { HashSet, Data, Equal } from "effect"
import assert from "node:assert/strict"

// Data.* implements the `Equal` traits for us
const person1 = Data.struct({ id: 1, name: "Alice", age: 30 })
const person2 = Data.struct({ id: 1, name: "Alice", age: 30 })

assert(Equal.equals(person1, person2))

const set = HashSet.empty().pipe(
  HashSet.add(person1),
  HashSet.add(person2)
)

// HashSet recognizes them as equal, so only one element is stored
console.log(HashSet.size(set)) // Output: 1
```

- **`Schema` Module:** When defining data schemas using the {@link Schema}
  module, you can use `Schema.Data` to automatically include the `Equal` and
  `Hash` traits in the decoded objects. This is particularly important when
  working with `HashSet`. **For decoded objects to be correctly recognized as
  equal within a `HashSet`, ensure that the schema for those objects is
  defined using `Schema.Data`.**

```ts
import { Equal, HashSet, Schema } from "effect"
import assert from "node:assert/strict"

// Schema.Data implements the `Equal` traits for us
const PersonSchema = Schema.Data(
  Schema.Struct({
    id: Schema.Number,
    name: Schema.String,
    age: Schema.Number
  })
)

const Person = Schema.decode(PersonSchema)

const person1 = Person({ id: 1, name: "Alice", age: 30 })
const person2 = Person({ id: 1, name: "Alice", age: 30 })

assert(Equal.equals(person1, person2)) // Output: true

const set = HashSet.empty().pipe(
  HashSet.add(person1),
  HashSet.add(person2)
)

// HashSet thanks to Schema.Data implementation of the `Equal` trait, recognizes the two Person as equal, so only one element is stored
console.log(HashSet.size(set)) // Output: 1
```

### Interoperability with the JavaScript Runtime:

To interoperate with the regular JavaScript runtime, Effect's `HashSet`
provides methods to access its elements in formats readily usable by
JavaScript APIs: {@link values `HashSet.values`},
{@link toValues `HashSet.toValues`}

```ts
import { HashSet } from "effect"

const hashSet: HashSet.HashSet<number> = HashSet.make(1, 2, 3)

// Using HashSet.values to convert HashSet.HashSet<A> to IterableIterator<A>
const iterable: IterableIterator<number> = HashSet.values(hashSet)

console.log(...iterable) // Logs:  1 2 3

// Using HashSet.toValues to convert HashSet.HashSet<A> to Array<A>
const array: Array<number> = HashSet.toValues(hashSet)

console.log(array) // Logs: [ 1, 2, 3 ]
```

Be mindful of performance implications (both time and space complexity) when
frequently converting between Effect's immutable HashSet and mutable
JavaScript data structures, especially for large collections.

@module HashSet
@since 2.0.0
/

const TypeId = HS.HashSetTypeId;
/**
@memberof HashSet
@since 2.0.0
@category refinements
/
const isHashSet = exports.isHashSet = HS.isHashSet;
/**
Creates an empty `HashSet`.

Time complexity: **`O(1)`**

@memberof HashSet
@since 2.0.0
@category constructors
@example

```ts
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    // Provide a type argument to create a HashSet of a specific type
    HashSet.empty<number>(),
    HashSet.add(1),
    HashSet.add(1), // Notice the duplicate
    HashSet.add(2),
    HashSet.toValues
  )
) // Output: [1, 2]
```

@see Other `HashSet` constructors are {@link module:HashSet.make} {@link module:HashSet.fromIterable}
/
const empty = exports.empty = HS.empty;
/**
Creates a new `HashSet` from an iterable collection of values.

Time complexity: **`O(n)`** where n is the number of elements in the iterable

@memberof HashSet
@since 2.0.0
@category constructors
@example

```ts
// Creating a HashSet from an Array
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.
    HashSet.fromIterable,
    HashSet.toValues
  )
) // Output: [1, 2, 3, 4, 5]
```

@example

```ts
// Creating a HashSet from a Set
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    new Set(["apple", "banana", "orange", "apple"]), // Set<string> is an Iterable<string>
    HashSet.fromIterable,
    HashSet.toValues
  )
) // Output: ["apple", "banana", "orange"]
```

@example

```ts
// Creating a HashSet from a Generator
import { HashSet } from "effect"

// Generator functions return iterables
function* fibonacci(n: number): Generator<number, void, unknown> {
  let [a, b] = [0, 1]
  for (let i = 0; i < n; i++) {
    yield a
    ;[a, b] = [b, a + b]
  }
}

// Create a HashSet from the first 10 Fibonacci numbers
const fibonacciSet = HashSet.fromIterable(fibonacci(10))

console.log(HashSet.toValues(fibonacciSet))
// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order
```

@example

```ts
//  Creating a HashSet from another HashSet
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    // since HashSet implements the Iterable interface, we can use it to create a new HashSet
    HashSet.make(1, 2, 3, 4),
    HashSet.fromIterable,
    HashSet.toValues // turns the HashSet back into an array
  )
) // Output: [1, 2, 3, 4]
```

@example

```ts
// Creating a HashSet from other Effect's data structures like Chunk
import { Chunk, HashSet, pipe } from "effect"

console.log(
  pipe(
    Chunk.make(1, 2, 3, 4), // Iterable<number>
    HashSet.fromIterable,
    HashSet.toValues // turns the HashSet back into an array
  )
) // Outputs: [1, 2, 3, 4]
```

@see Other `HashSet` constructors are {@link module:HashSet.empty} {@link module:HashSet.make}
/
const fromIterable = exports.fromIterable = HS.fromIterable;
/**
Construct a new `HashSet` from a variable number of values.

Time complexity: **`O(n)`** where n is the number of elements

@memberof HashSet
@since 2.0.0
@category constructors
@example

```ts
import { Equal, Hash, HashSet, pipe } from "effect"
import assert from "node:assert/strict"

class Character implements Equal.Equal {
  readonly name: string
  readonly trait: string

  constructor(name: string, trait: string) {
    this.name = name
    this.trait = trait
  }

  // Define equality based on name, and trait
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Character) {
      return (
        Equal.equals(this.name, that.name) &&
        Equal.equals(this.trait, that.trait)
      )
    }
    return false
  }

  // Generate a hash code based on the sum of the character's name and trait
  [Hash.symbol](): number {
    return Hash.hash(this.name + this.trait)
  }

  static readonly of = (name: string, trait: string): Character => {
    return new Character(name, trait)
  }
}

assert.strictEqual(
  Equal.equals(
    HashSet.make(
      Character.of("Alice", "Curious"),
      Character.of("Alice", "Curious"),
      Character.of("White Rabbit", "Always late"),
      Character.of("Mad Hatter", "Tea enthusiast")
    ),
    // Is the same as adding each character to an empty set
    pipe(
      HashSet.empty(),
      HashSet.add(Character.of("Alice", "Curious")),
      HashSet.add(Character.of("Alice", "Curious")), // Alice tried to attend twice!
      HashSet.add(Character.of("White Rabbit", "Always late")),
      HashSet.add(Character.of("Mad Hatter", "Tea enthusiast"))
    )
  ),
  true,
  "`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal"
)

assert.strictEqual(
  Equal.equals(
    HashSet.make(
      Character.of("Alice", "Curious"),
      Character.of("Alice", "Curious"),
      Character.of("White Rabbit", "Always late"),
      Character.of("Mad Hatter", "Tea enthusiast")
    ),
    HashSet.fromIterable([
      Character.of("Alice", "Curious"),
      Character.of("Alice", "Curious"),
      Character.of("White Rabbit", "Always late"),
      Character.of("Mad Hatter", "Tea enthusiast")
    ])
  ),
  true,
  "`HashSet.make` and `HashSet.fromIterable` should be equal"
)
```

@see Other `HashSet` constructors are {@link module:HashSet.fromIterable} {@link module:HashSet.empty}
/
const make = exports.make = HS.make;
/**
Checks if the specified value exists in the `HashSet`.

Time complexity: **`O(1)`** average

@memberof HashSet
@since 2.0.0
@category elements
@example

```ts
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false

// or piped with the pipe function
HashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false

// or with `data-first` API
HashSet.has(HashSet.make(0, 1, 2), 3) // false
```

@returns A `boolean` signaling the presence of the value in the HashSet
@see Other `HashSet` elements are {@link module:HashSet.some} {@link module:HashSet.every} {@link module:HashSet.isSubset}
/
const has = exports.has = HS.has;
/**
Check if a predicate holds true for some `HashSet` element.

Time complexity: **`O(n)`** where n is the number of elements in the set

@memberof HashSet
@since 2.0.0
@category elements
@example

```ts
// Syntax
import { HashSet, pipe } from "effect"

const set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)

// with `data-last`, a.k.a. `pipeable` API
pipe(
  set,
  HashSet.some((n) => n > 0)
) // true

// or piped with the pipe function
set.pipe(HashSet.some((n) => n > 0)) // true

// or with `data-first` API
HashSet.some(set, (n) => n > 0) // true
```

@see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.every} {@link module:HashSet.isSubset}
/
const some = exports.some = HS.some;
/**
Check if a predicate holds true for every `HashSet` element.

Time complexity is **`O(n)`** as it needs to traverse the whole HashSet
collection

@memberof HashSet
@since 2.0.0
@category elements
@example

```ts
// Syntax with Refinement
import { HashSet, pipe, Predicate } from "effect"

const numberOrString = HashSet.make(1, "1", "one", "uno")

// with `data-last`, a.k.a. `pipeable` API and `Refinement`
pipe(
  numberOrString, // HashSet.HashSet<number | string>
  HashSet.every(Predicate.isString)
) // HashSet.HashSet<string>

// or piped with the pipe function and  `Refinement`
numberOrString // HashSet.HashSet<number | string>
  .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>

// or with `data-first` API and `Refinement`
HashSet.every(
  numberOrString, // HashSet.HashSet<number | string>
  Predicate.isString
) // HashSet.HashSet<string>
```

@example

```ts
// Syntax with Predicate
import { HashSet, pipe } from "effect"

const set = HashSet.make(1, 2, 3)

// with `data-last`, a.k.a. `pipeable` API
pipe(
  set,
  HashSet.every((n) => n >= 0)
) // true

// or piped with the pipe function
set.pipe(HashSet.every((n) => n >= 0)) // true

// or with `data-first` API
HashSet.every(set, (n) => n >= 0) // true
```

@returns A boolean once it has evaluated that whole collection fulfill the
  Predicate function
@see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.isSubset}
/
const every = exports.every = HS.every;
/**
Returns `true` if and only if every element in the this `HashSet` is an
element of the second set,

**NOTE**: the hash and equal of both sets must be the same.

Time complexity analysis is of **`O(n)`**

@memberof HashSet
@since 2.0.0
@category elements
@example

```ts
// Syntax
import { HashSet, pipe } from "effect"

const set1 = HashSet.make(0, 1)
const set2 = HashSet.make(1, 2)
const set3 = HashSet.make(0, 1, 2)

// with `data-last`, a.k.a. `pipeable` API
pipe(set1, HashSet.isSubset(set2)) // false
pipe(set1, HashSet.isSubset(set3)) // true

// or piped with the pipe function
set1.pipe(HashSet.isSubset(set2)) // false
set1.pipe(HashSet.isSubset(set3)) // true

// or with `data-first` API
HashSet.isSubset(set1, set2) // false
HashSet.isSubset(set1, set3) // true)
```

@see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.every}
/
const isSubset = exports.isSubset = HS.isSubset;
/**
Returns an `IterableIterator` of the values in the `HashSet`.

Time complexity: **`O(1)`**

@memberof HashSet
@since 2.0.0
@category getters
@example

```ts
import { HashSet, pipe } from "effect"

const numberIterable = pipe(
  HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>
  HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>
)

for (const number of numberIterable) {
  console.log(number) // it will logs: 0, 1, 2
}
```

@see Other `HashSet` getters are {@link module:HashSet.toValues} {@link module:HashSet.size}
/
const values = exports.values = HS.values;
/**
Returns an `Array` of the values within the `HashSet`.

Time complexity: **`O(n)`** where n is the number of elements in the set

@memberof HashSet
@since 3.13.0
@category getters
@example

```ts
import { HashSet, pipe } from "effect"
import { deepStrictEqual } from "node:assert/strict"

deepStrictEqual(
  pipe(
    HashSet.make(0, 1, 1, 2), // HashSet<number>
    HashSet.toValues // takes an HashSet<A> and returns an Array<A>
  ),
  Array.of(0, 1, 2)
)
```

@see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.size}
/
const toValues = self => Array.from(values(self));
/**
Calculates the number of values in the `HashSet`.

Time complexity: **`O(1)`**

@memberof HashSet
@since 2.0.0
@category getters
@example

```ts
import { HashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)

assert.deepStrictEqual(
  pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),
  4
)
```

@see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.toValues}

## toJSON

Source: `my-backend/node_modules/effect/dist/cjs/Inspectable.js`

Signature: `toJSON(= toJSON;
const format = x => JSON.stringify(x, null, 2)`

JSDoc:

@since 2.0.0
@category symbols
/
const NodeInspectSymbol = exports.NodeInspectSymbol = /*#__PURE__*/Symbol.for("nodejs.util.inspect.custom");
/**
@since 2.0.0
/
const toJSON = x => {
  try {
    if ((0, _Predicate.hasProperty)(x, "toJSON") && (0, _Predicate.isFunction)(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
/**
@since 2.0.0

## format

Source: `my-backend/node_modules/effect/dist/cjs/Inspectable.js`

Signature: `format(= format;
const BaseProto = exports.BaseProto = {
  toJSON()`

JSDoc:

@since 2.0.0

## Class

Source: `my-backend/node_modules/effect/dist/cjs/Inspectable.js`

Signature: `Class(= Class;
const toStringUnknown = (u, whitespace = 2)`

JSDoc:

@since 2.0.0
/
class Class {
  /**
@since 2.0.0
/
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
@since 2.0.0
/
  toString() {
    return format(this.toJSON());
  }
}
/**
@since 2.0.0

## toStringUnknown

Source: `my-backend/node_modules/effect/dist/cjs/Inspectable.js`

Signature: `toStringUnknown(= toStringUnknown;
const stringifyCircular = (obj, whitespace)`

JSDoc:

@since 2.0.0

## stringifyCircular

Source: `my-backend/node_modules/effect/dist/cjs/Inspectable.js`

Signature: `stringifyCircular(= stringifyCircular;
const symbolRedactable = exports.symbolRedactable = /*#__PURE__*/Symbol.for("effect/Inspectable/Redactable")`

JSDoc:

@since 3.10.0
@category redactable

## withRedactableContext

Source: `my-backend/node_modules/effect/dist/cjs/Inspectable.js`

Signature: `withRedactableContext(= withRedactableContext;
const redact = u => {
  if (isRedactable(u)`

JSDoc:

@since 3.10.0
@category redactable
/
const isRedactable = u => typeof u === "object" && u !== null && symbolRedactable in u;
exports.isRedactable = isRedactable;
const redactableState = /*#__PURE__*/(0, _GlobalValue.globalValue)("effect/Inspectable/redactableState", () => ({
  fiberRefs: undefined
}));
/**
@since 3.10.0
@category redactable
/
const withRedactableContext = (context, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
/**
@since 3.10.0
@category redactable

## makeBy

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `makeBy(= makeBy;
const range = (start, end)`

JSDoc:

This module provides utility functions for working with Iterables in TypeScript.

@since 2.0.0
/

/**
Return a `Iterable` with element `i` initialized with `f(i)`.

If the `length` is not specified, the `Iterable` will be infinite.

**Note**. `length` is normalized to an integer >= 1.

@example
```ts
import * as assert from "node:assert"
import { makeBy } from "effect/Iterable"

assert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])
```

@category constructors
@since 2.0.0
/
const makeBy = (f, options) => {
  const max = options?.length !== undefined ? Math.max(1, Math.floor(options.length)) : Infinity;
  return {
    [Symbol.iterator]() {
      let i = 0;
      return {
        next() {
          if (i < max) {
            return {
              value: f(i++),
              done: false
            };
          }
          return {
            done: true,
            value: undefined
          };
        }
      };
    }
  };
};
/**
Return a `Iterable` containing a range of integers, including both endpoints.

If `end` is omitted, the range will not have an upper bound.

@example
```ts
import * as assert from "node:assert"
import { range } from "effect/Iterable"

assert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])
```

@category constructors
@since 2.0.0

## range

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `range(= range;
const replicate = exports.replicate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Return a `Iterable` containing a value repeated the specified number of times.

**Note**. `n` is normalized to an integer >= 1.

@example
```ts
import * as assert from "node:assert"
import { replicate } from "effect/Iterable"

assert.deepStrictEqual(Array.from(replicate("a", 3)), ["a", "a", "a"])
```

@category constructors
@since 2.0.0

## fromRecord

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `fromRecord(= fromRecord;
const prepend = exports.prepend = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Takes a record and returns an Iterable of tuples containing its keys and values.

@example
```ts
import * as assert from "node:assert"
import { fromRecord } from "effect/Iterable"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(Array.from(fromRecord(x)), [["a", 1], ["b", 2], ["c", 3]])
```

@category conversions
@since 2.0.0
/
const fromRecord = self => ({
[Symbol.iterator]() {
    for (const key in self) {
      if (Object.prototype.hasOwnProperty.call(self, key)) {
        yield [key, self[key]];
      }
    }
  }
});
/**
Prepend an element to the front of an `Iterable`, creating a new `Iterable`.

@category concatenating
@since 2.0.0

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `isEmpty(= isEmpty;
const size = self => {
  const iterator = self[Symbol.iterator]()`

JSDoc:

Prepends the specified prefix iterable to the beginning of the specified iterable.

@example
```ts
import * as assert from "node:assert"
import { Iterable } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.prependAll([1, 2], ["a", "b"])),
  ["a", "b", 1, 2]
)
```

@category concatenating
@since 2.0.0
/
const prependAll = exports.prependAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => appendAll(that, self));
/**
Append an element to the end of an `Iterable`, creating a new `Iterable`.

@category concatenating
@since 2.0.0
/
const append = exports.append = /*#__PURE__*/(0, _Function.dual)(2, (self, last) => appendAll(self, [last]));
/**
Concatenates two iterables, combining their elements.

@category concatenating
@since 2.0.0
/
const appendAll = exports.appendAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => ({
  [Symbol.iterator]() {
    const iterA = self[Symbol.iterator]();
    let doneA = false;
    let iterB;
    return {
      next() {
        if (!doneA) {
          const r = iterA.next();
          if (r.done) {
            doneA = true;
            iterB = that[Symbol.iterator]();
            return iterB.next();
          }
          return r;
        }
        return iterB.next();
      }
    };
  }
}));
/**
Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.

@category folding
@since 2.0.0
/
const scan = exports.scan = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => ({
  [Symbol.iterator]() {
    let acc = b;
    let iterator;
    function next() {
      if (iterator === undefined) {
        iterator = self[Symbol.iterator]();
        return {
          done: false,
          value: acc
        };
      }
      const result = iterator.next();
      if (result.done) {
        return result;
      }
      acc = f(acc, result.value);
      return {
        done: false,
        value: acc
      };
    }
    return {
      next
    };
  }
}));
/**
Determine if an `Iterable` is empty

@example
```ts
import * as assert from "node:assert"
import { isEmpty } from "effect/Iterable"

assert.deepStrictEqual(isEmpty([]), true);
assert.deepStrictEqual(isEmpty([1, 2, 3]), false);
```

@category guards
@since 2.0.0
/
const isEmpty = self => {
  const iterator = self[Symbol.iterator]();
  return iterator.next().done === true;
};
/**
Return the number of elements in a `Iterable`.

@category getters
@since 2.0.0

## size

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `size(= size;
const head = self => {
  const iterator = self[Symbol.iterator]()`

JSDoc:

Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.

@category getters
@since 2.0.0

## head

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `head(= head;
const unsafeHead = self => {
  const iterator = self[Symbol.iterator]()`

JSDoc:

Get the first element of a `Iterable`, or throw an error if the `Iterable` is empty.

@category getters
@since 3.3.0

## unsafeHead

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `unsafeHead(= unsafeHead;
const take = exports.take = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.

**Note**. `n` is normalized to a non negative integer.

@category getters
@since 2.0.0

## empty

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `empty(= empty;
const of = a => [a];
/**
 * @category mapping
 * @since 2.0.0
 */
exports.of = of;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.

@category getters
@since 2.0.0
/
const takeWhile = exports.takeWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done || !predicate(result.value, i++)) {
          return {
            done: true,
            value: undefined
          };
        }
        return result;
      }
    };
  }
}));
/**
Drop a max number of elements from the start of an `Iterable`

**Note**. `n` is normalized to a non negative integer.

@category getters
@since 2.0.0
/
const drop = exports.drop = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        while (i < n) {
          const result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: undefined
            };
          }
          i++;
        }
        return iterator.next();
      }
    };
  }
}));
/**
Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

@category elements
@since 2.0.0
/
const findFirst = exports.findFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if ((0, _Predicate.isBoolean)(o)) {
      if (o) {
        return O.some(a);
      }
    } else {
      if (O.isSome(o)) {
        return o;
      }
    }
    i++;
  }
  return O.none();
});
/**
Find the last element for which a predicate holds.

@category elements
@since 2.0.0
/
const findLast = exports.findLast = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  let i = 0;
  let last = O.none();
  for (const a of self) {
    const o = f(a, i);
    if ((0, _Predicate.isBoolean)(o)) {
      if (o) {
        last = O.some(a);
      }
    } else {
      if (O.isSome(o)) {
        last = o;
      }
    }
    i++;
  }
  return last;
});
/**
Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.

@category zipping
@since 2.0.0
/
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(self, that, Tuple.make));
/**
Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one
input `Iterable` is short, excess elements of the longer `Iterable` are discarded.

@category zipping
@since 2.0.0
/
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => ({
  [Symbol.iterator]() {
    const selfIterator = self[Symbol.iterator]();
    const thatIterator = that[Symbol.iterator]();
    return {
      next() {
        const selfResult = selfIterator.next();
        const thatResult = thatIterator.next();
        if (selfResult.done || thatResult.done) {
          return {
            done: true,
            value: undefined
          };
        }
        return {
          done: false,
          value: f(selfResult.value, thatResult.value)
        };
      }
    };
  }
}));
/**
Places an element in between members of an `Iterable`.
If the input is a non-empty array, the result is also a non-empty array.

@since 2.0.0
/
const intersperse = exports.intersperse = /*#__PURE__*/(0, _Function.dual)(2, (self, middle) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let next = iterator.next();
    let emitted = false;
    return {
      next() {
        if (next.done) {
          return next;
        } else if (emitted) {
          emitted = false;
          return {
            done: false,
            value: middle
          };
        }
        emitted = true;
        const result = next;
        next = iterator.next();
        return result;
      }
    };
  }
}));
/**
Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.

@category elements
@since 2.0.0
/
const containsWith = isEquivalent => (0, _Function.dual)(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
exports.containsWith = containsWith;
const _equivalence = /*#__PURE__*/Equal.equivalence();
/**
Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.

@category elements
@since 2.0.0
/
const contains = exports.contains = /*#__PURE__*/containsWith(_equivalence);
/**
Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
the `Iterable`.

@category splitting
@since 2.0.0
/
const chunksOf = exports.chunksOf = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const safeN = Math.max(1, Math.floor(n));
  return {
    [Symbol.iterator]() {
      let iterator = self[Symbol.iterator]();
      return {
        next() {
          if (iterator === undefined) {
            return {
              done: true,
              value: undefined
            };
          }
          const chunk = [];
          for (let i = 0; i < safeN; i++) {
            const result = iterator.next();
            if (result.done) {
              iterator = undefined;
              return chunk.length === 0 ? {
                done: true,
                value: undefined
              } : {
                done: false,
                value: chunk
              };
            }
            chunk.push(result.value);
          }
          return {
            done: false,
            value: chunk
          };
        }
      };
    }
  };
});
/**
Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.

@category grouping
@since 2.0.0
/
const groupWith = exports.groupWith = /*#__PURE__*/(0, _Function.dual)(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let nextResult;
    return {
      next() {
        let result;
        if (nextResult !== undefined) {
          if (nextResult.done) {
            return {
              done: true,
              value: undefined
            };
          }
          result = nextResult;
          nextResult = undefined;
        } else {
          result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: undefined
            };
          }
        }
        const chunk = [result.value];
        while (true) {
          const next = iterator.next();
          if (next.done || !isEquivalent(result.value, next.value)) {
            nextResult = next;
            return {
              done: false,
              value: chunk
            };
          }
          chunk.push(next.value);
        }
      }
    };
  }
}));
/**
Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.

@category grouping
@since 2.0.0
/
const group = exports.group = /*#__PURE__*/groupWith(/*#__PURE__*/Equal.equivalence());
/**
Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
function on each element, and grouping the results according to values returned

@category grouping
@since 2.0.0
/
const groupBy = exports.groupBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const out = {};
  for (const a of self) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
const constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
const constEmptyIterator = {
  next() {
    return {
      done: true,
      value: undefined
    };
  }
};
/**
@category constructors
@since 2.0.0
/
const empty = () => constEmpty;
/**
Constructs a new `Iterable<A>` from the specified value.

@category constructors
@since 2.0.0

## flatten

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `flatten(= flatten;
const filterMap = exports.filterMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.

@category sequencing
@since 2.0.0
/
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flatten(map(self, f)));
/**
Flattens an Iterable of Iterables into a single Iterable

@category sequencing
@since 2.0.0
/
const flatten = self => ({
  [Symbol.iterator]() {
    const outerIterator = self[Symbol.iterator]();
    let innerIterator;
    function next() {
      if (innerIterator === undefined) {
        const next = outerIterator.next();
        if (next.done) {
          return next;
        }
        innerIterator = next.value[Symbol.iterator]();
      }
      const result = innerIterator.next();
      if (result.done) {
        innerIterator = undefined;
        return next();
      }
      return result;
    }
    return {
      next
    };
  }
});
/**
@category filtering
@since 2.0.0

## getLefts

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `getLefts(= getLefts;
const getRights = self => filterMap(self, E.getRight)`

JSDoc:

Transforms all elements of the `Iterable` for as long as the specified function returns some value

@category filtering
@since 2.0.0
/
const filterMapWhile = exports.filterMapWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: undefined
          };
        }
        const b = f(result.value, i++);
        if (O.isSome(b)) {
          return {
            done: false,
            value: b.value
          };
        }
        return {
          done: true,
          value: undefined
        };
      }
    };
  }
}));
/**
Retrieves the `Some` values from an `Iterable` of `Option`s.

@example
```ts
import * as assert from "node:assert"
import { Iterable, Option } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])),
  [1, 2]
)
```

@category filtering
@since 2.0.0
/
const getSomes = exports.getSomes = /*#__PURE__*/filterMap(_Function.identity);
/**
Retrieves the `Left` values from an `Iterable` of `Either`s.

@example
```ts
import * as assert from "node:assert"
import { Iterable, Either } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getLefts([Either.right(1), Either.left("err"), Either.right(2)])),
  ["err"]
)
```

@category filtering
@since 2.0.0
/
const getLefts = self => filterMap(self, E.getLeft);
/**
Retrieves the `Right` values from an `Iterable` of `Either`s.

@example
```ts
import * as assert from "node:assert"
import { Iterable, Either } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getRights([Either.right(1), Either.left("err"), Either.right(2)])),
  [1, 2]
)
```

@category filtering
@since 2.0.0

## getRights

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `getRights(= getRights;
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category filtering
@since 2.0.0

## unfold

Source: `my-backend/node_modules/effect/dist/cjs/Iterable.js`

Signature: `unfold(= unfold;
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category sequencing
@since 2.0.0
/
const flatMapNullable = exports.flatMapNullable = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => filterMap(self, a => {
  const b = f(a);
  return b == null ? O.none() : O.some(b);
}));
/**
Check if a predicate holds true for some `Iterable` element.

@category elements
@since 2.0.0
/
const some = exports.some = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i++)) {
      return true;
    }
  }
  return false;
});
/**
@category constructors
@since 2.0.0
/
const unfold = (b, f) => ({
  [Symbol.iterator]() {
    let next = b;
    return {
      next() {
        const o = f(next);
        if (O.isNone(o)) {
          return {
            done: true,
            value: undefined
          };
        }
        const [a, b] = o.value;
        next = b;
        return {
          done: false,
          value: a
        };
      }
    };
  }
});
/**
Iterate over the `Iterable` applying `f`.

@since 2.0.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/JSONSchema.js`

Signature: `make(= make;
const fromAST = (ast, options)`

JSDoc:

@since 3.10.0
/

/**
@category encoding
@since 3.10.0
/
const make = schema => {
  const definitions = {};
  const ast = AST.isTransformation(schema.ast) && isParseJsonTransformation(schema.ast.from)
  // Special case top level `parseJson` transformations
  ? schema.ast.to : schema.ast;
  const jsonSchema = fromAST(ast, {
    definitions
  });
  const out = {
    $schema,
    $defs: {},
    ...jsonSchema
  };
  if (Record.isEmptyRecord(definitions)) {
    delete out.$defs;
  } else {
    out.$defs = definitions;
  }
  return out;
};
/**
Returns a JSON Schema with additional options and definitions.

**Warning**

This function is experimental and subject to change.

**Options**

- `definitions`: A record of definitions that are included in the schema.
- `definitionPath`: The path to the definitions within the schema (defaults
  to "#/$defs/").
- `target`: Which spec to target. Possible values are:
  - `'jsonSchema7'`: JSON Schema draft-07 (default behavior).
  - `'jsonSchema2019-09'`: JSON Schema draft-2019-09.
  - `'openApi3.1'`: OpenAPI 3.1.
- `topLevelReferenceStrategy`: Controls the handling of the top-level
  reference. Possible values are:
  - `"keep"`: Keep the top-level reference (default behavior).
  - `"skip"`: Skip the top-level reference.
- `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:
  - `"strict"`: Disallow additional properties (default behavior).
  - `"allow"`: Allow additional properties.

@category encoding
@since 3.11.5
@experimental

## setClock

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setClock(= setClock;
const setConfigProvider = exports.setConfigProvider = circularLayer.setConfigProvider;
/**
 * Adds the provided span to the span stack.
 *
 * @since 2.0.0
 * @category tracing
 */
const parentSpan = exports.parentSpan = circularLayer.parentSpan;
/**
 * @since 3.15.0
 * @category Random
 */
const setRandom = random => scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(_random.randomTag, random)`

JSDoc:

@since 2.0.0
@category symbols
/
const LayerTypeId = exports.LayerTypeId = internal.LayerTypeId;
/**
@since 2.0.0
@category symbols
/
const MemoMapTypeId = exports.MemoMapTypeId = internal.MemoMapTypeId;
/**
@since 3.13.0
@category models
/
const CurrentMemoMap = exports.CurrentMemoMap = internal.CurrentMemoMap;
/**
Returns `true` if the specified value is a `Layer`, `false` otherwise.

@since 2.0.0
@category getters
/
const isLayer = exports.isLayer = internal.isLayer;
/**
Returns `true` if the specified `Layer` is a fresh version that will not be
shared, `false` otherwise.

@since 2.0.0
@category getters
/
const isFresh = exports.isFresh = internal.isFresh;
/**
@since 3.3.0
@category tracing
/
const annotateLogs = exports.annotateLogs = internal.annotateLogs;
/**
@since 3.3.0
@category tracing
/
const annotateSpans = exports.annotateSpans = internal.annotateSpans;
/**
Builds a layer into a scoped value.

@since 2.0.0
@category destructors
/
const build = exports.build = internal.build;
/**
Builds a layer into an `Effect` value. Any resources associated with this
layer will be released when the specified scope is closed unless their scope
has been extended. This allows building layers where the lifetime of some of
the services output by the layer exceed the lifetime of the effect the
layer is provided to.

@since 2.0.0
@category destructors
/
const buildWithScope = exports.buildWithScope = internal.buildWithScope;
/**
Recovers from all errors.

@since 2.0.0
@category error handling
/
const catchAll = exports.catchAll = internal.catchAll;
/**
Recovers from all errors.

@since 2.0.0
@category error handling
/
const catchAllCause = exports.catchAllCause = internal.catchAllCause;
/**
Constructs a `Layer` that passes along the specified context as an
output.

@since 2.0.0
@category constructors
/
const context = exports.context = internal.context;
/**
Constructs a layer that dies with the specified defect.

@since 2.0.0
@category constructors
/
const die = exports.die = internal.die;
/**
Constructs a layer that dies with the specified defect.

@since 2.0.0
@category constructors
/
const dieSync = exports.dieSync = internal.dieSync;
/**
Replaces the layer's output with `never` and includes the layer only for its
side-effects.

@since 2.0.0
@category mapping
/
const discard = exports.discard = internal.discard;
/**
Constructs a layer from the specified effect.

@since 2.0.0
@category constructors
/
const effect = exports.effect = internal.fromEffect;
/**
Constructs a layer from the specified effect, discarding its output.

@since 2.0.0
@category constructors
/
const effectDiscard = exports.effectDiscard = internal.fromEffectDiscard;
/**
Constructs a layer from the specified effect, which must return one or more
services.

@since 2.0.0
@category constructors
/
const effectContext = exports.effectContext = internal.fromEffectContext;
/**
A Layer that constructs an empty Context.

@since 2.0.0
@category constructors
/
const empty = exports.empty = internal.empty;
/**
Extends the scope of this layer, returning a new layer that when provided
to an effect will not immediately release its associated resources when
that effect completes execution but instead when the scope the resulting
effect depends on is closed.

@since 2.0.0
@category utils
/
const extendScope = exports.extendScope = internal.extendScope;
/**
Constructs a layer that fails with the specified error.

@since 2.0.0
@category constructors
/
const fail = exports.fail = internal.fail;
/**
Constructs a layer that fails with the specified error.

@since 2.0.0
@category constructors
/
const failSync = exports.failSync = internal.failSync;
/**
Constructs a layer that fails with the specified cause.

@since 2.0.0
@category constructors
/
const failCause = exports.failCause = internal.failCause;
/**
Constructs a layer that fails with the specified cause.

@since 2.0.0
@category constructors
/
const failCauseSync = exports.failCauseSync = internal.failCauseSync;
/**
Constructs a layer dynamically based on the output of this layer.

@since 2.0.0
@category sequencing
/
const flatMap = exports.flatMap = internal.flatMap;
/**
Flattens layers nested in the context of an effect.

@since 2.0.0
@category sequencing
/
const flatten = exports.flatten = internal.flatten;
/**
Creates a fresh version of this layer that will not be shared.

@since 2.0.0
@category utils
/
const fresh = exports.fresh = internal.fresh;
const fromFunction = exports.function = internal.fromFunction;
/**
Builds this layer and uses it until it is interrupted. This is useful when
your entire application is a layer, such as an HTTP server.

@since 2.0.0
@category conversions
/
const launch = exports.launch = internal.launch;
/**
Returns a new layer whose output is mapped by the specified function.

@since 2.0.0
@category mapping
/
const map = exports.map = internal.map;
/**
Returns a layer with its error channel mapped using the specified function.

@since 2.0.0
@category mapping
/
const mapError = exports.mapError = internal.mapError;
/**
Feeds the error or output services of this layer into the input of either
the specified `failure` or `success` layers, resulting in a new layer with
the inputs of this layer, and the error or outputs of the specified layer.

@since 2.0.0
@category folding
/
const match = exports.match = internal.match;
/**
Feeds the error or output services of this layer into the input of either
the specified `failure` or `success` layers, resulting in a new layer with
the inputs of this layer, and the error or outputs of the specified layer.

@since 2.0.0
@category folding
/
const matchCause = exports.matchCause = internal.matchCause;
/**
Returns a scoped effect that, if evaluated, will return the lazily computed
result of this layer.

@since 2.0.0
@category utils
/
const memoize = exports.memoize = internal.memoize;
/**
Merges this layer with the specified layer concurrently, producing a new layer with combined input and output types.

@since 2.0.0
@category zipping
/
const merge = exports.merge = internal.merge;
/**
Combines all the provided layers concurrently, creating a new layer with merged input, error, and output types.

@since 2.0.0
@category zipping
/
const mergeAll = exports.mergeAll = internal.mergeAll;
/**
Translates effect failure into death of the fiber, making all failures
unchecked and not a part of the type of the layer.

@since 2.0.0
@category error handling
/
const orDie = exports.orDie = internal.orDie;
/**
Executes this layer and returns its output, if it succeeds, but otherwise
executes the specified layer.

@since 2.0.0
@category error handling
/
const orElse = exports.orElse = internal.orElse;
/**
Returns a new layer that produces the outputs of this layer but also
passes through the inputs.

@since 2.0.0
@category utils
/
const passthrough = exports.passthrough = internal.passthrough;
/**
Projects out part of one of the services output by this layer using the
specified function.

@since 2.0.0
@category utils
/
const project = exports.project = internal.project;
/**
@since 2.0.0
@category utils
/
const locallyEffect = exports.locallyEffect = internal.locallyEffect;
/**
@since 2.0.0
@category utils
/
const locally = exports.locally = internal.fiberRefLocally;
/**
@since 2.0.0
@category utils
/
const locallyWith = exports.locallyWith = internal.fiberRefLocallyWith;
/**
@since 2.0.0
@category utils
/
const locallyScoped = exports.locallyScoped = internal.fiberRefLocallyScoped;
/**
@since 2.0.0
@category utils
/
const fiberRefLocallyScopedWith = exports.fiberRefLocallyScopedWith = internal.fiberRefLocallyScopedWith;
/**
Retries constructing this layer according to the specified schedule.

@since 2.0.0
@category retrying
/
const retry = exports.retry = internal.retry;
/**
A layer that constructs a scope and closes it when the workflow the layer
is provided to completes execution, whether by success, failure, or
interruption. This can be used to close a scope when providing a layer to a
workflow.

@since 2.0.0
@category constructors
/
const scope = exports.scope = internal.scope;
/**
Constructs a layer from the specified scoped effect.

@since 2.0.0
@category constructors
/
const scoped = exports.scoped = internal.scoped;
/**
Constructs a layer from the specified scoped effect.

@since 2.0.0
@category constructors
/
const scopedDiscard = exports.scopedDiscard = internal.scopedDiscard;
/**
Constructs a layer from the specified scoped effect, which must return one
or more services.

@since 2.0.0
@category constructors
/
const scopedContext = exports.scopedContext = internal.scopedContext;
/**
Constructs a layer that accesses and returns the specified service from the
context.

@since 2.0.0
@category constructors
/
const service = exports.service = internal.service;
/**
Constructs a layer from the specified value.

@since 2.0.0
@category constructors
/
const succeed = exports.succeed = internal.succeed;
/**
Constructs a layer from the specified value, which must return one or more
services.

@since 2.0.0
@category constructors
/
const succeedContext = exports.succeedContext = internal.succeedContext;
/**
Lazily constructs a layer. This is useful to avoid infinite recursion when
creating layers that refer to themselves.

@since 2.0.0
@category constructors
/
const suspend = exports.suspend = internal.suspend;
/**
Lazily constructs a layer from the specified value.

@since 2.0.0
@category constructors
/
const sync = exports.sync = internal.sync;
/**
Lazily constructs a layer from the specified value, which must return one or more
services.

@since 2.0.0
@category constructors
/
const syncContext = exports.syncContext = internal.syncContext;
/**
Performs the specified effect if this layer succeeds.

@since 2.0.0
@category sequencing
/
const tap = exports.tap = internal.tap;
/**
Performs the specified effect if this layer fails.

@since 2.0.0
@category sequencing
/
const tapError = exports.tapError = internal.tapError;
/**
Performs the specified effect if this layer fails.

@since 2.0.0
@category sequencing
/
const tapErrorCause = exports.tapErrorCause = internal.tapErrorCause;
/**
Converts a layer that requires no services into a scoped runtime, which can
be used to execute effects.

@since 2.0.0
@category conversions
/
const toRuntime = exports.toRuntime = internal.toRuntime;
/**
Converts a layer that requires no services into a scoped runtime, which can
be used to execute effects.

@since 2.0.0
@category conversions
/
const toRuntimeWithMemoMap = exports.toRuntimeWithMemoMap = internal.toRuntimeWithMemoMap;
/**
Feeds the output services of this builder into the input of the specified
builder, resulting in a new builder with the inputs of this builder as
well as any leftover inputs, and the outputs of the specified builder.

@since 2.0.0
@category utils
/
const provide = exports.provide = internal.provide;
/**
Feeds the output services of this layer into the input of the specified
layer, resulting in a new layer with the inputs of this layer, and the
outputs of both layers.

@since 2.0.0
@category utils
/
const provideMerge = exports.provideMerge = internal.provideMerge;
/**
Combines this layer with the specified layer concurrently, creating a new layer with merged input types and
combined output types using the provided function.

@since 2.0.0
@category zipping
/
const zipWith = exports.zipWith = internal.zipWith;
/**
@since 2.0.0
@category utils
/
const unwrapEffect = exports.unwrapEffect = internal.unwrapEffect;
/**
@since 2.0.0
@category utils
/
const unwrapScoped = exports.unwrapScoped = internal.unwrapScoped;
/**
@since 2.0.0
@category clock
/
const setClock = clock => scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(_clock.clockTag, clock)));
/**
Sets the current `ConfigProvider`.

@since 2.0.0
@category config

## setRandom

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setRandom(= setRandom;
const setRequestBatching = requestBatching => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(core.currentRequestBatching, requestBatching)`

JSDoc:

@since 2.0.0
@category requests & batching

## setRequestBatching

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setRequestBatching(= setRequestBatching;
const setRequestCaching = requestCaching => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(query.currentCacheEnabled, requestCaching)`

JSDoc:

@since 2.0.0
@category requests & batching

## setRequestCaching

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setRequestCaching(= setRequestCaching;
const setRequestCache = cache => scopedDiscard(core.isEffect(cache)`

JSDoc:

@since 2.0.0
@category requests & batching

## setRequestCache

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setRequestCache(= setRequestCache;
const setScheduler = scheduler => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(Scheduler.currentScheduler, scheduler)`

JSDoc:

@since 2.0.0
@category scheduler

## setScheduler

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setScheduler(= setScheduler;
const span = exports.span = circularLayer.span;
/**
 * Create a Layer that sets the current Tracer
 *
 * @since 2.0.0
 * @category tracing
 */
const setTracer = exports.setTracer = circularLayer.setTracer;
/**
 * @since 2.0.0
 * @category tracing
 */
const setTracerEnabled = enabled => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(core.currentTracerEnabled, enabled)`

JSDoc:

Create and add a span to the current span stack.

The span is ended when the Layer is released.

@since 2.0.0
@category tracing

## setTracerEnabled

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setTracerEnabled(= setTracerEnabled;
const setTracerTiming = enabled => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(core.currentTracerTimingEnabled, enabled)`

JSDoc:

@since 2.0.0
@category tracing

## setTracerTiming

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setTracerTiming(= setTracerTiming;
const setUnhandledErrorLogLevel = level => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(core.currentUnhandledErrorLogLevel, level)`

JSDoc:

@since 2.0.0
@category logging

## setUnhandledErrorLogLevel

Source: `my-backend/node_modules/effect/dist/cjs/Layer.js`

Signature: `setUnhandledErrorLogLevel(= setUnhandledErrorLogLevel;
const withSpan = exports.withSpan = internal.withSpan;
/**
 * @since 2.0.0
 * @category tracing
 */
const withParentSpan = exports.withParentSpan = internal.withParentSpan;
// -----------------------------------------------------------------------------
// memo map
// -----------------------------------------------------------------------------
/**
 * Constructs a `MemoMap` that can be used to build additional layers.
 *
 * @since 2.0.0
 * @category memo map
 */
const makeMemoMap = exports.makeMemoMap = internal.makeMemoMap;
/**
 * Builds a layer into an `Effect` value, using the specified `MemoMap` to memoize
 * the layer construction.
 *
 * @since 2.0.0
 * @category memo map
 */
const buildWithMemoMap = exports.buildWithMemoMap = internal.buildWithMemoMap;
/**
 * Updates a service in the context with a new implementation.
 *
 * **Details**
 *
 * This function modifies the existing implementation of a service in the
 * context. It retrieves the current service, applies the provided
 * transformation function `f`, and replaces the old service with the
 * transformed one.
 *
 * **When to Use**
 *
 * This is useful for adapting or extending a service's behavior during the
 * creation of a layer.
 *
 * @since 3.13.0
 * @category utils
 */
const updateService = exports.updateService = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 2.0.0
@category tracing

## fromRecord

Source: `my-backend/node_modules/effect/dist/cjs/LayerMap.js`

Signature: `fromRecord(= fromRecord;
const Service = ()`

JSDoc:

@since 3.14.0
@experimental
/

/**
@since 3.14.0
@category Symbols
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/LayerMap");
/**
@since 3.14.0
@category Constructors
@experimental

A `LayerMap` allows you to create a map of Layer's that can be used to
dynamically access resources based on a key.

```ts
import { NodeRuntime } from "@effect/platform-node"
import { Context, Effect, FiberRef, Layer, LayerMap } from "effect"

class Greeter extends Context.Tag("Greeter")<Greeter, {
  greet: Effect.Effect<string>
}>() {}

// create a service that wraps a LayerMap
class GreeterMap extends LayerMap.Service<GreeterMap>()("GreeterMap", {
  // define the lookup function for the layer map
  //
  // The returned Layer will be used to provide the Greeter service for the
  // given name.
  lookup: (name: string) =>
    Layer.succeed(Greeter, {
      greet: Effect.succeed(`Hello, ${name}!`)
    }).pipe(
      Layer.merge(Layer.locallyScoped(FiberRef.currentConcurrency, 123))
    ),

  // If a layer is not used for a certain amount of time, it can be removed
  idleTimeToLive: "5 seconds",

  // Supply the dependencies for the layers in the LayerMap
  dependencies: []
}) {}

// usage
const program: Effect.Effect<void, never, GreeterMap> = Effect.gen(function*() {
  // access and use the Greeter service
  const greeter = yield* Greeter
  yield* Effect.log(yield* greeter.greet)
}).pipe(
  // use the GreeterMap service to provide a variant of the Greeter service
  Effect.provide(GreeterMap.get("John"))
)

// run the program
program.pipe(
  Effect.provide(GreeterMap.Default),
  NodeRuntime.runMain
)
```
/
const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (lookup, options) {
  const context = yield* Effect.context();
  // If we are inside another layer build, use the current memo map,
  // otherwise create a new one.
  const memoMap = context.unsafeMap.has(Layer.CurrentMemoMap.key) ? Context.get(context, Layer.CurrentMemoMap) : yield* Layer.makeMemoMap;
  const rcMap = yield* RcMap.make({
    lookup: key => Effect.scopeWith(scope => Effect.diffFiberRefs(Layer.buildWithMemoMap(lookup(key), memoMap, scope))).pipe(Effect.map(([patch, context]) => ({
      layer: Layer.scopedContext(core.withFiberRuntime(fiber => {
        const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope);
        const oldRefs = fiber.getFiberRefs();
        const newRefs = FiberRefsPatch.patch(patch, fiber.id(), oldRefs);
        const revert = FiberRefsPatch.diff(newRefs, oldRefs);
        fiber.setFiberRefs(newRefs);
        return Effect.as(Scope.addFinalizerExit(scope, () => {
          fiber.setFiberRefs(FiberRefsPatch.patch(revert, fiber.id(), fiber.getFiberRefs()));
          return Effect.void;
        }), context);
      })),
      runtimeEffect: Effect.withFiberRuntime(fiber => {
        const fiberRefs = FiberRefsPatch.patch(patch, fiber.id(), fiber.getFiberRefs());
        return Effect.succeed(Runtime.make({
          context,
          fiberRefs,
          runtimeFlags: Runtime.defaultRuntime.runtimeFlags
        }));
      })
    }))),
    idleTimeToLive: options?.idleTimeToLive
  });
  return (0, _Function.identity)({
    [TypeId]: TypeId,
    rcMap,
    get: key => Layer.unwrapScoped(Effect.map(RcMap.get(rcMap, key), ({
      layer
    }) => layer)),
    runtime: key => Effect.flatMap(RcMap.get(rcMap, key), ({
      runtimeEffect
    }) => runtimeEffect),
    invalidate: key => RcMap.invalidate(rcMap, key)
  });
});
/**
@since 3.14.0
@category Constructors
@experimental
/
const fromRecord = (layers, options) => make(key => layers[key], options);
/**
@since 3.14.0
@category Service
@experimental

Create a `LayerMap` service that provides a dynamic set of resources based on
a key.

```ts
import { NodeRuntime } from "@effect/platform-node"
import { Context, Effect, FiberRef, Layer, LayerMap } from "effect"

class Greeter extends Context.Tag("Greeter")<Greeter, {
  greet: Effect.Effect<string>
}>() {}

// create a service that wraps a LayerMap
class GreeterMap extends LayerMap.Service<GreeterMap>()("GreeterMap", {
  // define the lookup function for the layer map
  //
  // The returned Layer will be used to provide the Greeter service for the
  // given name.
  lookup: (name: string) =>
    Layer.succeed(Greeter, {
      greet: Effect.succeed(`Hello, ${name}!`)
    }).pipe(
      Layer.merge(Layer.locallyScoped(FiberRef.currentConcurrency, 123))
    ),

  // If a layer is not used for a certain amount of time, it can be removed
  idleTimeToLive: "5 seconds",

  // Supply the dependencies for the layers in the LayerMap
  dependencies: []
}) {}

// usage
const program: Effect.Effect<void, never, GreeterMap> = Effect.gen(function*() {
  // access and use the Greeter service
  const greeter = yield* Greeter
  yield* Effect.log(yield* greeter.greet)
}).pipe(
  // use the GreeterMap service to provide a variant of the Greeter service
  Effect.provide(GreeterMap.get("John"))
)

// run the program
program.pipe(
  Effect.provide(GreeterMap.Default),
  NodeRuntime.runMain
)
```

## toArray

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `toArray(= toArray;
const getEquivalence = isEquivalent => Equivalence.mapInput(Arr.getEquivalence(isEquivalent)`

JSDoc:

A data type for immutable linked lists representing ordered collections of elements of type `A`.

This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.

**Performance**

- Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.
- Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.

@since 2.0.0
/
/**
This file is ported from

Scala (https://www.scala-lang.org)

Copyright EPFL and Lightbend, Inc.

Licensed under Apache License 2.0
(http://www.apache.org/licenses/LICENSE-2.0).
/

/**
@since 2.0.0
@category symbol
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/List");
/**
Converts the specified `List` to an `Array`.

@category conversions
@since 2.0.0
/
const toArray = self => Arr.fromIterable(self);
/**
@category equivalence
@since 2.0.0

## isList

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `isList(= isList;
const isNil = self => self._tag === "Nil";
/**
 * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.
 *
 * @since 2.0.0
 * @category refinements
 */
exports.isNil = isNil;
const isCons = self => self._tag === "Cons";
/**
 * Returns the number of elements contained in the specified `List`
 *
 * @since 2.0.0
 * @category getters
 */
exports.isCons = isCons;
const size = self => {
  let these = self;
  let len = 0;
  while (!isNil(these)`

JSDoc:

Returns `true` if the specified value is a `List`, `false` otherwise.

@since 2.0.0
@category refinements
/
const isList = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.

@since 2.0.0
@category refinements

## size

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `size(= size;
const nil = ()`

JSDoc:

Constructs a new empty `List<A>`.

@since 2.0.0
@category constructors

## nil

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `nil(= nil;
const cons = (head, tail)`

JSDoc:

Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.

@since 2.0.0
@category constructors

## cons

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `cons(= cons;
const empty = exports.empty = nil;
/**
 * Constructs a new `List<A>` from the specified value.
 *
 * @since 2.0.0
 * @category constructors
 */
const of = value => makeCons(value, _Nil)`

JSDoc:

Constructs a new empty `List<A>`.

Alias of {@link nil}.

@since 2.0.0
@category constructors

## of

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `of(= of;
const fromIterable = prefix => {
  const iterator = prefix[Symbol.iterator]()`

JSDoc:

Creates a new `List` from an iterable collection of values.

@since 2.0.0
@category constructors

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `fromIterable(= fromIterable;
const make = (...elements)`

JSDoc:

Constructs a new `List<A>` from the specified values.

@since 2.0.0
@category constructors

## make

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `make(= make;
const append = exports.append = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Appends the specified element to the end of the `List`, creating a new `Cons`.

@category concatenating
@since 2.0.0

## compact

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `compact(= compact;
const findFirst = exports.findFirst = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Concatenates two lists, combining their elements.
If either list is non-empty, the result is also a non-empty list.

@example
```ts
import * as assert from "node:assert"
import { List } from "effect"

assert.deepStrictEqual(
  List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray),
  [1, 2, "a", "b"]
)
```

@category concatenating
@since 2.0.0
/
const appendAll = exports.appendAll = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => prependAll(that, self));
/**
Prepends the specified element to the beginning of the list.

@category concatenating
@since 2.0.0
/
const prepend = exports.prepend = /*#__PURE__*/(0, _Function.dual)(2, (self, element) => cons(element, self));
/**
Prepends the specified prefix list to the beginning of the specified list.
If either list is non-empty, the result is also a non-empty list.

@example
```ts
import * as assert from "node:assert"
import { List } from "effect"

assert.deepStrictEqual(
  List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray),
  ["a", "b", 1, 2]
)
```

@category concatenating
@since 2.0.0
/
const prependAll = exports.prependAll = /*#__PURE__*/(0, _Function.dual)(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
/**
Prepends the specified prefix list (in reverse order) to the beginning of the
specified list.

@category concatenating
@since 2.0.0
/
const prependAllReversed = exports.prependAllReversed = /*#__PURE__*/(0, _Function.dual)(2, (self, prefix) => {
  let out = self;
  let pres = prefix;
  while (isCons(pres)) {
    out = makeCons(pres.head, out);
    pres = pres.tail;
  }
  return out;
});
/**
Drops the first `n` elements from the specified list.

@since 2.0.0
@category combinators
/
const drop = exports.drop = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  if (n <= 0) {
    return self;
  }
  if (n >= size(self)) {
    return _Nil;
  }
  let these = self;
  let i = 0;
  while (!isNil(these) && i < n) {
    these = these.tail;
    i += 1;
  }
  return these;
});
/**
Check if a predicate holds true for every `List` element.

@since 2.0.0
@category elements
/
const every = exports.every = /*#__PURE__*/(0, _Function.dual)(2, (self, refinement) => {
  for (const a of self) {
    if (!refinement(a)) {
      return false;
    }
  }
  return true;
});
/**
Check if a predicate holds true for some `List` element.

@since 2.0.0
@category elements
/
const some = exports.some = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return true;
    }
    these = these.tail;
  }
  return false;
});
/**
Filters a list using the specified predicate.

@since 2.0.0
@category combinators
/
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => noneIn(self, predicate, false));
// everything seen so far is not included
const noneIn = (self, predicate, isFlipped) => {
  while (true) {
    if (isNil(self)) {
      return _Nil;
    } else {
      if (predicate(self.head) !== isFlipped) {
        return allIn(self, self.tail, predicate, isFlipped);
      } else {
        self = self.tail;
      }
    }
  }
};
// everything from 'start' is included, if everything from this point is in we can return the origin
// start otherwise if we discover an element that is out we must create a new partial list.
const allIn = (start, remaining, predicate, isFlipped) => {
  while (true) {
    if (isNil(remaining)) {
      return start;
    } else {
      if (predicate(remaining.head) !== isFlipped) {
        remaining = remaining.tail;
      } else {
        return partialFill(start, remaining, predicate, isFlipped);
      }
    }
  }
};
// we have seen elements that should be included then one that should be excluded, start building
const partialFill = (origStart, firstMiss, predicate, isFlipped) => {
  const newHead = makeCons(unsafeHead(origStart), _Nil);
  let toProcess = unsafeTail(origStart);
  let currentLast = newHead;
  // we know that all elements are :: until at least firstMiss.tail
  while (!(toProcess === firstMiss)) {
    const newElem = makeCons(unsafeHead(toProcess), _Nil);
    currentLast.tail = newElem;
    currentLast = (0, _Function.unsafeCoerce)(newElem);
    toProcess = (0, _Function.unsafeCoerce)(toProcess.tail);
  }
  // at this point newHead points to a list which is a duplicate of all the 'in' elements up to the first miss.
  // currentLast is the last element in that list.
  // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.
  let next = firstMiss.tail;
  let nextToCopy = (0, _Function.unsafeCoerce)(next); // the next element we would need to copy to our list if we cant share.
  while (!isNil(next)) {
    // generally recommended is next.isNonEmpty but this incurs an extra method call.
    const head = unsafeHead(next);
    if (predicate(head) !== isFlipped) {
      next = next.tail;
    } else {
      // its not a match - do we have outstanding elements?
      while (!(nextToCopy === next)) {
        const newElem = makeCons(unsafeHead(nextToCopy), _Nil);
        currentLast.tail = newElem;
        currentLast = newElem;
        nextToCopy = (0, _Function.unsafeCoerce)(nextToCopy.tail);
      }
      nextToCopy = (0, _Function.unsafeCoerce)(next.tail);
      next = next.tail;
    }
  }
  // we have remaining elements - they are unchanged attach them to the end
  if (!isNil(nextToCopy)) {
    currentLast.tail = nextToCopy;
  }
  return newHead;
};
/**
Filters and maps a list using the specified partial function. The resulting
list may be smaller than the input list due to the possibility of the partial
function not being defined for some elements.

@since 2.0.0
@category combinators
/
const filterMap = exports.filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const bs = [];
  for (const a of self) {
    const oa = f(a);
    if (Option.isSome(oa)) {
      bs.push(oa.value);
    }
  }
  return fromIterable(bs);
});
/**
Removes all `None` values from the specified list.

@since 2.0.0
@category combinators
/
const compact = self => filterMap(self, _Function.identity);
/**
Returns the first element that satisfies the specified
predicate, or `None` if no such element exists.

@category elements
@since 2.0.0

## head

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `head(= head;
const last = self => isNil(self)`

JSDoc:

Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.

@since 2.0.0
@category sequencing
/
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  let rest = self;
  let head = undefined;
  let tail = undefined;
  while (!isNil(rest)) {
    let bs = f(rest.head);
    while (!isNil(bs)) {
      const next = makeCons(bs.head, _Nil);
      if (tail === undefined) {
        head = next;
      } else {
        tail.tail = next;
      }
      tail = next;
      bs = bs.tail;
    }
    rest = rest.tail;
  }
  if (head === undefined) {
    return _Nil;
  }
  return head;
});
/**
Applies the specified function to each element of the `List`.

@since 2.0.0
@category combinators
/
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  let these = self;
  while (!isNil(these)) {
    f(these.head);
    these = these.tail;
  }
});
/**
Returns the first element of the specified list, or `None` if the list is
empty.

@since 2.0.0
@category getters
/
const head = self => isNil(self) ? Option.none() : Option.some(self.head);
/**
Returns the last element of the specified list, or `None` if the list is
empty.

@since 2.0.0
@category getters

## last

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `last(= last;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Applies the specified mapping function to each element of the list.

@since 2.0.0
@category mapping

## reverse

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `reverse(= reverse;
const splitAt = exports.splitAt = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Partition a list into two lists, where the first list contains all elements
that did not satisfy the specified predicate, and the second list contains
all elements that did satisfy the specified predicate.

@since 2.0.0
@category combinators
/
const partition = exports.partition = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const left = [];
  const right = [];
  for (const a of self) {
    if (predicate(a)) {
      right.push(a);
    } else {
      left.push(a);
    }
  }
  return [fromIterable(left), fromIterable(right)];
});
/**
Partition a list into two lists, where the first list contains all elements
for which the specified function returned a `Left`, and the second list
contains all elements for which the specified function returned a `Right`.

@since 2.0.0
@category combinators
/
const partitionMap = exports.partitionMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const left = [];
  const right = [];
  for (const a of self) {
    const e = f(a);
    if (Either.isLeft(e)) {
      left.push(e.left);
    } else {
      right.push(e.right);
    }
  }
  return [fromIterable(left), fromIterable(right)];
});
/**
Folds over the elements of the list using the specified function, using the
specified initial value.

@since 2.0.0
@category folding
/
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => {
  let acc = zero;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
/**
Folds over the elements of the list using the specified function, beginning
with the last element of the list, using the specified initial value.

@since 2.0.0
@category folding
/
const reduceRight = exports.reduceRight = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => {
  let acc = zero;
  let these = reverse(self);
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
/**
Returns a new list with the elements of the specified list in reverse order.

@since 2.0.0
@category elements
/
const reverse = self => {
  let result = empty();
  let these = self;
  while (!isNil(these)) {
    result = prepend(result, these.head);
    these = these.tail;
  }
  return result;
};
/**
Splits the specified list into two lists at the specified index.

@since 2.0.0
@category combinators

## tail

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `tail(= tail;
const take = exports.take = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns the tail of the specified list, or `None` if the list is empty.

@since 2.0.0
@category getters
/
const tail = self => isNil(self) ? Option.none() : Option.some(self.tail);
/**
Takes the specified number of elements from the beginning of the specified
list.

@since 2.0.0
@category combinators

## unsafeHead

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `unsafeHead(= unsafeHead;
const unsafeLast = self => {
  if (isNil(self)`

JSDoc:

Converts the specified `List` to a `Chunk`.

@since 2.0.0
@category conversions
/
const toChunk = self => Chunk.fromIterable(self);
exports.toChunk = toChunk;
const getExpectedListToBeNonEmptyErrorMessage = "Expected List to be non-empty";
/**
Unsafely returns the first element of the specified `List`.

@since 2.0.0
@category unsafe
/
const unsafeHead = self => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.head;
};
/**
Unsafely returns the last element of the specified `List`.

@since 2.0.0
@category unsafe

## unsafeLast

Source: `my-backend/node_modules/effect/dist/cjs/List.js`

Signature: `unsafeLast(= unsafeLast;
const unsafeTail = self => {
  if (isNil(self)`

JSDoc:

Unsafely returns the tail of the specified `List`.

@since 2.0.0
@category unsafe

## isMailbox

Source: `my-backend/node_modules/effect/dist/cjs/Mailbox.js`

Signature: `isMailbox(= isMailbox;
const isReadonlyMailbox = u => (0, _Predicate.hasProperty)`

JSDoc:

@since 3.8.0
@experimental
@category type ids
/
const TypeId = exports.TypeId = internal.TypeId;
/**
@since 3.8.0
@experimental
@category type ids
/
const ReadonlyTypeId = exports.ReadonlyTypeId = internal.ReadonlyTypeId;
/**
@since 3.8.0
@experimental
@category guards
/
const isMailbox = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
@since 3.8.0
@experimental
@category guards

## isReadonlyMailbox

Source: `my-backend/node_modules/effect/dist/cjs/Mailbox.js`

Signature: `isReadonlyMailbox(= isReadonlyMailbox;
const make = exports.make = internal.make;
/**
 * Run an `Effect` into a `Mailbox`, where success ends the mailbox and failure
 * fails the mailbox.
 *
 * @since 3.8.0
 * @experimental
 * @category combinators
 */
const into = exports.into = internal.into;
/**
 * Create a `Channel` from a `Mailbox`.
 *
 * @since 3.8.0
 * @experimental
 * @category conversions
 */
const toChannel = exports.toChannel = internal.toChannel;
/**
 * Create a `Stream` from a `Mailbox`.
 *
 * @since 3.8.0
 * @experimental
 * @category conversions
 */
const toStream = exports.toStream = internal.toStream;
/**
 * Create a `ReadonlyMailbox` from a `Stream`.
 *
 * @since 3.11.0
 * @experimental
 * @category conversions
 */
const fromStream = exports.fromStream = internal.fromStream;
//# sourceMappingURL=Mailbox.js.map)`

JSDoc:

A `Mailbox` is a queue that can be signaled to be done or failed.

@since 3.8.0
@experimental
@category constructors
@example
```ts
import * as assert from "node:assert"
import { Effect, Mailbox } from "effect"

Effect.gen(function*() {
  const mailbox = yield* Mailbox.make<number, string>()

  // add messages to the mailbox
  yield* mailbox.offer(1)
  yield* mailbox.offer(2)
  yield* mailbox.offerAll([3, 4, 5])

  // take messages from the mailbox
  const [messages, done] = yield* mailbox.takeAll
  assert.deepStrictEqual(messages, [1, 2, 3, 4, 5])
  assert.strictEqual(done, false)

  // signal that the mailbox is done
  yield* mailbox.end
  const [messages2, done2] = yield* mailbox.takeAll
  assert.deepStrictEqual(messages2, [])
  assert.strictEqual(done2, true)

  // signal that the mailbox has failed
  yield* mailbox.fail("boom")
})
```

## isMicro

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `isMicro(= isMicro;
const MicroCauseTypeId = exports.MicroCauseTypeId = /*#__PURE__*/Symbol.for("effect/Micro/MicroCause")`

JSDoc:

A lightweight alternative to the `Effect` data type, with a subset of the functionality.

@since 3.4.0
@experimental
/

/**
@since 3.4.0
@experimental
@category type ids
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Micro");
/**
@since 3.4.0
@experimental
@category MicroExit
/
const MicroExitTypeId = exports.MicroExitTypeId = /*#__PURE__*/Symbol.for("effect/Micro/MicroExit");
/**
@since 3.4.0
@experimental
@category guards
/
const isMicro = u => typeof u === "object" && u !== null && TypeId in u;
// ----------------------------------------------------------------------------
// MicroCause
// ----------------------------------------------------------------------------
/**
@since 3.4.6
@experimental
@category MicroCause

## causeInterrupt

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `causeInterrupt(= causeInterrupt;
const causeIsFail = self => self._tag === "Fail";
/**
 * @since 3.4.6
 * @experimental
 * @category MicroCause
 */
exports.causeIsFail = causeIsFail;
const causeIsDie = self => self._tag === "Die";
/**
 * @since 3.4.6
 * @experimental
 * @category MicroCause
 */
exports.causeIsDie = causeIsDie;
const causeIsInterrupt = self => self._tag === "Interrupt";
/**
 * @since 3.4.6
 * @experimental
 * @category MicroCause
 */
exports.causeIsInterrupt = causeIsInterrupt;
const causeSquash = self => self._tag === "Fail" ? self.error : self._tag === "Die" ? self.defect : self;
/**
 * @since 3.4.6
 * @experimental
 * @category MicroCause
 */
exports.causeSquash = causeSquash;
const causeWithTrace = exports.causeWithTrace = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 3.6.6
@experimental
@category guards
/
const isMicroCause = self => (0, _Predicate.hasProperty)(self, MicroCauseTypeId);
exports.isMicroCause = isMicroCause;
const microCauseVariance = {
  _E: _Function.identity
};
class MicroCauseImpl extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = (0, _Inspectable.toStringUnknown)(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `\n    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [_Inspectable.NodeInspectSymbol]() {
    return this.stack;
  }
}
class Fail extends MicroCauseImpl {
  error;
  constructor(error, traces = []) {
    super("Fail", error, traces);
    this.error = error;
  }
}
/**
@since 3.4.6
@experimental
@category MicroCause
/
const causeFail = (error, traces = []) => new Fail(error, traces);
exports.causeFail = causeFail;
class Die extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
}
/**
@since 3.4.6
@experimental
@category MicroCause
/
const causeDie = (defect, traces = []) => new Die(defect, traces);
exports.causeDie = causeDie;
class Interrupt extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
}
/**
@since 3.4.6
@experimental
@category MicroCause
/
const causeInterrupt = (traces = []) => new Interrupt(traces);
/**
@since 3.4.6
@experimental
@category MicroCause

## fiberAwait

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `fiberAwait(= fiberAwait;
const fiberJoin = self => flatten(fiberAwait(self)`

JSDoc:

@since 3.11.0
@experimental
@category MicroFiber
/
const MicroFiberTypeId = exports.MicroFiberTypeId = /*#__PURE__*/Symbol.for("effect/Micro/MicroFiber");
const fiberVariance = {
  _A: _Function.identity,
  _E: _Function.identity
};
class MicroFiberImpl {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context, interruptible = true) {
    this.context = context;
    this.interruptible = interruptible;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return InternalContext.unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return _Function.constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== undefined) {
      const yielded = this._yielded;
      this._yielded = undefined;
      yielded();
    }
    const exit = this.runLoop(effect);
    if (exit === Yield) {
      return;
    }
    // the interruptChildren middlware is added in Micro.fork, so it can be
    // tree-shaken if not used
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== undefined) {
      return this.evaluate(flatMap(interruptChildren, () => exit));
    }
    this._exit = exit;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap(yieldNow, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = undefined;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error) {
      if (!(0, _Predicate.hasProperty)(current, evaluate)) {
        return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie(error);
    }
  }
  getCont(symbol) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return undefined;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol]: cont
      };
      if (op[symbol]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = undefined;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= new Set();
  }
}
const fiberMiddleware = /*#__PURE__*/(0, _GlobalValue.globalValue)("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: undefined
}));
const fiberInterruptChildren = fiber => {
  if (fiber._children === undefined || fiber._children.size === 0) {
    return undefined;
  }
  return fiberInterruptAll(fiber._children);
};
/**
@since 3.11.0
@experimental
@category MicroFiber
/
const fiberAwait = self => async(resume => sync(self.addObserver(exit => resume(succeed(exit)))));
/**
@since 3.11.2
@experimental
@category MicroFiber

## fiberJoin

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `fiberJoin(= fiberJoin;
const fiberInterrupt = self => suspend(()`

JSDoc:

@since 3.11.0
@experimental
@category MicroFiber

## fiberInterrupt

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `fiberInterrupt(= fiberInterrupt;
const fiberInterruptAll = fibers => suspend(()`

JSDoc:

@since 3.11.0
@experimental
@category MicroFiber

## fail

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `fail(= fail;
const sync = exports.sync = /*#__PURE__*/makePrimitive({
  op: "Sync",
  eval(fiber)`

JSDoc:

Creates a `Micro` effect that will succeed with the specified constant value.

@since 3.4.0
@experimental
@category constructors
/
const succeed = exports.succeed = /*#__PURE__*/makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
/**
Creates a `Micro` effect that will fail with the specified `MicroCause`.

@since 3.4.6
@experimental
@category constructors
/
const failCause = exports.failCause = /*#__PURE__*/makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
/**
Creates a `Micro` effect that fails with the given error.

This results in a `Fail` variant of the `MicroCause` type, where the error is
tracked at the type level.

@since 3.4.0
@experimental
@category constructors
/
const fail = error => failCause(causeFail(error));
/**
Creates a `Micro` effect that succeeds with a lazily evaluated value.

If the evaluation of the value throws an error, the effect will fail with a
`Die` variant of the `MicroCause` type.

@since 3.4.0
@experimental
@category constructors

## succeedSome

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `succeedSome(= succeedSome;
const succeedNone = exports.succeedNone = /*#__PURE__*/succeed(/*#__PURE__*/Option.none()`

JSDoc:

Lazily creates a `Micro` effect from the given side-effect.

@since 3.4.0
@experimental
@category constructors
/
const suspend = exports.suspend = /*#__PURE__*/makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
/**
Pause the execution of the current `Micro` effect, and resume it on the next
scheduler tick.

@since 3.4.0
@experimental
@category constructors
/
const yieldNowWith = exports.yieldNowWith = /*#__PURE__*/makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
/**
Pause the execution of the current `Micro` effect, and resume it on the next
scheduler tick.

@since 3.4.0
@experimental
@category constructors
/
const yieldNow = exports.yieldNow = /*#__PURE__*/yieldNowWith(0);
/**
Creates a `Micro` effect that will succeed with the value wrapped in `Some`.

@since 3.4.0
@experimental
@category constructors
/
const succeedSome = a => succeed(Option.some(a));
/**
Creates a `Micro` effect that succeeds with `None`.

@since 3.4.0
@experimental
@category constructors

## failCauseSync

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `failCauseSync(= failCauseSync;
const die = defect => exitDie(defect)`

JSDoc:

Creates a `Micro` effect that will fail with the lazily evaluated `MicroCause`.

@since 3.4.0
@experimental
@category constructors
/
const failCauseSync = evaluate => suspend(() => failCause(evaluate()));
/**
Creates a `Micro` effect that will die with the specified error.

This results in a `Die` variant of the `MicroCause` type, where the error is
not tracked at the type level.

@since 3.4.0
@experimental
@category constructors

## die

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `die(= die;
const failSync = error => suspend(()`

JSDoc:

Creates a `Micro` effect that will fail with the lazily evaluated error.

This results in a `Fail` variant of the `MicroCause` type, where the error is
tracked at the type level.

@since 3.4.6
@experimental
@category constructors

## failSync

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `failSync(= failSync;
const fromOption = option => option._tag === "Some" ? succeed(option.value)`

JSDoc:

Converts an `Option` into a `Micro` effect, that will fail with
`NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the
value of the option.

@since 3.4.0
@experimental
@category constructors

## fromOption

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `fromOption(= fromOption;
const fromEither = either => either._tag === "Right" ? succeed(either.right)`

JSDoc:

Converts an `Either` into a `Micro` effect, that will fail with the left side
of the either if it is a `Left`. Otherwise, it will succeed with the right
side of the either.

@since 3.4.0
@experimental
@category constructors

## promise

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `promise(= promise;
const tryPromise = options => asyncOptions(function (resume, signal)`

JSDoc:

Wrap a `Promise` into a `Micro` effect.

Any errors will result in a `Die` variant of the `MicroCause` type, where the
error is not tracked at the type level.

@since 3.4.0
@experimental
@category constructors
/
const promise = evaluate => asyncOptions(function (resume, signal) {
  evaluate(signal).then(a => resume(succeed(a)), e => resume(die(e)));
}, evaluate.length !== 0);
/**
Wrap a `Promise` into a `Micro` effect. Any errors will be caught and
converted into a specific error type.

@example
```ts
import { Micro } from "effect"

Micro.tryPromise({
  try: () => Promise.resolve("success"),
  catch: (cause) => new Error("caught", { cause })
})
```

@since 3.4.0
@experimental
@category constructors

## tryPromise

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `tryPromise(= tryPromise;
const withMicroFiber = exports.withMicroFiber = /*#__PURE__*/makePrimitive({
  op: "WithMicroFiber",
  eval(fiber)`

JSDoc:

Create a `Micro` effect using the current `MicroFiber`.

@since 3.4.0
@experimental
@category constructors

## async

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `async(= async;
const never = exports.never = /*#__PURE__*/async(function ()`

JSDoc:

Flush any yielded effects that are waiting to be executed.

@since 3.4.0
@experimental
@category constructors
/
const yieldFlush = exports.yieldFlush = /*#__PURE__*/withMicroFiber(fiber => {
  fiber.getRef(CurrentScheduler).flush();
  return exitVoid;
});
const asyncOptions = /*#__PURE__*/makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : undefined;
    const onCancel = register(effect => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect);
      } else {
        yielded = effect;
      }
    }, controller?.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === undefined && onCancel === undefined) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid;
    }));
    return Yield;
  }
});
const asyncFinalizer = /*#__PURE__*/makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause, _fiber) {
    return causeIsInterrupt(cause) ? flatMap(this[args](), () => failCause(cause)) : failCause(cause);
  }
});
/**
Create a `Micro` effect from an asynchronous computation.

You can return a cleanup effect that will be run when the effect is aborted.
It is also passed an `AbortSignal` that is triggered when the effect is
aborted.

@since 3.4.0
@experimental
@category constructors
/
const async = register => asyncOptions(register, register.length >= 2);
/**
A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent
the Javascript runtime from exiting.

@since 3.4.0
@experimental
@category constructors

## asSome

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `asSome(= asSome;
const flip = self => matchEffect(self, {
  onFailure: succeed,
  onSuccess: fail
})`

JSDoc:

@since 3.4.0
@experimental
@category constructors
/
const gen = (...args) => suspend(() => fromIterator(args.length === 1 ? args[0]() : args[1].call(args[0])));
exports.gen = gen;
const fromIterator = /*#__PURE__*/makePrimitive({
  op: "Iterator",
  contA(value, fiber) {
    const state = this[args].next(value);
    if (state.done) return succeed(state.value);
    fiber._stack.push(this);
    return (0, _Utils.yieldWrapGet)(state.value);
  },
  eval(fiber) {
    return this[successCont](undefined, fiber);
  }
});
// ----------------------------------------------------------------------------
// mapping & sequencing
// ----------------------------------------------------------------------------
/**
Create a `Micro` effect that will replace the success value of the given
effect.

@since 3.4.0
@experimental
@category mapping & sequencing
/
const as = exports.as = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => map(self, _ => value));
/**
Wrap the success value of this `Micro` effect in a `Some`.

@since 3.4.0
@experimental
@category mapping & sequencing
/
const asSome = self => map(self, Option.some);
/**
Swap the error and success types of the `Micro` effect.

@since 3.4.0
@experimental
@category mapping & sequencing

## flip

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `flip(= flip;
const andThen = exports.andThen = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

A more flexible version of `flatMap` that combines `map` and `flatMap` into a
single API.

It also lets you directly pass a `Micro` effect, which will be executed after
the current effect.

@since 3.4.0
@experimental
@category mapping & sequencing

## asVoid

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `asVoid(= asVoid;
const exit = self => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
})`

JSDoc:

Execute a side effect from the success value of the `Micro` effect.

It is similar to the `andThen` api, but the success value is ignored.

@since 3.4.0
@experimental
@category mapping & sequencing
/
const tap = exports.tap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flatMap(self, a => {
  const value = isMicro(f) ? f : typeof f === "function" ? f(a) : f;
  return isMicro(value) ? as(value, a) : succeed(a);
}));
/**
Replace the success value of the `Micro` effect with `void`.

@since 3.4.0
@experimental
@category mapping & sequencing
/
const asVoid = self => flatMap(self, _ => exitVoid);
/**
Access the `MicroExit` of the given `Micro` effect.

@since 3.4.6
@experimental
@category mapping & sequencing

## exit

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `exit(= exit;
const sandbox = self => catchAllCause(self, fail)`

JSDoc:

Replace the error type of the given `Micro` with the full `MicroCause` object.

@since 3.4.0
@experimental
@category mapping & sequencing

## sandbox

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `sandbox(= sandbox;
const raceAll = all => withMicroFiber(parent => async(resume => {
  const effects = Arr.fromIterable(all)`

JSDoc:

Returns an effect that races all the specified effects,
yielding the value of the first effect to succeed with a value. Losers of
the race will be interrupted immediately

@since 3.4.0
@experimental
@category sequencing

## raceAll

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `raceAll(= raceAll;
const raceAllFirst = all => withMicroFiber(parent => async(resume => {
  let done = false;
  const fibers = new Set()`

JSDoc:

Returns an effect that races all the specified effects,
yielding the value of the first effect to succeed or fail. Losers of
the race will be interrupted immediately.

@since 3.4.0
@experimental
@category sequencing

## raceAllFirst

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `raceAllFirst(= raceAllFirst;
const race = exports.race = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns an effect that races two effects, yielding the value of the first
effect to succeed. Losers of the race will be interrupted immediately.

@since 3.4.0
@experimental
@category sequencing

## flatten

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `flatten(= flatten;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns an effect that races two effects, yielding the value of the first
effect to succeed *or* fail. Losers of the race will be interrupted immediately.

@since 3.4.0
@experimental
@category sequencing
/
const raceFirst = exports.raceFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => raceAllFirst([self, that]));
/**
Map the success value of this `Micro` effect to another `Micro` effect, then
flatten the result.

@since 3.4.0
@experimental
@category mapping & sequencing
/
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f;
  return onSuccess;
});
const OnSuccessProto = /*#__PURE__*/makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
// ----------------------------------------------------------------------------
// mapping & sequencing
// ----------------------------------------------------------------------------
/**
Flattens any nested `Micro` effects, merging the error and requirement types.

@since 3.4.0
@experimental
@category mapping & sequencing
/
const flatten = self => flatMap(self, _Function.identity);
/**
Transforms the success value of the `Micro` effect with the specified
function.

@since 3.4.0
@experimental
@category mapping & sequencing

## isMicroExit

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `isMicroExit(= isMicroExit;
const exitSucceed = exports.exitSucceed = succeed;
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
const exitFailCause = exports.exitFailCause = failCause;
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
const exitInterrupt = exports.exitInterrupt = /*#__PURE__*/exitFailCause(/*#__PURE__*/causeInterrupt()`

JSDoc:

@since 3.4.6
@experimental
@category MicroExit
/
const isMicroExit = u => (0, _Predicate.hasProperty)(u, MicroExitTypeId);
/**
@since 3.4.6
@experimental
@category MicroExit

## exitFail

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `exitFail(= exitFail;
const exitDie = defect => exitFailCause(causeDie(defect)`

JSDoc:

@since 3.4.6
@experimental
@category MicroExit
/
const exitFail = e => exitFailCause(causeFail(e));
/**
@since 3.4.6
@experimental
@category MicroExit

## exitDie

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `exitDie(= exitDie;
const exitIsSuccess = self => self._tag === "Success";
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
exports.exitIsSuccess = exitIsSuccess;
const exitIsFailure = self => self._tag === "Failure";
/**
 * @since 3.4.6
 * @experimental
 * @category MicroExit
 */
exports.exitIsFailure = exitIsFailure;
const exitIsInterrupt = self => exitIsFailure(self)`

JSDoc:

@since 3.4.6
@experimental
@category MicroExit

## exitIsInterrupt

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `exitIsInterrupt(= exitIsInterrupt;
const exitIsFail = self => exitIsFailure(self)`

JSDoc:

@since 3.4.6
@experimental
@category MicroExit

## exitIsFail

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `exitIsFail(= exitIsFail;
const exitIsDie = self => exitIsFailure(self)`

JSDoc:

@since 3.4.6
@experimental
@category MicroExit

## exitIsDie

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `exitIsDie(= exitIsDie;
const exitVoid = exports.exitVoid = /*#__PURE__*/exitSucceed(void 0)`

JSDoc:

@since 3.4.6
@experimental
@category MicroExit

## MicroSchedulerDefault

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `MicroSchedulerDefault(= MicroSchedulerDefault;
const service = tag => withMicroFiber(fiber => succeed(Context.unsafeGet(fiber.context, tag)`

JSDoc:

@since 3.11.0
@experimental
@category MicroExit
/
const exitVoidAll = exits => {
  for (const exit of exits) {
    if (exit._tag === "Failure") {
      return exit;
    }
  }
  return exitVoid;
};
exports.exitVoidAll = exitVoidAll;
const setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : f => setTimeout(f, 0);
/**
@since 3.5.9
@experimental
@category scheduler
/
class MicroSchedulerDefault {
  tasks = [];
  running = false;
  /**
@since 3.5.9
/
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  /**
@since 3.5.9
/
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  /**
@since 3.5.9
/
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
@since 3.5.9
/
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
@since 3.5.9
/
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
}
/**
Access the given `Context.Tag` from the environment.

@since 3.4.0
@experimental
@category environment

## service

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `service(= service;
const serviceOption = tag => withMicroFiber(fiber => succeed(Context.getOption(fiber.context, tag)`

JSDoc:

Access the given `Context.Tag` from the environment, without tracking the
dependency at the type level.

It will return an `Option` of the service, depending on whether it is
available in the environment or not.

@since 3.4.0
@experimental
@category environment

## serviceOption

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `serviceOption(= serviceOption;
const updateContext = exports.updateContext = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Update the Context with the given mapping function.

@since 3.11.0
@experimental
@category environment

## MaxOpsBeforeYield

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `MaxOpsBeforeYield(= MaxOpsBeforeYield;
class CurrentConcurrency extends /*#__PURE__*/Context.Reference()`

JSDoc:

Update the service for the given `Context.Tag` in the environment.

@since 3.11.0
@experimental
@category environment
/
const updateService = exports.updateService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, f) => withMicroFiber(fiber => {
  const prev = Context.unsafeGet(fiber.context, tag);
  fiber.context = Context.add(fiber.context, tag, f(prev));
  return onExit(self, () => {
    fiber.context = Context.add(fiber.context, tag, prev);
    return void_;
  });
}));
/**
Access the current `Context` from the environment.

@since 3.4.0
@experimental
@category environment
/
const context = () => getContext;
exports.context = context;
const getContext = /*#__PURE__*/withMicroFiber(fiber => succeed(fiber.context));
/**
Merge the given `Context` with the current context.

@since 3.4.0
@experimental
@category environment
/
const provideContext = exports.provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, provided) => updateContext(self, Context.merge(provided)));
/**
Add the provided service to the current context.

@since 3.4.0
@experimental
@category environment
/
const provideService = exports.provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, service) => updateContext(self, Context.add(tag, service)));
/**
Create a service using the provided `Micro` effect, and add it to the
current context.

@since 3.4.6
@experimental
@category environment
/
const provideServiceEffect = exports.provideServiceEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, acquire) => flatMap(acquire, service => provideService(self, tag, service)));
// ========================================================================
// References
// ========================================================================
/**
@since 3.11.0
@experimental
@category references
/
class MaxOpsBeforeYield extends /*#__PURE__*/Context.Reference()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
}) {}
/**
@since 3.11.0
@experimental
@category environment refs

## CurrentConcurrency

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `CurrentConcurrency(= CurrentConcurrency;
class CurrentScheduler extends /*#__PURE__*/Context.Reference()`

JSDoc:

@since 3.11.0
@experimental
@category environment refs

## CurrentScheduler

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `CurrentScheduler(= CurrentScheduler;
const withConcurrency = exports.withConcurrency = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

If you have a `Micro` that uses `concurrency: "inherit"`, you can use this
api to control the concurrency of that `Micro` when it is run.

@example
```ts
import * as Micro from "effect/Micro"

Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {
  concurrency: "inherit"
}).pipe(
  Micro.withConcurrency(2) // use a concurrency of 2
)
```

@since 3.4.0
@experimental
@category environment refs

## forever

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `forever(= forever;
const scheduleRecurs = n => attempt => attempt <= n ? Option.some(0)`

JSDoc:

Combine two `Micro` effects into a single effect that produces a tuple of
their results.

@since 3.4.0
@experimental
@category zipping
/
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)(args => isMicro(args[1]), (self, that, options) => zipWith(self, that, (a, a2) => [a, a2], options));
/**
The `Micro.zipWith` function combines two `Micro` effects and allows you to
apply a function to the results of the combined effects, transforming them
into a single value.

@since 3.4.3
@experimental
@category zipping
/
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)(args => isMicro(args[1]), (self, that, f, options) => options?.concurrent
// Use `all` exclusively for concurrent cases, as it introduces additional overhead due to the management of concurrency
? map(all([self, that], {
  concurrency: 2
}), ([a, a2]) => f(a, a2)) : flatMap(self, a => map(that, a2 => f(a, a2))));
// ----------------------------------------------------------------------------
// filtering & conditionals
// ----------------------------------------------------------------------------
/**
Filter the specified effect with the provided function, failing with specified
`MicroCause` if the predicate fails.

In addition to the filtering capabilities discussed earlier, you have the option to further
refine and narrow down the type of the success channel by providing a

@since 3.4.0
@experimental
@category filtering & conditionals
/
const filterOrFailCause = exports.filterOrFailCause = /*#__PURE__*/(0, _Function.dual)(args => isMicro(args[0]), (self, refinement, orFailWith) => flatMap(self, a => refinement(a) ? succeed(a) : failCause(orFailWith(a))));
/**
Filter the specified effect with the provided function, failing with specified
error if the predicate fails.

In addition to the filtering capabilities discussed earlier, you have the option to further
refine and narrow down the type of the success channel by providing a

@since 3.4.0
@experimental
@category filtering & conditionals
/
const filterOrFail = exports.filterOrFail = /*#__PURE__*/(0, _Function.dual)(args => isMicro(args[0]), (self, refinement, orFailWith) => flatMap(self, a => refinement(a) ? succeed(a) : fail(orFailWith(a))));
/**
The moral equivalent of `if (p) exp`.

@since 3.4.0
@experimental
@category filtering & conditionals
/
const when = exports.when = /*#__PURE__*/(0, _Function.dual)(2, (self, condition) => flatMap(isMicro(condition) ? condition : sync(condition), pass => pass ? asSome(self) : succeedNone));
// ----------------------------------------------------------------------------
// repetition
// ----------------------------------------------------------------------------
/**
Repeat the given `Micro` using the provided options.

The `while` predicate will be checked after each iteration, and can use the
fall `MicroExit` of the effect to determine if the repetition should continue.

@since 3.4.6
@experimental
@category repetition
/
const repeatExit = exports.repeatExit = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => suspend(() => {
  const startedAt = options.schedule ? Date.now() : 0;
  let attempt = 0;
  const loop = flatMap(exit(self), exit => {
    if (options.while !== undefined && !options.while(exit)) {
      return exit;
    } else if (options.times !== undefined && attempt >= options.times) {
      return exit;
    }
    attempt++;
    let delayEffect = yieldNow;
    if (options.schedule !== undefined) {
      const elapsed = Date.now() - startedAt;
      const duration = options.schedule(attempt, elapsed);
      if (Option.isNone(duration)) {
        return exit;
      }
      delayEffect = sleep(duration.value);
    }
    return flatMap(delayEffect, () => loop);
  });
  return loop;
}));
/**
Repeat the given `Micro` effect using the provided options. Only successful
results will be repeated.

@since 3.4.0
@experimental
@category repetition
/
const repeat = exports.repeat = /*#__PURE__*/(0, _Function.dual)(args => isMicro(args[0]), (self, options) => repeatExit(self, {
  ...options,
  while: exit => exit._tag === "Success" && (options?.while === undefined || options.while(exit.value))
}));
/**
Replicates the given effect `n` times.

@since 3.11.0
@experimental
@category repetition
/
const replicate = exports.replicate = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => Array.from({
  length: n
}, () => self));
/**
Performs this effect the specified number of times and collects the
results.

@since 3.11.0
@category repetition
/
const replicateEffect = exports.replicateEffect = /*#__PURE__*/(0, _Function.dual)(args => isMicro(args[0]), (self, n, options) => all(replicate(self, n), options));
/**
Repeat the given `Micro` effect forever, only stopping if the effect fails.

@since 3.4.0
@experimental
@category repetition
/
const forever = self => repeat(self);
/**
Create a `MicroSchedule` that will stop repeating after the specified number
of attempts.

@since 3.4.6
@experimental
@category scheduling

## scheduleRecurs

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `scheduleRecurs(= scheduleRecurs;
const scheduleSpaced = millis => ()`

JSDoc:

Create a `MicroSchedule` that will generate a constant delay.

@since 3.4.6
@experimental
@category scheduling

## scheduleSpaced

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `scheduleSpaced(= scheduleSpaced;
const scheduleExponential = (baseMillis, factor = 2)`

JSDoc:

Create a `MicroSchedule` that will generate a delay with an exponential backoff.

@since 3.4.6
@experimental
@category scheduling

## scheduleExponential

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `scheduleExponential(= scheduleExponential;
const scheduleAddDelay = exports.scheduleAddDelay = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns a new `MicroSchedule` with an added calculated delay to each delay
returned by this schedule.

@since 3.4.6
@experimental
@category scheduling

## orDie

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `orDie(= orDie;
const orElseSucceed = exports.orElseSucceed = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Transform a `MicroSchedule` to one that will have a delay that will never exceed
the specified maximum.

@since 3.4.6
@experimental
@category scheduling
/
const scheduleWithMaxDelay = exports.scheduleWithMaxDelay = /*#__PURE__*/(0, _Function.dual)(2, (self, max) => (attempt, elapsed) => Option.map(self(attempt, elapsed), duration => Math.min(duration, max)));
/**
Transform a `MicroSchedule` to one that will stop repeating after the specified
amount of time.

@since 3.4.6
@experimental
@category scheduling
/
const scheduleWithMaxElapsed = exports.scheduleWithMaxElapsed = /*#__PURE__*/(0, _Function.dual)(2, (self, max) => (attempt, elapsed) => elapsed < max ? self(attempt, elapsed) : Option.none());
/**
Combines two `MicroSchedule`s, by recurring if either schedule wants to
recur, using the minimum of the two durations between recurrences.

@since 3.4.6
@experimental
@category scheduling
/
const scheduleUnion = exports.scheduleUnion = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => (attempt, elapsed) => Option.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2) => Math.min(d1, d2)));
/**
Combines two `MicroSchedule`s, by recurring only if both schedules want to
recur, using the maximum of the two durations between recurrences.

@since 3.4.6
@experimental
@category scheduling
/
const scheduleIntersect = exports.scheduleIntersect = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => (attempt, elapsed) => Option.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2) => Math.max(d1, d2)));
// ----------------------------------------------------------------------------
// error handling
// ----------------------------------------------------------------------------
/**
Catch the full `MicroCause` object of the given `Micro` effect, allowing you to
recover from any kind of cause.

@since 3.4.6
@experimental
@category error handling
/
const catchAllCause = exports.catchAllCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const onFailure = Object.create(OnFailureProto);
  onFailure[args] = self;
  onFailure[failureCont] = f;
  return onFailure;
});
const OnFailureProto = /*#__PURE__*/makePrimitiveProto({
  op: "OnFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
/**
Selectively catch a `MicroCause` object of the given `Micro` effect,
using the provided predicate to determine if the failure should be caught.

@since 3.4.6
@experimental
@category error handling
/
const catchCauseIf = exports.catchCauseIf = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, f) => catchAllCause(self, cause => predicate(cause) ? f(cause) : failCause(cause)));
/**
Catch the error of the given `Micro` effect, allowing you to recover from it.

It only catches expected errors.

@since 3.4.6
@experimental
@category error handling
/
const catchAll = exports.catchAll = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchCauseIf(self, causeIsFail, cause => f(cause.error)));
/**
Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.

@since 3.4.6
@experimental
@category error handling
/
const catchAllDefect = exports.catchAllDefect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchCauseIf(self, causeIsDie, die => f(die.defect)));
/**
Perform a side effect using the full `MicroCause` object of the given `Micro`.

@since 3.4.6
@experimental
@category error handling
/
const tapErrorCause = exports.tapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => tapErrorCauseIf(self, _Function.constTrue, f));
/**
Perform a side effect using if a `MicroCause` object matches the specified
predicate.

@since 3.4.0
@experimental
@category error handling
/
const tapErrorCauseIf = exports.tapErrorCauseIf = /*#__PURE__*/(0, _Function.dual)(3, (self, refinement, f) => catchCauseIf(self, refinement, cause => andThen(f(cause), failCause(cause))));
/**
Perform a side effect from expected errors of the given `Micro`.

@since 3.4.6
@experimental
@category error handling
/
const tapError = exports.tapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => tapErrorCauseIf(self, causeIsFail, fail => f(fail.error)));
/**
Perform a side effect from unexpected errors of the given `Micro`.

@since 3.4.6
@experimental
@category error handling
/
const tapDefect = exports.tapDefect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => tapErrorCauseIf(self, causeIsDie, die => f(die.defect)));
/**
Catch any expected errors that match the specified predicate.

@since 3.4.0
@experimental
@category error handling
/
const catchIf = exports.catchIf = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, f) => catchCauseIf(self, f => causeIsFail(f) && predicate(f.error), fail => f(fail.error)));
/**
Recovers from the specified tagged error.

@since 3.4.0
@experimental
@category error handling
/
const catchTag = exports.catchTag = /*#__PURE__*/(0, _Function.dual)(3, (self, k, f) => catchIf(self, (0, _Predicate.isTagged)(k), f));
/**
Transform the full `MicroCause` object of the given `Micro` effect.

@since 3.4.6
@experimental
@category error handling
/
const mapErrorCause = exports.mapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAllCause(self, cause => failCause(f(cause))));
/**
Transform any expected errors of the given `Micro` effect.

@since 3.4.0
@experimental
@category error handling
/
const mapError = exports.mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAll(self, error => fail(f(error))));
/**
Elevate any expected errors of the given `Micro` effect to unexpected errors,
resulting in an error type of `never`.

@since 3.4.0
@experimental
@category error handling
/
const orDie = self => catchAll(self, die);
/**
Recover from all errors by succeeding with the given value.

@since 3.4.0
@experimental
@category error handling

## ignore

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `ignore(= ignore;
const ignoreLogged = self => matchEffect(self, {
  // eslint-disable-next-line no-console
  onFailure: error => sync(()`

JSDoc:

Ignore any expected errors of the given `Micro` effect, returning `void`.

@since 3.4.0
@experimental
@category error handling
/
const ignore = self => matchEffect(self, {
  onFailure: _ => void_,
  onSuccess: _ => void_
});
/**
Ignore any expected errors of the given `Micro` effect, returning `void`.

@since 3.4.0
@experimental
@category error handling

## ignoreLogged

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `ignoreLogged(= ignoreLogged;
const option = self => match(self, {
  onFailure: Option.none,
  onSuccess: Option.some
})`

JSDoc:

Replace the success value of the given `Micro` effect with an `Option`,
wrapping the success value in `Some` and returning `None` if the effect fails
with an expected error.

@since 3.4.0
@experimental
@category error handling

## option

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `option(= option;
const either = self => match(self, {
  onFailure: Either.left,
  onSuccess: Either.right
})`

JSDoc:

Replace the success value of the given `Micro` effect with an `Either`,
wrapping the success value in `Right` and wrapping any expected errors with
a `Left`.

@since 3.4.0
@experimental
@category error handling

## either

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `either(= either;
const retry = exports.retry = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Retry the given `Micro` effect using the provided options.

@since 3.4.0
@experimental
@category error handling

## withTrace

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `withTrace(= withTrace;
const matchCauseEffect = exports.matchCauseEffect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Add a stack trace to any failures that occur in the effect. The trace will be
added to the `traces` field of the `MicroCause` object.

@since 3.4.0
@experimental
@category error handling
/
const withTrace = function () {
  const prevLimit = globalThis.Error.stackTraceLimit;
  globalThis.Error.stackTraceLimit = 2;
  const error = new globalThis.Error();
  globalThis.Error.stackTraceLimit = prevLimit;
  function generate(name, cause) {
    const stack = error.stack;
    if (!stack) {
      return cause;
    }
    const line = stack.split("\n")[2]?.trim().replace(/^at /, "");
    if (!line) {
      return cause;
    }
    const lineMatch = line.match(/\((.*)\)$/);
    return causeWithTrace(cause, `at ${name} (${lineMatch ? lineMatch[1] : line})`);
  }
  const f = name => self => onError(self, cause => failCause(generate(name, cause)));
  if (arguments.length === 2) {
    return f(arguments[1])(arguments[0]);
  }
  return f(arguments[0]);
};
// ----------------------------------------------------------------------------
// pattern matching
// ----------------------------------------------------------------------------
/**
@since 3.4.6
@experimental
@category pattern matching

## sleep

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `sleep(= sleep;
const delay = exports.delay = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 3.4.6
@experimental
@category pattern matching
/
const matchCause = exports.matchCause = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => matchCauseEffect(self, {
  onFailure: cause => sync(() => options.onFailure(cause)),
  onSuccess: value => sync(() => options.onSuccess(value))
}));
/**
@since 3.4.6
@experimental
@category pattern matching
/
const matchEffect = exports.matchEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => matchCauseEffect(self, {
  onFailure: cause => cause._tag === "Fail" ? options.onFailure(cause.error) : failCause(cause),
  onSuccess: options.onSuccess
}));
/**
@since 3.4.0
@experimental
@category pattern matching
/
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => matchEffect(self, {
  onFailure: error => sync(() => options.onFailure(error)),
  onSuccess: value => sync(() => options.onSuccess(value))
}));
// ----------------------------------------------------------------------------
// delays & timeouts
// ----------------------------------------------------------------------------
/**
Create a `Micro` effect that will sleep for the specified duration.

@since 3.4.0
@experimental
@category delays & timeouts
/
const sleep = millis => async(resume => {
  const timeout = setTimeout(() => {
    resume(void_);
  }, millis);
  return sync(() => {
    clearTimeout(timeout);
  });
});
/**
Returns an effect that will delay the execution of this effect by the
specified duration.

@since 3.4.0
@experimental
@category delays & timeouts

## scopeUnsafeMake

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `scopeUnsafeMake(= scopeUnsafeMake;
const scope = exports.scope = /*#__PURE__*/service(MicroScope)`

JSDoc:

Returns an effect that will timeout this effect, that will execute the
fallback effect if the timeout elapses before the effect has produced a value.

If the timeout elapses, the running effect will be safely interrupted.

@since 3.4.0
@experimental
@category delays & timeouts
/
const timeoutOrElse = exports.timeoutOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => raceFirst(self, andThen(interruptible(sleep(options.duration)), options.onTimeout)));
/**
Returns an effect that will timeout this effect, that will fail with a
`TimeoutException` if the timeout elapses before the effect has produced a
value.

If the timeout elapses, the running effect will be safely interrupted.

@since 3.4.0
@experimental
@category delays & timeouts
/
const timeout = exports.timeout = /*#__PURE__*/(0, _Function.dual)(2, (self, millis) => timeoutOrElse(self, {
  duration: millis,
  onTimeout: () => fail(new TimeoutException())
}));
/**
Returns an effect that will timeout this effect, succeeding with a `None`
if the timeout elapses before the effect has produced a value; and `Some` of
the produced value otherwise.

If the timeout elapses, the running effect will be safely interrupted.

@since 3.4.0
@experimental
@category delays & timeouts
/
const timeoutOption = exports.timeoutOption = /*#__PURE__*/(0, _Function.dual)(2, (self, millis) => raceFirst(asSome(self), as(interruptible(sleep(millis)), Option.none())));
// ----------------------------------------------------------------------------
// resources & finalization
// ----------------------------------------------------------------------------
/**
@since 3.4.0
@experimental
@category resources & finalization
/
const MicroScopeTypeId = exports.MicroScopeTypeId = /*#__PURE__*/Symbol.for("effect/Micro/MicroScope");
/**
@since 3.4.0
@experimental
@category resources & finalization
/
const MicroScope = exports.MicroScope = /*#__PURE__*/Context.GenericTag("effect/Micro/MicroScope");
class MicroScopeImpl {
  [MicroScopeTypeId];
  state = {
    _tag: "Open",
    finalizers: /*#__PURE__*/new Set()
  };
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer);
    }
  }
  addFinalizer(finalizer) {
    return suspend(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer);
        return void_;
      }
      return finalizer(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer);
    }
  }
  close(microExit) {
    return suspend(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap(forEach(finalizers, finalizer => exit(finalizer(microExit))), exitVoidAll);
      }
      return void_;
    });
  }
  get fork() {
    return sync(() => {
      const newScope = new MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit) {
        return newScope.close(exit);
      }
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer(_ => sync(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
}
/**
@since 3.4.0
@experimental
@category resources & finalization
/
const scopeMake = exports.scopeMake = /*#__PURE__*/sync(() => new MicroScopeImpl());
/**
@since 3.4.0
@experimental
@category resources & finalization
/
const scopeUnsafeMake = () => new MicroScopeImpl();
/**
Access the current `MicroScope`.

@since 3.4.0
@experimental
@category resources & finalization

## scoped

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `scoped(= scoped;
const acquireRelease = (acquire, release)`

JSDoc:

Provide a `MicroScope` to an effect.

@since 3.4.0
@experimental
@category resources & finalization
/
const provideScope = exports.provideScope = /*#__PURE__*/(0, _Function.dual)(2, (self, scope) => provideService(self, MicroScope, scope));
/**
Provide a `MicroScope` to the given effect, closing it after the effect has
finished executing.

@since 3.4.0
@experimental
@category resources & finalization
/
const scoped = self => suspend(() => {
  const scope = new MicroScopeImpl();
  return onExit(provideService(self, MicroScope, scope), exit => scope.close(exit));
});
/**
Create a resource with a cleanup `Micro` effect, ensuring the cleanup is
executed when the `MicroScope` is closed.

@since 3.4.0
@experimental
@category resources & finalization

## acquireRelease

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `acquireRelease(= acquireRelease;
const addFinalizer = finalizer => flatMap(scope, scope => scope.addFinalizer(finalizer)`

JSDoc:

Add a finalizer to the current `MicroScope`.

@since 3.4.0
@experimental
@category resources & finalization

## addFinalizer

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `addFinalizer(= addFinalizer;
const onExit = exports.onExit = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

When the `Micro` effect is completed, run the given finalizer effect with the
`MicroExit` of the executed effect.

@since 3.4.6
@experimental
@category resources & finalization

## acquireUseRelease

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `acquireUseRelease(= acquireUseRelease;
const interrupt = exports.interrupt = /*#__PURE__*/failCause(/*#__PURE__*/causeInterrupt()`

JSDoc:

Regardless of the result of the this `Micro` effect, run the finalizer effect.

@since 3.4.0
@experimental
@category resources & finalization
/
const ensuring = exports.ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => onExit(self, _ => finalizer));
/**
When the `Micro` effect is completed, run the given finalizer effect if it
matches the specified predicate.

@since 3.4.6
@experimental
@category resources & finalization
/
const onExitIf = exports.onExitIf = /*#__PURE__*/(0, _Function.dual)(3, (self, refinement, f) => onExit(self, exit => refinement(exit) ? f(exit) : exitVoid));
/**
When the `Micro` effect fails, run the given finalizer effect with the
`MicroCause` of the executed effect.

@since 3.4.6
@experimental
@category resources & finalization
/
const onError = exports.onError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => onExitIf(self, exitIsFailure, exit => f(exit.cause)));
/**
If this `Micro` effect is aborted, run the finalizer effect.

@since 3.4.6
@experimental
@category resources & finalization
/
const onInterrupt = exports.onInterrupt = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => onExitIf(self, exitIsInterrupt, _ => finalizer));
/**
Acquire a resource, use it, and then release the resource when the `use`
effect has completed.

@since 3.4.0
@experimental
@category resources & finalization
/
const acquireUseRelease = (acquire, use, release) => uninterruptibleMask(restore => flatMap(acquire, a => flatMap(exit(restore(use(a))), exit => andThen(release(a, exit), exit))));
// ----------------------------------------------------------------------------
// interruption
// ----------------------------------------------------------------------------
/**
Abort the current `Micro` effect.

@since 3.4.6
@experimental
@category interruption

## interruptible

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `interruptible(= interruptible;
const uninterruptibleMask = f => withMicroFiber(fiber => {
  if (!fiber.interruptible)`

JSDoc:

Flag the effect as uninterruptible, which means that when the effect is
interrupted, it will be allowed to continue running until completion.

@since 3.4.0
@experimental
@category flags
/
const uninterruptible = self => withMicroFiber(fiber => {
  if (!fiber.interruptible) return self;
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return self;
});
exports.uninterruptible = uninterruptible;
const setInterruptible = /*#__PURE__*/makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt;
    }
  }
});
/**
Flag the effect as interruptible, which means that when the effect is
interrupted, it will be interrupted immediately.

@since 3.4.0
@experimental
@category flags
/
const interruptible = self => withMicroFiber(fiber => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt;
  return self;
});
/**
Wrap the given `Micro` effect in an uninterruptible region, preventing the
effect from being aborted.

You can use the `restore` function to restore a `Micro` effect to the
interruptibility state before the `uninterruptibleMask` was applied.

@example
```ts
import * as Micro from "effect/Micro"

Micro.uninterruptibleMask((restore) =>
  Micro.sleep(1000).pipe( // uninterruptible
    Micro.andThen(restore(Micro.sleep(1000))) // interruptible
  )
)
```

@since 3.4.0
@experimental
@category interruption

## uninterruptibleMask

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `uninterruptibleMask(= uninterruptibleMask;
const all = (arg, options)`

JSDoc:

Runs all the provided effects in sequence respecting the structure provided in input.

Supports multiple arguments, a single argument tuple / array or record / struct.

@since 3.4.0
@experimental
@category collecting & elements

## all

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `all(= all;
const whileLoop = exports.whileLoop = /*#__PURE__*/makePrimitive({
  op: "While",
  contA(value, fiber)`

JSDoc:

@since 3.11.0
@experimental
@category collecting & elements

## forEach

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `forEach(= forEach;
const filter = (iterable, f, options)`

JSDoc:

For each element of the provided iterable, run the effect and collect the
results.

If the `discard` option is set to `true`, the results will be discarded and
the effect will return `void`.

The `concurrency` option can be set to control how many effects are run
concurrently. By default, the effects are run sequentially.

@since 3.4.0
@experimental
@category collecting & elements
/
const forEach = (iterable, f, options) => withMicroFiber(parent => {
  const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = Arr.fromIterable(iterable);
  let length = items.length;
  if (length === 0) {
    return options?.discard ? void_ : succeed([]);
  }
  const out = options?.discard ? undefined : new Array(length);
  let index = 0;
  if (concurrency === 1) {
    return as(whileLoop({
      while: () => index < items.length,
      body: () => f(items[index], index),
      step: out ? b => out[index++] = b : _ => index++
    }), out);
  }
  return async(resume => {
    const fibers = new Set();
    let result = undefined;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index < length) {
        const currentIndex = index;
        const item = items[currentIndex];
        index++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f(item, currentIndex), true, true);
          fibers.add(child);
          child.addObserver(exit => {
            fibers.delete(child);
            if (interrupted) {
              return;
            } else if (exit._tag === "Failure") {
              if (result === undefined) {
                result = exit;
                length = index;
                fibers.forEach(fiber => fiber.unsafeInterrupt());
              }
            } else if (out !== undefined) {
              out[currentIndex] = exit.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length) {
              resume(result ?? succeed(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err) {
          result = exitDie(err);
          length = index;
          fibers.forEach(fiber => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    pump();
    return suspend(() => {
      interrupted = true;
      index = length;
      return fiberInterruptAll(fibers);
    });
  });
});
/**
Effectfully filter the elements of the provided iterable.

Use the `concurrency` option to control how many elements are processed
concurrently.

@since 3.4.0
@experimental
@category collecting & elements

## filter

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `filter(= filter;
const filterMap = (iterable, f, options)`

JSDoc:

Effectfully filter the elements of the provided iterable.

Use the `concurrency` option to control how many elements are processed
concurrently.

@since 3.4.0
@experimental
@category collecting & elements

## filterMap

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `filterMap(= filterMap;
const Do = exports.Do = /*#__PURE__*/succeed({})`

JSDoc:

Start a do notation block.

@since 3.4.0
@experimental
@category do notation

## forkDaemon

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `forkDaemon(= forkDaemon;
const forkIn = exports.forkIn = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Bind the success value of this `Micro` effect to the provided name.

@since 3.4.0
@experimental
@category do notation
/
const bindTo = exports.bindTo = /*#__PURE__*/doNotation.bindTo(map);
/**
Bind the success value of this `Micro` effect to the provided name.

@since 3.4.0
@experimental
@category do notation
/
const bind = exports.bind = /*#__PURE__*/doNotation.bind(map, flatMap);
const let_ = exports.let = /*#__PURE__*/doNotation.let_(map);
// ----------------------------------------------------------------------------
// fibers & forking
// ----------------------------------------------------------------------------
/**
Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

When the parent `Micro` finishes, this `Micro` will be aborted.

@since 3.4.0
@experimental
@category fiber & forking
/
const fork = self => withMicroFiber(fiber => {
  fiberMiddleware.interruptChildren ??= fiberInterruptChildren;
  return succeed(unsafeFork(fiber, self));
});
exports.fork = fork;
const unsafeFork = (parent, effect, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect), 0);
  }
  return child;
};
/**
Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

It will not be aborted when the parent `Micro` finishes.

@since 3.4.0
@experimental
@category fiber & forking
/
const forkDaemon = self => withMicroFiber(fiber => succeed(unsafeFork(fiber, self, false, true)));
/**
Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

The lifetime of the handle will be attached to the provided `MicroScope`.

@since 3.4.0
@experimental
@category fiber & forking

## forkScoped

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `forkScoped(= forkScoped;
const runFork = (effect, options)`

JSDoc:

Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or
aborted.

The lifetime of the handle will be attached to the current `MicroScope`.

@since 3.4.0
@experimental
@category fiber & forking
/
const forkScoped = self => flatMap(scope, scope => forkIn(self, scope));
// ----------------------------------------------------------------------------
// execution
// ----------------------------------------------------------------------------
/**
Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,
or aborted.

You can listen for the result by adding an observer using the handle's
`addObserver` method.

@example
```ts
import * as Micro from "effect/Micro"

const handle = Micro.succeed(42).pipe(
  Micro.delay(1000),
  Micro.runFork
)

handle.addObserver((exit) => {
  console.log(exit)
})
```

@since 3.4.0
@experimental
@category execution

## runFork

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `runFork(= runFork;
const runPromiseExit = (effect, options)`

JSDoc:

Execute the `Micro` effect and return a `Promise` that resolves with the
`MicroExit` of the computation.

@since 3.4.6
@experimental
@category execution

## runPromiseExit

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `runPromiseExit(= runPromiseExit;
const runPromise = (effect, options)`

JSDoc:

Execute the `Micro` effect and return a `Promise` that resolves with the
successful value of the computation.

@since 3.4.0
@experimental
@category execution

## runPromise

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `runPromise(= runPromise;
const runSyncExit = effect => {
  const scheduler = new MicroSchedulerDefault()`

JSDoc:

Attempt to execute the `Micro` effect synchronously and return the `MicroExit`.

If any asynchronous effects are encountered, the function will return a
`CauseDie` containing the `MicroFiber`.

@since 3.4.6
@experimental
@category execution

## runSyncExit

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `runSyncExit(= runSyncExit;
const runSync = effect => {
  const exit = runSyncExit(effect)`

JSDoc:

Attempt to execute the `Micro` effect synchronously and return the success
value.

@since 3.4.0
@experimental
@category execution

## TaggedError

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `TaggedError(= TaggedError;
class NoSuchElementException extends /*#__PURE__*/TaggedError("NoSuchElementException")`

JSDoc:

@since 3.4.0
@experimental
@category errors
/
const Error = exports.Error = /*#__PURE__*/function () {
  return class extends YieldableError {
    constructor(args) {
      super();
      if (args) {
        Object.assign(this, args);
      }
    }
  };
}();
/**
@since 3.4.0
@experimental
@category errors
/
const TaggedError = tag => {
  class Base extends Error {
    _tag = tag;
  }
  ;
  Base.prototype.name = tag;
  return Base;
};
/**
Represents a checked exception which occurs when an expected element was
unable to be found.

@since 3.4.4
@experimental
@category errors

## NoSuchElementException

Source: `my-backend/node_modules/effect/dist/cjs/Micro.js`

Signature: `NoSuchElementException(= NoSuchElementException;
class TimeoutException extends /*#__PURE__*/TaggedError("TimeoutException")`

JSDoc:

Represents a checked exception which occurs when a timeout occurs.

@since 3.4.4
@experimental
@category errors

## empty

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashMap.js`

Signature: `empty(= empty;
const make = (...entries)`

JSDoc:

@since 2.0.0
@category constructors
/
const empty = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = new Map();
  self.buckets = new Map();
  self.bucketsSize = 0;
  return self;
};
/**
@since 2.0.0
@category constructors

## make

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashMap.js`

Signature: `make(= make;
const fromIterable = entries => {
  const self = empty()`

JSDoc:

Creates a new `MutableHashMap` from an iterable collection of key/value pairs.

@since 2.0.0
@category constructors

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashMap.js`

Signature: `fromIterable(= fromIterable;
const get = exports.get = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 2.0.0
@category elements

## keys

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashMap.js`

Signature: `keys(= keys;
const values = self => {
  const values = Array.from(self.referential.values()`

JSDoc:

@since 3.8.0
@category elements
/
const keys = self => {
  const keys = Array.from(self.referential.keys());
  for (const bucket of self.buckets.values()) {
    for (let i = 0, len = bucket.length; i < len; i++) {
      keys.push(bucket[i][0]);
    }
  }
  return keys;
};
/**
@since 3.8.0
@category elements

## clear

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashMap.js`

Signature: `clear(= clear;
const size = self => {
  return self.referential.size + self.bucketsSize;
};
/**
 * @since 2.0.0
 */
exports.size = size;
const isEmpty = self => size(self)`

JSDoc:

@since 2.0.0
@category elements
/
const has = exports.has = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => Option.isSome(get(self, key)));
/**
@since 2.0.0
/
const set = exports.set = /*#__PURE__*/(0, _Function.dual)(3, (self, key, value) => {
  if (Equal.isEqual(key) === false) {
    self.referential.set(key, value);
    return self;
  }
  const hash = key[Hash.symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    self.buckets.set(hash, [[key, value]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value]);
  self.bucketsSize++;
  return self;
});
const removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[Equal.symbol](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};
/**
Updates the value of the specified key within the `MutableHashMap` if it exists.

@since 2.0.0
/
const modify = exports.modify = /*#__PURE__*/(0, _Function.dual)(3, (self, key, f) => {
  if (Equal.isEqual(key) === false) {
    if (self.referential.has(key)) {
      self.referential.set(key, f(self.referential.get(key)));
    }
    return self;
  }
  const hash = key[Hash.symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    return self;
  }
  const value = getFromBucket(self, bucket, key, true);
  if (Option.isNone(value)) {
    return self;
  }
  bucket.push([key, f(value.value)]);
  self.bucketsSize++;
  return self;
});
/**
Set or remove the specified key in the `MutableHashMap` using the specified
update function.

@since 2.0.0
/
const modifyAt = exports.modifyAt = /*#__PURE__*/(0, _Function.dual)(3, (self, key, f) => {
  if (Equal.isEqual(key) === false) {
    const result = f(get(self, key));
    if (Option.isSome(result)) {
      set(self, key, result.value);
    } else {
      remove(self, key);
    }
    return self;
  }
  const hash = key[Hash.symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    const result = f(Option.none());
    return Option.isSome(result) ? set(self, key, result.value) : self;
  }
  const result = f(getFromBucket(self, bucket, key, true));
  if (Option.isNone(result)) {
    if (bucket.length === 0) {
      self.buckets.delete(hash);
    }
    return self;
  }
  bucket.push([key, result.value]);
  self.bucketsSize++;
  return self;
});
/**
@since 2.0.0
/
const remove = exports.remove = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => {
  if (Equal.isEqual(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash = key[Hash.symbol]();
  const bucket = self.buckets.get(hash);
  if (bucket === undefined) {
    return self;
  }
  removeFromBucket(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash);
  }
  return self;
});
/**
@since 2.0.0
/
const clear = self => {
  self.referential.clear();
  self.buckets.clear();
  self.bucketsSize = 0;
  return self;
};
/**
@since 2.0.0
@category elements

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashMap.js`

Signature: `isEmpty(= isEmpty;
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 2.0.0

## empty

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashSet.js`

Signature: `empty(= empty;
const fromIterable = keys => fromHashMap(MutableHashMap.fromIterable(Array.from(keys)`

JSDoc:

# MutableHashSet

A mutable `MutableHashSet` provides a collection of unique values with
efficient lookup, insertion and removal. Unlike its immutable sibling
{@link module:HashSet}, a `MutableHashSet` can be modified in-place;
operations like add, remove, and clear directly modify the original set
rather than creating a new one. This mutability offers benefits like improved
performance in scenarios where you need to build or modify a set
incrementally.

## What Problem Does It Solve?

`MutableHashSet` solves the problem of maintaining an unsorted collection
where each value appears exactly once, with fast operations for checking
membership and adding/removing values, in contexts where mutability is
preferred for performance or implementation simplicity.

## When to Use

Use `MutableHashSet` when you need:

- A collection with no duplicate values
- Efficient membership testing (**`O(1)`** average complexity)
- In-place modifications for better performance
- A set that will be built or modified incrementally
- Local mutability in otherwise immutable code

## Advanced Features

MutableHashSet provides operations for:

- Adding and removing elements with direct mutation
- Checking for element existence
- Clearing all elements at once
- Converting to/from other collection types

## Performance Characteristics

- **Lookup** operations ({@link module:MutableHashSet.has}): **`O(1)`** average
  time complexity
- **Insertion** operations ({@link module:MutableHashSet.add}): **`O(1)`**
  average time complexity
- **Removal** operations ({@link module:MutableHashSet.remove}): **`O(1)`**
  average time complexity
- **Iteration**: **`O(n)`** where n is the size of the set

The MutableHashSet data structure implements the following traits:

- {@link Iterable}: allows iterating over the values in the set
- {@link Pipeable}: allows chaining operations with the pipe operator
- {@link Inspectable}: allows inspecting the contents of the set

## Operations Reference

| Category     | Operation                                  | Description                         | Complexity |
| ------------ | ------------------------------------------ | ----------------------------------- | ---------- |
| constructors | {@link module:MutableHashSet.empty}        | Creates an empty MutableHashSet     | O(1)       |
| constructors | {@link module:MutableHashSet.fromIterable} | Creates a set from an iterable      | O(n)       |
| constructors | {@link module:MutableHashSet.make}         | Creates a set from multiple values  | O(n)       |
|              |                                            |                                     |            |
| elements     | {@link module:MutableHashSet.has}          | Checks if a value exists in the set | O(1) avg   |
| elements     | {@link module:MutableHashSet.add}          | Adds a value to the set             | O(1) avg   |
| elements     | {@link module:MutableHashSet.remove}       | Removes a value from the set        | O(1) avg   |
| elements     | {@link module:MutableHashSet.size}         | Gets the number of elements         | O(1)       |
| elements     | {@link module:MutableHashSet.clear}        | Removes all values from the set     | O(1)       |

## Notes

### Mutability Considerations:

Unlike most data structures in the Effect ecosystem, `MutableHashSet` is
mutable. This means that operations like `add`, `remove`, and `clear` modify
the original set rather than creating a new one. This can lead to more
efficient code in some scenarios, but requires careful handling to avoid
unexpected side effects.

### When to Choose `MutableHashSet` vs {@link module:HashSet}:

- Use `MutableHashSet` when you need to build or modify a set incrementally and
  performance is a priority
- Use `HashSet` when you want immutability guarantees and functional
  programming patterns
- Consider using {@link module:HashSet}'s bounded mutation context (via
  {@link module:HashSet.beginMutation}, {@link module:HashSet.endMutation}, and
  {@link module:HashSet.mutate} methods) when you need temporary mutability
  within an otherwise immutable context - this approach might be sufficient
  for many use cases without requiring a separate `MutableHashSet`
- `MutableHashSet` is often useful for local operations where the mutability is
  contained and doesn't leak into the broader application

@module MutableHashSet
@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/MutableHashSet");
const MutableHashSetProto = {
  [TypeId]: TypeId,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const fromHashMap = keyMap => {
  const set = Object.create(MutableHashSetProto);
  set.keyMap = keyMap;
  return set;
};
/**
Creates an empty mutable hash set.

This function initializes and returns an empty `MutableHashSet` instance,
which allows for efficient storage and manipulation of unique elements.

Time complexity: **`O(1)`**

@memberof MutableHashSet
@since 2.0.0
@category constructors
@example

```ts
import { MutableHashSet } from "effect"

type T = unknown // replace with your type

// in places where the type can't be inferred, replace with your type
const set: MutableHashSet.MutableHashSet<T> = MutableHashSet.empty<T>()
```

@template K - The type of the elements to be stored in the hash set. Defaults
  to `never` if not specified.
@returns A new mutable instance of `MutableHashSet` containing no elements
  for the specified type `K`.
@see Other `MutableHashSet` constructors are {@link module:MutableHashSet.make} {@link module:MutableHashSet.fromIterable}
/
const empty = () => fromHashMap(MutableHashMap.empty());
/**
Creates a new `MutableHashSet` from an iterable collection of values.
Duplicate values are omitted.

Time complexity: **`O(n)`** where n is the number of elements in the iterable

Creating a `MutableHashSet` from an {@link Array}

```ts
import { MutableHashSet } from "effect"

const array: Iterable<number> = [1, 2, 3, 4, 5, 1, 2, 3] // Array<T> is also Iterable<T>
const mutableHashSet: MutableHashSet.MutableHashSet<number> =
  MutableHashSet.fromIterable(array)

console.log(
  // MutableHashSet.MutableHashSet<T> is also an Iterable<T>
  Array.from(mutableHashSet)
) // Output: [1, 2, 3, 4, 5]
```

Creating a `MutableHashSet` from a {@link Set}

```ts
import { MutableHashSet, pipe } from "effect"

console.log(
  pipe(
    // Set<string> is an Iterable<string>
    new Set(["apple", "banana", "orange", "apple"]),
    // constructs MutableHashSet from an Iterable Set
    MutableHashSet.fromIterable,
    // since MutableHashSet it is itself an Iterable, we can pass it to other functions expecting an Iterable
    Array.from
  )
) // Output: ["apple", "banana", "orange"]
```

Creating a `MutableHashSet` from a {@link Generator}

```ts
import { MutableHashSet } from "effect"

// Generator functions return iterables
function* fibonacci(n: number): Generator<number, void, never> {
  let [a, b] = [0, 1]
  for (let i = 0; i < n; i++) {
    yield a
    ;[a, b] = [b, a + b]
  }
}

// Create a MutableHashSet from the first 10 Fibonacci numbers
const fibonacciSet = MutableHashSet.fromIterable(fibonacci(10))

console.log(Array.from(fibonacciSet))
// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order
```

Creating a `MutableHashSet` from another {@link module:MutableHashSet}

```ts
import { MutableHashSet, pipe } from "effect"

console.log(
  pipe(
    MutableHashSet.make(1, 2, 3, 4),
    MutableHashSet.fromIterable,
    Array.from
  )
) // Output: [1, 2, 3, 4]
```

Creating a `MutableHashSet` from an {@link module:HashSet}

```ts
import { HashSet, MutableHashSet, pipe } from "effect"

console.log(
  pipe(
    HashSet.make(1, 2, 3, 4), // it works also with its immutable HashSet sibling
    MutableHashSet.fromIterable,
    Array.from
  )
) // Output: [1, 2, 3, 4]
```

Creating a `MutableHashSet` from other Effect's data structures like
{@link Chunk}

```ts
import { Chunk, MutableHashSet, pipe } from "effect"

console.log(
  pipe(
    Chunk.make(1, 2, 3, 4), //  Chunk is also an Iterable<T>
    MutableHashSet.fromIterable,
    Array.from
  )
) // Outputs: [1, 2, 3, 4]
```

@memberof MutableHashSet
@since 2.0.0
@category constructors
@template K - The type of elements to be stored in the resulting
  `MutableHashSet`.
@param keys - An `Iterable` collection containing the keys to be added to the
  `MutableHashSet`.
@returns A new `MutableHashSet` containing just the unique elements from the
  provided iterable.
@see Other `MutableHashSet` constructors are {@link module:MutableHashSet.empty} {@link module:MutableHashSet.make}

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashSet.js`

Signature: `fromIterable(= fromIterable;
const make = (...keys)`

JSDoc:

Construct a new `MutableHashSet` from a variable number of values.

Time complexity: **`O(n)`** where n is the number of elements

@memberof MutableHashSet
@since 2.0.0
@category constructors
@example

```ts
import { Equal, Hash, MutableHashSet } from "effect"
import assert from "node:assert/strict"

class Character implements Equal.Equal {
  readonly name: string
  readonly trait: string

  constructor(name: string, trait: string) {
    this.name = name
    this.trait = trait
  }

  // Define equality based on name, and trait
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Character) {
      return (
        Equal.equals(this.name, that.name) &&
        Equal.equals(this.trait, that.trait)
      )
    }
    return false
  }

  // Generate a hash code based on the sum of the character's name and trait
  [Hash.symbol](): number {
    return Hash.hash(this.name + this.trait)
  }

  static readonly of = (name: string, trait: string): Character => {
    return new Character(name, trait)
  }
}

const mutableCharacterHashSet = MutableHashSet.make(
  Character.of("Alice", "Curious"),
  Character.of("Alice", "Curious"),
  Character.of("White Rabbit", "Always late"),
  Character.of("Mad Hatter", "Tea enthusiast")
)

assert.equal(
  MutableHashSet.has(
    mutableCharacterHashSet,
    Character.of("Alice", "Curious")
  ),
  true
)
assert.equal(
  MutableHashSet.has(
    mutableCharacterHashSet,
    Character.of("Fluffy", "Kind")
  ),
  false
)
```

@see Other `MutableHashSet` constructors are {@link module:MutableHashSet.fromIterable} {@link module:MutableHashSet.empty}

## make

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashSet.js`

Signature: `make(= make;
const add = exports.add = /*#__PURE__*/Dual.dual(2, (self, key)`

JSDoc:

**Checks** whether the `MutableHashSet` contains the given element, and
**adds** it if not.

Time complexity: **`O(1)`** average

**Syntax**

```ts
import { MutableHashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(
  MutableHashSet.empty(),
  MutableHashSet.add(0),
  MutableHashSet.add(0)
)

// or piped with the pipe function
MutableHashSet.empty().pipe(MutableHashSet.add(0))

// or with data-first API
MutableHashSet.add(MutableHashSet.empty(), 0)
```

@memberof MutableHashSet
@since 2.0.0
@category elements
@see Other `MutableHashSet` elements are {@link module:MutableHashSet.remove} {@link module:MutableHashSet.size} {@link module:MutableHashSet.clear} {@link module:MutableHashSet.has}

## size

Source: `my-backend/node_modules/effect/dist/cjs/MutableHashSet.js`

Signature: `size(= size;
const clear = self => (MutableHashMap.clear(self.keyMap)`

JSDoc:

Checks if the specified value exists in the `MutableHashSet`.

Time complexity: `O(1)` average

**Syntax**

```ts
import { MutableHashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.equal(
  // with `data-last`, a.k.a. `pipeable` API
  pipe(MutableHashSet.make(0, 1, 2), MutableHashSet.has(3)),
  false
)

assert.equal(
  // or piped with the pipe function
  MutableHashSet.make(0, 1, 2).pipe(MutableHashSet.has(3)),
  false
)

assert.equal(
  // or with `data-first` API
  MutableHashSet.has(MutableHashSet.make(0, 1, 2), 3),
  false
)
```

@memberof MutableHashSet
@since 2.0.0
@category elements
@see Other `MutableHashSet` elements are {@link module:MutableHashSet.add} {@link module:MutableHashSet.remove} {@link module:MutableHashSet.size} {@link module:MutableHashSet.clear}
/
const has = exports.has = /*#__PURE__*/Dual.dual(2, (self, key) => MutableHashMap.has(self.keyMap, key));
/**
Removes a value from the `MutableHashSet`.

Time complexity: **`O(1)`** average

**Syntax**

```ts
import { MutableHashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.equal(
  // with `data-last`, a.k.a. `pipeable` API
  pipe(
    MutableHashSet.make(0, 1, 2),
    MutableHashSet.remove(0),
    MutableHashSet.has(0)
  ),
  false
)

assert.equal(
  // or piped with the pipe function
  MutableHashSet.make(0, 1, 2).pipe(
    MutableHashSet.remove(0),
    MutableHashSet.has(0)
  ),
  false
)

assert.equal(
  // or with `data-first` API
  MutableHashSet.remove(MutableHashSet.make(0, 1, 2), 0).pipe(
    MutableHashSet.has(0)
  ),
  false
)
```

@memberof MutableHashSet
@since 2.0.0
@category elements
@see Other `MutableHashSet` elements are {@link module:MutableHashSet.add} {@link module:MutableHashSet.has} {@link module:MutableHashSet.size} {@link module:MutableHashSet.clear}
/
const remove = exports.remove = /*#__PURE__*/Dual.dual(2, (self, key) => (MutableHashMap.remove(self.keyMap, key), self));
/**
Calculates the number of values in the `HashSet`.

Time complexity: **`O(1)`**

@memberof MutableHashSet
@since 2.0.0
@category elements
@example

```ts
import { MutableHashSet } from "effect"
import assert from "node:assert/strict"

assert.equal(MutableHashSet.size(MutableHashSet.empty()), 0)

assert.equal(
  MutableHashSet.size(MutableHashSet.make(1, 2, 2, 3, 4, 3)),
  4
)
```

@template V - The type of the elements to be stored in the `MutableHashSet`.
@param self - The `MutableHashSet` instance for which the size is to be
  determined.
@returns The total number of elements within the `MutableHashSet`.
@see Other `MutableHashSet` elements are {@link module:MutableHashSet.add} {@link module:MutableHashSet.has} {@link module:MutableHashSet.remove} {@link module:MutableHashSet.clear}
/
const size = self => MutableHashMap.size(self.keyMap);
/**
Removes all values from the `MutableHashSet`.

This function operates by delegating the clearing action to the underlying
key map associated with the given `MutableHashSet`. It ensures that the hash
set becomes empty while maintaining its existence and structure.

@memberof MutableHashSet
@since 2.0.0
@category elements
@example

```ts
import { MutableHashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.deepStrictEqual(
  pipe(
    MutableHashSet.make(1, 2, 3, 4),
    MutableHashSet.clear,
    MutableHashSet.size
  ),
  0
)
```

@param self - The `MutableHashSet` to clear.
@returns The same `MutableHashSet` after all elements have been removed.
@see Other `MutableHashSet` elements are {@link module:MutableHashSet.add} {@link module:MutableHashSet.has} {@link module:MutableHashSet.remove} {@link module:MutableHashSet.size}

## empty

Source: `my-backend/node_modules/effect/dist/cjs/MutableList.js`

Signature: `empty(= empty;
const fromIterable = iterable => {
  const list = empty()`

JSDoc:

@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/MutableList");
const MutableListProto = {
  [TypeId]: TypeId,
  [Symbol.iterator]() {
    let done = false;
    let head = this.head;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (head == null) {
          done = true;
          return this.return();
        }
        const value = head.value;
        head = head.next;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const makeNode = value => ({
  value,
  removed: false,
  prev: undefined,
  next: undefined
});
/**
Creates an empty `MutableList`.

@since 2.0.0
@category constructors
/
const empty = () => {
  const list = Object.create(MutableListProto);
  list.head = undefined;
  list.tail = undefined;
  list._length = 0;
  return list;
};
/**
Creates a new `MutableList` from an iterable collection of values.

@since 2.0.0
@category constructors

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/MutableList.js`

Signature: `fromIterable(= fromIterable;
const make = (...elements)`

JSDoc:

Creates a new `MutableList` from the specified elements.

@since 2.0.0
@category constructors

## make

Source: `my-backend/node_modules/effect/dist/cjs/MutableList.js`

Signature: `make(= make;
const isEmpty = self => length(self)`

JSDoc:

Returns `true` if the list contains zero elements, `false`, otherwise.

@since 2.0.0
@category getters

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/MutableList.js`

Signature: `isEmpty(= isEmpty;
const length = self => self._length;
/**
 * Returns the last element of the list, if it exists.
 *
 * @since 2.0.0
 * @category getters
 */
exports.length = length;
const tail = self => self.tail === undefined ? undefined : self.tail.value;
/**
 * Returns the first element of the list, if it exists.
 *
 * @since 2.0.0
 * @category getters
 */
exports.tail = tail;
const head = self => self.head === undefined ? undefined : self.head.value;
/**
 * Executes the specified function `f` for each element in the list.
 *
 * @since 2.0.0
 * @category traversing
 */
exports.head = head;
const forEach = exports.forEach = /*#__PURE__*/Dual.dual(2, (self, f)`

JSDoc:

Returns the length of the list.

@since 2.0.0
@category getters

## reset

Source: `my-backend/node_modules/effect/dist/cjs/MutableList.js`

Signature: `reset(= reset;
const append = exports.append = /*#__PURE__*/Dual.dual(2, (self, value)`

JSDoc:

Removes all elements from the doubly-linked list.

@since 2.0.0
/
const reset = self => {
  ;
  self._length = 0;
  self.head = undefined;
  self.tail = undefined;
  return self;
};
/**
Appends the specified element to the end of the `MutableList`.

@category concatenating
@since 2.0.0

## shift

Source: `my-backend/node_modules/effect/dist/cjs/MutableList.js`

Signature: `shift(= shift;
const pop = self => {
  const tail = self.tail;
  if (tail !== undefined)`

JSDoc:

Removes the first value from the list and returns it, if it exists.

@since 0.0.1
/
const shift = self => {
  const head = self.head;
  if (head !== undefined) {
    remove(self, head);
    return head.value;
  }
  return undefined;
};
/**
Removes the last value from the list and returns it, if it exists.

@since 0.0.1

## pop

Source: `my-backend/node_modules/effect/dist/cjs/MutableList.js`

Signature: `pop(= pop;
const prepend = exports.prepend = /*#__PURE__*/Dual.dual(2, (self, value)`

JSDoc:

Prepends the specified value to the beginning of the list.

@category concatenating
@since 2.0.0

## bounded

Source: `my-backend/node_modules/effect/dist/cjs/MutableQueue.js`

Signature: `bounded(= bounded;
const unbounded = ()`

JSDoc:

@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/MutableQueue");
/**
@since 2.0.0
@category symbol
/
const EmptyMutableQueue = exports.EmptyMutableQueue = /*#__PURE__*/Symbol.for("effect/mutable/MutableQueue/Empty");
const MutableQueueProto = {
  [TypeId]: TypeId,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const make = capacity => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = MutableList.empty();
  queue.capacity = capacity;
  return queue;
};
/**
Creates a new bounded `MutableQueue`.

@since 2.0.0
@category constructors
/
const bounded = capacity => make(capacity);
/**
Creates a new unbounded `MutableQueue`.

@since 2.0.0
@category constructors

## unbounded

Source: `my-backend/node_modules/effect/dist/cjs/MutableQueue.js`

Signature: `unbounded(= unbounded;
const length = self => MutableList.length(self.queue)`

JSDoc:

Returns the current number of elements in the queue.

@since 2.0.0
@category getters

## length

Source: `my-backend/node_modules/effect/dist/cjs/MutableQueue.js`

Signature: `length(= length;
const isEmpty = self => MutableList.isEmpty(self.queue)`

JSDoc:

Returns `true` if the queue is empty, `false` otherwise.

@since 2.0.0
@category getters

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/MutableQueue.js`

Signature: `isEmpty(= isEmpty;
const isFull = self => self.capacity === undefined ? false : MutableList.length(self.queue)`

JSDoc:

Returns `true` if the queue is full, `false` otherwise.

@since 2.0.0
@category getters

## isFull

Source: `my-backend/node_modules/effect/dist/cjs/MutableQueue.js`

Signature: `isFull(= isFull;
const capacity = self => self.capacity === undefined ? Infinity : self.capacity;
/**
 * Offers an element to the queue.
 *
 * Returns whether the enqueue was successful or not.
 *
 * @since 2.0.0
 */
exports.capacity = capacity;
const offer = exports.offer = /*#__PURE__*/Dual.dual(2, (self, value)`

JSDoc:

The **maximum** number of elements that a queue can hold.

**Note**: unbounded queues can still implement this interface with
`capacity = Infinity`.

@since 2.0.0
@category getters

## make

Source: `my-backend/node_modules/effect/dist/cjs/MutableRef.js`

Signature: `make(= make;
const compareAndSet = exports.compareAndSet = /*#__PURE__*/Dual.dual(3, (self, oldValue, newValue)`

JSDoc:

@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/MutableRef");
const MutableRefProto = {
  [TypeId]: TypeId,
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: (0, _Inspectable.toJSON)(this.current)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/**
@since 2.0.0
@category constructors
/
const make = value => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
/**
@since 2.0.0
@category general

## decrement

Source: `my-backend/node_modules/effect/dist/cjs/MutableRef.js`

Signature: `decrement(= decrement;
const decrementAndGet = self => updateAndGet(self, n => n - 1)`

JSDoc:

@since 2.0.0
@category numeric
/
const decrement = self => update(self, n => n - 1);
/**
@since 2.0.0
@category numeric

## decrementAndGet

Source: `my-backend/node_modules/effect/dist/cjs/MutableRef.js`

Signature: `decrementAndGet(= decrementAndGet;
const get = self => self.current;
/**
 * @since 2.0.0
 * @category numeric
 */
exports.get = get;
const getAndDecrement = self => getAndUpdate(self, n => n - 1)`

JSDoc:

@since 2.0.0
@category general

## getAndDecrement

Source: `my-backend/node_modules/effect/dist/cjs/MutableRef.js`

Signature: `getAndDecrement(= getAndDecrement;
const getAndIncrement = self => getAndUpdate(self, n => n + 1)`

JSDoc:

@since 2.0.0
@category numeric

## getAndIncrement

Source: `my-backend/node_modules/effect/dist/cjs/MutableRef.js`

Signature: `getAndIncrement(= getAndIncrement;
const getAndSet = exports.getAndSet = /*#__PURE__*/Dual.dual(2, (self, value)`

JSDoc:

@since 2.0.0
@category general

## increment

Source: `my-backend/node_modules/effect/dist/cjs/MutableRef.js`

Signature: `increment(= increment;
const incrementAndGet = self => updateAndGet(self, n => n + 1)`

JSDoc:

@since 2.0.0
@category general
/
const getAndUpdate = exports.getAndUpdate = /*#__PURE__*/Dual.dual(2, (self, f) => getAndSet(self, f(get(self))));
/**
@since 2.0.0
@category numeric
/
const increment = self => update(self, n => n + 1);
/**
@since 2.0.0
@category numeric

## incrementAndGet

Source: `my-backend/node_modules/effect/dist/cjs/MutableRef.js`

Signature: `incrementAndGet(= incrementAndGet;
const set = exports.set = /*#__PURE__*/Dual.dual(2, (self, value)`

JSDoc:

@since 2.0.0
@category general

## negate

Source: `my-backend/node_modules/effect/dist/cjs/Number.js`

Signature: `negate(= negate;
const sum = exports.sum = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

# Number

This module provides utility functions and type class instances for working
with the `number` type in TypeScript. It includes functions for basic
arithmetic operations, as well as type class instances for `Equivalence` and
`Order`.

## Operations Reference

| Category     | Operation                                  | Description                                             | Domain                         | Co-domain             |
| ------------ | ------------------------------------------ | ------------------------------------------------------- | ------------------------------ | --------------------- |
| constructors | {@link module:Number.parse}                | Safely parses a string to a number                      | `string`                       | `Option<number>`      |
|              |                                            |                                                         |                                |                       |
| math         | {@link module:Number.sum}                  | Adds two numbers                                        | `number`, `number`             | `number`              |
| math         | {@link module:Number.sumAll}               | Sums all numbers in a collection                        | `Iterable<number>`             | `number`              |
| math         | {@link module:Number.subtract}             | Subtracts one number from another                       | `number`, `number`             | `number`              |
| math         | {@link module:Number.multiply}             | Multiplies two numbers                                  | `number`, `number`             | `number`              |
| math         | {@link module:Number.multiplyAll}          | Multiplies all numbers in a collection                  | `Iterable<number>`             | `number`              |
| math         | {@link module:Number.divide}               | Safely divides handling division by zero                | `number`, `number`             | `Option<number>`      |
| math         | {@link module:Number.unsafeDivide}         | Divides but misbehaves for division by zero             | `number`, `number`             | `number`              |
| math         | {@link module:Number.remainder}            | Calculates remainder of division                        | `number`, `number`             | `number`              |
| math         | {@link module:Number.increment}            | Adds 1 to a number                                      | `number`                       | `number`              |
| math         | {@link module:Number.decrement}            | Subtracts 1 from a number                               | `number`                       | `number`              |
| math         | {@link module:Number.sign}                 | Determines the sign of a number                         | `number`                       | `Ordering`            |
| math         | {@link module:Number.nextPow2}             | Finds the next power of 2                               | `number`                       | `number`              |
| math         | {@link module:Number.round}                | Rounds a number with specified precision                | `number`, `number`             | `number`              |
|              |                                            |                                                         |                                |                       |
| predicates   | {@link module:Number.between}              | Checks if a number is in a range                        | `number`, `{minimum, maximum}` | `boolean`             |
| predicates   | {@link module:Number.lessThan}             | Checks if one number is less than another               | `number`, `number`             | `boolean`             |
| predicates   | {@link module:Number.lessThanOrEqualTo}    | Checks if one number is less than or equal              | `number`, `number`             | `boolean`             |
| predicates   | {@link module:Number.greaterThan}          | Checks if one number is greater than another            | `number`, `number`             | `boolean`             |
| predicates   | {@link module:Number.greaterThanOrEqualTo} | Checks if one number is greater or equal                | `number`, `number`             | `boolean`             |
|              |                                            |                                                         |                                |                       |
| guards       | {@link module:Number.isNumber}             | Type guard for JavaScript numbers                       | `unknown`                      | `boolean`             |
|              |                                            |                                                         |                                |                       |
| comparison   | {@link module:Number.min}                  | Returns the minimum of two numbers                      | `number`, `number`             | `number`              |
| comparison   | {@link module:Number.max}                  | Returns the maximum of two numbers                      | `number`, `number`             | `number`              |
| comparison   | {@link module:Number.clamp}                | Restricts a number to a range                           | `number`, `{minimum, maximum}` | `number`              |
|              |                                            |                                                         |                                |                       |
| instances    | {@link module:Number.Equivalence}          | Equivalence instance for numbers                        |                                | `Equivalence<number>` |
| instances    | {@link module:Number.Order}                | Order instance for numbers                              |                                | `Order<number>`       |
|              |                                            |                                                         |                                |                       |
| errors       | {@link module:Number.DivisionByZeroError}  | Error thrown by unsafeDivide                            |                                |                       |

## Composition Patterns and Type Safety

When building function pipelines, understanding how types flow through
operations is critical:

### Composing with type-preserving operations

Most operations in this module are type-preserving (`number  number`),
making them easily composable in pipelines:

```ts
import { pipe } from "effect"
import * as Number from "effect/Number"

const result = pipe(
  10,
  Number.increment, // number  number
  Number.multiply(2), // number  number
  Number.round(1) // number  number
) // Result: number (21)
```

### Working with Option results

Operations that might fail (like division by zero) return Option types and
require Option combinators:

```ts
import { pipe, Option } from "effect"
import * as Number from "effect/Number"

const result = pipe(
  10,
  Number.divide(0), // number  Option<number>
  Option.getOrElse(() => 0) // Option<number>  number
) // Result: number (0)
```

### Composition best practices

- Chain type-preserving operations for maximum composability
- Use Option combinators when working with potentially failing operations
- Consider using Effect for operations that might fail with specific errors
- Remember that all operations maintain JavaScript's floating-point precision
  limitations

@module Number
@since 2.0.0
@see {@link module:BigInt} for more similar operations on `bigint` types
@see {@link module:BigDecimal} for more similar operations on `BigDecimal` types
/

/**
Type guard that tests if a value is a member of the set of JavaScript
numbers.

@memberof Number
@since 2.0.0
@category guards
@example

```ts
import * as assert from "node:assert/strict"
import * as Number from "effect/Number"

// Regular numbers
assert.equal(Number.isNumber(2), true)
assert.equal(Number.isNumber(-3.14), true)
assert.equal(Number.isNumber(0), true)

// Special numeric values
assert.equal(Number.isNumber(Infinity), true)
assert.equal(Number.isNumber(NaN), true)

// Non-number values
assert.equal(Number.isNumber("2"), false)
assert.equal(Number.isNumber(true), false)
assert.equal(Number.isNumber(null), false)
assert.equal(Number.isNumber(undefined), false)
assert.equal(Number.isNumber({}), false)
assert.equal(Number.isNumber([]), false)

// Using as a type guard in conditionals
function processValue(value: unknown): string {
  if (Number.isNumber(value)) {
    // TypeScript now knows 'value' is a number
    return `Numeric value: ${value.toFixed(2)}`
  }
  return "Not a number"
}

assert.strictEqual(processValue(42), "Numeric value: 42.00")
assert.strictEqual(processValue("hello"), "Not a number")

// Filtering for numbers in an array
const mixed = [1, "two", 3, false, 5]
const onlyNumbers = mixed.filter(Number.isNumber)
assert.equal(onlyNumbers, [1, 3, 5])
```

@param input - The value to test for membership in the set of JavaScript
  numbers

@returns `true` if the input is a JavaScript number, `false` otherwise
/
const isNumber = exports.isNumber = predicate.isNumber;
/**
Returns the additive inverse of a number, effectively negating it.

@memberof Number
@since 3.14.6
@example

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

assert.equal(
  Number.negate(5), //
  -5
)

assert.equal(
  Number.negate(-5), //
  5
)

assert.equal(
  Number.negate(0), //
  0
)
```

@param n - The number value to be negated.

@returns The negated number value.
/
const negate = n => multiply(n, -1);
/**
Performs addition in the set of JavaScript numbers.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.sum(2, 3), 5)
assert.equal(Number.sum(-10, 5), -5)
assert.equal(Number.sum(0.1, 0.2), 0.30000000000000004) // Note: floating-point precision limitation

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.sum(5) // 10 + 5 = 15
  ),
  15
)

// Chaining multiple additions
assert.equal(
  pipe(
    1,
    Number.sum(2), // 1 + 2 = 3
    Number.sum(3), // 3 + 3 = 6
    Number.sum(4) // 6 + 4 = 10
  ),
  10
)

// Identity property: a + 0 = a
assert.equal(Number.sum(42, 0), 42)

// Commutative property: a + b = b + a
assert.equal(Number.sum(5, 3), Number.sum(3, 5))
```

## sumAll

Source: `my-backend/node_modules/effect/dist/cjs/Number.js`

Signature: `sumAll(= sumAll;
const subtract = exports.subtract = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Computes the sum of all elements in an iterable collection of numbers.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import * as Number from "effect/Number"

// Basic sums
assert.equal(Number.sumAll([2, 3, 4]), 9) // 2 + 3 + 4 = 9
assert.equal(Number.sumAll([1.1, 2.2, 3.3]), 6.6) // 1.1 + 2.2 + 3.3 = 6.6

// Empty collection returns the additive identity (0)
assert.equal(Number.sumAll([]), 0)

// Single element collection
assert.equal(Number.sumAll([42]), 42)

// Sums with negative numbers
assert.equal(Number.sumAll([2, -3, 4]), 3) // 2 + (-3) + 4 = 3
assert.equal(Number.sumAll([-2, -3, -4]), -9) // (-2) + (-3) + (-4) = -9

// Works with any iterable
assert.equal(Number.sumAll(new Set([2, 3, 4])), 9)

// Using with generated sequences
function* range(start: number, end: number) {
  for (let i = start; i <= end; i++) yield i
}

// Compute sum of first 5 natural numbers: 1 + 2 + 3 + 4 + 5 = 15
assert.equal(Number.sumAll(range(1, 5)), 15)

// Floating point precision example
assert.equal(
  Number.sumAll([0.1, 0.2]),
  0.30000000000000004 // Note IEEE 754 precision limitation
)
```

@param collection - An `iterable` containing the `numbers` to sum

@returns The sum of all numbers in the collection, or 0 if the collection is
  empty
/
const sumAll = collection => _Iterable.reduce(collection, 0, sum);
/**
Performs subtraction in the set of JavaScript numbers.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.subtract(2, 3), -1) // 2 - 3 = -1
assert.equal(Number.subtract(10, 5), 5) // 10 - 5 = 5
assert.equal(Number.subtract(0.3, 0.1), 0.19999999999999998) // Note: floating-point precision limitation

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.subtract(5) // 10 - 5 = 5
  ),
  5
)

// Chaining multiple subtractions
assert.equal(
  pipe(
    20,
    Number.subtract(5), // 20 - 5 = 15
    Number.subtract(3), // 15 - 3 = 12
    Number.subtract(2) // 12 - 2 = 10
  ),
  10
)

// Right identity property: a - 0 = a
assert.equal(Number.subtract(42, 0), 42)

// Self-annihilation property: a - a = 0
assert.equal(Number.subtract(42, 42), 0)

// Non-commutative property: a - b  b - a
assert.equal(Number.subtract(5, 3), 2) // 5 - 3 = 2
assert.equal(Number.subtract(3, 5), -2) // 3 - 5 = -2

// Inverse relation: a - b = -(b - a)
assert.equal(Number.subtract(5, 3), -Number.subtract(3, 5))
```

## multiplyAll

Source: `my-backend/node_modules/effect/dist/cjs/Number.js`

Signature: `multiplyAll(= multiplyAll;
const divide = exports.divide = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Performs **multiplication** in the set of JavaScript numbers.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.multiply(2, 3), 6) // 2  3 = 6
assert.equal(Number.multiply(-4, 5), -20) // (-4)  5 = -20
assert.equal(Number.multiply(-3, -2), 6) // (-3)  (-2) = 6
assert.equal(Number.multiply(0.1, 0.2), 0.020000000000000004) // Note: floating-point precision limitation

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.multiply(5) // 10  5 = 50
  ),
  50
)

// Chaining multiple multiplications
assert.equal(
  pipe(
    2,
    Number.multiply(3), // 2  3 = 6
    Number.multiply(4), // 6  4 = 24
    Number.multiply(0.5) // 24  0.5 = 12
  ),
  12
)

// Identity property: a  1 = a
assert.equal(Number.multiply(42, 1), 42)

// Zero property: a  0 = 0
assert.equal(Number.multiply(42, 0), 0)

// Commutative property: a  b = b  a
assert.equal(Number.multiply(5, 3), Number.multiply(3, 5))

// Associative property: (a  b)  c = a  (b  c)
const a = 2,
  b = 3,
  c = 4
assert.equal(
  Number.multiply(Number.multiply(a, b), c),
  Number.multiply(a, Number.multiply(b, c))
)
```
/
const multiply = exports.multiply = /*#__PURE__*/(0, _Function.dual)(2, (multiplier, multiplicand) => multiplier * multiplicand);
/**
Computes the product of all elements in an iterable collection of numbers.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import * as Number from "effect/Number"

// Basic products
assert.equal(Number.multiplyAll([2, 3, 4]), 24) // 2  3  4 = 24
assert.equal(Number.multiplyAll([1.5, 2, 3]), 9) // 1.5  2  3 = 9

// Empty collection returns the multiplicative identity (1)
assert.equal(Number.multiplyAll([]), 1)

// Single element collection
assert.equal(Number.multiplyAll([42]), 42)

// Products with negative numbers
assert.equal(Number.multiplyAll([2, -3, 4]), -24) // 2  (-3)  4 = -24
assert.equal(Number.multiplyAll([-2, -3]), 6) // (-2)  (-3) = 6

// Zero property - if any element is zero, product is zero
assert.equal(Number.multiplyAll([2, 0, 3]), 0)

// Works with any iterable
assert.equal(Number.multiplyAll(new Set([2, 3, 4])), 24)

// Using with generated sequences
function* range(start: number, end: number) {
  for (let i = start; i <= end; i++) yield i
}

// Compute factorial: 5! = 5  4  3  2  1 = 120
assert.equal(Number.multiplyAll(range(1, 5)), 120)
```

@param collection - An `iterable` containing the `numbers` to multiply

@returns The product of all numbers in the collection, or 1 if the collection
  is empty
/
const multiplyAll = collection => {
  let out = 1;
  for (const n of collection) {
    if (n === 0) {
      return 0;
    }
    out *= n;
  }
  return out;
};
/**
Performs division in the set of JavaScript numbers, returning the result
wrapped in an `Option` to handle division by zero.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { pipe, Option } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.divide(6, 3), Option.some(2)) // 6  3 = 2
assert.equal(Number.divide(-8, 4), Option.some(-2)) // (-8)  4 = -2
assert.equal(Number.divide(-10, -5), Option.some(2)) // (-10)  (-5) = 2
assert.equal(Number.divide(1, 3), Option.some(0.3333333333333333)) // Note: floating-point approximation

// Handling division by zero
assert.equal(Number.divide(6, 0), Option.none()) // 6  0 is undefined

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.divide(2) // 10  2 = 5
  ),
  Option.some(5)
)

// Chaining multiple divisions using Option combinators
assert.equal(
  pipe(
    Option.some(24),
    Option.flatMap((n) => Number.divide(n, 2)), // 24  2 = 12
    Option.flatMap(Number.divide(3)), // 12  3 = 4
    Option.flatMap(Number.divide(2)) // 4  2 = 2
  ),
  Option.some(2)
)

// Division-by-one property: a  1 = a
assert.equal(Number.divide(42, 1), Option.some(42))

// Self-division property: a  a = 1 (for a  0)
assert.equal(Number.divide(42, 42), Option.some(1))

// Non-commutative property: a  b  b  a
assert.notDeepStrictEqual(
  Number.divide(6, 3), // 6  3 = 2
  Number.divide(3, 6) // 3  6 = 0.5
)
```

## increment

Source: `my-backend/node_modules/effect/dist/cjs/Number.js`

Signature: `increment(= increment;
const decrement = n => subtract(n, 1)`

JSDoc:

Performs division in the set of JavaScript numbers, but misbehaves for
division by zero.

Unlike {@link module:Number.divide} which returns an Option, this function
directly returns a number or `Infinity` or `NaN`.

- If the `divisor` is zero, it returns `Infinity`.
- If both the `dividend` and the `divisor` are zero, then it returns `NaN`.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { pipe } from "effect"
import * as Number from "effect/Number"

// Data-first style (direct application)
assert.equal(Number.unsafeDivide(6, 3), 2) // 6  3 = 2
assert.equal(Number.unsafeDivide(-8, 4), -2) // (-8)  4 = -2
assert.equal(Number.unsafeDivide(-10, -5), 2) // (-10)  (-5) = 2
assert.equal(Number.unsafeDivide(1, 3), 0.3333333333333333)

// Data-last style (pipeable)
assert.equal(
  pipe(
    10,
    Number.unsafeDivide(2) // 10  2 = 5
  ),
  5
)

// Chaining multiple divisions
assert.equal(
  pipe(
    24,
    Number.unsafeDivide(2), // 24  2 = 12
    Number.unsafeDivide(3), // 12  3 = 4
    Number.unsafeDivide(2) // 4  2 = 2
  ),
  2
)

assert.equal(Number.unsafeDivide(6, 0), Infinity)

assert.equal(Number.unsafeDivide(0, 0), NaN)

// Compare with safe division
const safeResult = Number.divide(6, 3) // Option.some(2)
const unsafeResult = Number.unsafeDivide(6, 3) // 2 directly
```

@throws - An {@link module:Number.DivisionByZeroError} if the divisor is zero.
@see {@link module:Number.divide} - Safe division returning an Option
/
const unsafeDivide = exports.unsafeDivide = /*#__PURE__*/(0, _Function.dual)(2, (dividend, divisor) => dividend / divisor);
/**
Returns the result of adding `1` to a given number.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { increment } from "effect/Number"

assert.equal(increment(2), 3)
```
/
const increment = n => sum(n, 1);
/**
Decrements a number by `1`.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { decrement } from "effect/Number"

assert.equal(decrement(3), 2)
```

## decrement

Source: `my-backend/node_modules/effect/dist/cjs/Number.js`

Signature: `decrement(= decrement;
const Equivalence = exports.Equivalence = equivalence.number;
/**
 * @memberof Number
 * @since 2.0.0
 * @category instances
 */
const Order = exports.Order = order.number;
/**
 * Returns `true` if the first argument is less than the second, otherwise
 * `false`.
 *
 * @memberof Number
 * @since 2.0.0
 * @category predicates
 * @example
 *
 * ```ts
 * import * as assert from "node:assert/strict"
 * import { lessThan } from "effect/Number"
 *
 * assert.equal(lessThan(2, 3)`

JSDoc:

@memberof Number
@since 2.0.0
@category instances

## sign

Source: `my-backend/node_modules/effect/dist/cjs/Number.js`

Signature: `sign(= sign;
const remainder = exports.remainder = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns a function that checks if a given `number` is less than or equal to
the provided one.

@memberof Number
@since 2.0.0
@category predicates
@example

```ts
import * as assert from "node:assert/strict"
import { lessThanOrEqualTo } from "effect/Number"

assert.equal(lessThanOrEqualTo(2, 3), true)
assert.equal(lessThanOrEqualTo(3, 3), true)
assert.equal(lessThanOrEqualTo(4, 3), false)
```
/
const lessThanOrEqualTo = exports.lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);
/**
Returns `true` if the first argument is greater than the second, otherwise
`false`.

@memberof Number
@since 2.0.0
@category predicates
@example

```ts
import * as assert from "node:assert/strict"
import { greaterThan } from "effect/Number"

assert.equal(greaterThan(2, 3), false)
assert.equal(greaterThan(3, 3), false)
assert.equal(greaterThan(4, 3), true)
```
/
const greaterThan = exports.greaterThan = /*#__PURE__*/order.greaterThan(Order);
/**
Returns a function that checks if a given `number` is greater than or equal
to the provided one.

@memberof Number
@since 2.0.0
@category predicates
@example

```ts
import * as assert from "node:assert/strict"
import { greaterThanOrEqualTo } from "effect/Number"

assert.equal(greaterThanOrEqualTo(2, 3), false)
assert.equal(greaterThanOrEqualTo(3, 3), true)
assert.equal(greaterThanOrEqualTo(4, 3), true)
```
/
const greaterThanOrEqualTo = exports.greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);
/**
Checks if a `number` is between a `minimum` and `maximum` value (inclusive).

@memberof Number
@since 2.0.0
@category predicates
@example

```ts
import * as assert from "node:assert/strict"
import { Number } from "effect"

const between = Number.between({ minimum: 0, maximum: 5 })

assert.equal(between(3), true)
assert.equal(between(-1), false)
assert.equal(between(6), false)
```
/
const between = exports.between = /*#__PURE__*/order.between(Order);
/**
Restricts the given `number` to be within the range specified by the
`minimum` and `maximum` values.

- If the `number` is less than the `minimum` value, the function returns the
  `minimum` value.
- If the `number` is greater than the `maximum` value, the function returns the
  `maximum` value.
- Otherwise, it returns the original `number`.

@memberof Number
@since 2.0.0
@example

```ts
import * as assert from "node:assert/strict"
import { Number } from "effect"

const clamp = Number.clamp({ minimum: 1, maximum: 5 })

assert.equal(clamp(3), 3)
assert.equal(clamp(0), 1)
assert.equal(clamp(6), 5)
```
/
const clamp = exports.clamp = /*#__PURE__*/order.clamp(Order);
/**
Returns the minimum between two `number`s.

@memberof Number
@since 2.0.0
@example

```ts
import * as assert from "node:assert/strict"
import { min } from "effect/Number"

assert.equal(min(2, 3), 2)
```
/
const min = exports.min = /*#__PURE__*/order.min(Order);
/**
Returns the maximum between two `number`s.

@memberof Number
@since 2.0.0
@example

```ts
import * as assert from "node:assert/strict"
import { max } from "effect/Number"

assert.equal(max(2, 3), 3)
```
/
const max = exports.max = /*#__PURE__*/order.max(Order);
/**
Determines the sign of a given `number`.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { sign } from "effect/Number"

assert.equal(sign(-5), -1)
assert.equal(sign(0), 0)
assert.equal(sign(5), 1)
```
/
const sign = n => Order(n, 0);
/**
Returns the remainder left over when one operand is divided by a second
operand.

It always takes the sign of the dividend.

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { remainder } from "effect/Number"

assert.equal(remainder(2, 2), 0)
assert.equal(remainder(3, 2), 1)
assert.equal(remainder(-4, 2), -0)
```

## nextPow2

Source: `my-backend/node_modules/effect/dist/cjs/Number.js`

Signature: `nextPow2(= nextPow2;
const parse = s => {
  if (s === "NaN")`

JSDoc:

Returns the next power of 2 greater than or equal to the given number.

- For `positive` inputs, returns the smallest power of 2 that is >= the input
- For `zero`, returns 2
- For `negative` inputs, returns NaN (as logarithms of negative numbers are
  undefined)
- For `NaN` input, returns NaN
- For `Infinity`, returns Infinity

@memberof Number
@since 2.0.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { nextPow2 } from "effect/Number"

assert.equal(nextPow2(5), 8)
assert.equal(nextPow2(17), 32)
assert.equal(nextPow2(0), 2)
assert.equal(Number.isNaN(nextPow2(-1)), true) // Negative inputs result in NaN
```
/
const nextPow2 = n => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
/**
Tries to parse a `number` from a `string` using the `Number()` function. The
following special string values are supported: "NaN", "Infinity",
"-Infinity".

@memberof Number
@since 2.0.0
@category constructors

## parse

Source: `my-backend/node_modules/effect/dist/cjs/Number.js`

Signature: `parse(= parse;
const round = exports.round = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns the number rounded with the given precision.

@memberof Number
@since 3.8.0
@category math
@example

```ts
import * as assert from "node:assert/strict"
import { round } from "effect/Number"

assert.equal(round(1.1234, 2), 1.12)
assert.equal(round(1.567, 2), 1.57)
```

## none

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `none(= none;
const some = exports.some = option.some;
/**
 * Determines whether the given value is an `Option`.
 *
 * **Details**
 *
 * This function checks if a value is an instance of `Option`. It returns `true`
 * if the value is either `Option.some` or `Option.none`, and `false` otherwise.
 * This is particularly useful when working with unknown values or when you need
 * to ensure type safety in your code.
 *
 * @example
 * ```ts
 * import { Option } from "effect"
 *
 * console.log(Option.isOption(Option.some(1)`

JSDoc:

@category Symbols
@since 2.0.0
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Option");
/**
Represents the absence of a value by creating an empty `Option`.

`Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.
This means you can use it in place of any `Option<A>` regardless of the type
`A`.

**Example** (Creating an Option with No Value)

```ts
import { Option } from "effect"

// An Option holding no value
//
//       Option<never>
//      
const noValue = Option.none()

console.log(noValue)
// Output: { _id: 'Option', _tag: 'None' }
```

@see {@link some} for the opposite operation.

@category Constructors
@since 2.0.0
/
const none = () => option.none;
/**
Wraps the given value into an `Option` to represent its presence.

**Example** (Creating an Option with a Value)

```ts
import { Option } from "effect"

// An Option holding the number 1
//
//       Option<number>
//      
const value = Option.some(1)

console.log(value)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

@see {@link none} for the opposite operation.

@category Constructors
@since 2.0.0

## toRefinement

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `toRefinement(= toRefinement;
const fromIterable = collection => {
  for (const a of collection)`

JSDoc:

Checks whether an `Option` represents the absence of a value (`None`).

@example
```ts
import { Option } from "effect"

console.log(Option.isNone(Option.some(1)))
// Output: false

console.log(Option.isNone(Option.none()))
// Output: true
```

@see {@link isSome} for the opposite check.

@category Guards
@since 2.0.0
/
const isNone = exports.isNone = option.isNone;
/**
Checks whether an `Option` contains a value (`Some`).

@example
```ts
import { Option } from "effect"

console.log(Option.isSome(Option.some(1)))
// Output: true

console.log(Option.isSome(Option.none()))
// Output: false
```

@see {@link isNone} for the opposite check.

@category Guards
@since 2.0.0
/
const isSome = exports.isSome = option.isSome;
/**
Performs pattern matching on an `Option` to handle both `Some` and `None`
cases.

**Details**

This function allows you to match against an `Option` and handle both
scenarios: when the `Option` is `None` (i.e., contains no value), and when
the `Option` is `Some` (i.e., contains a value). It executes one of the
provided functions based on the case:

- If the `Option` is `None`, the `onNone` function is executed and its result
  is returned.
- If the `Option` is `Some`, the `onSome` function is executed with the
  contained value, and its result is returned.

This function provides a concise and functional way to handle optional values
without resorting to `if` or manual checks, making your code more declarative
and readable.

**Example** (Pattern Matching with Option)

```ts
import { Option } from "effect"

const foo = Option.some(1)

const message = Option.match(foo, {
  onNone: () => "Option is empty",
  onSome: (value) => `Option has a value: ${value}`
})

console.log(message)
// Output: "Option has a value: 1"
```

@category Pattern matching
@since 2.0.0
/
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onNone,
  onSome
}) => isNone(self) ? onNone() : onSome(self.value));
/**
Converts an `Option`-returning function into a type guard.

**Details**

This function transforms a function that returns an `Option` into a type
guard, ensuring type safety when validating or narrowing types. The returned
type guard function checks whether the input satisfies the condition defined
in the original `Option`-returning function.

If the original function returns `Option.some`, the type guard evaluates to
`true`, confirming the input is of the desired type. If the function returns
`Option.none`, the type guard evaluates to `false`.

This utility is especially useful for validating types in union types,
filtering arrays, or ensuring safe handling of specific subtypes.

@example
```ts
import { Option } from "effect"

type MyData = string | number

const parseString = (data: MyData): Option.Option<string> =>
  typeof data === "string" ? Option.some(data) : Option.none()

//       (a: MyData) => a is string
//      
const isString = Option.toRefinement(parseString)

console.log(isString("a"))
// Output: true

console.log(isString(1))
// Output: false
```

@category Conversions
@since 2.0.0
/
const toRefinement = f => a => isSome(f(a));
/**
Converts an `Iterable` into an `Option`, wrapping the first element if it
exists.

**Details**

This function takes an `Iterable` (e.g., an array, a generator, or any object
implementing the `Iterable` interface) and returns an `Option` based on its
content:

- If the `Iterable` contains at least one element, the first element is
  wrapped in a `Some` and returned.
- If the `Iterable` is empty, `None` is returned, representing the absence of
  a value.

This utility is useful for safely handling collections that might be empty,
ensuring you explicitly handle both cases where a value exists or doesn't.

@example
```ts
import { Option } from "effect"

console.log(Option.fromIterable([1, 2, 3]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.fromIterable([]))
// Output: { _id: 'Option', _tag: 'None' }
```

@category Constructors
@since 2.0.0

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `fromIterable(= fromIterable;
const getRight = exports.getRight = either.getRight;
/**
 * Converts an `Either` into an `Option` by discarding the right value and
 * extracting the left value.
 *
 * **Details**
 *
 * This function transforms an `Either` into an `Option` as follows:
 *
 * - If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.
 * - If the `Either` is a `Right`, the value is discarded, and `None` is
 *   returned.
 *
 * This utility is useful when you only care about the error case (`Left`)`

JSDoc:

Converts an `Either` into an `Option` by discarding the error and extracting
the right value.

**Details**

This function takes an `Either` and returns an `Option` based on its value:

- If the `Either` is a `Right`, its value is wrapped in a `Some` and
  returned.
- If the `Either` is a `Left`, the error is discarded, and `None` is
  returned.

This is particularly useful when you only care about the success case
(`Right`) of an `Either` and want to handle the result using `Option`. By
using this function, you can convert `Either` into a simpler structure for
cases where error handling is not required.

@example
```ts
import { Either, Option } from "effect"

console.log(Option.getRight(Either.right("ok")))
// Output: { _id: 'Option', _tag: 'Some', value: 'ok' }

console.log(Option.getRight(Either.left("err")))
// Output: { _id: 'Option', _tag: 'None' }
```

@see {@link getLeft} for the opposite operation.

@category Conversions
@since 2.0.0

## firstSomeOf

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `firstSomeOf(= firstSomeOf;
const fromNullable = nullableValue => nullableValue == null ? none()`

JSDoc:

Returns the value contained in the `Option` if it is `Some`, otherwise
evaluates and returns the result of `onNone`.

**Details**

This function allows you to provide a fallback value or computation for when
an `Option` is `None`. If the `Option` contains a value (`Some`), that value
is returned. If it is empty (`None`), the `onNone` function is executed, and
its result is returned instead.

This utility is helpful for safely handling `Option` values by ensuring you
always receive a meaningful result, whether or not the `Option` contains a
value. It is particularly useful for providing default values or alternative
logic when working with optional values.

@example
```ts
import { Option } from "effect"

console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))
// Output: 1

console.log(Option.none().pipe(Option.getOrElse(() => 0)))
// Output: 0
```

@see {@link getOrNull} for a version that returns `null` instead of executing a function.
@see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.

@category Getters
@since 2.0.0
/
const getOrElse = exports.getOrElse = /*#__PURE__*/(0, _Function.dual)(2, (self, onNone) => isNone(self) ? onNone() : self.value);
/**
Returns the provided `Option` `that` if the current `Option` (`self`) is
`None`; otherwise, it returns `self`.

**Details**

This function provides a fallback mechanism for `Option` values. If the
current `Option` is `None` (i.e., it contains no value), the `that` function
is evaluated, and its resulting `Option` is returned. If the current `Option`
is `Some` (i.e., it contains a value), the original `Option` is returned
unchanged.

This is particularly useful for chaining fallback values or computations,
allowing you to provide alternative `Option` values when the first one is
empty.

@example
```ts
import { Option } from "effect"

console.log(Option.none().pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }

console.log(Option.none().pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

@category Error handling
@since 2.0.0
/
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isNone(self) ? that() : self);
/**
Returns the provided default value wrapped in `Some` if the current `Option`
(`self`) is `None`; otherwise, returns `self`.

**Details**

This function provides a way to supply a default value for cases where an
`Option` is `None`. If the current `Option` is empty (`None`), the `onNone`
function is executed to compute the default value, which is then wrapped in a
`Some`. If the current `Option` contains a value (`Some`), it is returned as
is.

This is particularly useful for handling optional values where a fallback
default needs to be provided explicitly in case of absence.

@example
```ts
import { Option } from "effect"

console.log(Option.none().pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

@category Error handling
@since 2.0.0
/
const orElseSome = exports.orElseSome = /*#__PURE__*/(0, _Function.dual)(2, (self, onNone) => isNone(self) ? some(onNone()) : self);
/**
Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to
indicate the source of the value.

**Details**

This function allows you to provide a fallback `Option` in case the current
`Option` (`self`) is `None`. However, unlike `orElse`, it returns the value
wrapped in an `Either` object, providing additional information about where
the value came from:

- If the value is from the fallback `Option` (`that`), it is wrapped in an
  `Either.right`.
- If the value is from the original `Option` (`self`), it is wrapped in an
  `Either.left`.

This is especially useful when you need to differentiate between values
originating from the primary `Option` and those coming from the fallback,
while still maintaining the `Option`-style handling.

@category Error handling
@since 2.0.0
/
const orElseEither = exports.orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => isNone(self) ? map(that(), either.right) : map(self, either.left));
/**
Returns the first `Some` value found in an `Iterable` collection of
`Option`s, or `None` if no `Some` is found.

**Details**

This function iterates over a collection of `Option` values and returns the
first `Some` it encounters. If the collection contains only `None` values,
the result will also be `None`. This utility is useful for efficiently
finding the first valid value in a sequence of potentially empty or invalid
options.

The iteration stops as soon as a `Some` is found, making this function
efficient for large collections.

@example
```ts
import { Option } from "effect"

console.log(Option.firstSomeOf([
  Option.none(),
  Option.some(1),
  Option.some(2)
]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

@category Error handling
@since 2.0.0
/
const firstSomeOf = collection => {
  let out = none();
  for (out of collection) {
    if (isSome(out)) {
      return out;
    }
  }
  return out;
};
/**
Converts a nullable value into an `Option`. Returns `None` if the value is
`null` or `undefined`, otherwise wraps the value in a `Some`.

@example
```ts
import { Option } from "effect"

console.log(Option.fromNullable(undefined))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(null))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }
```

@category Conversions
@since 2.0.0

## fromNullable

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `fromNullable(= fromNullable;
const liftNullable = f => (...a)`

JSDoc:

Lifts a function that returns `null` or `undefined` into the `Option`
context.

**Details**

This function takes a function `f` that might return `null` or `undefined`
and transforms it into a function that returns an `Option`. The resulting
function will return:
- `Some` if the original function produces a non-null, non-undefined value.
- `None` if the original function produces `null` or `undefined`.

@example
```ts
import { Option } from "effect"

const parse = (s: string): number | undefined => {
  const n = parseFloat(s)
  return isNaN(n) ? undefined : n
}

const parseOption = Option.liftNullable(parse)

console.log(parseOption("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parseOption("not a number"))
// Output: { _id: 'Option', _tag: 'None' }
```

@category Conversions
@since 2.0.0

## liftNullable

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `liftNullable(= liftNullable;
const getOrNull = exports.getOrNull = /*#__PURE__*/getOrElse(_Function.constNull)`

JSDoc:

Returns the value contained in the `Option` if it is `Some`; otherwise,
returns `null`.

**Details**

This function provides a way to extract the value of an `Option` while
falling back to `null` if the `Option` is `None`.

It is particularly useful in scenarios where `null` is an acceptable
placeholder for the absence of a value, such as when interacting with APIs or
systems that use `null` as a default for missing values.

@example
```ts
import { Option } from "effect"

console.log(Option.getOrNull(Option.some(1)))
// Output: 1

console.log(Option.getOrNull(Option.none()))
// Output: null
```

@category Getters
@since 2.0.0

## liftThrowable

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `liftThrowable(= liftThrowable;
const getOrThrowWith = exports.getOrThrowWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns the value contained in the `Option` if it is `Some`; otherwise,
returns `undefined`.

**Details**

This function provides a way to extract the value of an `Option` while
falling back to `undefined` if the `Option` is `None`.

It is particularly useful in scenarios where `undefined` is an acceptable
placeholder for the absence of a value, such as when interacting with APIs or
systems that use `undefined` as a default for missing values.

@example
```ts
import { Option } from "effect"

console.log(Option.getOrUndefined(Option.some(1)))
// Output: 1

console.log(Option.getOrUndefined(Option.none()))
// Output: undefined
```

@category Getters
@since 2.0.0
/
const getOrUndefined = exports.getOrUndefined = /*#__PURE__*/getOrElse(_Function.constUndefined);
/**
Lifts a function that throws exceptions into a function that returns an
`Option`.

**Details**

This utility function takes a function `f` that might throw an exception and
transforms it into a safer function that returns an `Option`. If the original
function executes successfully, the result is wrapped in a `Some`. If an
exception is thrown, the result is `None`, allowing the developer to handle
errors in a functional, type-safe way.

@example
```ts
import { Option } from "effect"

const parse = Option.liftThrowable(JSON.parse)

console.log(parse("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parse(""))
// Output: { _id: 'Option', _tag: 'None' }
```

@category Conversions
@since 2.0.0
/
const liftThrowable = f => (...a) => {
  try {
    return some(f(...a));
  } catch {
    return none();
  }
};
/**
Extracts the value of an `Option` or throws an error if the `Option` is
`None`, using a custom error factory.

**Details**

This function allows you to extract the value of an `Option` when it is
`Some`. If the `Option` is `None`, it throws an error generated by the
provided `onNone` function. This utility is particularly useful when you need
a fail-fast behavior for empty `Option` values and want to provide a custom
error message or object.

@example
```ts
import * as assert from "node:assert"
import { Option } from "effect"

assert.deepStrictEqual(
  Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),
  1
)
assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))
```

@see {@link getOrThrow} for a version that throws a default error.

@category Conversions
@since 2.0.0

## product

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `product(= product;
const productMany = (self, collection)`

JSDoc:

Extracts the value of an `Option` or throws a default error if the `Option`
is `None`.

**Details**

This function extracts the value from an `Option` if it is `Some`. If the
`Option` is `None`, it throws a default error. It is useful for fail-fast
scenarios where the absence of a value is treated as an exceptional case and
a default error is sufficient.

@example
```ts
import * as assert from "node:assert"
import { Option } from "effect"

assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)
assert.throws(() => Option.getOrThrow(Option.none()))
```

@see {@link getOrThrowWith} for a version that allows you to provide a custom error.

@category Conversions
@since 2.0.0
/
const getOrThrow = exports.getOrThrow = /*#__PURE__*/getOrThrowWith(() => new Error("getOrThrow called on a None"));
/**
Transforms the value inside a `Some` to a new value using the provided
function, while leaving `None` unchanged.

**Details**

This function applies a mapping function `f` to the value inside an `Option`
if it is a `Some`. If the `Option` is `None`, it remains unchanged. The
result is a new `Option` with the transformed value (if it was a `Some`) or
still `None`.

This utility is particularly useful for chaining transformations in a
functional way without needing to manually handle `None` cases.

@example
```ts
import { Option } from "effect"

// Mapping over a `Some`
const someValue = Option.some(2)

console.log(Option.map(someValue, (n) => n * 2))
// Output: { _id: 'Option', _tag: 'Some', value: 4 }

// Mapping over a `None`
const noneValue = Option.none<number>()

console.log(Option.map(noneValue, (n) => n * 2))
// Output: { _id: 'Option', _tag: 'None' }
```

@category Mapping
@since 2.0.0
/
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isNone(self) ? none() : some(f(self.value)));
/**
Replaces the value inside a `Some` with the specified constant value, leaving
`None` unchanged.

**Details**

This function transforms an `Option` by replacing the value inside a `Some`
with the given constant value `b`. If the `Option` is `None`, it remains
unchanged.

This is useful when you want to preserve the presence of a value (`Some`) but
replace its content with a fixed value.

@example
```ts
import { Option } from "effect"

// Replacing the value of a `Some`
const someValue = Option.some(42)

console.log(Option.as(someValue, "new value"))
// Output: { _id: 'Option', _tag: 'Some', value: 'new value' }

// Replacing a `None` (no effect)
const noneValue = Option.none<number>()

console.log(Option.as(noneValue, "new value"))
// Output: { _id: 'Option', _tag: 'None' }
```

@category Mapping
@since 2.0.0
/
const as = exports.as = /*#__PURE__*/(0, _Function.dual)(2, (self, b) => map(self, () => b));
/**
Replaces the value inside a `Some` with the constant value `void`, leaving
`None` unchanged.

**Details**

This function transforms an `Option` by replacing the value inside a `Some`
with `void`. If the `Option` is `None`, it remains unchanged.

This is particularly useful in scenarios where the presence or absence of a
value is significant, but the actual content of the value is irrelevant.

@category Mapping
@since 2.0.0
/
const asVoid = exports.asVoid = /*#__PURE__*/as(undefined);
const void_ = exports.void = /*#__PURE__*/some(undefined);
/**
Applies a function to the value of a `Some` and flattens the resulting
`Option`. If the input is `None`, it remains `None`.

**Details**

This function allows you to chain computations that return `Option` values.
If the input `Option` is `Some`, the provided function `f` is applied to the
contained value, and the resulting `Option` is returned. If the input is
`None`, the function is not applied, and the result remains `None`.

This utility is particularly useful for sequencing operations that may fail
or produce optional results, enabling clean and concise workflows for
handling such cases.

@example
```ts
import { Option } from "effect"

interface Address {
  readonly city: string
  readonly street: Option.Option<string>
}

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option<string>
  readonly address: Option.Option<Address>
}

const user: User = {
  id: 1,
  username: "john_doe",
  email: Option.some("john.doe@example.com"),
  address: Option.some({
    city: "New York",
    street: Option.some("123 Main St")
  })
}

// Use flatMap to extract the street value
const street = user.address.pipe(
  Option.flatMap((address) => address.street)
)

console.log(street)
// Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }
```

@category Sequencing
@since 2.0.0
/
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isNone(self) ? none() : f(self.value));
/**
Chains two `Option`s together. The second `Option` can either be a static
value or depend on the result of the first `Option`.

**Details**

This function enables sequencing of two `Option` computations. If the first
`Option` is `Some`, the second `Option` is evaluated. The second `Option` can
either:

- Be a static `Option` value.
- Be a function that produces an `Option`, optionally based on the value of
  the first `Option`.

If the first `Option` is `None`, the function skips the evaluation of the
second `Option` and directly returns `None`.

@category Sequencing
@since 2.0.0
/
const andThen = exports.andThen = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flatMap(self, a => {
  const b = (0, _Function.isFunction)(f) ? f(a) : f;
  return isOption(b) ? b : some(b);
}));
/**
Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`
using a function that may return `null` or `undefined`.

**Details**

This function applies a transformation function `f` to the value inside a
`Some`. The function `f` may return a value, `null`, or `undefined`. If `f`
returns a value, it is wrapped in a `Some`. If `f` returns `null` or
`undefined`, the result is `None`. If the input `Option` is `None`, the
function is not applied, and `None` is returned.

This utility is particularly useful when working with deeply nested optional
values or chaining computations that may result in `null` or `undefined` at
some point.

@example
```ts
import { Option } from "effect"

interface Employee {
  company?: {
    address?: {
      street?: {
        name?: string
      }
    }
  }
}

const employee1: Employee = { company: { address: { street: { name: "high street" } } } }

// Extracting a deeply nested property
console.log(
  Option.some(employee1)
    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
)
// Output: { _id: 'Option', _tag: 'Some', value: 'high street' }

const employee2: Employee = { company: { address: { street: {} } } }

// Property does not exist
console.log(
  Option.some(employee2)
    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
)
// Output: { _id: 'Option', _tag: 'None' }
```

@category Sequencing
@since 2.0.0
/
const flatMapNullable = exports.flatMapNullable = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => isNone(self) ? none() : fromNullable(f(self.value)));
/**
Flattens an `Option` of `Option` into a single `Option`.

**Details**

This function takes an `Option` that wraps another `Option` and flattens it
into a single `Option`. If the outer `Option` is `Some`, the function
extracts the inner `Option`. If the outer `Option` is `None`, the result
remains `None`.

This is useful for simplifying nested `Option` structures that may arise
during functional operations.

@category Sequencing
@since 2.0.0
/
const flatten = exports.flatten = /*#__PURE__*/flatMap(_Function.identity);
/**
Combines two `Option`s, keeping the value from the second `Option` if both
are `Some`.

**Details**

This function takes two `Option`s and returns the second one if the first is
`Some`. If the first `Option` is `None`, the result will also be `None`,
regardless of the second `Option`. It effectively "zips" the two `Option`s
while discarding the value from the first `Option`.

This is particularly useful when sequencing computations where the result of
the first computation is not needed, and you only care about the result of
the second computation.

@category Zipping
@since 2.0.0
/
const zipRight = exports.zipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => flatMap(self, () => that));
/**
Combines two `Option`s, keeping the value from the first `Option` if both are
`Some`.

**Details**

This function takes two `Option`s and returns the first one if it is `Some`.
If either the first `Option` or the second `Option` is `None`, the result
will be `None`. This operation "zips" the two `Option`s while discarding the
value from the second `Option`.

This is useful when sequencing computations where the second `Option`
represents a dependency or condition that must hold, but its value is
irrelevant.

@category Zipping
@since 2.0.0
/
const zipLeft = exports.zipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => tap(self, () => that));
/**
Composes two functions that return `Option` values, creating a new function
that chains them together.

**Details**

This function allows you to compose two computations, each represented by a
function that returns an `Option`. The result of the first function is passed
to the second function if it is `Some`. If the first function returns `None`,
the composed function short-circuits and returns `None` without invoking the
second function.

@example
```ts
import { Option } from "effect"

const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))

const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()

const parseAndDouble = Option.composeK(parse, double)

console.log(parseAndDouble("42"))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }

console.log(parseAndDouble("not a number"))
// Output: { _id: 'Option', _tag: 'None' }
```

@category Sequencing
@since 2.0.0
/
const composeK = exports.composeK = /*#__PURE__*/(0, _Function.dual)(2, (afb, bfc) => a => flatMap(afb(a), bfc));
/**
Applies the provided function `f` to the value of the `Option` if it is
`Some` and returns the original `Option`, unless `f` returns `None`, in which
case it returns `None`.

**Details**

This function allows you to perform additional computations on the value of
an `Option` without modifying its original value. If the `Option` is `Some`,
the provided function `f` is executed with the value, and its result
determines whether the original `Option` is returned (`Some`) or the result
is `None` if `f` returns `None`. If the input `Option` is `None`, the
function is not executed, and `None` is returned.

This is particularly useful for applying side conditions or performing
validation checks while retaining the original `Option`'s value.

@example
```ts
import { Option } from "effect"

const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()

console.log(Option.tap(Option.none(), getInteger))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.tap(Option.some(1), getInteger))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.tap(Option.some(1.14), getInteger))
// Output: { _id: 'Option', _tag: 'None' }
```

@category Sequencing
@since 2.0.0
/
const tap = exports.tap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flatMap(self, a => map(f(a), () => a)));
/**
Combines two `Option` values into a single `Option` containing a tuple of
their values if both are `Some`.

**Details**

This function takes two `Option`s and combines their values into a tuple `[A,
B]` if both are `Some`. If either of the `Option`s is `None`, the result is
`None`. This is particularly useful for combining multiple `Option` values
into a single one, ensuring both contain valid values.

@category Combining
@since 2.0.0
/
const product = (self, that) => isSome(self) && isSome(that) ? some([self.value, that.value]) : none();
/**
Combines an `Option` with a collection of `Option`s into a single `Option`
containing a tuple of their values if all are `Some`.

**Details**

This function takes a primary `Option` and a collection of `Option`s and
combines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If
the primary `Option` or any `Option` in the collection is `None`, the result
is `None`.

@category Combining
@since 2.0.0

## all

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `all(= all;
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Combines a structure of `Option`s into a single `Option` containing the
values with the same structure.

**Details**

This function takes a structure of `Option`s (a tuple, struct, or iterable)
and produces a single `Option` that contains the values from the input
structure if all `Option`s are `Some`. If any `Option` in the input is
`None`, the result is `None`. The structure of the input is preserved in the
output.

- If the input is a tuple (e.g., an array), the result will be an `Option`
  containing a tuple with the same length.
- If the input is a struct (e.g., an object), the result will be an `Option`
  containing a struct with the same keys.
- If the input is an iterable, the result will be an `Option` containing an
  array.

@example
```ts
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

//       Option<[string, number]>
//      
const tuple = Option.all([maybeName, maybeAge])
console.log(tuple)
// Output:
// { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }

//       Option<{ name: string; age: number; }>
//      
const struct = Option.all({ name: maybeName, age: maybeAge })
console.log(struct)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }
```

@category Combining
@since 2.0.0
/
// @ts-expect-error
exports.productMany = productMany;
const all = input => {
  if (Symbol.iterator in input) {
    const out = [];
    for (const o of input) {
      if (isNone(o)) {
        return none();
      }
      out.push(o.value);
    }
    return some(out);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (isNone(o)) {
      return none();
    }
    out[key] = o.value;
  }
  return some(out);
};
/**
Combines two `Option` values into a new `Option` by applying a provided
function to their values.

**Details**

This function takes two `Option` values (`self` and `that`) and a combining
function `f`. If both `Option` values are `Some`, the function `f` is applied
to their values, and the result is wrapped in a new `Some`. If either
`Option` is `None`, the result is `None`.

This utility is useful for combining two optional computations into a single
result while maintaining type safety and avoiding explicit checks for `None`.

@example
```ts
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

// Combine the name and age into a person object
const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }
```

@category Zipping
@since 2.0.0

## toArray

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `toArray(= toArray;
const partitionMap = exports.partitionMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Applies a function inside a `Some` to a value inside another `Some`,
combining them into a new `Option`.

**Details**

This function allows you to apply a function wrapped in an `Option` (`self`)
to a value wrapped in another `Option` (`that`). If both `Option`s are
`Some`, the function is applied to the value, and the result is wrapped in a
new `Some`. If either `Option` is `None`, the result is `None`.

@category Combining
@since 2.0.0
/
const ap = exports.ap = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => zipWith(self, that, (f, a) => f(a)));
/**
Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring
elements that are `None`.

**Details**

This function takes an initial value of type `B` and a reducing function `f`
that combines the accumulator with values of type `A`. It processes an
iterable of `Option<A>`, applying `f` only to the `Some` values while
ignoring the `None` values. The result is a single value of type `B`.

This utility is particularly useful for aggregating values from an iterable
of `Option`s while skipping the absent (`None`) values.

@example
```ts
import { Option, pipe } from "effect"

const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]

console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))
// Output: 3
```

@category Reducing
@since 2.0.0
/
const reduceCompact = exports.reduceCompact = /*#__PURE__*/(0, _Function.dual)(3, (self, b, f) => {
  let out = b;
  for (const oa of self) {
    if (isSome(oa)) {
      out = f(out, oa.value);
    }
  }
  return out;
});
/**
Converts an `Option` into an `Array`.
If the input is `None`, an empty array is returned.
If the input is `Some`, its value is wrapped in a single-element array.

@example
```ts
import { Option } from "effect"

console.log(Option.toArray(Option.some(1)))
// Output: [1]

console.log(Option.toArray(Option.none()))
// Output: []
```

@category Conversions
@since 2.0.0
/
const toArray = self => isNone(self) ? [] : [self.value];
/**
Splits an `Option` into two `Option`s based on the result of a mapping
function that produces an `Either`.

**Details**

This function takes an `Option` and a mapping function `f` that converts its
value into an `Either`. It returns a tuple of two `Option`s:

- The first `Option` (`left`) contains the value from the `Left` side of the
  `Either` if it exists, otherwise `None`.
- The second `Option` (`right`) contains the value from the `Right` side of
  the `Either` if it exists, otherwise `None`.

If the input `Option` is `None`, both returned `Option`s are `None`.

This utility is useful for filtering and categorizing the contents of an
`Option` based on a bifurcating computation.

@category Filtering
@since 2.0.0

## getEquivalence

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `getEquivalence(= getEquivalence;
const getOrder = O => order.make((self, that)`

JSDoc:

Alias of {@link flatMap}.

@example
```ts
import { Option } from "effect"

// Transform and filter numbers
const transformEven = (n: Option.Option<number>): Option.Option<string> =>
  Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))

console.log(transformEven(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(transformEven(Option.some(1)))
// Output: { _id: 'Option', _tag: 'None' }

console.log(transformEven(Option.some(2)))
// Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }
```

@category Filtering
@since 2.0.0
/
const filterMap = exports.filterMap = flatMap;
/**
Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.

If you need to change the type of the `Option` in addition to filtering, see `filterMap`.

@example
```ts
import { Option } from "effect"

const removeEmptyString = (input: Option.Option<string>) =>
  Option.filter(input, (value) => value !== "")

console.log(removeEmptyString(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("")))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("a")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }
```

@category Filtering
@since 2.0.0
/
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => filterMap(self, b => predicate(b) ? option.some(b) : option.none));
/**
Creates an `Equivalence` instance for comparing `Option` values, using a
provided `Equivalence` for the inner type.

**Details**

This function takes an `Equivalence` instance for a specific type `A` and
produces an `Equivalence` instance for `Option<A>`. The resulting
`Equivalence` determines whether two `Option` values are equivalent:

- Two `None`s are considered equivalent.
- A `Some` and a `None` are not equivalent.
- Two `Some` values are equivalent if their inner values are equivalent
  according to the provided `Equivalence`.

**Example** (Comparing Optional Numbers for Equivalence)

```ts
import { Number, Option } from "effect"

const isEquivalent = Option.getEquivalence(Number.Equivalence)

console.log(isEquivalent(Option.none(), Option.none()))
// Output: true

console.log(isEquivalent(Option.none(), Option.some(1)))
// Output: false

console.log(isEquivalent(Option.some(1), Option.none()))
// Output: false

console.log(isEquivalent(Option.some(1), Option.some(2)))
// Output: false

console.log(isEquivalent(Option.some(1), Option.some(1)))
// Output: true
```

@category Equivalence
@since 2.0.0
/
const getEquivalence = isEquivalent => Equivalence.make((x, y) => isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value));
/**
Creates an `Order` instance for comparing `Option` values, using a provided
`Order` for the inner type.

**Details**

This function produces an `Order` instance for `Option<A>`, allowing `Option`
values to be compared:

- `None` is always considered less than any `Some` value.
- If both are `Some`, their inner values are compared using the provided
  `Order` instance.

@example
```ts
import { Number, Option } from "effect"

const order = Option.getOrder(Number.Order)

console.log(order(Option.none(), Option.none()))
// Output: 0

console.log(order(Option.none(), Option.some(1)))
// Output: -1

console.log(order(Option.some(1), Option.none()))
// Output: 1

console.log(order(Option.some(1), Option.some(2)))
// Output: -1

console.log(order(Option.some(1), Option.some(1)))
// Output: 0
```

@category Sorting
@since 2.0.0

## getOrder

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `getOrder(= getOrder;
const lift2 = f => (0, _Function.dual)`

JSDoc:

Lifts a binary function to work with `Option` values, allowing the function
to operate on two `Option`s.

**Details**

This function takes a binary function `f` and returns a new function that
applies `f` to the values of two `Option`s (`self` and `that`). If both
`Option`s are `Some`, the binary function `f` is applied to their values, and
the result is wrapped in a new `Some`. If either `Option` is `None`, the
result is `None`.

@example
```ts
import { Option } from "effect"

// A binary function to add two numbers
const add = (a: number, b: number): number => a + b

// Lift the `add` function to work with `Option` values
const addOptions = Option.lift2(add)

// Both `Option`s are `Some`
console.log(addOptions(Option.some(2), Option.some(3)))
// Output: { _id: 'Option', _tag: 'Some', value: 5 }

// One `Option` is `None`
console.log(addOptions(Option.some(2), Option.none()))
// Output: { _id: 'Option', _tag: 'None' }
```

@category Lifting
@since 2.0.0

## lift2

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `lift2(= lift2;
const liftPredicate = exports.liftPredicate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Lifts a `Predicate` or `Refinement` into the `Option` context, returning a
`Some` of the input value if the predicate is satisfied, or `None` otherwise.

**Details**

This function transforms a `Predicate` (or a more specific `Refinement`) into
a function that produces an `Option`. If the predicate evaluates to `true`,
the input value is wrapped in a `Some`. If the predicate evaluates to
`false`, the result is `None`.

@example
```ts
import { Option } from "effect"

// Check if a number is positive
const isPositive = (n: number) => n > 0

//       (b: number) => Option<number>
//      
const parsePositive = Option.liftPredicate(isPositive)

console.log(parsePositive(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parsePositive(-1))
// OUtput: { _id: 'Option', _tag: 'None' }
```

@category Lifting
@since 2.0.0

## gen

Source: `my-backend/node_modules/effect/dist/cjs/Option.js`

Signature: `gen(= gen;
const mergeWith = f => (o1, o2)`

JSDoc:

Returns a function that checks if an `Option` contains a specified value,
using a provided equivalence function.

**Details**

This function allows you to check whether an `Option` contains a specific
value. It uses an equivalence function `isEquivalent` to compare the value
inside the `Option` to the provided value. If the `Option` is `Some` and the
equivalence function returns `true`, the result is `true`. If the `Option` is
`None` or the values are not equivalent, the result is `false`.

@example
```ts
import { Number, Option } from "effect"

const contains = Option.containsWith(Number.Equivalence)

console.log(Option.some(2).pipe(contains(2)))
// Output: true

console.log(Option.some(1).pipe(contains(2)))
// Output: false

console.log(Option.none().pipe(contains(2)))
// Output: false
```

@see {@link contains} for a version that uses the default `Equivalence`.

@category Elements
@since 2.0.0
/
const containsWith = isEquivalent => (0, _Function.dual)(2, (self, a) => isNone(self) ? false : isEquivalent(self.value, a));
exports.containsWith = containsWith;
const _equivalence = /*#__PURE__*/Equal.equivalence();
/**
Returns a function that checks if an `Option` contains a specified value
using the default `Equivalence`.

**Details**

This function allows you to check whether an `Option` contains a specific
value. It uses the default `Equivalence` for equality comparison. If the
`Option` is `Some` and its value is equivalent to the provided value, the
result is `true`. If the `Option` is `None` or the values are not equivalent,
the result is `false`.

@example
```ts
import { Option } from "effect"

console.log(Option.some(2).pipe(Option.contains(2)))
// Output: true

console.log(Option.some(1).pipe(Option.contains(2)))
// Output: false

console.log(Option.none().pipe(Option.contains(2)))
// Output: false
```

@see {@link containsWith} for a version that allows you to specify a custom equivalence function.

@category Elements
@since 2.0.0
/
const contains = exports.contains = /*#__PURE__*/containsWith(_equivalence);
/**
Checks if a value in an `Option` satisfies a given predicate or refinement.

**Details**

This function allows you to check if a value inside a `Some` meets a
specified condition. If the `Option` is `None`, the result is `false`. If the
`Option` is `Some`, the provided predicate or refinement is applied to the
value:

- If the condition is met, the result is `true`.
- If the condition is not met, the result is `false`.

@example
```ts
import { Option } from "effect"

const isEven = (n: number) => n % 2 === 0

console.log(Option.some(2).pipe(Option.exists(isEven)))
// Output: true

console.log(Option.some(1).pipe(Option.exists(isEven)))
// Output: false

console.log(Option.none().pipe(Option.exists(isEven)))
// Output: false
```

@category Elements
@since 2.0.0
/
const exists = exports.exists = /*#__PURE__*/(0, _Function.dual)(2, (self, refinement) => isNone(self) ? false : refinement(self.value));
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

@example
```ts
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

@see {@link Do}
@see {@link bind}
@see {@link let_ let}

@category Do notation
@since 2.0.0
/
const bindTo = exports.bindTo = /*#__PURE__*/doNotation.bindTo(map);
const let_ = exports.let = /*#__PURE__*/doNotation.let_(map);
/**
The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

@example
```ts
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

@see {@link Do}
@see {@link bindTo}
@see {@link let_ let}

@category Do notation
@since 2.0.0
/
const bind = exports.bind = /*#__PURE__*/doNotation.bind(map, flatMap);
/**
The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.

Here's how the do simulation works:

1. Start the do simulation using the `Do` value
2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values
3. You can accumulate multiple `bind` statements to define multiple variables within the scope
4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope

@example
```ts
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))
```

@see {@link bindTo}
@see {@link bind}
@see {@link let_ let}

@category Do notation
@since 2.0.0
/
const Do = exports.Do = /*#__PURE__*/some({});
const adapter = /*#__PURE__*/Gen.adapter();
/**
Similar to `Effect.gen`, `Option.gen` provides a more readable,
generator-based syntax for working with `Option` values, making code that
involves `Option` easier to write and understand. This approach is similar to
using `async/await` but tailored for `Option`.

**Example** (Using `Option.gen` to Create a Combined Value)

```ts
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

const person = Option.gen(function* () {
  const name = (yield* maybeName).toUpperCase()
  const age = yield* maybeAge
  return { name, age }
})

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }
```

@category Generators
@since 2.0.0
/
const gen = (...args) => {
  const f = args.length === 1 ? args[0] : args[1].bind(args[0]);
  const iterator = f(adapter);
  let state = iterator.next();
  while (!state.done) {
    const current = Gen.isGenKind(state.value) ? state.value.value : Gen.yieldWrapGet(state.value);
    if (isNone(current)) {
      return current;
    }
    state = iterator.next(current.value);
  }
  return some(state.value);
};
/**
Merges two optional values, applying a function if both exist.
Unlike {@link zipWith}, this function returns `None` only if both inputs are `None`.

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `make(= make;
const string = exports.string = /*#__PURE__*/make((self, that)`

JSDoc:

This module provides an implementation of the `Order` type class which is used to define a total ordering on some type `A`.
An order is defined by a relation `<=`, which obeys the following laws:

- either `x <= y` or `y <= x` (totality)
- if `x <= y` and `y <= x`, then `x == y` (antisymmetry)
- if `x <= y` and `y <= z`, then `x <= z` (transitivity)

The truth table for compare is defined as follows:

| `x <= y` | `x >= y` | Ordering |                       |
| -------- | -------- | -------- | --------------------- |
| `true`   | `true`   | `0`      | corresponds to x == y |
| `true`   | `false`  | `< 0`    | corresponds to x < y  |
| `false`  | `true`   | `> 0`    | corresponds to x > y  |

@since 2.0.0
/

/**
@category constructors
@since 2.0.0
/
const make = compare => (self, that) => self === that ? 0 : compare(self, that);
/**
@category instances
@since 2.0.0

## reverse

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `reverse(= reverse;
const combine = exports.combine = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category instances
@since 2.0.0
/
const number = exports.number = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);
/**
@category instances
@since 2.0.0
/
const boolean = exports.boolean = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);
/**
@category instances
@since 2.0.0
/
const bigint = exports.bigint = /*#__PURE__*/make((self, that) => self < that ? -1 : 1);
/**
@since 2.0.0
/
const reverse = O => make((self, that) => O(that, self));
/**
@category combining
@since 2.0.0

## empty

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `empty(= empty;
const combineAll = collection => combineMany(empty()`

JSDoc:

@category combining
@since 2.0.0
/
const combineMany = exports.combineMany = /*#__PURE__*/(0, _Function.dual)(2, (self, collection) => make((a1, a2) => {
  let out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  for (const O of collection) {
    out = O(a1, a2);
    if (out !== 0) {
      return out;
    }
  }
  return out;
}));
/**
@since 2.0.0
/
const empty = () => make(() => 0);
/**
@category combining
@since 2.0.0

## combineAll

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `combineAll(= combineAll;
const mapInput = exports.mapInput = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category mapping
@since 2.0.0

## all

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `all(= all;
const productMany = exports.productMany = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category instances
@since 2.0.0
/
const Date = exports.Date = /*#__PURE__*/mapInput(number, date => date.getTime());
/**
@category combining
@since 2.0.0
/
const product = exports.product = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(([xa, xb], [ya, yb]) => {
  const o = self(xa, ya);
  return o !== 0 ? o : that(xb, yb);
}));
/**
@category combining
@since 2.0.0
/
const all = collection => {
  return make((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
};
/**
@category combining
@since 2.0.0

## tuple

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `tuple(= tuple;
const array = O => make((self, that)`

JSDoc:

Similar to `Promise.all` but operates on `Order`s.

```
[Order<A>, Order<B>, ...] -> Order<[A, B, ...]>
```

This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
of the tuple.

@category combinators
@since 2.0.0
/
const tuple = (...elements) => all(elements);
/**
This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
If all elements are equal, the arrays are then compared based on their length.
It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.

@category combinators
@since 2.0.0

## array

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `array(= array;
const struct = fields => {
  const keys = Object.keys(fields)`

JSDoc:

This function creates and returns a new `Order` for a struct of values based on the given `Order`s
for each property in the struct.

@category combinators
@since 2.0.0

## struct

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `struct(= struct;
const lessThan = O => (0, _Function.dual)`

JSDoc:

Test whether one value is _strictly less than_ another.

@since 2.0.0

## lessThan

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `lessThan(= lessThan;
const greaterThan = O => (0, _Function.dual)`

JSDoc:

Test whether one value is _strictly greater than_ another.

@since 2.0.0

## greaterThan

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `greaterThan(= greaterThan;
const lessThanOrEqualTo = O => (0, _Function.dual)`

JSDoc:

Test whether one value is _non-strictly less than_ another.

@since 2.0.0

## lessThanOrEqualTo

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `lessThanOrEqualTo(= lessThanOrEqualTo;
const greaterThanOrEqualTo = O => (0, _Function.dual)`

JSDoc:

Test whether one value is _non-strictly greater than_ another.

@since 2.0.0

## greaterThanOrEqualTo

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `greaterThanOrEqualTo(= greaterThanOrEqualTo;
const min = O => (0, _Function.dual)`

JSDoc:

Take the minimum of two values. If they are considered equal, the first argument is chosen.

@since 2.0.0

## min

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `min(= min;
const max = O => (0, _Function.dual)`

JSDoc:

Take the maximum of two values. If they are considered equal, the first argument is chosen.

@since 2.0.0

## max

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `max(= max;
const clamp = O => (0, _Function.dual)`

JSDoc:

Clamp a value between a minimum and a maximum.

@example
```ts
import * as assert from "node:assert"
import { Order, Number } from "effect"

const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })

assert.equal(clamp(3), 3)
assert.equal(clamp(0), 1)
assert.equal(clamp(6), 5)
```

@since 2.0.0

## clamp

Source: `my-backend/node_modules/effect/dist/cjs/Order.js`

Signature: `clamp(= clamp;
const between = O => (0, _Function.dual)`

JSDoc:

Test whether a value is between a minimum and a maximum (inclusive).

@since 2.0.0

## reverse

Source: `my-backend/node_modules/effect/dist/cjs/Ordering.js`

Signature: `reverse(= reverse;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Inverts the ordering of the input `Ordering`.

@example
```ts
import * as assert from "node:assert"
import { reverse } from "effect/Ordering"

assert.deepStrictEqual(reverse(1), -1)
assert.deepStrictEqual(reverse(-1), 1)
assert.deepStrictEqual(reverse(0), 0)
```

@since 2.0.0
/
const reverse = o => o === -1 ? 1 : o === 1 ? -1 : 0;
/**
Depending on the `Ordering` parameter given to it, returns a value produced by one of the 3 functions provided as parameters.

@example
```ts
import * as assert from "node:assert"
import { Ordering } from "effect"
import { constant } from "effect/Function"

const toMessage = Ordering.match({
  onLessThan: constant('less than'),
  onEqual: constant('equal'),
  onGreaterThan: constant('greater than')
})

assert.deepStrictEqual(toMessage(-1), "less than")
assert.deepStrictEqual(toMessage(0), "equal")
assert.deepStrictEqual(toMessage(1), "greater than")
```

@category pattern matching
@since 2.0.0

## Pointer

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `Pointer(= Pointer;
class Unexpected {
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Unexpected";
  constructor(actual,
  /**
   * @since 3.10.0
   */
  message)`

JSDoc:

@since 3.10.0
/

/**
@category model
@since 3.10.0
/
class Pointer {
  path;
  actual;
  issue;
  /**
@since 3.10.0
/
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}
/**
Error that occurs when an unexpected key or index is present.

@category model
@since 3.10.0

## Unexpected

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `Unexpected(= Unexpected;
class Missing {
  ast;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Missing";
  /**
   * @since 3.10.0
   */
  actual = undefined;
  constructor(
  /**
   * @since 3.10.0
   */
  ast,
  /**
   * @since 3.10.0
   */
  message)`

JSDoc:

Error that occurs when a required key or index is missing.

@category model
@since 3.10.0

## Missing

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `Missing(= Missing;
class Composite {
  ast;
  actual;
  issues;
  output;
  /**
   * @since 3.10.0
   */
  _tag = "Composite";
  constructor(ast, actual, issues, output)`

JSDoc:

Error that contains multiple issues.

@category model
@since 3.10.0

## Composite

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `Composite(= Composite;
class Refinement {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(ast, actual, kind, issue)`

JSDoc:

Error that occurs when a refinement has an error.

@category model
@since 3.10.0

## Refinement

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `Refinement(= Refinement;
class Transformation {
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(ast, actual, kind, issue)`

JSDoc:

Error that occurs when a transformation has an error.

@category model
@since 3.10.0

## Transformation

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `Transformation(= Transformation;
class Type {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Type";
  constructor(ast, actual, message)`

JSDoc:

The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.

@category model
@since 3.10.0

## Type

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `Type(= Type;
class Forbidden {
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Forbidden";
  constructor(ast, actual, message)`

JSDoc:

The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).

@category model
@since 3.10.0

## Forbidden

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `Forbidden(= Forbidden;
const ParseErrorTypeId = exports.ParseErrorTypeId = /*#__PURE__*/Symbol.for("effect/Schema/ParseErrorTypeId")`

JSDoc:

@category type id
@since 3.10.0

## isParseError

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `isParseError(= isParseError;
class ParseError extends /*#__PURE__*/(0, _Data.TaggedError)`

JSDoc:

@since 3.10.0
/
const isParseError = u => Predicate.hasProperty(u, ParseErrorTypeId);
/**
@since 3.10.0

## ParseError

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `ParseError(= ParseError;
const parseError = issue => new ParseError({
  issue
})`

JSDoc:

@since 3.10.0
/
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  /**
@since 3.10.0
/
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
@since 3.10.0
/
  [Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/**
@category constructors
@since 3.10.0

## parseError

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `parseError(= parseError;
const succeed = exports.succeed = Either.right;
/**
 * @category constructors
 * @since 3.10.0
 */
const fail = exports.fail = Either.left;
const _try = exports.try = Either.try;
/**
 * @category constructors
 * @since 3.10.0
 */
const fromOption = exports.fromOption = Either.fromOption;
const isEither = Either.isEither;
/**
 * @category optimisation
 * @since 3.10.0
 */
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category constructors
@since 3.10.0

## eitherOrUndefined

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `eitherOrUndefined(= eitherOrUndefined;
const mapBoth = exports.mapBoth = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category optimisation
@since 3.10.0
/
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  return isEither(self) ? Either.map(self, f) : Effect.map(self, f);
});
/**
@category optimisation
@since 3.10.0
/
const mapError = exports.mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  return isEither(self) ? Either.mapLeft(self, f) : Effect.mapError(self, f);
});
// TODO(4.0): remove
/**
@category optimisation
@since 3.10.0
/
const eitherOrUndefined = self => {
  if (isEither(self)) {
    return self;
  }
};
/**
@category optimisation
@since 3.10.0

## decodeUnknownSync

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `decodeUnknownSync(= decodeUnknownSync;
const decodeUnknownOption = (schema, options)`

JSDoc:

@category optimisation
@since 3.10.0
/
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  return isEither(self) ? Either.match(self, {
    onLeft: f,
    onRight: Either.right
  }) : Effect.catchAll(self, f);
});
/** @internal */
const mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === undefined || Predicate.isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
exports.mergeInternalOptions = mergeInternalOptions;
const getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
const getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => Either.getOrThrowWith(parser(input, overrideOptions), parseError);
};
/** @internal */
const getOption = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => Option.getRight(parser(input, overrideOptions));
};
exports.getOption = getOption;
const getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
/**
@throws `ParseError`
@category decoding
@since 3.10.0
/
const decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
/**
@category decoding
@since 3.10.0

## decodeUnknownOption

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `decodeUnknownOption(= decodeUnknownOption;
const decodeUnknownEither = (schema, options)`

JSDoc:

@category decoding
@since 3.10.0

## decodeUnknownEither

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `decodeUnknownEither(= decodeUnknownEither;
const decodeUnknownPromise = (schema, options)`

JSDoc:

@category decoding
@since 3.10.0

## decodeUnknownPromise

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `decodeUnknownPromise(= decodeUnknownPromise;
const decodeUnknown = (schema, options)`

JSDoc:

@category decoding
@since 3.10.0

## decodeUnknown

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `decodeUnknown(= decodeUnknown;
const encodeUnknownSync = (schema, options)`

JSDoc:

@throws `ParseError`
@category encoding
@since 3.10.0

## encodeUnknownSync

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `encodeUnknownSync(= encodeUnknownSync;
const encodeUnknownOption = (schema, options)`

JSDoc:

@category encoding
@since 3.10.0

## encodeUnknownOption

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `encodeUnknownOption(= encodeUnknownOption;
const encodeUnknownEither = (schema, options)`

JSDoc:

@category encoding
@since 3.10.0

## encodeUnknownEither

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `encodeUnknownEither(= encodeUnknownEither;
const encodeUnknownPromise = (schema, options)`

JSDoc:

@category encoding
@since 3.10.0

## encodeUnknownPromise

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `encodeUnknownPromise(= encodeUnknownPromise;
const encodeUnknown = (schema, options)`

JSDoc:

@category encoding
@since 3.10.0

## encodeUnknown

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `encodeUnknown(= encodeUnknown;
const decodeSync = exports.decodeSync = decodeUnknownSync;
/**
 * @category decoding
 * @since 3.10.0
 */
const decodeOption = exports.decodeOption = decodeUnknownOption;
/**
 * @category decoding
 * @since 3.10.0
 */
const decodeEither = exports.decodeEither = decodeUnknownEither;
/**
 * @category decoding
 * @since 3.10.0
 */
const decodePromise = exports.decodePromise = decodeUnknownPromise;
/**
 * @category decoding
 * @since 3.10.0
 */
const decode = exports.decode = decodeUnknown;
/**
 * @throws `ParseError`
 * @category validation
 * @since 3.10.0
 */
const validateSync = (schema, options)`

JSDoc:

@category decoding
@since 3.10.0

## validateSync

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `validateSync(= validateSync;
const validateOption = (schema, options)`

JSDoc:

@category validation
@since 3.10.0

## validateOption

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `validateOption(= validateOption;
const validateEither = (schema, options)`

JSDoc:

@category validation
@since 3.10.0

## validateEither

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `validateEither(= validateEither;
const validatePromise = (schema, options)`

JSDoc:

@category validation
@since 3.10.0

## validatePromise

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `validatePromise(= validatePromise;
const validate = (schema, options)`

JSDoc:

@category validation
@since 3.10.0

## validate

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `validate(= validate;
const is = (schema, options)`

JSDoc:

By default the option `exact` is set to `true`.

@category validation
@since 3.10.0

## is

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `is(= is;
const asserts = (schema, options)`

JSDoc:

By default the option `exact` is set to `true`.

@throws `ParseError`
@category validation
@since 3.10.0

## asserts

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `asserts(= asserts;
const encodeSync = exports.encodeSync = encodeUnknownSync;
/**
 * @category encoding
 * @since 3.10.0
 */
const encodeOption = exports.encodeOption = encodeUnknownOption;
/**
 * @category encoding
 * @since 3.10.0
 */
const encodeEither = exports.encodeEither = encodeUnknownEither;
/**
 * @category encoding
 * @since 3.10.0
 */
const encodePromise = exports.encodePromise = encodeUnknownPromise;
/**
 * @category encoding
 * @since 3.10.0
 */
const encode = exports.encode = encodeUnknown;
const decodeMemoMap = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@category encoding
@since 3.10.0

## getLiterals

Source: `my-backend/node_modules/effect/dist/cjs/ParseResult.js`

Signature: `getLiterals(= getLiterals;
const getSearchTree = (members, isDecoding)`

JSDoc:

@internal */
const getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration":
      {
        const annotation = AST.getSurrogateAnnotation(ast);
        if (Option.isSome(annotation)) {
          return getLiterals(annotation.value, isDecoding);
        }
        break;
      }
    case "TypeLiteral":
      {
        const out = [];
        for (let i = 0; i < ast.propertySignatures.length; i++) {
          const propertySignature = ast.propertySignatures[i];
          const type = isDecoding ? AST.encodedAST(propertySignature.type) : AST.typeAST(propertySignature.type);
          if (AST.isLiteral(type) && !propertySignature.isOptional) {
            out.push([propertySignature.name, type]);
          }
        }
        return out;
      }
    case "TupleType":
      {
        const out = [];
        for (let i = 0; i < ast.elements.length; i++) {
          const element = ast.elements[i];
          const type = isDecoding ? AST.encodedAST(element.type) : AST.typeAST(element.type);
          if (AST.isLiteral(type) && !element.isOptional) {
            out.push([i, type]);
          }
        }
        return out;
      }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
/**
The purpose of the algorithm is to narrow down the pool of possible
candidates for decoding as much as possible.

This function separates the schemas into two groups, `keys` and `otherwise`:

- `keys`: the schema has at least one property with a literal value
- `otherwise`: the schema has no properties with a literal value

If a schema has at least one property with a literal value, so it ends up in
`keys`, first a namespace is created for the name of the property containing
the literal, and then within this namespace a "bucket" is created for the
literal value in which to store all the schemas that have the same property
and literal value.

@internal

## pipeArguments

Source: `my-backend/node_modules/effect/dist/cjs/Pipeable.js`

Signature: `pipeArguments(= pipeArguments;
const Prototype = exports.Prototype = {
  pipe()`

JSDoc:

@since 2.0.0
/
/**
@since 2.0.0
/
const pipeArguments = (self, args) => {
  switch (args.length) {
    case 0:
      return self;
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](args[2](args[1](args[0](self))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
    default:
      {
        let ret = self;
        for (let i = 0, len = args.length; i < len; i++) {
          ret = args[i](ret);
        }
        return ret;
      }
  }
};
/**
@since 3.15.0
@category Prototypes

## isTruthy

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isTruthy(= isTruthy;
const isSet = input => input instanceof Set;
/**
 * Tests if a value is a `Map`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isMap } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isMap(new Map()`

JSDoc:

@since 2.0.0
/

/**
Given a `Predicate<A>` returns a `Predicate<B>`

@example
```ts
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)

assert.deepStrictEqual(minLength3("a"), false)
assert.deepStrictEqual(minLength3("aa"), false)
assert.deepStrictEqual(minLength3("aaa"), true)
assert.deepStrictEqual(minLength3("aaaa"), true)
```

@category combinators
@since 2.0.0
/
const mapInput = exports.mapInput = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => b => self(f(b)));
/**
Determine if an `Array` is a tuple with exactly `N` elements, narrowing down the type to `TupleOf`.

An `Array` is considered to be a `TupleOf` if its length is exactly `N`.

@example
```ts
import * as assert from "node:assert"
import { isTupleOf } from "effect/Predicate"

assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);
assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);
assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);

const arr: number[] = [1, 2, 3];
if (isTupleOf(arr, 3)) {
  console.log(arr);
  // ^? [number, number, number]
}
```

@category guards
@since 3.3.0
/
const isTupleOf = exports.isTupleOf = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => self.length === n);
/**
Determine if an `Array` is a tuple with at least `N` elements, narrowing down the type to `TupleOfAtLeast`.

An `Array` is considered to be a `TupleOfAtLeast` if its length is at least `N`.

@example
```ts
import * as assert from "node:assert"
import { isTupleOfAtLeast } from "effect/Predicate"

assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);

const arr: number[] = [1, 2, 3, 4];
if (isTupleOfAtLeast(arr, 3)) {
  console.log(arr);
  // ^? [number, number, number, ...number[]]
}
```

@category guards
@since 3.3.0
/
const isTupleOfAtLeast = exports.isTupleOfAtLeast = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => self.length >= n);
/**
Tests if a value is `truthy`.

@example
```ts
import * as assert from "node:assert"
import { isTruthy } from "effect/Predicate"

assert.deepStrictEqual(isTruthy(1), true)
assert.deepStrictEqual(isTruthy(0), false)
assert.deepStrictEqual(isTruthy(""), false)
```

@category guards
@since 2.0.0
/
const isTruthy = input => !!input;
/**
Tests if a value is a `Set`.

@example
```ts
import * as assert from "node:assert"
import { isSet } from "effect/Predicate"

assert.deepStrictEqual(isSet(new Set([1, 2])), true)
assert.deepStrictEqual(isSet(new Set()), true)
assert.deepStrictEqual(isSet({}), false)
assert.deepStrictEqual(isSet(null), false)
assert.deepStrictEqual(isSet(undefined), false)
```

@category guards
@since 2.0.0

## isMap

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isMap(= isMap;
const isString = input => typeof input === "string";
/**
 * Tests if a value is a `number`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isNumber } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNumber(2)`

JSDoc:

Tests if a value is a `string`.

@example
```ts
import * as assert from "node:assert"
import { isString } from "effect/Predicate"

assert.deepStrictEqual(isString("a"), true)

assert.deepStrictEqual(isString(1), false)
```

@category guards
@since 2.0.0

## isNumber

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isNumber(= isNumber;
const isBoolean = input => typeof input === "boolean";
/**
 * Tests if a value is a `bigint`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isBigInt } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isBigInt(1n)`

JSDoc:

Tests if a value is a `boolean`.

@example
```ts
import * as assert from "node:assert"
import { isBoolean } from "effect/Predicate"

assert.deepStrictEqual(isBoolean(true), true)

assert.deepStrictEqual(isBoolean("true"), false)
```

@category guards
@since 2.0.0

## isBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isBigInt(= isBigInt;
const isSymbol = input => typeof input === "symbol";
// TODO: make public
/** @internal */
exports.isSymbol = isSymbol;
const isPropertyKey = u => isString(u)`

JSDoc:

Tests if a value is a `symbol`.

@example
```ts
import * as assert from "node:assert"
import { isSymbol } from "effect/Predicate"

assert.deepStrictEqual(isSymbol(Symbol.for("a")), true)

assert.deepStrictEqual(isSymbol("a"), false)
```

@category guards
@since 2.0.0

## isPropertyKey

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isPropertyKey(= isPropertyKey;
const isFunction = exports.isFunction = _Function.isFunction;
/**
 * Tests if a value is `undefined`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isUndefined } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isUndefined(undefined)`

JSDoc:

Tests if a value is a `function`.

@example
```ts
import * as assert from "node:assert"
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)

assert.deepStrictEqual(isFunction("function"), false)
```

@category guards
@since 2.0.0

## isUndefined

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isUndefined(= isUndefined;
const isNotUndefined = input => input !== undefined;
/**
 * Tests if a value is `null`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isNull } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNull(null)`

JSDoc:

Tests if a value is not `undefined`.

@example
```ts
import * as assert from "node:assert"
import { isNotUndefined } from "effect/Predicate"

assert.deepStrictEqual(isNotUndefined(null), true)
assert.deepStrictEqual(isNotUndefined("undefined"), true)

assert.deepStrictEqual(isNotUndefined(undefined), false)
```

@category guards
@since 2.0.0

## isNull

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isNull(= isNull;
const isNotNull = input => input !== null;
/**
 * A guard that always fails.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isNever } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isNever(null)`

JSDoc:

Tests if a value is not `null`.

@example
```ts
import * as assert from "node:assert"
import { isNotNull } from "effect/Predicate"

assert.deepStrictEqual(isNotNull(undefined), true)
assert.deepStrictEqual(isNotNull("null"), true)

assert.deepStrictEqual(isNotNull(null), false)
```

@category guards
@since 2.0.0

## isNever

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isNever(= isNever;
const isUnknown = _ => true;
/** @internal */
exports.isUnknown = isUnknown;
const isRecordOrArray = input => typeof input === "object" && input !== null;
/**
 * Tests if a value is an `object`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isObject } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isObject({})`

JSDoc:

A guard that always succeeds.

@example
```ts
import * as assert from "node:assert"
import { isUnknown } from "effect/Predicate"

assert.deepStrictEqual(isUnknown(null), true)
assert.deepStrictEqual(isUnknown(undefined), true)

assert.deepStrictEqual(isUnknown({}), true)
assert.deepStrictEqual(isUnknown([]), true)
```

@category guards
@since 2.0.0

## isObject

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isObject(= isObject;
const hasProperty = exports.hasProperty = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Checks whether a value is an `object` containing a specified property key.

@category guards
@since 2.0.0

## isNullable

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isNullable(= isNullable;
const isNotNullable = input => input !== null && input !== undefined;
/**
 * A guard that succeeds when the input is an `Error`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isError } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isError(new Error()`

JSDoc:

Tests if a value is an `object` with a property `_tag` that matches the given tag.

@example
```ts
import * as assert from "node:assert"
import { isTagged } from "effect/Predicate"

assert.deepStrictEqual(isTagged(1, "a"), false)
assert.deepStrictEqual(isTagged(null, "a"), false)
assert.deepStrictEqual(isTagged({}, "a"), false)
assert.deepStrictEqual(isTagged({ a: "a" }, "a"), false)
assert.deepStrictEqual(isTagged({ _tag: "a" }, "a"), true)
assert.deepStrictEqual(isTagged("a")({ _tag: "a" }), true)
```

@category guards
@since 2.0.0
/
const isTagged = exports.isTagged = /*#__PURE__*/(0, _Function.dual)(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
/**
A guard that succeeds when the input is `null` or `undefined`.

@example
```ts
import * as assert from "node:assert"
import { isNullable } from "effect/Predicate"

assert.deepStrictEqual(isNullable(null), true)
assert.deepStrictEqual(isNullable(undefined), true)

assert.deepStrictEqual(isNullable({}), false)
assert.deepStrictEqual(isNullable([]), false)
```

@category guards
@since 2.0.0
/
const isNullable = input => input === null || input === undefined;
/**
A guard that succeeds when the input is not `null` or `undefined`.

@example
```ts
import * as assert from "node:assert"
import { isNotNullable } from "effect/Predicate"

assert.deepStrictEqual(isNotNullable({}), true)
assert.deepStrictEqual(isNotNullable([]), true)

assert.deepStrictEqual(isNotNullable(null), false)
assert.deepStrictEqual(isNotNullable(undefined), false)
```

@category guards
@since 2.0.0

## isError

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isError(= isError;
const isUint8Array = input => input instanceof Uint8Array;
/**
 * A guard that succeeds when the input is a `Date`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isDate } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isDate(new Date()`

JSDoc:

A guard that succeeds when the input is a `Uint8Array`.

@example
```ts
import * as assert from "node:assert"
import { isUint8Array } from "effect/Predicate"

assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)

assert.deepStrictEqual(isUint8Array(null), false)
assert.deepStrictEqual(isUint8Array({}), false)
```

@category guards
@since 2.0.0

## isDate

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isDate(= isDate;
const isIterable = input => hasProperty(input, Symbol.iterator)`

JSDoc:

A guard that succeeds when the input is an `Iterable`.

@example
```ts
import * as assert from "node:assert"
import { isIterable } from "effect/Predicate"

assert.deepStrictEqual(isIterable([]), true)
assert.deepStrictEqual(isIterable(new Set()), true)

assert.deepStrictEqual(isIterable(null), false)
assert.deepStrictEqual(isIterable({}), false)
```

@category guards
@since 2.0.0

## isIterable

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isIterable(= isIterable;
const isRecord = input => isRecordOrArray(input)`

JSDoc:

A guard that succeeds when the input is a record.

@example
```ts
import * as assert from "node:assert"
import { isRecord } from "effect/Predicate"

assert.deepStrictEqual(isRecord({}), true)
assert.deepStrictEqual(isRecord({ a: 1 }), true)

assert.deepStrictEqual(isRecord([]), false)
assert.deepStrictEqual(isRecord([1, 2, 3]), false)
assert.deepStrictEqual(isRecord(null), false)
assert.deepStrictEqual(isRecord(undefined), false)
assert.deepStrictEqual(isRecord(() => null), false)
```

@category guards
@since 2.0.0

## isRecord

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isRecord(= isRecord;
const isReadonlyRecord = exports.isReadonlyRecord = isRecord;
/**
 * A guard that succeeds when the input is a Promise.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { isPromise } from "effect/Predicate"
 *
 * assert.deepStrictEqual(isPromise({})`

JSDoc:

A guard that succeeds when the input is a readonly record.

@example
```ts
import * as assert from "node:assert"
import { isReadonlyRecord } from "effect/Predicate"

assert.deepStrictEqual(isReadonlyRecord({}), true)
assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)

assert.deepStrictEqual(isReadonlyRecord([]), false)
assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)
assert.deepStrictEqual(isReadonlyRecord(null), false)
assert.deepStrictEqual(isReadonlyRecord(undefined), false)
```

@category guards
@since 2.0.0

## isPromise

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isPromise(= isPromise;
const isPromiseLike = input => hasProperty(input, "then")`

JSDoc:

@category guards
@since 2.0.0

## isPromiseLike

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `isPromiseLike(= isPromiseLike;
const isRegExp = input => input instanceof RegExp;
/**
 * @since 2.0.0
 */
exports.isRegExp = isRegExp;
const compose = exports.compose = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Tests if a value is a `RegExp`.

@example
```ts
import * as assert from "node:assert"
import { Predicate } from "effect"

assert.deepStrictEqual(Predicate.isRegExp(/a/), true)
assert.deepStrictEqual(Predicate.isRegExp("a"), false)
```

@category guards
@since 3.9.0

## product

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `product(= product;
const all = collection => {
  return as => {
    let collectionIndex = 0;
    for (const p of collection)`

JSDoc:

@category combining
@since 2.0.0
/
const product = (self, that) => ([a, b]) => self(a) && that(b);
/**
@category combining
@since 2.0.0

## all

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `all(= all;
const productMany = (self, collection)`

JSDoc:

@category combining
@since 2.0.0

## productMany

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `productMany(= productMany;
const tuple = (...elements)`

JSDoc:

Similar to `Promise.all` but operates on `Predicate`s.

```ts skip-type-checking
[Refinement<A, B>, Refinement<C, D>, ...] -> Refinement<[A, C, ...], [B, D, ...]>
[Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>
[Refinement<A, B>, Predicate<C>, ...] -> Refinement<[A, C, ...], [B, C, ...]>
```

@since 2.0.0

## tuple

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `tuple(= tuple;
const struct = fields => {
  const keys = Object.keys(fields)`

JSDoc:

```ts skip-type-checking
{ ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>
{ a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>
{ ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: ; ... }>
```

@since 2.0.0

## struct

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `struct(= struct;
const not = self => a => !self(a)`

JSDoc:

Negates the result of a given predicate.

@example
```ts
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const isPositive = Predicate.not(Number.lessThan(0))

assert.deepStrictEqual(isPositive(-1), false)
assert.deepStrictEqual(isPositive(0), true)
assert.deepStrictEqual(isPositive(1), true)
```

@category combinators
@since 2.0.0

## not

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `not(= not;
const or = exports.or = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.

@example
```ts
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))

assert.deepStrictEqual(nonZero(-1), true)
assert.deepStrictEqual(nonZero(0), false)
assert.deepStrictEqual(nonZero(1), true)
```

@category combinators
@since 2.0.0

## every

Source: `my-backend/node_modules/effect/dist/cjs/Predicate.js`

Signature: `every(= every;
const some = collection => a => {
  for (const p of collection)`

JSDoc:

Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.

@example
```ts
import * as assert from "node:assert"
import { Predicate } from "effect"

const minLength = (n: number) => (s: string) => s.length >= n
const maxLength = (n: number) => (s: string) => s.length <= n

const length = (n: number) => Predicate.and(minLength(n), maxLength(n))

assert.deepStrictEqual(length(2)("aa"), true)
assert.deepStrictEqual(length(2)("a"), false)
assert.deepStrictEqual(length(2)("aaa"), false)
```

@category combinators
@since 2.0.0
/
const and = exports.and = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => self(a) && that(a));
/**
@category combinators
@since 2.0.0
/
const xor = exports.xor = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => self(a) !== that(a));
/**
@category combinators
@since 2.0.0
/
const eqv = exports.eqv = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => self(a) === that(a));
/**
Represents the logical implication combinator for predicates. In formal
logic, the implication operator `->` denotes that if the first proposition
(antecedent) is true, then the second proposition (consequent) must also be
true. In simpler terms, `p implies q` can be interpreted as "if p then q". If
the first predicate holds, then the second predicate must hold
for the given context.

In practical terms within TypeScript, `p implies q` is equivalent to `!p || (p && q)`.

Note that if the antecedent is `false`, the result is `true` by default
because the outcome of the consequent cannot be determined.

This function is useful in situations where you need to enforce rules or
constraints that are contingent on certain conditions.
It proves especially helpful in defining property tests.

The example below illustrates the transitive property of order using the
`implies` function. In simple terms, if `a <= b` and `b <= c`, then `a <= c`
must be true.

@example
```ts
import * as assert from "node:assert"
import { Predicate } from "effect"

type Triple = {
  readonly a: number
  readonly b: number
  readonly c: number
}

const transitivity = Predicate.implies(
  // antecedent
  (input: Triple) => input.a <= input.b && input.b <= input.c,
  // consequent
  (input: Triple) => input.a <= input.c
)

assert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)
// antecedent is `false`, so the result is `true`
assert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)
```

@category combinators
@since 2.0.0
/
const implies = exports.implies = /*#__PURE__*/(0, _Function.dual)(2, (antecedent, consequent) => a => antecedent(a) ? consequent(a) : true);
/**
@category combinators
@since 2.0.0
/
const nor = exports.nor = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => !(self(a) || that(a)));
/**
@category combinators
@since 2.0.0
/
const nand = exports.nand = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => a => !(self(a) && that(a)));
/**
@category elements
@since 2.0.0
/
const every = collection => a => {
  for (const p of collection) {
    if (!p(a)) {
      return false;
    }
  }
  return true;
};
/**
@category elements
@since 2.0.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/Readable.js`

Signature: `make(= make;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 2.0.0
@category type ids
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Readable");
/**
@since 2.0.0
@category refinements
/
const isReadable = u => (0, _Predicate.hasProperty)(u, TypeId);
exports.isReadable = isReadable;
const Proto = {
  [TypeId]: TypeId,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/**
@since 2.0.0
@category constructors
/
const make = get => {
  const self = Object.create(Proto);
  self.get = get;
  return self;
};
/**
@since 2.0.0
@category combinators

## empty

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `empty(= empty;
const isEmptyRecord = self => keys(self)`

JSDoc:

This module provides utility functions for working with records in TypeScript.

@since 2.0.0
/

/**
Creates a new, empty record.

@category constructors
@since 2.0.0
/
const empty = () => ({});
/**
Determine if a record is empty.

@example
```ts
import * as assert from "node:assert"
import { isEmptyRecord } from "effect/Record"

assert.deepStrictEqual(isEmptyRecord({}), true);
assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);
```

@category guards
@since 2.0.0

## isEmptyRecord

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `isEmptyRecord(= isEmptyRecord;
const isEmptyReadonlyRecord = exports.isEmptyReadonlyRecord = isEmptyRecord;
/**
 * Takes an iterable and a projection function and returns a record.
 * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { fromIterableWith } from "effect/Record"
 *
 * const input = [1, 2, 3, 4]
 *
 * assert.deepStrictEqual(
 *   fromIterableWith(input, a => [String(a)`

JSDoc:

Determine if a record is empty.

@example
```ts
import * as assert from "node:assert"
import { isEmptyReadonlyRecord } from "effect/Record"

assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);
assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);
```

@category guards
@since 2.0.0

## fromIterableBy

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `fromIterableBy(= fromIterableBy;
const fromEntries = exports.fromEntries = Object.fromEntries;
/**
 * Transforms the values of a record into an `Array` with a custom mapping function.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { collect } from "effect/Record"
 *
 * const x = { a: 1, b: 2, c: 3 }
 * assert.deepStrictEqual(collect(x, (key, n)`

JSDoc:

Creates a new record from an iterable, utilizing the provided function to determine the key for each element.

@example
```ts
import * as assert from "node:assert"
import { fromIterableBy } from "effect/Record"

const users = [
  { id: "2", name: "name2" },
  { id: "1", name: "name1" }
]

assert.deepStrictEqual(
  fromIterableBy(users, user => user.id),
  {
    "2": { id: "2", name: "name2" },
    "1": { id: "1", name: "name1" }
  }
)
```

@category constructors
@since 2.0.0
/
const fromIterableBy = (items, f) => fromIterableWith(items, a => [f(a), a]);
/**
Builds a record from an iterable of key-value pairs.

If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the
previous ones. So the resulting record will only have the value of the last occurrence of each key.

@example
```ts
import * as assert from "node:assert"
import { fromEntries } from "effect/Record"

const input: Array<[string, number]> = [["a", 1], ["b", 2]]

assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })
```

@since 2.0.0
@category constructors

## size

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `size(= size;
const has = exports.has = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Takes a record and returns an array of tuples containing its keys and values.

@example
```ts
import * as assert from "node:assert"
import { toEntries } from "effect/Record"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(toEntries(x), [["a", 1], ["b", 2], ["c", 3]])
```

@category conversions
@since 2.0.0
/
const toEntries = exports.toEntries = /*#__PURE__*/collect((key, value) => [key, value]);
/**
Returns the number of key/value pairs in a record.

@example
```ts
import * as assert from "node:assert"
import { size } from "effect/Record";

assert.deepStrictEqual(size({ a: "a", b: 1, c: true }), 3);
```

@since 2.0.0
/
const size = self => keys(self).length;
/**
Check if a given `key` exists in a record.

@example
```ts
import * as assert from "node:assert"
import { empty, has } from "effect/Record"

assert.deepStrictEqual(has({ a: 1, b: 2 }, "a"), true);
assert.deepStrictEqual(has(empty<string>(), "c"), false);
```

@since 2.0.0

## getLefts

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `getLefts(= getLefts;
const getRights = self => {
  const out = empty()`

JSDoc:

Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.

@example
```ts
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

const person: Record<string, unknown> = { name: "John Doe", age: 35 }

assert.deepStrictEqual(R.get(person, "name"), Option.some("John Doe"))
assert.deepStrictEqual(R.get(person, "email"), Option.none())
```

@since 2.0.0
/
const get = exports.get = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => has(self, key) ? Option.some(self[key]) : Option.none());
/**
Apply a function to the element at the specified key, creating a new record.
If the key does not exist, the record is returned unchanged.

@example
```ts
import * as assert from "node:assert"
import { Record as R } from "effect"

const f = (x: number) => x * 2

assert.deepStrictEqual(
 R.modify({ a: 3 }, 'a', f),
 { a: 6 }
)
assert.deepStrictEqual(
 R.modify({ a: 3 } as Record<string, number>, 'b', f),
 { a: 3 }
)
```

@since 2.0.0
/
const modify = exports.modify = /*#__PURE__*/(0, _Function.dual)(3, (self, key, f) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  return {
    ...self,
    [key]: f(self[key])
  };
});
/**
Apply a function to the element at the specified key, creating a new record,
or return `None` if the key doesn't exist.

@example
```ts
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

const f = (x: number) => x * 2

assert.deepStrictEqual(
 R.modifyOption({ a: 3 }, 'a', f),
 Option.some({ a: 6 })
)
assert.deepStrictEqual(
 R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),
 Option.none()
)
```

@since 2.0.0
/
const modifyOption = exports.modifyOption = /*#__PURE__*/(0, _Function.dual)(3, (self, key, f) => {
  if (!has(self, key)) {
    return Option.none();
  }
  return Option.some({
    ...self,
    [key]: f(self[key])
  });
});
/**
Replaces a value in the record with the new value passed as parameter.

@example
```ts
import * as assert from "node:assert"
import { Record, Option } from "effect"

assert.deepStrictEqual(
  Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),
  Option.some({ a: 10, b: 2, c: 3 })
)
assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())
```

@since 2.0.0
/
const replaceOption = exports.replaceOption = /*#__PURE__*/(0, _Function.dual)(3, (self, key, b) => modifyOption(self, key, () => b));
/**
If the given key exists in the record, returns a new record with the key removed,
otherwise returns a copy of the original record.

@example
```ts
import * as assert from "node:assert"
import { remove } from "effect/Record"

assert.deepStrictEqual(remove({ a: 1, b: 2 }, "a"), { b: 2 })
```

@since 2.0.0
/
const remove = exports.remove = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  const out = {
    ...self
  };
  delete out[key];
  return out;
});
/**
Retrieves the value of the property with the given `key` from a record and returns an `Option`
of a tuple with the value and the record with the removed property.
If the key is not present, returns `O.none`.

@example
```ts
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, "a"), Option.some([1, { b: 2 }]))
assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, "c"), Option.none())
```

@category record
@since 2.0.0
/
const pop = exports.pop = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => has(self, key) ? Option.some([self[key], remove(self, key)]) : Option.none());
/**
Maps a record into another record by applying a transformation function to each of its values.

@example
```ts
import * as assert from "node:assert"
import { map } from "effect/Record"

const f = (n: number) => `-${n}`

assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: "-3", b: "-5" })

const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`

assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: "A-3", b: "B-5" })
```

@category mapping
@since 2.0.0
/
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
});
/**
Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.

@example
```ts
import * as assert from "node:assert"
import { mapKeys } from "effect/Record"

assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })
```

@category mapping
@since 2.0.0
/
const mapKeys = exports.mapKeys = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const out = {};
  for (const key of keys(self)) {
    const a = self[key];
    out[f(key, a)] = a;
  }
  return out;
});
/**
Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.

@example
```ts
import * as assert from "node:assert"
import { mapEntries } from "effect/Record"

assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })
```

@category mapping
@since 2.0.0
/
const mapEntries = exports.mapEntries = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const out = {};
  for (const key of keys(self)) {
    const [k, b] = f(self[key], key);
    out[k] = b;
  }
  return out;
});
/**
Transforms a record into a record by applying the function `f` to each key and value in the original record.
If the function returns `Some`, the key-value pair is included in the output record.

@example
```ts
import * as assert from "node:assert"
import { Record, Option } from "effect"

const x = { a: 1, b: 2, c: 3 }
const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()
assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })
```

@since 2.0.0
/
const filterMap = exports.filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const out = empty();
  for (const key of keys(self)) {
    const o = f(self[key], key);
    if (Option.isSome(o)) {
      out[key] = o.value;
    }
  }
  return out;
});
/**
Selects properties from a record whose values match the given predicate.

@example
```ts
import * as assert from "node:assert"
import { filter } from "effect/Record"

const x = { a: 1, b: 2, c: 3, d: 4 }
assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })
```

@category filtering
@since 2.0.0
/
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const out = empty();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      out[key] = self[key];
    }
  }
  return out;
});
/**
Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.

@example
```ts
import * as assert from "node:assert"
import { Record, Option } from "effect"

assert.deepStrictEqual(
  Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),
  { a: 1, c: 2 }
)
```

@category filtering
@since 2.0.0
/
const getSomes = exports.getSomes = /*#__PURE__*/filterMap(_Function.identity);
/**
Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.

@example
```ts
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.getLefts({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }),
  { b: "err" }
)
```

@category filtering
@since 2.0.0
/
const getLefts = self => {
  const out = empty();
  for (const key of keys(self)) {
    const value = self[key];
    if (E.isLeft(value)) {
      out[key] = value.left;
    }
  }
  return out;
};
/**
Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.

@example
```ts
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.getRights({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }),
  { a: 1, c: 2 }
)
```

@category filtering
@since 2.0.0

## getRights

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `getRights(= getRights;
const partitionMap = exports.partitionMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Partitions the elements of a record into two groups: those that match a predicate, and those that don't.

@example
```ts
import * as assert from "node:assert"
import { Record, Either } from "effect"

const x = { a: 1, b: 2, c: 3 }
const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))
assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])
```

@category filtering
@since 2.0.0

## keys

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `keys(= keys;
const values = self => collect(self, (_, a)`

JSDoc:

Partitions a record of `Either` values into two separate records,
one with the `Left` values and one with the `Right` values.

@example
```ts
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.separate({ a: Either.left("e"), b: Either.right(1) }),
  [{ a: "e" }, { b: 1 }]
)
```

@category filtering
@since 2.0.0
/
const separate = exports.separate = /*#__PURE__*/partitionMap(_Function.identity);
/**
Partitions a record into two separate records based on the result of a predicate function.

@example
```ts
import * as assert from "node:assert"
import { partition } from "effect/Record"

assert.deepStrictEqual(
  partition({ a: 1, b: 3 }, (n) => n > 2),
  [{ a: 1 }, { b: 3 }]
)
```

@category filtering
@since 2.0.0
/
const partition = exports.partition = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const left = empty();
  const right = empty();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      right[key] = self[key];
    } else {
      left[key] = self[key];
    }
  }
  return [left, right];
});
/**
Retrieve the keys of a given record as an array.

@since 2.0.0
/
const keys = self => Object.keys(self);
/**
Retrieve the values of a given record as an array.

@since 2.0.0

## values

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `values(= values;
const set = exports.set = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Add a new key-value pair or update an existing key's value in a record.

@example
```ts
import * as assert from "node:assert"
import { set } from "effect/Record"

assert.deepStrictEqual(set("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
assert.deepStrictEqual(set("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
```

@since 2.0.0

## isSubrecordBy

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `isSubrecordBy(= isSubrecordBy;
const isSubrecord = exports.isSubrecord = /*#__PURE__*/isSubrecordBy(/*#__PURE__*/Equal.equivalence()`

JSDoc:

Replace a key's value in a record and return the updated record.
If the key does not exist in the record, a copy of the original record is returned.

@example
```ts
import * as assert from "node:assert"
import { Record } from "effect"

assert.deepStrictEqual(Record.replace("a", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });
assert.deepStrictEqual(Record.replace("c", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });
```

@since 2.0.0
/
const replace = exports.replace = /*#__PURE__*/(0, _Function.dual)(3, (self, key, value) => {
  if (has(self, key)) {
    return {
      ...self,
      [key]: value
    };
  }
  return {
    ...self
  };
});
/**
Check if all the keys and values in one record are also found in another record.

@since 2.0.0
/
const isSubrecordBy = equivalence => (0, _Function.dual)(2, (self, that) => {
  for (const key of keys(self)) {
    if (!has(that, key) || !equivalence(self[key], that[key])) {
      return false;
    }
  }
  return true;
});
/**
Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.
This comparison uses default equality checks (`Equal.equivalence()`).

@since 2.0.0

## getEquivalence

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `getEquivalence(= getEquivalence;
const singleton = (key, value)`

JSDoc:

Reduce a record to a single value by combining its entries with a specified function.

@category folding
@since 2.0.0
/
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => {
  let out = zero;
  for (const key of keys(self)) {
    out = f(out, self[key], key);
  }
  return out;
});
/**
Check if all entries in a record meet a specific condition.

@since 2.0.0
/
const every = exports.every = /*#__PURE__*/(0, _Function.dual)(2, (self, refinement) => {
  for (const key of keys(self)) {
    if (!refinement(self[key], key)) {
      return false;
    }
  }
  return true;
});
/**
Check if any entry in a record meets a specific condition.

@since 2.0.0
/
const some = exports.some = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      return true;
    }
  }
  return false;
});
/**
Merge two records, preserving entries that exist in either of the records.

@since 2.0.0
/
const union = exports.union = /*#__PURE__*/(0, _Function.dual)(3, (self, that, combine) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = empty();
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine(self[key], that[key]);
    } else {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(out, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
/**
Merge two records, retaining only the entries that exist in both records.

@since 2.0.0
/
const intersection = exports.intersection = /*#__PURE__*/(0, _Function.dual)(3, (self, that, combine) => {
  const out = empty();
  if (isEmptyRecord(self) || isEmptyRecord(that)) {
    return out;
  }
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine(self[key], that[key]);
    }
  }
  return out;
});
/**
Merge two records, preserving only the entries that are unique to each record.

@since 2.0.0
/
const difference = exports.difference = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = {};
  for (const key of keys(self)) {
    if (!has(that, key)) {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(self, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
/**
Create an `Equivalence` for records using the provided `Equivalence` for values.

@category instances
@since 2.0.0
/
const getEquivalence = equivalence => {
  const is = isSubrecordBy(equivalence);
  return (self, that) => is(self, that) && is(that, self);
};
/**
Create a non-empty record from a single element.

@category constructors
@since 2.0.0

## singleton

Source: `my-backend/node_modules/effect/dist/cjs/Record.js`

Signature: `singleton(= singleton;
const findFirst = exports.findFirst = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Returns the first entry that satisfies the specified
predicate, or `None` if no such entry exists.

@example
```ts
import { Record, Option } from "effect"

const record = { a: 1, b: 2, c: 3 }
const result = Record.findFirst(record, (value, key) => value > 1 && key !== "b")
console.log(result) // Option.Some(["c", 3])
```

@category elements
@since 3.14.0

## makeCache

Source: `my-backend/node_modules/effect/dist/cjs/Request.js`

Signature: `makeCache(= makeCache;
const EntryTypeId = exports.EntryTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock.Entry")`

JSDoc:

@since 2.0.0
@category symbols
/
const RequestTypeId = exports.RequestTypeId = internal.RequestTypeId;
/**
Returns `true` if the specified value is a `Request`, `false` otherwise.

@since 2.0.0
@category refinements
/
const isRequest = exports.isRequest = internal.isRequest;
/**
Constructs a new `Request`.

@since 2.0.0
@category constructors
/
const of = exports.of = internal.of;
/**
Constructs a new `Request`.

@since 2.0.0
@category constructors
/
const tagged = exports.tagged = internal.tagged;
/**
Provides a constructor for a Request Class.

@example
```ts
import { Request } from "effect"

type Success = string
type Error = never

class MyRequest extends Request.Class<Success, Error, {
  readonly id: string
}> {}
```

@since 2.0.0
@category constructors
/
const Class = exports.Class = internal.Class;
/**
Provides a Tagged constructor for a Request Class.

@example
```ts
import { Request } from "effect"

type Success = string
type Error = never

class MyRequest extends Request.TaggedClass("MyRequest")<Success, Error, {
  readonly name: string
}> {}
```

@since 2.0.0
@category constructors
/
const TaggedClass = exports.TaggedClass = internal.TaggedClass;
/**
Complete a `Request` with the specified result.

@since 2.0.0
@category request completion
/
const complete = exports.complete = internal.complete;
/**
Interrupts the child effect when requests are no longer needed

@since 2.0.0
@category request completion
/
const interruptWhenPossible = exports.interruptWhenPossible = fiberRuntime.interruptWhenPossible;
/**
Complete a `Request` with the specified effectful computation, failing the
request with the error from the effect workflow if it fails, and completing
the request with the value of the effect workflow if it succeeds.

@since 2.0.0
@category request completion
/
const completeEffect = exports.completeEffect = internal.completeEffect;
/**
Complete a `Request` with the specified error.

@since 2.0.0
@category request completion
/
const fail = exports.fail = internal.fail;
/**
Complete a `Request` with the specified cause.

@since 2.0.0
@category request completion
/
const failCause = exports.failCause = internal.failCause;
/**
Complete a `Request` with the specified value.

@since 2.0.0
@category request completion
/
const succeed = exports.succeed = internal.succeed;
/**
@since 2.0.0
@category models
/
const makeCache = options => cache.make({
  ...options,
  lookup: () => core.map(core.deferredMake(), handle => ({
    listeners: new internal.Listeners(),
    handle
  }))
});
/**
@since 2.0.0
@category symbols

## contextFromEffect

Source: `my-backend/node_modules/effect/dist/cjs/RequestResolver.js`

Signature: `contextFromEffect(= contextFromEffect;
const contextFromServices = (...services)`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
@category symbols
/
const RequestResolverTypeId = exports.RequestResolverTypeId = core.RequestResolverTypeId;
/**
@since 2.0.0
@category utils
/
const contextFromEffect = self => Effect.contextWith(_ => provideContext(self, _));
/**
@since 2.0.0
@category utils

## contextFromServices

Source: `my-backend/node_modules/effect/dist/cjs/RequestResolver.js`

Signature: `contextFromServices(= contextFromServices;
const isRequestResolver = exports.isRequestResolver = core.isRequestResolver;
/**
 * Constructs a data source with the specified identifier and method to run
 * requests.
 *
 * @since 2.0.0
 * @category constructors
 */
const make = exports.make = internal.make;
/**
 * Constructs a data source with the specified identifier and method to run
 * requests.
 *
 * @since 2.0.0
 * @category constructors
 */
const makeWithEntry = exports.makeWithEntry = internal.makeWithEntry;
/**
 * Constructs a data source from a function taking a collection of requests.
 *
 * @since 2.0.0
 * @category constructors
 */
const makeBatched = exports.makeBatched = internal.makeBatched;
/**
 * A data source aspect that executes requests between two effects, `before`
 * and `after`, where the result of `before` can be used by `after`.
 *
 * @since 2.0.0
 * @category combinators
 */
const around = exports.around = internal.around;
/**
 * A data source aspect that executes requests between two effects, `before`
 * and `after`, where the result of `before` can be used by `after`.
 *
 * The `before` and `after` effects are provided with the requests being executed.
 *
 * @since 2.0.0
 * @category combinators
 * @example
 * ```ts
 * import { Effect, Request, RequestResolver } from "effect"
 *
 * interface GetUserById extends Request.Request<unknown> {
 *   readonly id: number
 * }
 *
 * const resolver = RequestResolver.fromFunction(
 *   (request: GetUserById)`

JSDoc:

Returns `true` if the specified value is a `RequestResolver`, `false` otherwise.

@since 2.0.0
@category refinements

## firstSuccessOf

Source: `my-backend/node_modules/effect/dist/cjs/STM.js`

Signature: `firstSuccessOf(= firstSuccessOf;
const Do = exports.Do = /*#__PURE__*/succeed({})`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
@category symbols
/
const STMTypeId = exports.STMTypeId = core.STMTypeId;
/**
Returns `true` if the provided value is an `STM`, `false` otherwise.

@since 2.0.0
@category refinements
/
const isSTM = exports.isSTM = core.isSTM;
/**
Treats the specified `acquire` transaction as the acquisition of a
resource. The `acquire` transaction will be executed interruptibly. If it
is a success and is committed the specified `release` workflow will be
executed uninterruptibly as soon as the `use` workflow completes execution.

@since 2.0.0
@category constructors
/
const acquireUseRelease = exports.acquireUseRelease = stm.acquireUseRelease;
/**
Runs all the provided transactional effects in sequence respecting the
structure provided in input.

Supports multiple arguments, a single argument tuple / array or record /
struct.

@since 2.0.0
@category constructors
/
const all = exports.all = stm.all;
/**
Maps the success value of this effect to the specified constant value.

@since 2.0.0
@category mapping
/
const as = exports.as = stm.as;
/**
Maps the success value of this effect to an optional value.

@since 2.0.0
@category mapping
/
const asSome = exports.asSome = stm.asSome;
/**
Maps the error value of this effect to an optional value.

@since 2.0.0
@category mapping
/
const asSomeError = exports.asSomeError = stm.asSomeError;
/**
This function maps the success value of an `STM` to `void`. If the original
`STM` succeeds, the returned `STM` will also succeed. If the original `STM`
fails, the returned `STM` will fail with the same error.

@since 2.0.0
@category mapping
/
const asVoid = exports.asVoid = stm.asVoid;
/**
Creates an `STM` value from a partial (but pure) function.

@since 2.0.0
@category constructors
/
const attempt = exports.attempt = stm.attempt;
/**
Recovers from all errors.

@since 2.0.0
@category error handling
/
const catchAll = exports.catchAll = core.catchAll;
/**
Recovers from some or all of the error cases.

@since 2.0.0
@category error handling
/
const catchSome = exports.catchSome = stm.catchSome;
/**
Recovers from the specified tagged error.

@since 2.0.0
@category error handling
/
const catchTag = exports.catchTag = stm.catchTag;
/**
Recovers from multiple tagged errors.

@since 2.0.0
@category error handling
/
const catchTags = exports.catchTags = stm.catchTags;
/**
Checks the condition, and if it's true, returns unit, otherwise, retries.

@since 2.0.0
@category constructors
/
const check = exports.check = stm.check;
/**
Simultaneously filters and maps the value produced by this effect.

@since 2.0.0
@category mutations
/
const collect = exports.collect = stm.collect;
/**
Simultaneously filters and maps the value produced by this effect.

@since 2.0.0
@category mutations
/
const collectSTM = exports.collectSTM = stm.collectSTM;
/**
Commits this transaction atomically.

@since 2.0.0
@category destructors
/
const commit = exports.commit = core.commit;
/**
Commits this transaction atomically, regardless of whether the transaction
is a success or a failure.

@since 2.0.0
@category destructors
/
const commitEither = exports.commitEither = stm.commitEither;
/**
Similar to Either.cond, evaluate the predicate, return the given A as
success if predicate returns true, and the given E as error otherwise

@since 2.0.0
@category constructors
/
const cond = exports.cond = stm.cond;
/**
Retrieves the environment inside an stm.

@since 2.0.0
@category constructors
/
const context = exports.context = core.context;
/**
Accesses the environment of the transaction to perform a transaction.

@since 2.0.0
@category constructors
/
const contextWith = exports.contextWith = core.contextWith;
/**
Accesses the environment of the transaction to perform a transaction.

@since 2.0.0
@category constructors
/
const contextWithSTM = exports.contextWithSTM = core.contextWithSTM;
/**
Transforms the environment being provided to this effect with the specified
function.

@since 2.0.0
@category context
/
const mapInputContext = exports.mapInputContext = core.mapInputContext;
/**
Fails the transactional effect with the specified defect.

@since 2.0.0
@category constructors
/
const die = exports.die = core.die;
/**
Kills the fiber running the effect with a `Cause.RuntimeException` that
contains the specified message.

@since 2.0.0
@category constructors
/
const dieMessage = exports.dieMessage = core.dieMessage;
/**
Fails the transactional effect with the specified lazily evaluated defect.

@since 2.0.0
@category constructors
/
const dieSync = exports.dieSync = core.dieSync;
/**
Converts the failure channel into an `Either`.

@since 2.0.0
@category mutations
/
const either = exports.either = stm.either;
/**
Executes the specified finalization transaction whether or not this effect
succeeds. Note that as with all STM transactions, if the full transaction
fails, everything will be rolled back.

@since 2.0.0
@category finalization
/
const ensuring = exports.ensuring = core.ensuring;
/**
Returns an effect that ignores errors and runs repeatedly until it
eventually succeeds.

@since 2.0.0
@category mutations
/
const eventually = exports.eventually = stm.eventually;
/**
Determines whether all elements of the `Iterable<A>` satisfy the effectual
predicate.

@since 2.0.0
@category constructors
/
const every = exports.every = stm.every;
/**
Determines whether any element of the `Iterable[A]` satisfies the effectual
predicate `f`.

@since 2.0.0
@category constructors
/
const exists = exports.exists = stm.exists;
/**
Fails the transactional effect with the specified error.

@since 2.0.0
@category constructors
/
const fail = exports.fail = core.fail;
/**
Fails the transactional effect with the specified lazily evaluated error.

@since 2.0.0
@category constructors
/
const failSync = exports.failSync = core.failSync;
/**
Returns the fiber id of the fiber committing the transaction.

@since 2.0.0
@category constructors
/
const fiberId = exports.fiberId = stm.fiberId;
/**
Filters the collection using the specified effectual predicate.

@since 2.0.0
@category constructors
/
const filter = exports.filter = stm.filter;
/**
Filters the collection using the specified effectual predicate, removing
all elements that satisfy the predicate.

@since 2.0.0
@category constructors
/
const filterNot = exports.filterNot = stm.filterNot;
/**
Dies with specified defect if the predicate fails.

@since 2.0.0
@category filtering
/
const filterOrDie = exports.filterOrDie = stm.filterOrDie;
/**
Dies with a `Cause.RuntimeException` having the specified  message if the
predicate fails.

@since 2.0.0
@category filtering
/
const filterOrDieMessage = exports.filterOrDieMessage = stm.filterOrDieMessage;
/**
Supplies `orElse` if the predicate fails.

@since 2.0.0
@category filtering
/
const filterOrElse = exports.filterOrElse = stm.filterOrElse;
/**
Fails with the specified error if the predicate fails.

@since 2.0.0
@category filtering
/
const filterOrFail = exports.filterOrFail = stm.filterOrFail;
/**
Feeds the value produced by this effect to the specified function, and then
runs the returned effect as well to produce its results.

@since 2.0.0
@category sequencing
/
const flatMap = exports.flatMap = core.flatMap;
/**
Flattens out a nested `STM` effect.

@since 2.0.0
@category sequencing
/
const flatten = exports.flatten = stm.flatten;
/**
Flips the success and failure channels of this transactional effect. This
allows you to use all methods on the error channel, possibly before
flipping back.

@since 2.0.0
@category mutations
/
const flip = exports.flip = stm.flip;
/**
Swaps the error/value parameters, applies the function `f` and flips the
parameters back

@since 2.0.0
@category mutations
/
const flipWith = exports.flipWith = stm.flipWith;
/**
Folds over the `STM` effect, handling both failure and success, but not
retry.

@since 2.0.0
@category folding
/
const match = exports.match = stm.match;
/**
Effectfully folds over the `STM` effect, handling both failure and success.

@since 2.0.0
@category folding
/
const matchSTM = exports.matchSTM = core.matchSTM;
/**
Applies the function `f` to each element of the `Iterable<A>` and returns
a transactional effect that produces a new `Chunk<A2>`.

@since 2.0.0
@category traversing
/
const forEach = exports.forEach = stm.forEach;
/**
Lifts an `Either` into a `STM`.

@since 2.0.0
@category constructors
/
const fromEither = exports.fromEither = stm.fromEither;
/**
Lifts an `Option` into a `STM`.

@since 2.0.0
@category constructors
/
const fromOption = exports.fromOption = stm.fromOption;
/**
@since 2.0.0
@category constructors
/
const gen = exports.gen = stm.gen;
/**
Returns a successful effect with the head of the list if the list is
non-empty or fails with the error `None` if the list is empty.

@since 2.0.0
@category getters
/
const head = exports.head = stm.head;
const if_ = exports.if = stm.if_;
/**
Returns a new effect that ignores the success or failure of this effect.

@since 2.0.0
@category mutations
/
const ignore = exports.ignore = stm.ignore;
/**
Interrupts the fiber running the effect.

@since 2.0.0
@category constructors
/
const interrupt = exports.interrupt = core.interrupt;
/**
Interrupts the fiber running the effect with the specified `FiberId`.

@since 2.0.0
@category constructors
/
const interruptAs = exports.interruptAs = core.interruptAs;
/**
Returns whether this transactional effect is a failure.

@since 2.0.0
@category getters
/
const isFailure = exports.isFailure = stm.isFailure;
/**
Returns whether this transactional effect is a success.

@since 2.0.0
@category getters
/
const isSuccess = exports.isSuccess = stm.isSuccess;
/**
Iterates with the specified transactional function. The moral equivalent
of:

```ts skip-type-checking
const s = initial

while (cont(s)) {
  s = body(s)
}

return s
```

@since 2.0.0
@category constructors
/
const iterate = exports.iterate = stm.iterate;
/**
Loops with the specified transactional function, collecting the results
into a list. The moral equivalent of:

```ts skip-type-checking
const as = []
let s  = initial

while (cont(s)) {
  as.push(body(s))
  s  = inc(s)
}

return as
```

@since 2.0.0
@category constructors
/
const loop = exports.loop = stm.loop;
/**
Maps the value produced by the effect.

@since 2.0.0
@category mapping
/
const map = exports.map = core.map;
/**
Maps the value produced by the effect with the specified function that may
throw exceptions but is otherwise pure, translating any thrown exceptions
into typed failed effects.

@since 2.0.0
@category mapping
/
const mapAttempt = exports.mapAttempt = stm.mapAttempt;
/**
Returns an `STM` effect whose failure and success channels have been mapped
by the specified pair of functions, `f` and `g`.

@since 2.0.0
@category mapping
/
const mapBoth = exports.mapBoth = stm.mapBoth;
/**
Maps from one error type to another.

@since 2.0.0
@category mapping
/
const mapError = exports.mapError = stm.mapError;
/**
Returns a new effect where the error channel has been merged into the
success channel to their common combined type.

@since 2.0.0
@category mutations
/
const merge = exports.merge = stm.merge;
/**
Merges an `Iterable<STM>` to a single `STM`, working sequentially.

@since 2.0.0
@category constructors
/
const mergeAll = exports.mergeAll = stm.mergeAll;
/**
Returns a new effect where boolean value of this effect is negated.

@since 2.0.0
@category mutations
/
const negate = exports.negate = stm.negate;
/**
Requires the option produced by this value to be `None`.

@since 2.0.0
@category mutations
/
const none = exports.none = stm.none;
/**
Converts the failure channel into an `Option`.

@since 2.0.0
@category mutations
/
const option = exports.option = stm.option;
/**
Translates `STM` effect failure into death of the fiber, making all
failures unchecked and not a part of the type of the effect.

@since 2.0.0
@category error handling
/
const orDie = exports.orDie = stm.orDie;
/**
Keeps none of the errors, and terminates the fiber running the `STM` effect
with them, using the specified function to convert the `E` into a defect.

@since 2.0.0
@category error handling
/
const orDieWith = exports.orDieWith = stm.orDieWith;
/**
Tries this effect first, and if it fails or retries, tries the other
effect.

@since 2.0.0
@category error handling
/
const orElse = exports.orElse = stm.orElse;
/**
Returns a transactional effect that will produce the value of this effect
in left side, unless it fails or retries, in which case, it will produce
the value of the specified effect in right side.

@since 2.0.0
@category error handling
/
const orElseEither = exports.orElseEither = stm.orElseEither;
/**
Tries this effect first, and if it fails or retries, fails with the
specified error.

@since 2.0.0
@category error handling
/
const orElseFail = exports.orElseFail = stm.orElseFail;
/**
Returns an effect that will produce the value of this effect, unless it
fails with the `None` value, in which case it will produce the value of the
specified effect.

@since 2.0.0
@category error handling
/
const orElseOptional = exports.orElseOptional = stm.orElseOptional;
/**
Tries this effect first, and if it fails or retries, succeeds with the
specified value.

@since 2.0.0
@category error handling
/
const orElseSucceed = exports.orElseSucceed = stm.orElseSucceed;
/**
Tries this effect first, and if it enters retry, then it tries the other
effect. This is an equivalent of Haskell's orElse.

@since 2.0.0
@category error handling
/
const orTry = exports.orTry = core.orTry;
/**
Feeds elements of type `A` to a function `f` that returns an effect.
Collects all successes and failures in a tupled fashion.

@since 2.0.0
@category traversing
/
const partition = exports.partition = stm.partition;
/**
Provides the transaction its required environment, which eliminates its
dependency on `R`.

@since 2.0.0
@category context
/
const provideContext = exports.provideContext = stm.provideContext;
/**
Splits the context into two parts, providing one part using the
specified layer and leaving the remainder `R0`.

@since 2.0.0
@category context
/
const provideSomeContext = exports.provideSomeContext = stm.provideSomeContext;
/**
Provides the effect with the single service it requires. If the transactional
effect requires more than one service use `provideEnvironment` instead.

@since 2.0.0
@category context
/
const provideService = exports.provideService = stm.provideService;
/**
Provides the effect with the single service it requires. If the transactional
effect requires more than one service use `provideEnvironment` instead.

@since 2.0.0
@category context
/
const provideServiceSTM = exports.provideServiceSTM = stm.provideServiceSTM;
/**
Folds an `Iterable<A>` using an effectual function f, working sequentially
from left to right.

@since 2.0.0
@category constructors
/
const reduce = exports.reduce = stm.reduce;
/**
Reduces an `Iterable<STM>` to a single `STM`, working sequentially.

@since 2.0.0
@category constructors
/
const reduceAll = exports.reduceAll = stm.reduceAll;
/**
Folds an `Iterable<A>` using an effectual function f, working sequentially
from right to left.

@since 2.0.0
@category constructors
/
const reduceRight = exports.reduceRight = stm.reduceRight;
/**
Keeps some of the errors, and terminates the fiber with the rest.

@since 2.0.0
@category mutations
/
const refineOrDie = exports.refineOrDie = stm.refineOrDie;
/**
Keeps some of the errors, and terminates the fiber with the rest, using the
specified function to convert the `E` into a `Throwable`.

@since 2.0.0
@category mutations
/
const refineOrDieWith = exports.refineOrDieWith = stm.refineOrDieWith;
/**
Fail with the returned value if the `PartialFunction` matches, otherwise
continue with our held value.

@since 2.0.0
@category mutations
/
const reject = exports.reject = stm.reject;
/**
Continue with the returned computation if the specified partial function
matches, translating the successful match into a failure, otherwise continue
with our held value.

@since 2.0.0
@category mutations
/
const rejectSTM = exports.rejectSTM = stm.rejectSTM;
/**
Repeats this `STM` effect until its result satisfies the specified
predicate.

**WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will
consume a thread until it completes (it cannot yield). This is because STM
describes a single atomic transaction which must either complete, retry or
fail a transaction before yielding back to the Effect runtime.
  - Use `retryUntil` instead if you don't need to maintain transaction
    state for repeats.
  - Ensure repeating the STM effect will eventually satisfy the predicate.

@since 2.0.0
@category mutations
/
const repeatUntil = exports.repeatUntil = stm.repeatUntil;
/**
Repeats this `STM` effect while its result satisfies the specified
predicate.

**WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will
consume a thread until it completes (it cannot yield). This is because STM
describes a single atomic transaction which must either complete, retry or
fail a transaction before yielding back to the Effect runtime.
  - Use `retryWhile` instead if you don't need to maintain transaction
    state for repeats.
  - Ensure repeating the STM effect will eventually not satisfy the
    predicate.

@since 2.0.0
@category mutations
/
const repeatWhile = exports.repeatWhile = stm.repeatWhile;
/**
Replicates the given effect n times. If 0 or negative numbers are given, an
empty `Chunk` will be returned.

@since 2.0.0
@category constructors
/
const replicate = exports.replicate = stm.replicate;
/**
Performs this transaction the specified number of times and collects the
results.

@since 2.0.0
@category constructors
/
const replicateSTM = exports.replicateSTM = stm.replicateSTM;
/**
Performs this transaction the specified number of times, discarding the
results.

@since 2.0.0
@category constructors
/
const replicateSTMDiscard = exports.replicateSTMDiscard = stm.replicateSTMDiscard;
/**
Abort and retry the whole transaction when any of the underlying
transactional variables have changed.

@since 2.0.0
@category error handling
/
const retry = exports.retry = core.retry;
/**
Filters the value produced by this effect, retrying the transaction until
the predicate returns `true` for the value.

@since 2.0.0
@category mutations
/
const retryUntil = exports.retryUntil = stm.retryUntil;
/**
Filters the value produced by this effect, retrying the transaction while
the predicate returns `true` for the value.

@since 2.0.0
@category mutations
/
const retryWhile = exports.retryWhile = stm.retryWhile;
/**
Converts an option on values into an option on errors.

@since 2.0.0
@category getters
/
const some = exports.some = stm.some;
/**
Returns an `STM` effect that succeeds with the specified value.

@since 2.0.0
@category constructors
/
const succeed = exports.succeed = core.succeed;
/**
Returns an effect with the empty value.

@since 2.0.0
@category constructors
/
const succeedNone = exports.succeedNone = stm.succeedNone;
/**
Returns an effect with the optional value.

@since 2.0.0
@category constructors
/
const succeedSome = exports.succeedSome = stm.succeedSome;
/**
Summarizes a `STM` effect by computing a provided value before and after
execution, and then combining the values to produce a summary, together
with the result of execution.

@since 2.0.0
@category mutations
/
const summarized = exports.summarized = stm.summarized;
/**
Suspends creation of the specified transaction lazily.

@since 2.0.0
@category constructors
/
const suspend = exports.suspend = stm.suspend;
/**
Returns an `STM` effect that succeeds with the specified lazily evaluated
value.

@since 2.0.0
@category constructors
/
const sync = exports.sync = core.sync;
/**
"Peeks" at the success of transactional effect.

@since 2.0.0
@category sequencing
/
const tap = exports.tap = stm.tap;
/**
"Peeks" at both sides of an transactional effect.

@since 2.0.0
@category sequencing
/
const tapBoth = exports.tapBoth = stm.tapBoth;
/**
"Peeks" at the error of the transactional effect.

@since 2.0.0
@category sequencing
/
const tapError = exports.tapError = stm.tapError;
const try_ = exports.try = stm.try_;
/**
The moral equivalent of `if (!p) exp`

@since 2.0.0
@category mutations
/
const unless = exports.unless = stm.unless;
/**
The moral equivalent of `if (!p) exp` when `p` has side-effects

@since 2.0.0
@category mutations
/
const unlessSTM = exports.unlessSTM = stm.unlessSTM;
/**
Converts an option on errors into an option on values.

@since 2.0.0
@category getters
/
const unsome = exports.unsome = stm.unsome;
const void_ = exports.void = stm.void;
/**
Feeds elements of type `A` to `f` and accumulates all errors in error
channel or successes in success channel.

This combinator is lossy meaning that if there are errors all successes
will be lost. To retain all information please use `STM.partition`.

@since 2.0.0
@category mutations
/
const validateAll = exports.validateAll = stm.validateAll;
/**
Feeds elements of type `A` to `f` until it succeeds. Returns first success
or the accumulation of all errors.

@since 2.0.0
@category mutations
/
const validateFirst = exports.validateFirst = stm.validateFirst;
/**
The moral equivalent of `if (p) exp`.

@since 2.0.0
@category mutations
/
const when = exports.when = stm.when;
/**
The moral equivalent of `if (p) exp` when `p` has side-effects.

@since 2.0.0
@category mutations
/
const whenSTM = exports.whenSTM = stm.whenSTM;
/**
Sequentially zips this value with the specified one.

@since 2.0.0
@category zipping
/
const zip = exports.zip = core.zip;
/**
Sequentially zips this value with the specified one, discarding the second
element of the tuple.

@since 2.0.0
@category zipping
/
const zipLeft = exports.zipLeft = core.zipLeft;
/**
Sequentially zips this value with the specified one, discarding the first
element of the tuple.

@since 2.0.0
@category zipping
/
const zipRight = exports.zipRight = core.zipRight;
/**
Sequentially zips this value with the specified one, combining the values
using the specified combiner function.

@since 2.0.0
@category zipping
/
const zipWith = exports.zipWith = core.zipWith;
/**
This function takes an iterable of `STM` values and returns a new
`STM` value that represents the first `STM` value in the iterable
that succeeds. If all of the `Effect` values in the iterable fail, then
the resulting `STM` value will fail as well.

This function is sequential, meaning that the `STM` values in the
iterable will be executed in sequence, and the first one that succeeds
will determine the outcome of the resulting `STM` value.

Returns a new `STM` value that represents the first successful
`STM` value in the iterable, or a failed `STM` value if all of the
`STM` values in the iterable fail.

@since 2.0.0
@category elements
/
const firstSuccessOf = effects => suspend(() => {
  const list = Chunk.fromIterable(effects);
  if (!Chunk.isNonEmpty(list)) {
    return dieSync(() => new Cause.IllegalArgumentException(`Received an empty collection of effects`));
  }
  return Chunk.reduce(Chunk.tailNonEmpty(list), Chunk.headNonEmpty(list), (left, right) => orElse(left, () => right));
});
/**
@category do notation
@since 2.0.0

## PriorityBuckets

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `PriorityBuckets(= PriorityBuckets;
class MixedScheduler {
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /*#__PURE__*/new PriorityBuckets()`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
@category utils
/
class PriorityBuckets {
  /**
@since 2.0.0
/
  buckets = [];
  /**
@since 2.0.0
/
  scheduleTask(task, priority) {
    const length = this.buckets.length;
    let bucket = undefined;
    let index = 0;
    for (; index < length; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
}
/**
@since 2.0.0
@category constructors

## MixedScheduler

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `MixedScheduler(= MixedScheduler;
const defaultScheduler = exports.defaultScheduler = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@since 2.0.0
/
  maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
@since 2.0.0
/
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
@since 2.0.0
/
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
@since 2.0.0
/
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield) ? fiber.getFiberRef(core.currentSchedulingPriority) : false;
  }
  /**
@since 2.0.0
/
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}
/**
@since 2.0.0
@category schedulers

## SyncScheduler

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `SyncScheduler(= SyncScheduler;
class ControlledScheduler {
  /**
   * @since 2.0.0
   */
  tasks = /*#__PURE__*/new PriorityBuckets()`

JSDoc:

@since 2.0.0
@category constructors
/
class SyncScheduler {
  /**
@since 2.0.0
/
  tasks = /*#__PURE__*/new PriorityBuckets();
  /**
@since 2.0.0
/
  deferred = false;
  /**
@since 2.0.0
/
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
@since 2.0.0
/
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield) ? fiber.getFiberRef(core.currentSchedulingPriority) : false;
  }
  /**
@since 2.0.0
/
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
}
/**
@since 2.0.0
@category constructors

## ControlledScheduler

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `ControlledScheduler(= ControlledScheduler;
const makeMatrix = (...record)`

JSDoc:

@since 2.0.0
/
  deferred = false;
  /**
@since 2.0.0
/
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
@since 2.0.0
/
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield) ? fiber.getFiberRef(core.currentSchedulingPriority) : false;
  }
  /**
@since 2.0.0
/
  step() {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
  }
}
/**
@since 2.0.0
@category constructors

## makeMatrix

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `makeMatrix(= makeMatrix;
const defaultShouldYield = fiber => {
  return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield)`

JSDoc:

@since 2.0.0
@category utilities

## defaultShouldYield

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `defaultShouldYield(= defaultShouldYield;
const make = (scheduleTask, shouldYield = defaultShouldYield)`

JSDoc:

@since 2.0.0
@category constructors

## make

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `make(= make;
const makeBatched = (callback, shouldYield = defaultShouldYield)`

JSDoc:

@since 2.0.0
@category constructors

## makeBatched

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `makeBatched(= makeBatched;
const timer = (ms, shouldYield = defaultShouldYield)`

JSDoc:

@since 2.0.0
@category constructors

## timer

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `timer(= timer;
const timerBatched = (ms, shouldYield = defaultShouldYield)`

JSDoc:

@since 2.0.0
@category constructors

## timerBatched

Source: `my-backend/node_modules/effect/dist/cjs/Scheduler.js`

Signature: `timerBatched(= timerBatched;
const currentScheduler = exports.currentScheduler = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@internal

## format

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `format(= format;
const encodedSchema = schema => make(AST.encodedAST(schema.ast)`

JSDoc:

@since 3.10.0
/

/**
@since 3.10.0
@category symbol
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Schema");
/**
@category constructors
@since 3.10.0
/
function make(ast) {
  return class SchemaClass {
    [TypeId] = variance;
    static ast = ast;
    static annotations(annotations) {
      return make(mergeSchemaAnnotations(this.ast, annotations));
    }
    static pipe() {
      return (0, _Pipeable.pipeArguments)(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId] = variance;
  };
}
const variance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _I: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
const makeStandardResult = exit => exit_.isSuccess(exit) ? exit.value : makeStandardFailureResult(cause_.pretty(exit.cause));
const makeStandardFailureResult = message => ({
  issues: [{
    message
  }]
});
const makeStandardFailureFromParseIssue = issue => Effect.map(ParseResult.ArrayFormatter.formatIssue(issue), issues => ({
  issues: issues.map(issue => ({
    path: issue.path,
    message: issue.message
  }))
}));
/**
Returns a "Standard Schema" object conforming to the [Standard Schema
v1](https://standardschema.dev/) specification.

This function creates a schema whose `validate` method attempts to decode and
validate the provided input synchronously. If the underlying `Schema`
includes any asynchronous components (e.g., asynchronous message resolutions
or checks), then validation will necessarily return a `Promise` instead.

Any detected defects will be reported via a single issue containing no
`path`.

@example
```ts
import { Schema } from "effect"

const schema = Schema.Struct({
  name: Schema.String
})

//       StandardSchemaV1<{ readonly name: string; }>
//      
const standardSchema = Schema.standardSchemaV1(schema)
```

@category Standard Schema
@since 3.13.0
/
const standardSchemaV1 = (schema, overrideOptions) => {
  const decodeUnknown = ParseResult.decodeUnknown(schema, {
    errors: "all"
  });
  return class StandardSchemaV1Class extends make(schema.ast) {
    static "~standard" = {
      version: 1,
      vendor: "effect",
      validate(value) {
        const scheduler = new scheduler_.SyncScheduler();
        const fiber = Effect.runFork(Effect.matchEffect(decodeUnknown(value, overrideOptions), {
          onFailure: makeStandardFailureFromParseIssue,
          onSuccess: value => Effect.succeed({
            value
          })
        }), {
          scheduler
        });
        scheduler.flush();
        const exit = fiber.unsafePoll();
        if (exit) {
          return makeStandardResult(exit);
        }
        return new Promise(resolve => {
          fiber.addObserver(exit => {
            resolve(makeStandardResult(exit));
          });
        });
      }
    };
  };
};
exports.standardSchemaV1 = standardSchemaV1;
const builtInAnnotations = {
  schemaId: AST.SchemaIdAnnotationId,
  message: AST.MessageAnnotationId,
  missingMessage: AST.MissingMessageAnnotationId,
  identifier: AST.IdentifierAnnotationId,
  title: AST.TitleAnnotationId,
  description: AST.DescriptionAnnotationId,
  examples: AST.ExamplesAnnotationId,
  default: AST.DefaultAnnotationId,
  documentation: AST.DocumentationAnnotationId,
  jsonSchema: AST.JSONSchemaAnnotationId,
  arbitrary: AST.ArbitraryAnnotationId,
  pretty: AST.PrettyAnnotationId,
  equivalence: AST.EquivalenceAnnotationId,
  concurrency: AST.ConcurrencyAnnotationId,
  batching: AST.BatchingAnnotationId,
  parseIssueTitle: AST.ParseIssueTitleAnnotationId,
  parseOptions: AST.ParseOptionsAnnotationId,
  decodingFallback: AST.DecodingFallbackAnnotationId
};
const toASTAnnotations = annotations => {
  if (!annotations) {
    return {};
  }
  const out = {
    ...annotations
  };
  for (const key in builtInAnnotations) {
    if (key in annotations) {
      const id = builtInAnnotations[key];
      out[id] = annotations[key];
      delete out[key];
    }
  }
  return out;
};
const mergeSchemaAnnotations = (ast, annotations) => AST.annotations(ast, toASTAnnotations(annotations));
/**
@since 3.10.0
/
function asSchema(schema) {
  return schema;
}
/**
@category formatting
@since 3.10.0
/
const format = schema => String(schema.ast);
/**
The `encodedSchema` function allows you to extract the `Encoded` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without retaining any refinements or transformations that
were applied previously.

@since 3.10.0

## encodedSchema

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `encodedSchema(= encodedSchema;
const encodedBoundSchema = schema => make(AST.encodedBoundAST(schema.ast)`

JSDoc:

The `encodedBoundSchema` function is similar to `encodedSchema` but preserves
the refinements up to the first transformation point in the original schema.

@since 3.10.0

## encodedBoundSchema

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `encodedBoundSchema(= encodedBoundSchema;
const typeSchema = schema => make(AST.typeAST(schema.ast)`

JSDoc:

The `typeSchema` function allows you to extract the `Type` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without considering the initial encoding or transformation
processes.

@since 3.10.0

## encodeUnknown

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `encodeUnknown(= encodeUnknown;
const encodeUnknownEither = (schema, options)`

JSDoc:

@category encoding
@since 3.10.0
/
const encodeUnknown = (schema, options) => {
  const encodeUnknown = ParseResult.encodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
@category encoding
@since 3.10.0

## encodeUnknownEither

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `encodeUnknownEither(= encodeUnknownEither;
const encodeUnknownPromise = (schema, options)`

JSDoc:

@category encoding
@since 3.10.0

## encodeUnknownPromise

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `encodeUnknownPromise(= encodeUnknownPromise;
const encode = exports.encode = encodeUnknown;
/**
 * @category encoding
 * @since 3.10.0
 */
const encodeEither = exports.encodeEither = encodeUnknownEither;
/**
 * @category encoding
 * @since 3.10.0
 */
const encodePromise = exports.encodePromise = encodeUnknownPromise;
/**
 * @category decoding
 * @since 3.10.0
 */
const decodeUnknown = (schema, options)`

JSDoc:

@category encoding
@since 3.10.0

## decodeUnknown

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `decodeUnknown(= decodeUnknown;
const decodeUnknownEither = (schema, options)`

JSDoc:

@category decoding
@since 3.10.0

## decodeUnknownEither

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `decodeUnknownEither(= decodeUnknownEither;
const decodeUnknownPromise = (schema, options)`

JSDoc:

@category decoding
@since 3.10.0

## decodeUnknownPromise

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `decodeUnknownPromise(= decodeUnknownPromise;
const decode = exports.decode = decodeUnknown;
/**
 * @category decoding
 * @since 3.10.0
 */
const decodeEither = exports.decodeEither = decodeUnknownEither;
/**
 * @category decoding
 * @since 3.10.0
 */
const decodePromise = exports.decodePromise = decodeUnknownPromise;
/**
 * @category validation
 * @since 3.10.0
 */
const validate = (schema, options)`

JSDoc:

@category decoding
@since 3.10.0

## validate

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `validate(= validate;
const validateEither = (schema, options)`

JSDoc:

@category validation
@since 3.10.0

## validateEither

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `validateEither(= validateEither;
const validatePromise = (schema, options)`

JSDoc:

@category validation
@since 3.10.0

## validatePromise

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `validatePromise(= validatePromise;
const isSchema = u => Predicate.hasProperty(u, TypeId)`

JSDoc:

Tests if a value is a `Schema`.

@category guards
@since 3.10.0

## pickLiteral

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `pickLiteral(= pickLiteral;
const UniqueSymbolFromSelf = symbol => make(new AST.UniqueSymbol(symbol)`

JSDoc:

Creates a new `Schema` from a literal schema.

@example
```ts
import * as assert from "node:assert"
import { Either, Schema } from "effect"

const schema = Schema.Literal("a", "b", "c").pipe(Schema.pickLiteral("a", "b"))

assert.deepStrictEqual(Schema.decodeSync(schema)("a"), "a")
assert.deepStrictEqual(Schema.decodeSync(schema)("b"), "b")
assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)("c")), true)
```

@category constructors
@since 3.10.0
/
const pickLiteral = (...literals) => _schema => Literal(...literals);
/**
@category constructors
@since 3.10.0

## Enums

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Enums(= Enums;
const TemplateLiteral = (...[head, ...tail])`

JSDoc:

@category constructors
@since 3.10.0
/
const Enums = enums => makeEnumsClass(enums);
/**
@category template literal
@since 3.10.0

## declare

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `declare(= declare;
const BrandSchemaId = exports.BrandSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Brand")`

JSDoc:

@category template literal
@since 3.10.0
/
const TemplateLiteralParser = (...params) => {
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    const schema = isSchema(param) ? param : Literal(param);
    schemas.push(schema);
    const encoded = encodedSchema(schema);
    encodedSchemas.push(encoded);
    const element = getTemplateLiteralParserCoercedElement(encoded, schema);
    if (element) {
      elements.push(element);
      coerced = true;
    } else {
      elements.push(schema);
    }
  }
  const from = TemplateLiteral(...encodedSchemas);
  const re = AST.getTemplateLiteralCapturingRegExp(from.ast);
  let to = Tuple(...elements);
  if (coerced) {
    to = to.annotations({
      [AST.AutoTitleAnnotationId]: format(Tuple(...schemas))
    });
  }
  return class TemplateLiteralParserClass extends transformOrFail(from, to, {
    strict: false,
    decode: (i, _, ast) => {
      const match = re.exec(i);
      return match ? ParseResult.succeed(match.slice(1, params.length + 1)) : ParseResult.fail(new ParseResult.Type(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
    },
    encode: tuple => ParseResult.succeed(tuple.join(""))
  }) {
    static params = params.slice();
  };
};
exports.TemplateLiteralParser = TemplateLiteralParser;
const declareConstructor = (typeParameters, options, annotations) => makeDeclareClass(typeParameters, new AST.Declaration(typeParameters.map(tp => tp.ast), (...typeParameters) => options.decode(...typeParameters.map(make)), (...typeParameters) => options.encode(...typeParameters.map(make)), toASTAnnotations(annotations)));
const declarePrimitive = (is, annotations) => {
  const decodeUnknown = () => (input, _, ast) => is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input));
  const encodeUnknown = decodeUnknown;
  return makeDeclareClass([], new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make(ast) {
    static annotations(annotations) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations));
    }
    static typeParameters = [...typeParameters];
  };
}
/**
The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.

@category constructors
@since 3.10.0
/
const declare = function () {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations = arguments[2];
    return declareConstructor(typeParameters, options, annotations);
  }
  const is = arguments[0];
  const annotations = arguments[1];
  return declarePrimitive(is, annotations);
};
/**
@category schema id
@since 3.10.0

## fromBrand

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `fromBrand(= fromBrand;
const InstanceOfSchemaId = exports.InstanceOfSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/InstanceOf")`

JSDoc:

@category constructors
@since 3.10.0
/
const fromBrand = (constructor, annotations) => self => {
  const out = makeBrandClass(self, new AST.Refinement(self.ast, function predicate(a, _, ast) {
    const either = constructor.either(a);
    return either_.isLeft(either) ? option_.some(new ParseResult.Type(ast, a, either.left.map(v => v.message).join(", "))) : option_.none();
  }, toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations
  })));
  return out;
};
/**
@category schema id
@since 3.10.0

## instanceOf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `instanceOf(= instanceOf;
class Undefined extends /*#__PURE__*/make(AST.undefinedKeyword)`

JSDoc:

@category constructors
@since 3.10.0
/
const instanceOf = (constructor, annotations) => declare(u => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations
});
/**
@category primitives
@since 3.10.0

## Undefined

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Undefined(= Undefined;
class Void extends /*#__PURE__*/make(AST.voidKeyword)`

JSDoc:

@category primitives
@since 3.10.0

## Void

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Void(= Void;
class Null extends /*#__PURE__*/make(AST.null)`

JSDoc:

@category primitives
@since 3.10.0

## Null

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Null(= Null;
class Never extends /*#__PURE__*/make(AST.neverKeyword)`

JSDoc:

@category primitives
@since 3.10.0

## Never

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Never(= Never;
class Unknown extends /*#__PURE__*/make(AST.unknownKeyword)`

JSDoc:

@category primitives
@since 3.10.0

## Unknown

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Unknown(= Unknown;
class Any extends /*#__PURE__*/make(AST.anyKeyword)`

JSDoc:

@category primitives
@since 3.10.0

## Any

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Any(= Any;
class BigIntFromSelf extends /*#__PURE__*/make(AST.bigIntKeyword)`

JSDoc:

@category primitives
@since 3.10.0

## BigIntFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `BigIntFromSelf(= BigIntFromSelf;
class SymbolFromSelf extends /*#__PURE__*/make(AST.symbolKeyword)`

JSDoc:

@category primitives
@since 3.10.0

## SymbolFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `SymbolFromSelf(= SymbolFromSelf;
class String$ extends /*#__PURE__*/make(AST.stringKeyword)`

JSDoc:

@ignore

## String

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `String(= String$;
class Number$ extends /*#__PURE__*/make(AST.numberKeyword)`

JSDoc:

@ignore

## Number

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Number(= Number$;
class Boolean$ extends /*#__PURE__*/make(AST.booleanKeyword)`

JSDoc:

@ignore

## Boolean

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Boolean(= Boolean$;
class Object$ extends /*#__PURE__*/make(AST.objectKeyword)`

JSDoc:

@ignore

## NullOr

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NullOr(= NullOr;
const UndefinedOr = self => Union(self, Undefined)`

JSDoc:

@category combinators
@since 3.10.0
/
const NullOr = self => Union(self, Null);
/**
@category combinators
@since 3.10.0

## UndefinedOr

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `UndefinedOr(= UndefinedOr;
const NullishOr = self => Union(self, Null, Undefined)`

JSDoc:

@category combinators
@since 3.10.0

## NullishOr

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NullishOr(= NullishOr;
const keyof = self => make(AST.keyof(self.ast)`

JSDoc:

@category combinators
@since 3.10.0

## keyof

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `keyof(= keyof;
const element = self => new ElementImpl(new AST.OptionalType(self.ast, false)`

JSDoc:

@since 3.10.0

## element

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `element(= element;
const optionalElement = self => new ElementImpl(new AST.OptionalType(self.ast, true)`

JSDoc:

@since 3.10.0

## NonEmptyArray

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NonEmptyArray(= NonEmptyArray;
function ArrayEnsure(value)`

JSDoc:

@category constructors
@since 3.10.0
/
const NonEmptyArray = value => makeNonEmptyArrayClass(value);
/**
@category constructors
@since 3.10.0

## PropertySignatureDeclaration

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `PropertySignatureDeclaration(= PropertySignatureDeclaration;
class FromPropertySignature extends AST.OptionalType {
  isReadonly;
  fromKey;
  constructor(type, isOptional, isReadonly, annotations, fromKey)`

JSDoc:

@category constructors
@since 3.10.0
/
function NonEmptyArrayEnsure(value) {
  return transform(Union(value, NonEmptyArray(value)), NonEmptyArray(typeSchema(asSchema(value))), {
    strict: true,
    decode: i => array_.isNonEmptyReadonlyArray(i) ? i : array_.of(i),
    encode: a => a.length === 1 ? a[0] : a
  });
}
const formatPropertySignatureToken = isOptional => isOptional ? "\"?:\"" : "\":\"";
/**
@category PropertySignature
@since 3.10.0
/
class PropertySignatureDeclaration extends AST.OptionalType {
  isReadonly;
  defaultValue;
  /**
@since 3.10.0
/
  _tag = "PropertySignatureDeclaration";
  constructor(type, isOptional, isReadonly, annotations, defaultValue) {
    super(type, isOptional, annotations);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
@since 3.10.0
/
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
}
/**
@category PropertySignature
@since 3.10.0

## FromPropertySignature

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `FromPropertySignature(= FromPropertySignature;
class ToPropertySignature extends AST.OptionalType {
  isReadonly;
  defaultValue;
  constructor(type, isOptional, isReadonly, annotations, defaultValue)`

JSDoc:

@category PropertySignature
@since 3.10.0

## propertySignature

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `propertySignature(= propertySignature;
const withConstructorDefault = exports.withConstructorDefault = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category PropertySignature
@since 3.10.0
/
class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  /**
@since 3.10.0
/
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
  /**
@since 3.10.0
/
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
exports.PropertySignatureTransformation = PropertySignatureTransformation;
const mergeSignatureAnnotations = (ast, annotations) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations
        }, ast.defaultValue);
      }
    case "PropertySignatureTransformation":
      {
        return new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations
        }, ast.to.defaultValue), ast.decode, ast.encode);
      }
  }
};
/**
@since 3.10.0
@category symbol
/
const PropertySignatureTypeId = exports.PropertySignatureTypeId = /*#__PURE__*/Symbol.for("effect/PropertySignature");
/**
@since 3.10.0
@category guards
/
const isPropertySignature = u => Predicate.hasProperty(u, PropertySignatureTypeId);
exports.isPropertySignature = isPropertySignature;
class PropertySignatureImpl {
  ast;
  [TypeId];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  annotations(annotations) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)));
  }
  toString() {
    return String(this.ast);
  }
}
/**
@category PropertySignature
@since 3.10.0
/
const makePropertySignature = ast => new PropertySignatureImpl(ast);
exports.makePropertySignature = makePropertySignature;
class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)), this.from);
  }
}
/**
Lifts a `Schema` into a `PropertySignature`.

@category PropertySignature
@since 3.10.0
/
const propertySignature = self => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, undefined), self);
/**
Enhances a property signature with a default constructor value.

@category PropertySignature
@since 3.10.0

## optionalToRequired

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `optionalToRequired(= optionalToRequired;
const requiredToOptional = (from, to, options)`

JSDoc:

Enhances a property signature with a default decoding value.

@category PropertySignature
@since 3.10.0
/
const withDecodingDefault = exports.withDecodingDefault = /*#__PURE__*/(0, _Function.dual)(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        const to = AST.typeAST(ast.type);
        return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined(to) ?? to, false, true, {}, ast.defaultValue), o => applyDefaultValue(o, defaultValue), _Function.identity));
      }
    case "PropertySignatureTransformation":
      {
        const to = ast.to.type;
        return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(pruneUndefined(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), o => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
      }
  }
});
/**
Enhances a property signature with a default decoding value and a default constructor value.

@category PropertySignature
@since 3.10.0
/
const withDefaults = exports.withDefaults = /*#__PURE__*/(0, _Function.dual)(2, (self, defaults) => self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
/**
Enhances a property signature by specifying a different key for it in the Encoded type.

@category PropertySignature
@since 3.10.0
/
const fromKey = exports.fromKey = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), _Function.identity, _Function.identity));
      }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
/**
Converts an optional property to a required one through a transformation `Option -> Type`.

- `decode`: `none` as argument means the value is missing in the input.
- `encode`: `none` as return value means the value will be missing in the output.

@category PropertySignature
@since 3.10.0
/
const optionalToRequired = (from, to, options) => makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, false, true, {}, undefined), o => option_.some(options.decode(o)), option_.flatMap(options.encode)));
/**
Converts an optional property to a required one through a transformation `Type -> Option`.

- `decode`: `none` as return value means the value will be missing in the output.
- `encode`: `none` as argument means the value is missing in the input.

@category PropertySignature
@since 3.10.0

## requiredToOptional

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `requiredToOptional(= requiredToOptional;
const optionalToOptional = (from, to, options)`

JSDoc:

Converts an optional property to another optional property through a transformation `Option -> Option`.

- `decode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.
- `encode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.

@category PropertySignature
@since 3.10.0

## optional

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `optional(= optional;
const optionalWith = exports.optionalWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category PropertySignature
@since 3.10.0
/
const optional = self => {
  const ast = self.ast === AST.undefinedKeyword || self.ast === AST.neverKeyword ? AST.undefinedKeyword : UndefinedOr(self).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self);
};
/**
@category PropertySignature
@since 3.10.0

## tag

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `tag(= tag;
const TaggedStruct = (value, fields)`

JSDoc:

Returns a property signature that represents a tag.
A tag is a literal value that is used to distinguish between different types of objects.
The tag is optional when using the `make` method.

@example
```ts
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.Struct({
  _tag: Schema.tag("User"),
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

@see {@link TaggedStruct}

@since 3.10.0
/
const tag = tag => Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag));
/**
A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.

The tag is optional when using the `make` method.

@example
```ts
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.TaggedStruct("User", {
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

@category constructors
@since 3.10.0

## Record

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Record(= Record;
const pick = (...keys)`

JSDoc:

@category constructors
@since 3.10.0
/
const Record = options => makeRecordClass(options.key, options.value);
/**
@category struct transformations
@since 3.10.0

## pick

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `pick(= pick;
const omit = (...keys)`

JSDoc:

@category struct transformations
@since 3.10.0

## omit

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `omit(= omit;
const pluck = exports.pluck = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

@example
```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

@category struct transformations
@since 3.10.0

## brand

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `brand(= brand;
const partial = self => make(AST.partial(self.ast)`

JSDoc:

Returns a nominal branded schema by applying a brand to a given schema.

```
Schema<A> + B -> Schema<A & Brand<B>>
```

@example
```ts
import * as Schema from "effect/Schema"

const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
```

@category branding
@since 3.10.0
/
const brand = (brand, annotations) => self => {
  const annotation = option_.match(AST.getBrandAnnotation(self.ast), {
    onNone: () => [brand],
    onSome: brands => [...brands, brand]
  });
  const ast = AST.annotations(self.ast, toASTAnnotations({
    [AST.BrandAnnotationId]: annotation,
    ...annotations
  }));
  return makeBrandClass(self, ast);
};
/**
@category combinators
@since 3.10.0

## partial

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `partial(= partial;
const partialWith = exports.partialWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@category combinators
@since 3.10.0

## required

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `required(= required;
const mutable = schema => make(AST.mutable(schema.ast)`

JSDoc:

@category combinators
@since 3.10.0
/
const required = self => make(AST.required(self.ast));
/**
Creates a new schema with shallow mutability applied to its properties.

@category combinators
@since 3.10.0

## suspend

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `suspend(= suspend;
const RefineSchemaId = exports.RefineSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Refine")`

JSDoc:

Extends a schema with another schema.

Not all extensions are supported, and their support depends on the nature of
the involved schemas.

Possible extensions include:
- `Schema.String` with another `Schema.String` refinement or a string literal
- `Schema.Number` with another `Schema.Number` refinement or a number literal
- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean
  literal
- A struct with another struct where overlapping fields support extension
- A struct with in index signature
- A struct with a union of supported schemas
- A refinement of a struct with a supported schema
- A suspend of a struct with a supported schema
- A transformation between structs where the from and to sides have no
  overlapping fields with the target struct

@example
```ts
import * as Schema from "effect/Schema"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

// const extended: Schema<
//   {
//     readonly a: string
//     readonly b: string
//   } & {
//     readonly c: string
//   } & {
//     readonly [x: string]: string
//   }
// >
const extended = Schema.asSchema(schema.pipe(
  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures
))
```

@category combinators
@since 3.10.0
/
const extend = exports.extend = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(extendAST(self.ast, that.ast, [])));
/**
@category combinators
@since 3.10.0
/
const compose = exports.compose = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[1]), (from, to) => makeTransformationClass(from, to, AST.compose(from.ast, to.ast)));
/**
@category constructors
@since 3.10.0
/
const suspend = f => make(new AST.Suspend(() => f().ast));
/**
@since 3.10.0
@category symbol

## trimmed

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `trimmed(= trimmed;
const MaxLengthSchemaId = exports.MaxLengthSchemaId = schemaId_.MaxLengthSchemaId;
/**
 * @category string filters
 * @since 3.10.0
 */
const maxLength = (maxLength, annotations)`

JSDoc:

@category transformations
@since 3.10.0
/
const filterEffect = exports.filterEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => transformOrFail(self, typeSchema(self), {
  strict: true,
  decode: (i, options, ast) => ParseResult.flatMap(f(i, options, ast), filterReturnType => option_.match(toFilterParseIssue(filterReturnType, ast, i), {
    onNone: () => ParseResult.succeed(i),
    onSome: ParseResult.fail
  })),
  encode: a => ParseResult.succeed(a)
}));
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make(ast) {
    static annotations(annotations) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations));
    }
    static from = from;
    static to = to;
  };
}
/**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided decoding functions.

@category transformations
@since 3.10.0
/
const transformOrFail = exports.transformOrFail = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => makeTransformationClass(from, to, new AST.Transformation(from.ast, to.ast, new AST.FinalTransformation(options.decode, options.encode))));
/**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided mapping functions.

@category transformations
@since 3.10.0
/
const transform = exports.transform = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => ParseResult.succeed(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => ParseResult.succeed(options.encode(toI, toA))
}));
/**
Creates a new `Schema` which transforms literal values.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"

const schema = S.transformLiteral(0, "a")

assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
```

@category constructors
@since 3.10.0
/
function transformLiteral(from, to) {
  return transform(Literal(from), Literal(to), {
    strict: true,
    decode: () => to,
    encode: () => from
  });
}
function transformLiterals(...pairs) {
  return Union(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
/**
Attaches a property signature with the specified key and value to the schema.
This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
but rather maps to another schema, for example when you want to add a discriminant to a simple union.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"
import { pipe } from "effect/Function"

const Circle = S.Struct({ radius: S.Number })
const Square = S.Struct({ sideLength: S.Number })
const Shape = S.Union(
  Circle.pipe(S.attachPropertySignature("kind", "circle")),
  Square.pipe(S.attachPropertySignature("kind", "square"))
)

assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
  kind: "circle",
  radius: 10
})
```

@category combinators
@since 3.10.0
/
const attachPropertySignature = exports.attachPropertySignature = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (schema, key, value, annotations) => {
  const ast = extend(typeSchema(schema), Struct({
    [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value)
  })).ast;
  return make(new AST.Transformation(schema.ast, annotations ? mergeSchemaAnnotations(ast, annotations) : ast, new AST.TypeLiteralTransformation([new AST.PropertySignatureTransformation(key, key, () => option_.some(value), () => option_.none())])));
});
/**
Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

@category annotations
@since 3.10.0
/
const annotations = exports.annotations = /*#__PURE__*/(0, _Function.dual)(2, (self, annotations) => self.annotations(annotations));
/**
@category renaming
@since 3.10.0
/
const rename = exports.rename = /*#__PURE__*/(0, _Function.dual)(2, (self, mapping) => make(AST.rename(self.ast, mapping)));
/**
@category schema id
@since 3.10.0
/
const TrimmedSchemaId = exports.TrimmedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Trimmed");
/**
Verifies that a string contains no leading or trailing whitespaces.

Note. This combinator does not make any transformations, it only validates.
If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.

@category string filters
@since 3.10.0
/
const trimmed = annotations => self => self.pipe(filter(a => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## maxLength

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `maxLength(= maxLength;
const MinLengthSchemaId = exports.MinLengthSchemaId = schemaId_.MinLengthSchemaId;
/**
 * @category string filters
 * @since 3.10.0
 */
const minLength = (minLength, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## minLength

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `minLength(= minLength;
const LengthSchemaId = exports.LengthSchemaId = schemaId_.LengthSchemaId;
/**
 * @category string filters
 * @since 3.10.0
 */
const length = (length, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## length

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `length(= length;
const PatternSchemaId = exports.PatternSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Pattern")`

JSDoc:

@category schema id
@since 3.10.0

## pattern

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `pattern(= pattern;
const StartsWithSchemaId = exports.StartsWithSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/StartsWith")`

JSDoc:

@category string filters
@since 3.10.0
/
const pattern = (regex, annotations) => self => {
  const source = regex.source;
  return self.pipe(filter(a => {
    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## startsWith

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `startsWith(= startsWith;
const EndsWithSchemaId = exports.EndsWithSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/EndsWith")`

JSDoc:

@category string filters
@since 3.10.0
/
const startsWith = (startsWith, annotations) => self => {
  const formatted = JSON.stringify(startsWith);
  return self.pipe(filter(a => a.startsWith(startsWith), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith}`
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## endsWith

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `endsWith(= endsWith;
const IncludesSchemaId = exports.IncludesSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Includes")`

JSDoc:

@category string filters
@since 3.10.0
/
const endsWith = (endsWith, annotations) => self => {
  const formatted = JSON.stringify(endsWith);
  return self.pipe(filter(a => a.endsWith(endsWith), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith}$`
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## includes

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `includes(= includes;
const LowercasedSchemaId = exports.LowercasedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Lowercased")`

JSDoc:

@category string filters
@since 3.10.0
/
const includes = (searchString, annotations) => self => {
  const formatted = JSON.stringify(searchString);
  return self.pipe(filter(a => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## lowercased

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lowercased(= lowercased;
class Lowercased extends /*#__PURE__*/String$.pipe(/*#__PURE__*/lowercased({
  identifier: "Lowercased"
})`

JSDoc:

Verifies that a string is lowercased.

@category string filters
@since 3.10.0
/
const lowercased = annotations => self => self.pipe(filter(a => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations
}));
/**
@category string constructors
@since 3.10.0

## Lowercased

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Lowercased(= Lowercased;
const UppercasedSchemaId = exports.UppercasedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Uppercased")`

JSDoc:

@category schema id
@since 3.10.0

## uppercased

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `uppercased(= uppercased;
class Uppercased extends /*#__PURE__*/String$.pipe(/*#__PURE__*/uppercased({
  identifier: "Uppercased"
})`

JSDoc:

Verifies that a string is uppercased.

@category string filters
@since 3.10.0
/
const uppercased = annotations => self => self.pipe(filter(a => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations
}));
/**
@category string constructors
@since 3.10.0

## Uppercased

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Uppercased(= Uppercased;
const CapitalizedSchemaId = exports.CapitalizedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Capitalized")`

JSDoc:

@category schema id
@since 3.10.0

## capitalized

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `capitalized(= capitalized;
class Capitalized extends /*#__PURE__*/String$.pipe(/*#__PURE__*/capitalized({
  identifier: "Capitalized"
})`

JSDoc:

Verifies that a string is capitalized.

@category string filters
@since 3.10.0
/
const capitalized = annotations => self => self.pipe(filter(a => a[0]?.toUpperCase() === a[0], {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations
}));
/**
@category string constructors
@since 3.10.0

## Capitalized

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Capitalized(= Capitalized;
const UncapitalizedSchemaId = exports.UncapitalizedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Uncapitalized")`

JSDoc:

@category schema id
@since 3.10.0

## uncapitalized

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `uncapitalized(= uncapitalized;
class Uncapitalized extends /*#__PURE__*/String$.pipe(/*#__PURE__*/uncapitalized({
  identifier: "Uncapitalized"
})`

JSDoc:

Verifies that a string is uncapitalized.

@category string filters
@since 3.10.0
/
const uncapitalized = annotations => self => self.pipe(filter(a => a[0]?.toLowerCase() === a[0], {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations
}));
/**
@category string constructors
@since 3.10.0

## Uncapitalized

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Uncapitalized(= Uncapitalized;
class Char extends /*#__PURE__*/String$.pipe(/*#__PURE__*/length(1, {
  identifier: "Char"
})`

JSDoc:

A schema representing a single character.

@category string constructors
@since 3.10.0

## Char

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Char(= Char;
const nonEmptyString = annotations => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations
})`

JSDoc:

@category string filters
@since 3.10.0

## nonEmptyString

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `nonEmptyString(= nonEmptyString;
class Lowercase extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be converted to lowercase"
})`

JSDoc:

This schema converts a string to lowercase.

@category string transformations
@since 3.10.0

## Lowercase

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Lowercase(= Lowercase;
class Uppercase extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be converted to uppercase"
})`

JSDoc:

This schema converts a string to uppercase.

@category string transformations
@since 3.10.0

## Uppercase

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Uppercase(= Uppercase;
class Capitalize extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be converted to a capitalized format"
})`

JSDoc:

This schema converts a string to capitalized one.

@category string transformations
@since 3.10.0

## Capitalize

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Capitalize(= Capitalize;
class Uncapitalize extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
})`

JSDoc:

This schema converts a string to uncapitalized one.

@category string transformations
@since 3.10.0

## Uncapitalize

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Uncapitalize(= Uncapitalize;
class Trimmed extends /*#__PURE__*/String$.pipe(/*#__PURE__*/trimmed({
  identifier: "Trimmed"
})`

JSDoc:

@category string constructors
@since 3.10.0

## Trimmed

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Trimmed(= Trimmed;
class NonEmptyTrimmedString extends /*#__PURE__*/Trimmed.pipe(/*#__PURE__*/nonEmptyString({
  identifier: "NonEmptyTrimmedString"
})`

JSDoc:

Useful for validating strings that must contain meaningful characters without
leading or trailing whitespace.

@example
```ts
import { Schema } from "effect"

console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(" a ")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("a")) // Option.some("a")
```

@category string constructors
@since 3.10.0

## NonEmptyTrimmedString

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NonEmptyTrimmedString(= NonEmptyTrimmedString;
class Trim extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be trimmed"
})`

JSDoc:

This schema allows removing whitespaces from the beginning and end of a string.

@category string transformations
@since 3.10.0

## Trim

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Trim(= Trim;
const split = separator => transform(String$.annotations({
  description: "a string that will be split"
})`

JSDoc:

Returns a schema that allows splitting a string into an array of strings.

@category string transformations
@since 3.10.0

## parseJson

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `parseJson(= parseJson;
class NonEmptyString extends /*#__PURE__*/String$.pipe(/*#__PURE__*/nonEmptyString({
  identifier: "NonEmptyString"
})`

JSDoc:

The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.

You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.

Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.

@example
```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{"a":"1"}`), { a: "1" })
assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{"a":"1"}`), { a: 1 })
```

@category string transformations
@since 3.10.0
/
const parseJson = (schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
/**
@category string constructors
@since 3.10.0

## NonEmptyString

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NonEmptyString(= NonEmptyString;
const UUIDSchemaId = exports.UUIDSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/UUID")`

JSDoc:

@category schema id
@since 3.10.0

## UUID

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `UUID(= UUID;
const ULIDSchemaId = exports.ULIDSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/ULID")`

JSDoc:

Represents a Universally Unique Identifier (UUID).

This schema ensures that the provided string adheres to the standard UUID format.

@category string constructors
@since 3.10.0
/
class UUID extends /*#__PURE__*/String$.pipe(/*#__PURE__*/pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => fc => fc.uuid()
})) {}
/**
@category schema id
@since 3.10.0

## ULID

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `ULID(= ULID;
class URLFromSelf extends /*#__PURE__*/instanceOf(URL, {
  identifier: "URLFromSelf",
  arbitrary: ()`

JSDoc:

Represents a Universally Unique Lexicographically Sortable Identifier (ULID).

ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
This schema ensures that the provided string adheres to the standard ULID format.

@category string constructors
@since 3.10.0
/
class ULID extends /*#__PURE__*/String$.pipe(/*#__PURE__*/pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => fc => fc.ulid()
})) {}
/**
Defines a schema that represents a `URL` object.

@category URL constructors
@since 3.11.0

## URLFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `URLFromSelf(= URLFromSelf;
class URL$ extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
})`

JSDoc:

@ignore

## finite

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `finite(= finite;
const GreaterThanSchemaId = exports.GreaterThanSchemaId = schemaId_.GreaterThanSchemaId;
/**
 * This filter checks whether the provided number is greater than the specified minimum.
 *
 * @category number filters
 * @since 3.10.0
 */
const greaterThan = (exclusiveMinimum, annotations)`

JSDoc:

@category schema id
@since 3.10.0
/
const FiniteSchemaId = exports.FiniteSchemaId = schemaId_.FiniteSchemaId;
/**
Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).

@category number filters
@since 3.10.0
/
const finite = annotations => self => self.pipe(filter(Number.isFinite, {
  schemaId: FiniteSchemaId,
  title: "finite",
  description: "a finite number",
  jsonSchema: {
    "type": "number"
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## greaterThan

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThan(= greaterThan;
const GreaterThanOrEqualToSchemaId = exports.GreaterThanOrEqualToSchemaId = schemaId_.GreaterThanOrEqualToSchemaId;
/**
 * This filter checks whether the provided number is greater than or equal to the specified minimum.
 *
 * @category number filters
 * @since 3.10.0
 */
const greaterThanOrEqualTo = (minimum, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## greaterThanOrEqualTo

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanOrEqualTo(= greaterThanOrEqualTo;
const MultipleOfSchemaId = exports.MultipleOfSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/MultipleOf")`

JSDoc:

@category schema id
@since 3.10.0

## multipleOf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `multipleOf(= multipleOf;
const IntSchemaId = exports.IntSchemaId = schemaId_.IntSchemaId;
/**
 * Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity)`

JSDoc:

@category number filters
@since 3.10.0
/
const multipleOf = (divisor, annotations) => self => {
  const positiveDivisor = Math.abs(divisor); // spec requires positive divisor
  return self.pipe(filter(a => number_.remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## int

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `int(= int;
const LessThanSchemaId = exports.LessThanSchemaId = schemaId_.LessThanSchemaId;
/**
 * This filter checks whether the provided number is less than the specified maximum.
 *
 * @category number filters
 * @since 3.10.0
 */
const lessThan = (exclusiveMaximum, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## lessThan

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThan(= lessThan;
const LessThanOrEqualToSchemaId = exports.LessThanOrEqualToSchemaId = schemaId_.LessThanOrEqualToSchemaId;
/**
 * This schema checks whether the provided number is less than or equal to the specified maximum.
 *
 * @category number filters
 * @since 3.10.0
 */
const lessThanOrEqualTo = (maximum, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## lessThanOrEqualTo

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanOrEqualTo(= lessThanOrEqualTo;
const BetweenSchemaId = exports.BetweenSchemaId = schemaId_.BetweenSchemaId;
/**
 * This filter checks whether the provided number falls within the specified minimum and maximum values.
 *
 * @category number filters
 * @since 3.10.0
 */
const between = (minimum, maximum, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## between

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `between(= between;
const NonNaNSchemaId = exports.NonNaNSchemaId = schemaId_.NonNaNSchemaId;
/**
 * @category number filters
 * @since 3.10.0
 */
const nonNaN = annotations => self => self.pipe(filter(a => !Number.isNaN(a)`

JSDoc:

@category schema id
@since 3.10.0

## nonNaN

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `nonNaN(= nonNaN;
const positive = annotations => greaterThan(0, {
  title: "positive",
  ...annotations
})`

JSDoc:

@category number filters
@since 3.10.0

## positive

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `positive(= positive;
const negative = annotations => lessThan(0, {
  title: "negative",
  ...annotations
})`

JSDoc:

@category number filters
@since 3.10.0

## negative

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `negative(= negative;
const nonPositive = annotations => lessThanOrEqualTo(0, {
  title: "nonPositive",
  ...annotations
})`

JSDoc:

@category number filters
@since 3.10.0

## nonPositive

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `nonPositive(= nonPositive;
const nonNegative = annotations => greaterThanOrEqualTo(0, {
  title: "nonNegative",
  ...annotations
})`

JSDoc:

@category number filters
@since 3.10.0

## nonNegative

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `nonNegative(= nonNegative;
const clamp = (minimum, maximum)`

JSDoc:

Clamps a number between a minimum and a maximum value.

@category number transformations
@since 3.10.0

## clamp

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `clamp(= clamp;
function parseNumber(self)`

JSDoc:

Transforms a `string` into a `number` by parsing the string using the `parse`
function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when
non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity",
"-Infinity".

@category number transformations
@since 3.10.0

## NumberFromString

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NumberFromString(= NumberFromString;
class Finite extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/finite({
  identifier: "Finite"
})`

JSDoc:

This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity", "-Infinity".

@category number transformations
@since 3.10.0
/
class NumberFromString extends /*#__PURE__*/parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
}) {}
/**
@category number constructors
@since 3.10.0

## Finite

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Finite(= Finite;
class Int extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/int({
  identifier: "Int"
})`

JSDoc:

@category number constructors
@since 3.10.0

## Int

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Int(= Int;
class NonNaN extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/nonNaN({
  identifier: "NonNaN"
})`

JSDoc:

@category number constructors
@since 3.10.0

## NonNaN

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NonNaN(= NonNaN;
class Positive extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/positive({
  identifier: "Positive"
})`

JSDoc:

@category number constructors
@since 3.10.0

## Positive

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Positive(= Positive;
class Negative extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/negative({
  identifier: "Negative"
})`

JSDoc:

@category number constructors
@since 3.10.0

## Negative

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Negative(= Negative;
class NonPositive extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/nonPositive({
  identifier: "NonPositive"
})`

JSDoc:

@category number constructors
@since 3.10.0

## NonPositive

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NonPositive(= NonPositive;
class NonNegative extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/nonNegative({
  identifier: "NonNegative"
})`

JSDoc:

@category number constructors
@since 3.10.0

## NonNegative

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NonNegative(= NonNegative;
const JsonNumberSchemaId = exports.JsonNumberSchemaId = schemaId_.JsonNumberSchemaId;
/**
 * The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
 * number by filtering out `NaN` and `(+/-)`

JSDoc:

@category schema id
@since 3.10.0

## JsonNumber

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `JsonNumber(= JsonNumber;
class Not extends /*#__PURE__*/transform(/*#__PURE__*/Boolean$.annotations({
  description: "a boolean that will be negated"
})`

JSDoc:

@category boolean transformations
@since 3.10.0

## greaterThanBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanBigInt(= greaterThanBigInt;
const GreaterThanOrEqualToBigIntSchemaId = exports.GreaterThanOrEqualToBigIntSchemaId = schemaId_.GreaterThanOrEqualToBigIntSchemaId;
/**
 * @category bigint filters
 * @since 3.10.0
 */
const greaterThanOrEqualToBigInt = (min, annotations)`

JSDoc:

@ignore */
class Symbol$ extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: i => decodeSymbol(i),
  encode: (a, _, ast) => encodeSymbol(a, ast)
}).annotations({
  identifier: "Symbol"
}) {}
exports.Symbol = Symbol$;
/**
@category schema id
@since 3.10.0
/
const GreaterThanBigIntSchemaId = exports.GreaterThanBigIntSchemaId = schemaId_.GreaterThanBigintSchemaId;
/**
@category bigint filters
@since 3.10.0
/
const greaterThanBigInt = (min, annotations) => self => self.pipe(filter(a => a > min, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min
  },
  title: `greaterThanBigInt(${min})`,
  description: min === 0n ? "a positive bigint" : `a bigint greater than ${min}n`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## greaterThanOrEqualToBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanOrEqualToBigInt(= greaterThanOrEqualToBigInt;
const LessThanBigIntSchemaId = exports.LessThanBigIntSchemaId = schemaId_.LessThanBigIntSchemaId;
/**
 * @category bigint filters
 * @since 3.10.0
 */
const lessThanBigInt = (max, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## lessThanBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanBigInt(= lessThanBigInt;
const LessThanOrEqualToBigIntSchemaId = exports.LessThanOrEqualToBigIntSchemaId = schemaId_.LessThanOrEqualToBigIntSchemaId;
/**
 * @category bigint filters
 * @since 3.10.0
 */
const lessThanOrEqualToBigInt = (max, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## lessThanOrEqualToBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanOrEqualToBigInt(= lessThanOrEqualToBigInt;
const BetweenBigIntSchemaId = exports.BetweenBigIntSchemaId = schemaId_.BetweenBigintSchemaId;
/**
 * @category bigint filters
 * @since 3.10.0
 */
const betweenBigInt = (min, max, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## betweenBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `betweenBigInt(= betweenBigInt;
const positiveBigInt = annotations => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations
})`

JSDoc:

@category bigint filters
@since 3.10.0

## positiveBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `positiveBigInt(= positiveBigInt;
const negativeBigInt = annotations => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations
})`

JSDoc:

@category bigint filters
@since 3.10.0

## negativeBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `negativeBigInt(= negativeBigInt;
const nonNegativeBigInt = annotations => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations
})`

JSDoc:

@category bigint filters
@since 3.10.0

## nonNegativeBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `nonNegativeBigInt(= nonNegativeBigInt;
const nonPositiveBigInt = annotations => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations
})`

JSDoc:

@category bigint filters
@since 3.10.0

## nonPositiveBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `nonPositiveBigInt(= nonPositiveBigInt;
const clampBigInt = (minimum, maximum)`

JSDoc:

Clamps a bigint between a minimum and a maximum value.

@category bigint transformations
@since 3.10.0

## clampBigInt

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `clampBigInt(= clampBigInt;
class BigInt$ extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
})`

JSDoc:

@ignore

## RedactedFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `RedactedFromSelf(= RedactedFromSelf;
function Redacted(value)`

JSDoc:

@category bigint constructors
@since 3.10.0
/
const PositiveBigIntFromSelf = exports.PositiveBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe(/*#__PURE__*/positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
/**
@category bigint constructors
@since 3.10.0
/
const PositiveBigInt = exports.PositiveBigInt = /*#__PURE__*/BigInt$.pipe(/*#__PURE__*/positiveBigInt({
  identifier: "PositiveBigint"
}));
/**
@category bigint constructors
@since 3.10.0
/
const NegativeBigIntFromSelf = exports.NegativeBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe(/*#__PURE__*/negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
/**
@category bigint constructors
@since 3.10.0
/
const NegativeBigInt = exports.NegativeBigInt = /*#__PURE__*/BigInt$.pipe(/*#__PURE__*/negativeBigInt({
  identifier: "NegativeBigint"
}));
/**
@category bigint constructors
@since 3.10.0
/
const NonPositiveBigIntFromSelf = exports.NonPositiveBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe(/*#__PURE__*/nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
/**
@category bigint constructors
@since 3.10.0
/
const NonPositiveBigInt = exports.NonPositiveBigInt = /*#__PURE__*/BigInt$.pipe(/*#__PURE__*/nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
/**
@category bigint constructors
@since 3.10.0
/
const NonNegativeBigIntFromSelf = exports.NonNegativeBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe(/*#__PURE__*/nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
/**
@category bigint constructors
@since 3.10.0
/
const NonNegativeBigInt = exports.NonNegativeBigInt = /*#__PURE__*/BigInt$.pipe(/*#__PURE__*/nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));
/**
This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.

It returns an error if the value can't be safely encoded as a `number` due to being out of range.

@category bigint transformations
@since 3.10.0
/
class BigIntFromNumber extends /*#__PURE__*/transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: (i, _, ast) => ParseResult.fromOption(bigInt_.fromNumber(i), () => new ParseResult.Type(ast, i, `Unable to decode ${i} into a bigint`)),
  encode: (a, _, ast) => ParseResult.fromOption(bigInt_.toNumber(a), () => new ParseResult.Type(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
  identifier: "BigIntFromNumber"
}) {}
exports.BigIntFromNumber = BigIntFromNumber;
const redactedArbitrary = value => fc => value(fc).map(redacted_.make);
const toComposite = (eff, onSuccess, ast, actual) => ParseResult.mapBoth(eff, {
  onFailure: e => new ParseResult.Composite(ast, actual, e),
  onSuccess
});
const redactedParse = decodeUnknown => (u, options, ast) => redacted_.isRedacted(u) ? toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Redacted constructors
@since 3.10.0
/
const RedactedFromSelf = value => declare([value], {
  decode: value => redactedParse(ParseResult.decodeUnknown(value)),
  encode: value => redactedParse(ParseResult.encodeUnknown(value))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: redacted_.getEquivalence
});
/**
A transformation that transform a `Schema<A, I, R>` into a
`RedactedFromSelf<A>`.

@category Redacted transformations
@since 3.10.0

## DurationFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DurationFromSelf(= DurationFromSelf;
class DurationFromNanos extends /*#__PURE__*/transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
})`

JSDoc:

@category Duration constructors
@since 3.10.0
/
class DurationFromSelf extends /*#__PURE__*/declare(duration_.isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => fc => fc.oneof(fc.constant(duration_.infinity), fc.bigInt({
    min: 0n
  }).map(_ => duration_.nanos(_)), fc.maxSafeNat().map(_ => duration_.millis(_))),
  equivalence: () => duration_.Equivalence
}) {}
/**
A schema that transforms a non negative `bigint` into a `Duration`. Treats
the value as the number of nanoseconds.

@category Duration transformations
@since 3.10.0

## DurationFromNanos

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DurationFromNanos(= DurationFromNanos;
const NonNegativeInt = exports.NonNegativeInt = /*#__PURE__*/NonNegative.pipe(int()`

JSDoc:

A non-negative integer. +Infinity is excluded.

@category number constructors
@since 3.11.10

## Duration

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Duration(= Duration;
const clampDuration = (minimum, maximum)`

JSDoc:

A schema that transforms a (possibly Infinite) non negative number into a
`Duration`. Treats the value as the number of milliseconds.

@category Duration transformations
@since 3.10.0
/
class DurationFromMillis extends /*#__PURE__*/transform(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: i => duration_.millis(i),
  encode: a => duration_.toMillis(a)
}).annotations({
  identifier: "DurationFromMillis"
}) {}
exports.DurationFromMillis = DurationFromMillis;
const DurationValueMillis = /*#__PURE__*/TaggedStruct("Millis", {
  millis: NonNegativeInt
});
const DurationValueNanos = /*#__PURE__*/TaggedStruct("Nanos", {
  nanos: BigInt$
});
const DurationValueInfinity = /*#__PURE__*/TaggedStruct("Infinity", {});
const durationValueInfinity = /*#__PURE__*/DurationValueInfinity.make({});
const DurationValue = /*#__PURE__*/Union(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
const FiniteHRTime = /*#__PURE__*/Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
const InfiniteHRTime = /*#__PURE__*/Tuple(Literal(-1), Literal(0)).annotations({
  identifier: "InfiniteHRTime"
});
const HRTime = /*#__PURE__*/Union(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
const isDurationValue = u => typeof u === "object";
// TODO(4.0): remove HRTime union member
/**
A schema that converts a JSON-compatible tagged union into a `Duration`.

@category Duration transformations
@since 3.10.0
/
class Duration extends /*#__PURE__*/transform(Union(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: i => {
    if (isDurationValue(i)) {
      switch (i._tag) {
        case "Millis":
          return duration_.millis(i.millis);
        case "Nanos":
          return duration_.nanos(i.nanos);
        case "Infinity":
          return duration_.infinity;
      }
    }
    const [seconds, nanos] = i;
    return seconds === -1 ? duration_.infinity : duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos));
  },
  encode: a => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }
}).annotations({
  identifier: "Duration"
}) {}
/**
Clamps a `Duration` between a minimum and a maximum value.

@category Duration transformations
@since 3.10.0

## clampDuration

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `clampDuration(= clampDuration;
const LessThanDurationSchemaId = exports.LessThanDurationSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/LessThanDuration")`

JSDoc:

@category schema id
@since 3.10.0

## lessThanDuration

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanDuration(= lessThanDuration;
const LessThanOrEqualToDurationSchemaId = exports.LessThanOrEqualToDurationSchemaId = /*#__PURE__*/Symbol.for("effect/schema/LessThanOrEqualToDuration")`

JSDoc:

@category Duration filters
@since 3.10.0
/
const lessThanDuration = (max, annotations) => self => self.pipe(filter(a => duration_.lessThan(a, max), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max
  },
  title: `lessThanDuration(${max})`,
  description: `a Duration less than ${duration_.decode(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## lessThanOrEqualToDuration

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanOrEqualToDuration(= lessThanOrEqualToDuration;
const GreaterThanDurationSchemaId = exports.GreaterThanDurationSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/GreaterThanDuration")`

JSDoc:

@category Duration filters
@since 3.10.0
/
const lessThanOrEqualToDuration = (max, annotations) => self => self.pipe(filter(a => duration_.lessThanOrEqualTo(a, max), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max
  },
  title: `lessThanOrEqualToDuration(${max})`,
  description: `a Duration less than or equal to ${duration_.decode(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## greaterThanDuration

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanDuration(= greaterThanDuration;
const GreaterThanOrEqualToDurationSchemaId = exports.GreaterThanOrEqualToDurationSchemaId = /*#__PURE__*/Symbol.for("effect/schema/GreaterThanOrEqualToDuration")`

JSDoc:

@category Duration filters
@since 3.10.0
/
const greaterThanDuration = (min, annotations) => self => self.pipe(filter(a => duration_.greaterThan(a, min), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min
  },
  title: `greaterThanDuration(${min})`,
  description: `a Duration greater than ${duration_.decode(min)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## greaterThanOrEqualToDuration

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanOrEqualToDuration(= greaterThanOrEqualToDuration;
const BetweenDurationSchemaId = exports.BetweenDurationSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/BetweenDuration")`

JSDoc:

@category Duration filters
@since 3.10.0
/
const greaterThanOrEqualToDuration = (min, annotations) => self => self.pipe(filter(a => duration_.greaterThanOrEqualTo(a, min), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min
  },
  title: `greaterThanOrEqualToDuration(${min})`,
  description: `a Duration greater than or equal to ${duration_.decode(min)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## betweenDuration

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `betweenDuration(= betweenDuration;
class Uint8ArrayFromSelf extends /*#__PURE__*/declare(Predicate.isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: ()`

JSDoc:

@category Duration filters
@since 3.10.0
/
const betweenDuration = (minimum, maximum, annotations) => self => self.pipe(filter(a => duration_.between(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,
  ...annotations
}));
/**
@category Uint8Array constructors
@since 3.10.0

## Uint8ArrayFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Uint8ArrayFromSelf(= Uint8ArrayFromSelf;
class Uint8 extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/between(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
})`

JSDoc:

@category number constructors
@since 3.11.10

## Uint8

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Uint8(= Uint8;
class Uint8Array$ extends /*#__PURE__*/transform(Array$(Uint8)`

JSDoc:

@ignore

## minItems

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `minItems(= minItems;
const MaxItemsSchemaId = exports.MaxItemsSchemaId = schemaId_.MaxItemsSchemaId;
/**
 * @category ReadonlyArray filters
 * @since 3.10.0
 */
const maxItems = (n, annotations)`

JSDoc:

Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
const Uint8ArrayFromBase64 = exports.Uint8ArrayFromBase64 = /*#__PURE__*/makeUint8ArrayTransformation("Uint8ArrayFromBase64", Encoding.decodeBase64, Encoding.encodeBase64);
/**
Decodes a base64 (URL) encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
const Uint8ArrayFromBase64Url = exports.Uint8ArrayFromBase64Url = /*#__PURE__*/makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", Encoding.decodeBase64Url, Encoding.encodeBase64Url);
/**
Decodes a hex encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
const Uint8ArrayFromHex = exports.Uint8ArrayFromHex = /*#__PURE__*/makeUint8ArrayTransformation("Uint8ArrayFromHex", Encoding.decodeHex, Encoding.encodeHex);
const makeEncodingTransformation = (id, decode, encode) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => either_.mapLeft(decode(i), decodeException => new ParseResult.Type(ast, i, decodeException.message)),
  encode: a => ParseResult.succeed(encode(a))
}).annotations({
  identifier: `StringFrom${id}`
});
/**
Decodes a base64 (RFC4648) encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
const StringFromBase64 = exports.StringFromBase64 = /*#__PURE__*/makeEncodingTransformation("Base64", Encoding.decodeBase64String, Encoding.encodeBase64);
/**
Decodes a base64 (URL) encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
const StringFromBase64Url = exports.StringFromBase64Url = /*#__PURE__*/makeEncodingTransformation("Base64Url", Encoding.decodeBase64UrlString, Encoding.encodeBase64Url);
/**
Decodes a hex encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
const StringFromHex = exports.StringFromHex = /*#__PURE__*/makeEncodingTransformation("Hex", Encoding.decodeHexString, Encoding.encodeHex);
/**
Decodes a URI component encoded string into a UTF-8 string.
Can be used to store data in a URL.

@example
```ts
import { Schema } from "effect"

const PaginationSchema = Schema.Struct({
  maxItemPerPage: Schema.Number,
  page: Schema.Number
})

const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))

console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))
// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D
```

@category string transformations
@since 3.12.0
/
const StringFromUriComponent = exports.StringFromUriComponent = /*#__PURE__*/transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => either_.mapLeft(Encoding.decodeUriComponent(i), decodeException => new ParseResult.Type(ast, i, decodeException.message)),
  encode: (a, _, ast) => either_.mapLeft(Encoding.encodeUriComponent(a), encodeException => new ParseResult.Type(ast, a, encodeException.message))
}).annotations({
  identifier: `StringFromUriComponent`
});
/**
@category schema id
@since 3.10.0
/
const MinItemsSchemaId = exports.MinItemsSchemaId = schemaId_.MinItemsSchemaId;
/**
@category ReadonlyArray filters
@since 3.10.0
/
const minItems = (n, annotations) => self => {
  const minItems = Math.floor(n);
  if (minItems < 1) {
    throw new Error(errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter(a => a.length >= minItems, {
    schemaId: MinItemsSchemaId,
    title: `minItems(${minItems})`,
    description: `an array of at least ${minItems} item(s)`,
    jsonSchema: {
      minItems
    },
    [AST.StableFilterAnnotationId]: true,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## maxItems

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `maxItems(= maxItems;
const ItemsCountSchemaId = exports.ItemsCountSchemaId = schemaId_.ItemsCountSchemaId;
/**
 * @category ReadonlyArray filters
 * @since 3.10.0
 */
const itemsCount = (n, annotations)`

JSDoc:

@category schema id
@since 3.10.0

## itemsCount

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `itemsCount(= itemsCount;
const getNumberIndexedAccess = self => make(AST.getNumberIndexedAccess(self.ast)`

JSDoc:

@category ReadonlyArray transformations
@since 3.10.0

## getNumberIndexedAccess

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `getNumberIndexedAccess(= getNumberIndexedAccess;
function head(self)`

JSDoc:

Get the first element of a `ReadonlyArray`, or `None` if the array is empty.

@category ReadonlyArray transformations
@since 3.10.0

## validDate

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `validDate(= validDate;
const LessThanDateSchemaId = exports.LessThanDateSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/LessThanDate")`

JSDoc:

Get the first element of a `NonEmptyReadonlyArray`.

@category NonEmptyReadonlyArray transformations
@since 3.12.0
/
function headNonEmpty(self) {
  return transform(self, getNumberIndexedAccess(typeSchema(self)), {
    strict: false,
    decode: i => array_.headNonEmpty(i),
    encode: a => array_.of(a)
  });
}
/**
Retrieves the first element of a `ReadonlyArray`.

If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.

@category ReadonlyArray transformations
@since 3.10.0
/
const headOrElse = exports.headOrElse = /*#__PURE__*/(0, _Function.dual)(args => isSchema(args[0]), (self, fallback) => transformOrFail(self, getNumberIndexedAccess(typeSchema(self)), {
  strict: true,
  decode: (i, _, ast) => i.length > 0 ? ParseResult.succeed(i[0]) : fallback ? ParseResult.succeed(fallback()) : ParseResult.fail(new ParseResult.Type(ast, i, "Unable to retrieve the first element of an empty array")),
  encode: a => ParseResult.succeed(array_.of(a))
}));
/**
@category schema id
@since 3.10.0
/
const ValidDateSchemaId = exports.ValidDateSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/ValidDate");
/**
Defines a filter that specifically rejects invalid dates, such as `new
Date("Invalid Date")`. This filter ensures that only properly formatted and
valid date objects are accepted, enhancing data integrity by preventing
erroneous date values from being processed.

@category Date filters
@since 3.10.0
/
const validDate = annotations => self => self.pipe(filter(a => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## lessThanDate

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanDate(= lessThanDate;
const LessThanOrEqualToDateSchemaId = exports.LessThanOrEqualToDateSchemaId = /*#__PURE__*/Symbol.for("effect/schema/LessThanOrEqualToDate")`

JSDoc:

@category Date filters
@since 3.10.0
/
const lessThanDate = (max, annotations) => self => self.pipe(filter(a => a < max, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max
  },
  title: `lessThanDate(${util_.formatDate(max)})`,
  description: `a date before ${util_.formatDate(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## lessThanOrEqualToDate

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanOrEqualToDate(= lessThanOrEqualToDate;
const GreaterThanDateSchemaId = exports.GreaterThanDateSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/GreaterThanDate")`

JSDoc:

@category Date filters
@since 3.10.0
/
const lessThanOrEqualToDate = (max, annotations) => self => self.pipe(filter(a => a <= max, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max
  },
  title: `lessThanOrEqualToDate(${util_.formatDate(max)})`,
  description: `a date before or equal to ${util_.formatDate(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## greaterThanDate

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanDate(= greaterThanDate;
const GreaterThanOrEqualToDateSchemaId = exports.GreaterThanOrEqualToDateSchemaId = /*#__PURE__*/Symbol.for("effect/schema/GreaterThanOrEqualToDate")`

JSDoc:

@category Date filters
@since 3.10.0
/
const greaterThanDate = (min, annotations) => self => self.pipe(filter(a => a > min, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min
  },
  title: `greaterThanDate(${util_.formatDate(min)})`,
  description: `a date after ${util_.formatDate(min)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## greaterThanOrEqualToDate

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanOrEqualToDate(= greaterThanOrEqualToDate;
const BetweenDateSchemaId = exports.BetweenDateSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/BetweenDate")`

JSDoc:

@category Date filters
@since 3.10.0
/
const greaterThanOrEqualToDate = (min, annotations) => self => self.pipe(filter(a => a >= min, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min
  },
  title: `greaterThanOrEqualToDate(${util_.formatDate(min)})`,
  description: `a date after or equal to ${util_.formatDate(min)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0

## betweenDate

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `betweenDate(= betweenDate;
const DateFromSelfSchemaId = exports.DateFromSelfSchemaId = schemaId_.DateFromSelfSchemaId;
/**
 * Describes a schema that accommodates potentially invalid `Date` instances,
 * such as `new Date("Invalid Date")`

JSDoc:

@category Date filters
@since 3.10.0
/
const betweenDate = (min, max, annotations) => self => self.pipe(filter(a => a <= max && a >= min, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max,
    min
  },
  title: `betweenDate(${util_.formatDate(min)}, ${util_.formatDate(max)})`,
  description: `a date between ${util_.formatDate(min)} and ${util_.formatDate(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.11.8

## DateFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DateFromSelf(= DateFromSelf;
class ValidDateFromSelf extends /*#__PURE__*/DateFromSelf.pipe(/*#__PURE__*/validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
})`

JSDoc:

Defines a schema that ensures only valid dates are accepted. This schema
rejects values like `new Date("Invalid Date")`, which, despite being a `Date`
instance, represents an invalid date. Such stringent validation ensures that
all date objects processed through this schema are properly formed and
represent real dates.

@category Date constructors
@since 3.10.0

## ValidDateFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `ValidDateFromSelf(= ValidDateFromSelf;
class DateFromString extends /*#__PURE__*/transform(String$.annotations({
  description: "a string to be decoded into a Date"
})`

JSDoc:

Defines a schema that attempts to convert a `string` to a `Date` object using
the `new Date` constructor. This conversion is lenient, meaning it does not
reject strings that do not form valid dates (e.g., using `new Date("Invalid
Date")` results in a `Date` object, despite being invalid).

@category Date transformations
@since 3.10.0

## DateFromString

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DateFromString(= DateFromString;
class Date$ extends /*#__PURE__*/DateFromString.pipe(/*#__PURE__*/validDate({
  identifier: "Date"
})`

JSDoc:

@ignore

## DateFromNumber

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DateFromNumber(= DateFromNumber;
class DateTimeUtcFromSelf extends /*#__PURE__*/declare(u => dateTime.isDateTime(u)`

JSDoc:

Defines a schema that converts a `number` into a `Date` object using the `new
Date` constructor. This schema does not validate the numerical input,
allowing potentially invalid values such as `NaN`, `Infinity`, and
`-Infinity` to be converted into `Date` objects. During the encoding process,
any invalid `Date` object will be encoded to `NaN`.

@category Date transformations
@since 3.10.0
/
class DateFromNumber extends /*#__PURE__*/transform(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: i => new Date(i),
  encode: a => a.getTime()
}).annotations({
  identifier: "DateFromNumber"
}) {}
/**
Describes a schema that represents a `DateTime.Utc` instance.

@category DateTime.Utc constructors
@since 3.10.0

## DateTimeUtcFromNumber

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DateTimeUtcFromNumber(= DateTimeUtcFromNumber;
class DateTimeUtcFromDate extends /*#__PURE__*/transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
})`

JSDoc:

Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.10.0
/
class DateTimeUtcFromNumber extends /*#__PURE__*/transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: a => ParseResult.succeed(dateTime.toEpochMillis(a))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
}) {}
/**
Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.12.0

## DateTimeUtcFromDate

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DateTimeUtcFromDate(= DateTimeUtcFromDate;
class DateTimeUtc extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
})`

JSDoc:

Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.10.0

## TimeZoneOffsetFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `TimeZoneOffsetFromSelf(= TimeZoneOffsetFromSelf;
class TimeZoneOffset extends /*#__PURE__*/transform(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
})`

JSDoc:

Describes a schema that represents a `TimeZone.Offset` instance.

@category TimeZone constructors
@since 3.10.0
/
class TimeZoneOffsetFromSelf extends /*#__PURE__*/declare(dateTime.isTimeZoneOffset, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => zone => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary
}) {}
/**
Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.

@category TimeZone transformations
@since 3.10.0

## TimeZoneNamedFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `TimeZoneNamedFromSelf(= TimeZoneNamedFromSelf;
class TimeZoneNamed extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
})`

JSDoc:

Describes a schema that represents a `TimeZone.Named` instance.

@category TimeZone constructors
@since 3.10.0
/
class TimeZoneNamedFromSelf extends /*#__PURE__*/declare(dateTime.isTimeZoneNamed, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => zone => zone.toString(),
  arbitrary: timeZoneNamedArbitrary
}) {}
/**
Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.

@category TimeZone transformations
@since 3.10.0

## TimeZoneNamed

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `TimeZoneNamed(= TimeZoneNamed;
class TimeZoneFromSelf extends /*#__PURE__*/Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)`

JSDoc:

@category TimeZone constructors
@since 3.10.0

## TimeZoneFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `TimeZoneFromSelf(= TimeZoneFromSelf;
class TimeZone extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
})`

JSDoc:

Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.

@category TimeZone transformations
@since 3.10.0

## DateTimeZonedFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DateTimeZonedFromSelf(= DateTimeZonedFromSelf;
class DateTimeZoned extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
})`

JSDoc:

Describes a schema that represents a `DateTime.Zoned` instance.

@category DateTime.Zoned constructors
@since 3.10.0
/
class DateTimeZonedFromSelf extends /*#__PURE__*/declare(u => dateTime.isDateTime(u) && dateTime.isZoned(u), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => dateTime => dateTime.toString(),
  arbitrary: () => fc => fc.tuple(fc.integer({
    // time zone db supports +/- 1000 years or so
    min: -31536000000000,
    max: 31536000000000
  }), timeZoneArbitrary(fc)).map(([millis, timeZone]) => dateTime.unsafeMakeZoned(millis, {
    timeZone
  })),
  equivalence: () => dateTime.Equivalence
}) {}
/**
Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.

@category DateTime.Zoned transformations
@since 3.10.0

## Either

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Either(= Either;
const EitherFromUnion = ({
  left,
  right
})`

JSDoc:

@category Option transformations
@since 3.10.0
/
const OptionFromSelf = value => {
  return declare([value], {
    decode: value => optionParse(ParseResult.decodeUnknown(value)),
    encode: value => optionParse(ParseResult.encodeUnknown(value))
  }, {
    description: `Option<${format(value)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: option_.getEquivalence
  });
};
exports.OptionFromSelf = OptionFromSelf;
const makeNoneEncoded = {
  _tag: "None"
};
const makeSomeEncoded = value => ({
  _tag: "Some",
  value
});
/**
@category Option transformations
@since 3.10.0
/
function Option(value) {
  const value_ = asSchema(value);
  const out = transform(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: i => optionDecode(i),
    encode: a => option_.match(a, {
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
  return out;
}
/**
@category Option transformations
@since 3.10.0
/
function OptionFromNullOr(value) {
  return transform(NullOr(value), OptionFromSelf(typeSchema(asSchema(value))), {
    strict: true,
    decode: i => option_.fromNullable(i),
    encode: a => option_.getOrNull(a)
  });
}
/**
@category Option transformations
@since 3.10.0
/
function OptionFromNullishOr(value, onNoneEncoding) {
  return transform(NullishOr(value), OptionFromSelf(typeSchema(asSchema(value))), {
    strict: true,
    decode: i => option_.fromNullable(i),
    encode: onNoneEncoding === null ? a => option_.getOrNull(a) : a => option_.getOrUndefined(a)
  });
}
/**
@category Option transformations
@since 3.10.0
/
function OptionFromUndefinedOr(value) {
  return transform(UndefinedOr(value), OptionFromSelf(typeSchema(asSchema(value))), {
    strict: true,
    decode: i => option_.fromNullable(i),
    encode: a => option_.getOrUndefined(a)
  });
}
/**
Transforms strings into an Option type, effectively filtering out empty or
whitespace-only strings by trimming them and checking their length. Returns
`none` for invalid inputs and `some` for valid non-empty strings.

@example
```ts
import { Schema } from "effect"

console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(" a ")) // Option.some("a")
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("a")) // Option.some("a")
```

@category Option transformations
@since 3.10.0
/
class OptionFromNonEmptyTrimmedString extends /*#__PURE__*/transform(String$, /*#__PURE__*/OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: i => option_.filter(option_.some(i.trim()), string_.isNonEmpty),
  encode: a => option_.getOrElse(a, () => "")
}) {}
exports.OptionFromNonEmptyTrimmedString = OptionFromNonEmptyTrimmedString;
const rightEncoded = right => Struct({
  _tag: Literal("Right"),
  right
}).annotations({
  description: `RightEncoded<${format(right)}>`
});
const leftEncoded = left => Struct({
  _tag: Literal("Left"),
  left
}).annotations({
  description: `LeftEncoded<${format(left)}>`
});
const eitherEncoded = (right, left) => Union(rightEncoded(right), leftEncoded(left)).annotations({
  description: `EitherEncoded<${format(left)}, ${format(right)}>`
});
const eitherDecode = input => input._tag === "Left" ? either_.left(input.left) : either_.right(input.right);
const eitherArbitrary = (right, left) => fc => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right(fc)
})).map(eitherDecode);
const eitherPretty = (right, left) => either_.match({
  onLeft: e => `left(${left(e)})`,
  onRight: a => `right(${right(a)})`
});
const eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => either_.isEither(u) ? either_.match(u, {
  onLeft: left => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),
  onRight: right => toComposite(parseRight(right, options), either_.right, ast, u)
}) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Either transformations
@since 3.10.0
/
const EitherFromSelf = ({
  left,
  right
}) => {
  return declare([right, left], {
    decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),
    encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))
  }, {
    description: `Either<${format(right)}, ${format(left)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right, left) => either_.getEquivalence({
      left,
      right
    })
  });
};
exports.EitherFromSelf = EitherFromSelf;
const makeLeftEncoded = left => ({
  _tag: "Left",
  left
});
const makeRightEncoded = right => ({
  _tag: "Right",
  right
});
/**
@category Either transformations
@since 3.10.0
/
const Either = ({
  left,
  right
}) => {
  const right_ = asSchema(right);
  const left_ = asSchema(left);
  const out = transform(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: i => eitherDecode(i),
    encode: a => either_.match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
/**
@example
```ts
import * as Schema from "effect/Schema"

// Schema<string | number, Either<string, number>>
Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })
```

@category Either transformations
@since 3.10.0

## ReadonlyMapFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `ReadonlyMapFromSelf(= ReadonlyMapFromSelf;
const MapFromSelf = ({
  key,
  value
})`

JSDoc:

@category ReadonlyMap
@since 3.10.0
/
const ReadonlyMapFromSelf = ({
  key,
  value
}) => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`);
/**
@category Map
@since 3.10.0

## MapFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `MapFromSelf(= MapFromSelf;
function ReadonlyMap({
  key,
  value
})`

JSDoc:

@category ReadonlyMap transformations
@since 3.10.0

## ReadonlyMapFromRecord

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `ReadonlyMapFromRecord(= ReadonlyMapFromRecord;
const MapFromRecord = ({
  key,
  value
})`

JSDoc:

@ignore */
function map({
  key,
  value
}) {
  return transform(Array$(Tuple(key, value)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value))
  }), {
    strict: true,
    decode: i => new Map(i),
    encode: a => Array.from(a.entries())
  });
}
/**
@category ReadonlyMap transformations
@since 3.10.0
/
const ReadonlyMapFromRecord = ({
  key,
  value
}) => transform(Record({
  key: encodedBoundSchema(key),
  value
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value)
}), {
  strict: true,
  decode: i => new Map(Object.entries(i)),
  encode: a => Object.fromEntries(a)
});
/**
@category Map transformations
@since 3.10.0

## ReadonlySetFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `ReadonlySetFromSelf(= ReadonlySetFromSelf;
const SetFromSelf = value => setFromSelf_(value, `Set<${format(value)`

JSDoc:

@category ReadonlySet
@since 3.10.0
/
const ReadonlySetFromSelf = value => setFromSelf_(value, `ReadonlySet<${format(value)}>`);
/**
@category Set
@since 3.10.0

## SetFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `SetFromSelf(= SetFromSelf;
function ReadonlySet(value)`

JSDoc:

@category ReadonlySet transformations
@since 3.10.0

## BigDecimalFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `BigDecimalFromSelf(= BigDecimalFromSelf;
class BigDecimal extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
})`

JSDoc:

@ignore */
function set(value) {
  return transform(Array$(value), SetFromSelf(typeSchema(asSchema(value))), {
    strict: true,
    decode: i => new Set(i),
    encode: a => Array.from(a)
  });
}
const bigDecimalPretty = () => val => `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`;
const bigDecimalArbitrary = () => fc => fc.tuple(fc.bigInt(), fc.integer({
  min: 0,
  max: 18
})).map(([value, scale]) => bigDecimal_.make(value, scale));
/**
@category BigDecimal constructors
@since 3.10.0
/
class BigDecimalFromSelf extends /*#__PURE__*/declare(bigDecimal_.isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => bigDecimal_.Equivalence
}) {}
/**
@category BigDecimal transformations
@since 3.10.0

## BigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `BigDecimal(= BigDecimal;
class BigDecimalFromNumber extends /*#__PURE__*/transform(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
})`

JSDoc:

A schema that transforms a `number` into a `BigDecimal`.
When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.

@category BigDecimal transformations
@since 3.10.0

## BigDecimalFromNumber

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `BigDecimalFromNumber(= BigDecimalFromNumber;
const GreaterThanBigDecimalSchemaId = exports.GreaterThanBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/GreaterThanBigDecimal")`

JSDoc:

@category schema id
@since 3.10.0

## greaterThanBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanBigDecimal(= greaterThanBigDecimal;
const GreaterThanOrEqualToBigDecimalSchemaId = exports.GreaterThanOrEqualToBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal")`

JSDoc:

@category BigDecimal filters
@since 3.10.0
/
const greaterThanBigDecimal = (min, annotations) => self => {
  const formatted = bigDecimal_.format(min);
  return self.pipe(filter(a => bigDecimal_.greaterThan(a, min), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## greaterThanOrEqualToBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `greaterThanOrEqualToBigDecimal(= greaterThanOrEqualToBigDecimal;
const LessThanBigDecimalSchemaId = exports.LessThanBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/LessThanBigDecimal")`

JSDoc:

@category BigDecimal filters
@since 3.10.0
/
const greaterThanOrEqualToBigDecimal = (min, annotations) => self => {
  const formatted = bigDecimal_.format(min);
  return self.pipe(filter(a => bigDecimal_.greaterThanOrEqualTo(a, min), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## lessThanBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanBigDecimal(= lessThanBigDecimal;
const LessThanOrEqualToBigDecimalSchemaId = exports.LessThanOrEqualToBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/LessThanOrEqualToBigDecimal")`

JSDoc:

@category BigDecimal filters
@since 3.10.0
/
const lessThanBigDecimal = (max, annotations) => self => {
  const formatted = bigDecimal_.format(max);
  return self.pipe(filter(a => bigDecimal_.lessThan(a, max), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## lessThanOrEqualToBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `lessThanOrEqualToBigDecimal(= lessThanOrEqualToBigDecimal;
const PositiveBigDecimalSchemaId = exports.PositiveBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/PositiveBigDecimal")`

JSDoc:

@category BigDecimal filters
@since 3.10.0
/
const lessThanOrEqualToBigDecimal = (max, annotations) => self => {
  const formatted = bigDecimal_.format(max);
  return self.pipe(filter(a => bigDecimal_.lessThanOrEqualTo(a, max), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0

## positiveBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `positiveBigDecimal(= positiveBigDecimal;
const PositiveBigDecimalFromSelf = exports.PositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe(/*#__PURE__*/positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
})`

JSDoc:

@category BigDecimal filters
@since 3.10.0
/
const positiveBigDecimal = annotations => self => self.pipe(filter(a => bigDecimal_.isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations
}));
/**
@category BigDecimal constructors
@since 3.10.0

## nonNegativeBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `nonNegativeBigDecimal(= nonNegativeBigDecimal;
const NonNegativeBigDecimalFromSelf = exports.NonNegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe(/*#__PURE__*/nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
})`

JSDoc:

@category schema id
@since 3.10.0
/
const NonNegativeBigDecimalSchemaId = exports.NonNegativeBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/NonNegativeBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
const nonNegativeBigDecimal = annotations => self => self.pipe(filter(a => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations
}));
/**
@category BigDecimal constructors
@since 3.10.0

## negativeBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `negativeBigDecimal(= negativeBigDecimal;
const NegativeBigDecimalFromSelf = exports.NegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe(/*#__PURE__*/negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
})`

JSDoc:

@category schema id
@since 3.10.0
/
const NegativeBigDecimalSchemaId = exports.NegativeBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/NegativeBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
const negativeBigDecimal = annotations => self => self.pipe(filter(a => bigDecimal_.isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations
}));
/**
@category BigDecimal constructors
@since 3.10.0

## nonPositiveBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `nonPositiveBigDecimal(= nonPositiveBigDecimal;
const NonPositiveBigDecimalFromSelf = exports.NonPositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe(/*#__PURE__*/nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
})`

JSDoc:

@category schema id
@since 3.10.0
/
const NonPositiveBigDecimalSchemaId = exports.NonPositiveBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/NonPositiveBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
const nonPositiveBigDecimal = annotations => self => self.pipe(filter(a => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations
}));
/**
@category BigDecimal constructors
@since 3.10.0

## betweenBigDecimal

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `betweenBigDecimal(= betweenBigDecimal;
const clampBigDecimal = (minimum, maximum)`

JSDoc:

@category schema id
@since 3.10.0
/
const BetweenBigDecimalSchemaId = exports.BetweenBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/BetweenBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
const betweenBigDecimal = (minimum, maximum, annotations) => self => {
  const formattedMinimum = bigDecimal_.format(minimum);
  const formattedMaximum = bigDecimal_.format(maximum);
  return self.pipe(filter(a => bigDecimal_.between(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations
  }));
};
/**
Clamps a `BigDecimal` between a minimum and a maximum value.

@category BigDecimal transformations
@since 3.10.0

## ChunkFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `ChunkFromSelf(= ChunkFromSelf;
function Chunk(value)`

JSDoc:

@category Chunk
@since 3.10.0
/
const ChunkFromSelf = value => {
  return declare([value], {
    decode: item => chunkParse(ParseResult.decodeUnknown(Array$(item))),
    encode: item => chunkParse(ParseResult.encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format(value)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: chunk_.getEquivalence
  });
};
/**
@category Chunk transformations
@since 3.10.0

## NonEmptyChunkFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `NonEmptyChunkFromSelf(= NonEmptyChunkFromSelf;
function NonEmptyChunk(value)`

JSDoc:

@category Chunk
@since 3.10.0
/
const NonEmptyChunkFromSelf = value => {
  return declare([value], {
    decode: item => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),
    encode: item => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format(value)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: chunk_.getEquivalence
  });
};
/**
@category Chunk transformations
@since 3.10.0

## DataFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `DataFromSelf(= DataFromSelf;
const Data = value => {
  return transform(value, DataFromSelf(typeSchema(value)`

JSDoc:

Type and Encoded must extend `Readonly<Record<string, any>> |
ReadonlyArray<any>` to be compatible with this API.

@category Data transformations
@since 3.10.0
/
const DataFromSelf = value => {
  return declare([value], {
    decode: item => dataParse(ParseResult.decodeUnknown(item)),
    encode: item => dataParse(ParseResult.encodeUnknown(item))
  }, {
    description: `Data<${format(value)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
/**
Type and Encoded must extend `Readonly<Record<string, any>> |
ReadonlyArray<any>` to be compatible with this API.

@category Data transformations
@since 3.10.0

## Class

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Class(= Class;
const getClassTag = tag => withConstructorDefault(propertySignature(Literal(tag)`

JSDoc:

@example
```ts
import { Schema } from "effect"

class MyClass extends Schema.Class<MyClass>("MyClass")({
 someField: Schema.String
}) {
 someMethod() {
   return this.someField + "bar"
 }
}
```

@category classes
@since 3.10.0
/
const Class = identifier => (fieldsOr, annotations) => makeClass({
  kind: "Class",
  identifier,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: data_.Class,
  annotations
});
/** @internal

## getClassTag

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `getClassTag(= getClassTag;
const TaggedClass = identifier => (tag, fieldsOr, annotations)`

JSDoc:

@example
```ts
import { Schema } from "effect"

class MyClass extends Schema.TaggedClass<MyClass>("MyClass")("MyClass", {
 a: Schema.String
}) {}
```

@category classes
@since 3.10.0

## TaggedClass

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `TaggedClass(= TaggedClass;
const TaggedError = identifier => (tag, fieldsOr, annotations)`

JSDoc:

@example
```ts
import { Schema } from "effect"

class MyError extends Schema.TaggedError<MyError>("MyError")(
  "MyError",
  {
    module: Schema.String,
    method: Schema.String,
    description: Schema.String
  }
) {
  get message(): string {
    return `${this.module}.${this.method}: ${this.description}`
  }
}
```
@category classes
@since 3.10.0

## Cause

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Cause(= Cause;
class Defect extends /*#__PURE__*/transform(Unknown, Unknown, {
  strict: true,
  decode: i => {
    if (Predicate.isObject(i)`

JSDoc:

@category FiberId constructors
@since 3.10.0
/
class FiberIdFromSelf extends /*#__PURE__*/declare(fiberId_.isFiberId, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
}) {}
exports.FiberIdFromSelf = FiberIdFromSelf;
const fiberIdDecode = input => {
  switch (input._tag) {
    case "None":
      return fiberId_.none;
    case "Runtime":
      return fiberId_.runtime(input.id, input.startTimeMillis);
    case "Composite":
      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
const fiberIdEncode = input => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
/**
@category FiberId transformations
@since 3.10.0
/
class FiberId extends /*#__PURE__*/transform(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: i => fiberIdDecode(i),
  encode: a => fiberIdEncode(a)
}).annotations({
  identifier: "FiberId"
}) {}
exports.FiberId = FiberId;
const causeDieEncoded = defect => Struct({
  _tag: Literal("Die"),
  defect
});
const CauseEmptyEncoded = /*#__PURE__*/Struct({
  _tag: /*#__PURE__*/Literal("Empty")
});
const causeFailEncoded = error => Struct({
  _tag: Literal("Fail"),
  error
});
const CauseInterruptEncoded = /*#__PURE__*/Struct({
  _tag: /*#__PURE__*/Literal("Interrupt"),
  fiberId: FiberIdEncoded
});
let causeEncodedId = 0;
const causeEncoded = (error, defect) => {
  const error_ = asSchema(error);
  const defect_ = asSchema(defect);
  const suspended = suspend(() => out);
  const out = Union(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal("Sequential"),
    left: suspended,
    right: suspended
  }), Struct({
    _tag: Literal("Parallel"),
    left: suspended,
    right: suspended
  })).annotations({
    title: `CauseEncoded<${format(error)}>`,
    [AST.JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
};
const causeArbitrary = (error, defect) => fc => fc.letrec(tie => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
const causePretty = error => cause => {
  const f = cause => {
    switch (cause._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error(cause.error)})`;
      case "Die":
        return `Cause.die(${cause_.pretty(cause)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`;
    }
  };
  return f(cause);
};
const causeParse = decodeUnknown => (u, options, ast) => cause_.isCause(u) ? toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Cause transformations
@since 3.10.0
/
const CauseFromSelf = ({
  defect,
  error
}) => {
  return declare([error, defect], {
    decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),
    encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))
  }, {
    title: `Cause<${error.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
exports.CauseFromSelf = CauseFromSelf;
function causeDecode(cause) {
  switch (cause._tag) {
    case "Empty":
      return cause_.empty;
    case "Fail":
      return cause_.fail(cause.error);
    case "Die":
      return cause_.die(cause.defect);
    case "Interrupt":
      return cause_.interrupt(fiberIdDecode(cause.fiberId));
    case "Sequential":
      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right));
    case "Parallel":
      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right));
  }
}
function causeEncode(cause) {
  switch (cause._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
  }
}
/**
@category Cause transformations
@since 3.10.0
/
const Cause = ({
  defect,
  error
}) => {
  const error_ = asSchema(error);
  const defect_ = asSchema(defect);
  const out = transform(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: i => causeDecode(i),
    encode: a => causeEncode(a)
  });
  return out;
};
/**
Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.
It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),
or converts other values to their string representations.

When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,
or other values into their string forms.

This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.

@category defect
@since 3.10.0

## ExitFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `ExitFromSelf(= ExitFromSelf;
const Exit = ({
  defect,
  failure,
  success
})`

JSDoc:

@category Exit transformations
@since 3.10.0
/
const ExitFromSelf = ({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success, failure, defect) => exitParse(ParseResult.decodeUnknown(success), ParseResult.decodeUnknown(CauseFromSelf({
    error: failure,
    defect
  }))),
  encode: (success, failure, defect) => exitParse(ParseResult.encodeUnknown(success), ParseResult.encodeUnknown(CauseFromSelf({
    error: failure,
    defect
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
/**
@category Exit transformations
@since 3.10.0

## HashSetFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `HashSetFromSelf(= HashSetFromSelf;
function HashSet(value)`

JSDoc:

@category HashSet transformations
@since 3.10.0
/
const HashSetFromSelf = value => {
  return declare([value], {
    decode: item => hashSetParse(ParseResult.decodeUnknown(Array$(item))),
    encode: item => hashSetParse(ParseResult.encodeUnknown(Array$(item)))
  }, {
    description: `HashSet<${format(value)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
/**
@category HashSet transformations
@since 3.10.0

## HashMapFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `HashMapFromSelf(= HashMapFromSelf;
const HashMap = ({
  key,
  value
})`

JSDoc:

@category HashMap transformations
@since 3.10.0
/
const HashMapFromSelf = ({
  key,
  value
}) => {
  return declare([key, value], {
    decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),
    encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))
  }, {
    description: `HashMap<${format(key)}, ${format(value)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
/**
@category HashMap transformations
@since 3.10.0

## ListFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `ListFromSelf(= ListFromSelf;
function List(value)`

JSDoc:

@category List transformations
@since 3.10.0
/
const ListFromSelf = value => {
  return declare([value], {
    decode: item => listParse(ParseResult.decodeUnknown(Array$(item))),
    encode: item => listParse(ParseResult.encodeUnknown(Array$(item)))
  }, {
    description: `List<${format(value)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
/**
@category List transformations
@since 3.10.0

## SortedSetFromSelf

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `SortedSetFromSelf(= SortedSetFromSelf;
function SortedSet(value, ordA)`

JSDoc:

@category SortedSet transformations
@since 3.10.0
/
const SortedSetFromSelf = (value, ordA, ordI) => {
  return declare([value], {
    decode: item => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),
    encode: item => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format(value)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
    equivalence: () => sortedSet_.getEquivalence()
  });
};
/**
@category SortedSet transformations
@since 3.10.0

## BooleanFromUnknown

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `BooleanFromUnknown(= BooleanFromUnknown;
class BooleanFromString extends /*#__PURE__*/transform(Literal("true", "false")`

JSDoc:

Converts an arbitrary value to a `boolean` by testing whether it is truthy.
Uses `!!val` to coerce the value to a `boolean`.

@see https://developer.mozilla.org/docs/Glossary/Truthy

@category boolean constructors
@since 3.10.0
/
class BooleanFromUnknown extends /*#__PURE__*/transform(Unknown, Boolean$, {
  strict: true,
  decode: i => Predicate.isTruthy(i),
  encode: _Function.identity
}).annotations({
  identifier: "BooleanFromUnknown"
}) {}
/**
Converts an `string` value into its corresponding `boolean`
("true" as `true` and "false" as `false`).

@category boolean transformations
@since 3.11.0

## BooleanFromString

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `BooleanFromString(= BooleanFromString;
const Config = (name, schema)`

JSDoc:

@category Config validations
@since 3.10.0

## Config

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `Config(= Config;
const symbolSerializable = exports.symbolSerializable = /*#__PURE__*/Symbol.for("effect/Schema/Serializable/symbol")`

JSDoc:

@since 3.10.0
@category symbol

## asSerializable

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `asSerializable(= asSerializable;
const serializableSchema = self => self[symbolSerializable];
/**
 * @since 3.10.0
 * @category encoding
 */
exports.serializableSchema = serializableSchema;
const serialize = self => encodeUnknown(self[symbolSerializable])`

JSDoc:

@since 3.10.0
/
const asSerializable = serializable => serializable;
/**
@since 3.10.0
@category accessor

## serialize

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `serialize(= serialize;
const deserialize = exports.deserialize = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 3.10.0
@category decoding

## asWithResult

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `asWithResult(= asWithResult;
const failureSchema = self => self[symbolWithResult].failure;
/**
 * @since 3.10.0
 * @category accessor
 */
exports.failureSchema = failureSchema;
const successSchema = self => self[symbolWithResult].success;
exports.successSchema = successSchema;
const exitSchemaCache = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@since 3.10.0
@category symbol
/
const symbolWithResult = exports.symbolWithResult = /*#__PURE__*/Symbol.for("effect/Schema/Serializable/symbolResult");
/**
@since 3.10.0
/
const asWithResult = withExit => withExit;
/**
@since 3.10.0
@category accessor

## exitSchema

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `exitSchema(= exitSchema;
const serializeFailure = exports.serializeFailure = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 3.10.0
@category accessor
/
const exitSchema = self => {
  const proto = Object.getPrototypeOf(self);
  if (!(symbolWithResult in proto)) {
    return Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
  }
  let schema = exitSchemaCache.get(proto);
  if (schema === undefined) {
    schema = Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
    exitSchemaCache.set(proto, schema);
  }
  return schema;
};
/**
@since 3.10.0
@category encoding

## asSerializableWithResult

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `asSerializableWithResult(= asSerializableWithResult;
const TaggedRequest = identifier => (tag, options, annotations)`

JSDoc:

@since 3.10.0
@category decoding
/
const deserializeFailure = exports.deserializeFailure = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => decodeUnknown(self[symbolWithResult].failure)(value));
/**
@since 3.10.0
@category encoding
/
const serializeSuccess = exports.serializeSuccess = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => encode(self[symbolWithResult].success)(value));
/**
@since 3.10.0
@category decoding
/
const deserializeSuccess = exports.deserializeSuccess = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => decodeUnknown(self[symbolWithResult].success)(value));
/**
@since 3.10.0
@category encoding
/
const serializeExit = exports.serializeExit = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => encode(exitSchema(self))(value));
/**
@since 3.10.0
@category decoding
/
const deserializeExit = exports.deserializeExit = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => decodeUnknown(exitSchema(self))(value));
/**
@since 3.10.0
/
const asSerializableWithResult = procedure => procedure;
/**
@example
```ts
import { Schema } from "effect"

class MyRequest extends Schema.TaggedRequest<MyRequest>("MyRequest")("MyRequest", {
 failure: Schema.String,
 success: Schema.Number,
 payload: { id: Schema.String }
}) {}
```

@category classes
@since 3.10.0

## TaggedRequest

Source: `my-backend/node_modules/effect/dist/cjs/Schema.js`

Signature: `TaggedRequest(= TaggedRequest;
const equivalence = schema => go(schema.ast, [])`

JSDoc:

Given a schema `Schema<A, I, R>`, returns an `Equivalence` instance for `A`.

@category Equivalence
@since 3.10.0

## hasStableFilter

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `hasStableFilter(= hasStableFilter;
const JSONIdentifierAnnotationId = exports.JSONIdentifierAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/JSONIdentifier")`

JSDoc:

@since 3.10.0
/

/**
@category annotations
@since 3.10.0
/
const BrandAnnotationId = exports.BrandAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Brand");
/**
@category annotations
@since 3.10.0
/
const SchemaIdAnnotationId = exports.SchemaIdAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/SchemaId");
/**
@category annotations
@since 3.10.0
/
const MessageAnnotationId = exports.MessageAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Message");
/**
@category annotations
@since 3.10.0
/
const MissingMessageAnnotationId = exports.MissingMessageAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/MissingMessage");
/**
@category annotations
@since 3.10.0
/
const IdentifierAnnotationId = exports.IdentifierAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Identifier");
/**
@category annotations
@since 3.10.0
/
const TitleAnnotationId = exports.TitleAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Title");
/** @internal */
const AutoTitleAnnotationId = exports.AutoTitleAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/AutoTitle");
/**
@category annotations
@since 3.10.0
/
const DescriptionAnnotationId = exports.DescriptionAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Description");
/**
@category annotations
@since 3.10.0
/
const ExamplesAnnotationId = exports.ExamplesAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Examples");
/**
@category annotations
@since 3.10.0
/
const DefaultAnnotationId = exports.DefaultAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Default");
/**
@category annotations
@since 3.10.0
/
const JSONSchemaAnnotationId = exports.JSONSchemaAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/JSONSchema");
/**
@category annotations
@since 3.10.0
/
const ArbitraryAnnotationId = exports.ArbitraryAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Arbitrary");
/**
@category annotations
@since 3.10.0
/
const PrettyAnnotationId = exports.PrettyAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Pretty");
/**
@category annotations
@since 3.10.0
/
const EquivalenceAnnotationId = exports.EquivalenceAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Equivalence");
/**
@category annotations
@since 3.10.0
/
const DocumentationAnnotationId = exports.DocumentationAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Documentation");
/**
@category annotations
@since 3.10.0
/
const ConcurrencyAnnotationId = exports.ConcurrencyAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Concurrency");
/**
@category annotations
@since 3.10.0
/
const BatchingAnnotationId = exports.BatchingAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Batching");
/**
@category annotations
@since 3.10.0
/
const ParseIssueTitleAnnotationId = exports.ParseIssueTitleAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/ParseIssueTitle");
/**
@category annotations
@since 3.10.0
/
const ParseOptionsAnnotationId = exports.ParseOptionsAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/ParseOptions");
/**
@category annotations
@since 3.10.0
/
const DecodingFallbackAnnotationId = exports.DecodingFallbackAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/DecodingFallback");
/**
@category annotations
@since 3.10.0
/
const SurrogateAnnotationId = exports.SurrogateAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/Surrogate");
/** @internal */
const StableFilterAnnotationId = exports.StableFilterAnnotationId = /*#__PURE__*/Symbol.for("effect/annotation/StableFilter");
/**
@category annotations
@since 3.10.0
/
const getAnnotation = exports.getAnnotation = /*#__PURE__*/(0, _Function.dual)(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? Option.some(annotated.annotations[key]) : Option.none());
/**
@category annotations
@since 3.10.0
/
const getBrandAnnotation = exports.getBrandAnnotation = /*#__PURE__*/getAnnotation(BrandAnnotationId);
/**
@category annotations
@since 3.14.2
/
const getSchemaIdAnnotation = exports.getSchemaIdAnnotation = /*#__PURE__*/getAnnotation(SchemaIdAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getMessageAnnotation = exports.getMessageAnnotation = /*#__PURE__*/getAnnotation(MessageAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getMissingMessageAnnotation = exports.getMissingMessageAnnotation = /*#__PURE__*/getAnnotation(MissingMessageAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getTitleAnnotation = exports.getTitleAnnotation = /*#__PURE__*/getAnnotation(TitleAnnotationId);
/** @internal */
const getAutoTitleAnnotation = exports.getAutoTitleAnnotation = /*#__PURE__*/getAnnotation(AutoTitleAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getIdentifierAnnotation = exports.getIdentifierAnnotation = /*#__PURE__*/getAnnotation(IdentifierAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getDescriptionAnnotation = exports.getDescriptionAnnotation = /*#__PURE__*/getAnnotation(DescriptionAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getExamplesAnnotation = exports.getExamplesAnnotation = /*#__PURE__*/getAnnotation(ExamplesAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getDefaultAnnotation = exports.getDefaultAnnotation = /*#__PURE__*/getAnnotation(DefaultAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getJSONSchemaAnnotation = exports.getJSONSchemaAnnotation = /*#__PURE__*/getAnnotation(JSONSchemaAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getDocumentationAnnotation = exports.getDocumentationAnnotation = /*#__PURE__*/getAnnotation(DocumentationAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getConcurrencyAnnotation = exports.getConcurrencyAnnotation = /*#__PURE__*/getAnnotation(ConcurrencyAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getBatchingAnnotation = exports.getBatchingAnnotation = /*#__PURE__*/getAnnotation(BatchingAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getParseIssueTitleAnnotation = exports.getParseIssueTitleAnnotation = /*#__PURE__*/getAnnotation(ParseIssueTitleAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getParseOptionsAnnotation = exports.getParseOptionsAnnotation = /*#__PURE__*/getAnnotation(ParseOptionsAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getDecodingFallbackAnnotation = exports.getDecodingFallbackAnnotation = /*#__PURE__*/getAnnotation(DecodingFallbackAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getSurrogateAnnotation = exports.getSurrogateAnnotation = /*#__PURE__*/getAnnotation(SurrogateAnnotationId);
const getStableFilterAnnotation = /*#__PURE__*/getAnnotation(StableFilterAnnotationId);
/** @internal */
const hasStableFilter = annotated => Option.exists(getStableFilterAnnotation(annotated), b => b === true);
/**
@category annotations
@since 3.10.0

## getJSONIdentifier

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `getJSONIdentifier(= getJSONIdentifier;
const ParseJsonSchemaId = exports.ParseJsonSchemaId = /*#__PURE__*/Symbol.for("effect/schema/ParseJson")`

JSDoc:

@category annotations
@since 3.10.0
/
const getJSONIdentifierAnnotation = exports.getJSONIdentifierAnnotation = /*#__PURE__*/getAnnotation(JSONIdentifierAnnotationId);
/**
@category annotations
@since 3.10.0
/
const getJSONIdentifier = annotated => Option.orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
// -------------------------------------------------------------------------------------
// schema ids
// -------------------------------------------------------------------------------------
/**
@category schema id
@since 3.10.0

## Literal

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `Literal(= Literal;
const isLiteral = exports.isLiteral = /*#__PURE__*/createASTGuard("Literal")`

JSDoc:

@category model
@since 3.10.0
/
class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
@since 3.10.0
/
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => "<declaration schema>");
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map(ast => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
exports.Declaration = Declaration;
const createASTGuard = tag => ast => ast._tag === tag;
/**
@category guards
@since 3.10.0
/
const isDeclaration = exports.isDeclaration = /*#__PURE__*/createASTGuard("Declaration");
/**
@category model
@since 3.10.0
/
class Literal {
  literal;
  annotations;
  /**
@since 3.10.0
/
  _tag = "Literal";
  constructor(literal, annotations = {}) {
    this.literal = literal;
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => util_.formatUnknown(this.literal));
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      literal: Predicate.isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category guards
@since 3.10.0

## UniqueSymbol

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `UniqueSymbol(= UniqueSymbol;
const isUniqueSymbol = exports.isUniqueSymbol = /*#__PURE__*/createASTGuard("UniqueSymbol")`

JSDoc:

@category model
@since 3.10.0
/
class UniqueSymbol {
  symbol;
  annotations;
  /**
@since 3.10.0
/
  _tag = "UniqueSymbol";
  constructor(symbol, annotations = {}) {
    this.symbol = symbol;
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => util_.formatUnknown(this.symbol));
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category guards
@since 3.10.0

## UndefinedKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `UndefinedKeyword(= UndefinedKeyword;
const undefinedKeyword = exports.undefinedKeyword = /*#__PURE__*/new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
})`

JSDoc:

@category model
@since 3.10.0
/
class UndefinedKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## VoidKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `VoidKeyword(= VoidKeyword;
const voidKeyword = exports.voidKeyword = /*#__PURE__*/new VoidKeyword({
  [TitleAnnotationId]: "void"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isUndefinedKeyword = exports.isUndefinedKeyword = /*#__PURE__*/createASTGuard("UndefinedKeyword");
/**
@category model
@since 3.10.0
/
class VoidKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## NeverKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `NeverKeyword(= NeverKeyword;
const neverKeyword = exports.neverKeyword = /*#__PURE__*/new NeverKeyword({
  [TitleAnnotationId]: "never"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isVoidKeyword = exports.isVoidKeyword = /*#__PURE__*/createASTGuard("VoidKeyword");
/**
@category model
@since 3.10.0
/
class NeverKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## UnknownKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `UnknownKeyword(= UnknownKeyword;
const unknownKeyword = exports.unknownKeyword = /*#__PURE__*/new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isNeverKeyword = exports.isNeverKeyword = /*#__PURE__*/createASTGuard("NeverKeyword");
/**
@category model
@since 3.10.0
/
class UnknownKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## AnyKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `AnyKeyword(= AnyKeyword;
const anyKeyword = exports.anyKeyword = /*#__PURE__*/new AnyKeyword({
  [TitleAnnotationId]: "any"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isUnknownKeyword = exports.isUnknownKeyword = /*#__PURE__*/createASTGuard("UnknownKeyword");
/**
@category model
@since 3.10.0
/
class AnyKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## StringKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `StringKeyword(= StringKeyword;
const stringKeyword = exports.stringKeyword = /*#__PURE__*/new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isAnyKeyword = exports.isAnyKeyword = /*#__PURE__*/createASTGuard("AnyKeyword");
/**
@category model
@since 3.10.0
/
class StringKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## NumberKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `NumberKeyword(= NumberKeyword;
const numberKeyword = exports.numberKeyword = /*#__PURE__*/new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isStringKeyword = exports.isStringKeyword = /*#__PURE__*/createASTGuard("StringKeyword");
/**
@category model
@since 3.10.0
/
class NumberKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## BooleanKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `BooleanKeyword(= BooleanKeyword;
const booleanKeyword = exports.booleanKeyword = /*#__PURE__*/new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isNumberKeyword = exports.isNumberKeyword = /*#__PURE__*/createASTGuard("NumberKeyword");
/**
@category model
@since 3.10.0
/
class BooleanKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## BigIntKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `BigIntKeyword(= BigIntKeyword;
const bigIntKeyword = exports.bigIntKeyword = /*#__PURE__*/new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isBooleanKeyword = exports.isBooleanKeyword = /*#__PURE__*/createASTGuard("BooleanKeyword");
/**
@category model
@since 3.10.0
/
class BigIntKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## SymbolKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `SymbolKeyword(= SymbolKeyword;
const symbolKeyword = exports.symbolKeyword = /*#__PURE__*/new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isBigIntKeyword = exports.isBigIntKeyword = /*#__PURE__*/createASTGuard("BigIntKeyword");
/**
@category model
@since 3.10.0
/
class SymbolKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## ObjectKeyword

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `ObjectKeyword(= ObjectKeyword;
const objectKeyword = exports.objectKeyword = /*#__PURE__*/new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
})`

JSDoc:

@category guards
@since 3.10.0
/
const isSymbolKeyword = exports.isSymbolKeyword = /*#__PURE__*/createASTGuard("SymbolKeyword");
/**
@category model
@since 3.10.0
/
class ObjectKeyword {
  annotations;
  /**
@since 3.10.0
/
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return formatKeyword(this);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category constructors
@since 3.10.0

## Enums

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `Enums(= Enums;
const isEnums = exports.isEnums = /*#__PURE__*/createASTGuard("Enums")`

JSDoc:

@category guards
@since 3.10.0
/
const isObjectKeyword = exports.isObjectKeyword = /*#__PURE__*/createASTGuard("ObjectKeyword");
/**
@category model
@since 3.10.0
/
class Enums {
  enums;
  annotations;
  /**
@since 3.10.0
/
  _tag = "Enums";
  constructor(enums, annotations = {}) {
    this.enums = enums;
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_, value]) => JSON.stringify(value)).join(" | ")}>`);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category guards
@since 3.10.0

## TemplateLiteralSpan

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `TemplateLiteralSpan(= TemplateLiteralSpan;
class TemplateLiteral {
  head;
  spans;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TemplateLiteral";
  constructor(head, spans, annotations = {})`

JSDoc:

@category model
@since 3.10.0
/
class TemplateLiteralSpan {
  literal;
  /**
@since 3.10.0
/
  type;
  constructor(type, literal) {
    this.literal = literal;
    if (isTemplateLiteralSpanType(type)) {
      this.type = type;
    } else {
      throw new Error(errors_.getSchemaUnsupportedLiteralSpanErrorMessage(type));
    }
  }
  /**
@since 3.10.0
/
  toString() {
    return templateLiteralSpanTypeToString(this.type) + this.literal;
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
}
/**
@category model
@since 3.10.0

## Type

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `Type(= Type;
class OptionalType extends Type {
  isOptional;
  constructor(type, isOptional, annotations = {})`

JSDoc:

@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => formatTemplateLiteral(this));
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map(span => span.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
exports.TemplateLiteral = TemplateLiteral;
const formatTemplateLiteral = ast => "`" + ast.head + ast.spans.map(String).join("") + "`";
/**
@category guards
@since 3.10.0
/
const isTemplateLiteral = exports.isTemplateLiteral = /*#__PURE__*/createASTGuard("TemplateLiteral");
/**
@category model
@since 3.10.0
/
class Type {
  type;
  annotations;
  constructor(type, annotations = {}) {
    this.type = type;
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
@since 3.10.0
/
  toString() {
    return String(this.type);
  }
}
/**
@category model
@since 3.10.0

## PropertySignature

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `PropertySignature(= PropertySignature;
const isParameter = ast => {
  switch (ast._tag)`

JSDoc:

@since 3.10.0
/
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
@since 3.10.0
/
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
exports.OptionalType = OptionalType;
const getRestASTs = rest => rest.map(annotatedAST => annotatedAST.type);
/**
@category model
@since 3.10.0
/
class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  /**
@since 3.10.0
/
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(errors_.getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => formatTuple(this));
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map(e => e.toJSON()),
      rest: this.rest.map(ast => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
exports.TupleType = TupleType;
const formatTuple = ast => {
  const formattedElements = ast.elements.map(String).join(", ");
  return Arr.matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head, tail) => {
      const formattedHead = String(head);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
/**
@category guards
@since 3.10.0
/
const isTupleType = exports.isTupleType = /*#__PURE__*/createASTGuard("TupleType");
/**
@category model
@since 3.10.0
/
class PropertySignature extends OptionalType {
  name;
  isReadonly;
  constructor(name, type, isOptional, isReadonly, annotations) {
    super(type, isOptional, annotations);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
@since 3.10.0
/
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@since 3.10.0

## isParameter

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `isParameter(= isParameter;
class IndexSignature {
  type;
  isReadonly;
  /**
   * @since 3.10.0
   */
  parameter;
  constructor(parameter, type, isReadonly)`

JSDoc:

@category model
@since 3.10.0

## IndexSignature

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `IndexSignature(= IndexSignature;
class TypeLiteral {
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 3.10.0
   */
  propertySignatures;
  /**
   * @since 3.10.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {})`

JSDoc:

@since 3.10.0
/
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}
/**
@category model
@since 3.10.0

## flatten

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `flatten(= flatten;
const unify = candidates => {
  const cs = sortCandidates(candidates)`

JSDoc:

@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map(ps => ps.toJSON()),
      indexSignatures: this.indexSignatures.map(ps => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
exports.TypeLiteral = TypeLiteral;
const formatIndexSignatures = iss => iss.map(String).join("; ");
const formatTypeLiteral = ast => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
/**
@category guards
@since 3.10.0
/
const isTypeLiteral = exports.isTypeLiteral = /*#__PURE__*/createASTGuard("TypeLiteral");
const sortCandidates = /*#__PURE__*/Arr.sort(/*#__PURE__*/Order.mapInput(Number.Order, ast => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
const literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
/** @internal */
const flatten = candidates => Arr.flatMap(candidates, ast => isUnion(ast) ? flatten(ast.types) : [ast]);
/** @internal

## unify

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `unify(= unify;
class Union {
  types;
  annotations;
  static make = (types, annotations)`

JSDoc:

@category model
@since 3.10.0

## Union

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `Union(= Union;
const mapMembers = (members, f)`

JSDoc:

@internal */
  static unify = (candidates, annotations) => {
    return Union.make(unify(flatten(candidates)), annotations);
  };
  /**
@since 3.10.0
/
  _tag = "Union";
  constructor(types, annotations = {}) {
    this.types = types;
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map(ast => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/** @internal

## mapMembers

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `mapMembers(= mapMembers;
const isMembers = as => as.length > 1;
/**
 * @category guards
 * @since 3.10.0
 */
exports.isMembers = isMembers;
const isUnion = exports.isUnion = /*#__PURE__*/createASTGuard("Union")`

JSDoc:

@internal

## Suspend

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `Suspend(= Suspend;
const isSuspend = exports.isSuspend = /*#__PURE__*/createASTGuard("Suspend")`

JSDoc:

@category model
@since 3.10.0
/
class Suspend {
  f;
  annotations;
  /**
@since 3.10.0
/
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = util_.memoizeThunk(f);
  }
  /**
@since 3.10.0
/
  toString() {
    return getExpected(this).pipe(Option.orElse(() => Option.flatMap(Option.liftThrowable(this.f)(), ast => getExpected(ast))), Option.getOrElse(() => "<suspended schema>"));
  }
  /**
@since 3.10.0
/
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
}
/**
@category guards
@since 3.10.0

## Refinement

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `Refinement(= Refinement;
const isRefinement = exports.isRefinement = /*#__PURE__*/createASTGuard("Refinement")`

JSDoc:

@category model
@since 3.10.0
/
class Refinement {
  from;
  filter;
  annotations;
  /**
@since 3.10.0
/
  _tag = "Refinement";
  constructor(from, filter, annotations = {}) {
    this.from = from;
    this.filter = filter;
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return getIdentifierAnnotation(this).pipe(Option.getOrElse(() => Option.match(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: expected => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category guards
@since 3.10.0

## Transformation

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `Transformation(= Transformation;
const isTransformation = exports.isTransformation = /*#__PURE__*/createASTGuard("Transformation")`

JSDoc:

@since 3.10.0
/
const defaultParseOption = exports.defaultParseOption = {};
/**
@category model
@since 3.10.0
/
class Transformation {
  from;
  to;
  transformation;
  annotations;
  /**
@since 3.10.0
/
  _tag = "Transformation";
  constructor(from, to, transformation, annotations = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations;
  }
  /**
@since 3.10.0
/
  toString() {
    return Option.getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
/**
@category guards
@since 3.10.0

## ComposeTransformation

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `ComposeTransformation(= ComposeTransformation;
const composeTransformation = exports.composeTransformation = /*#__PURE__*/new ComposeTransformation()`

JSDoc:

@category model
@since 3.10.0
/
class FinalTransformation {
  decode;
  encode;
  /**
@since 3.10.0
/
  _tag = "FinalTransformation";
  constructor(decode, encode) {
    this.decode = decode;
    this.encode = encode;
  }
}
exports.FinalTransformation = FinalTransformation;
const createTransformationGuard = tag => ast => ast._tag === tag;
/**
@category guards
@since 3.10.0
/
const isFinalTransformation = exports.isFinalTransformation = /*#__PURE__*/createTransformationGuard("FinalTransformation");
/**
@category model
@since 3.10.0
/
class ComposeTransformation {
  /**
@since 3.10.0
/
  _tag = "ComposeTransformation";
}
/**
@category constructors
@since 3.10.0

## TypeLiteralTransformation

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `TypeLiteralTransformation(= TypeLiteralTransformation;
const isTypeLiteralTransformation = exports.isTypeLiteralTransformation = /*#__PURE__*/createTransformationGuard("TypeLiteralTransformation")`

JSDoc:

@category guards
@since 3.10.0
/
const isComposeTransformation = exports.isComposeTransformation = /*#__PURE__*/createTransformationGuard("ComposeTransformation");
/**
Represents a `PropertySignature -> PropertySignature` transformation

The semantic of `decode` is:
- `none()` represents the absence of the key/value pair
- `some(value)` represents the presence of the key/value pair

The semantic of `encode` is:
- `none()` you don't want to output the key/value pair
- `some(value)` you want to output the key/value pair

@category model
@since 3.10.0
/
class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
}
exports.PropertySignatureTransformation = PropertySignatureTransformation;
const isRenamingPropertySignatureTransformation = t => t.decode === _Function.identity && t.encode === _Function.identity;
/**
@category model
@since 3.10.0
/
class TypeLiteralTransformation {
  propertySignatureTransformations;
  /**
@since 3.10.0
/
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    // check for duplicate property signature transformations
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(errors_.getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(errors_.getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
}
/**
@category guards
@since 3.10.0

## annotations

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `annotations(= annotations;
const keyof = ast => Union.unify(_keyof(ast)`

JSDoc:

Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

@since 3.10.0
/
const annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const value = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (Option.isSome(surrogate)) {
    value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value;
  return Object.create(Object.getPrototypeOf(ast), d);
};
/**
Equivalent at runtime to the TypeScript type-level `keyof` operator.

@since 3.10.0

## getTemplateLiteralRegExp

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `getTemplateLiteralRegExp(= getTemplateLiteralRegExp;
const getTemplateLiteralCapturingRegExp = ast => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)`

JSDoc:

Generates a regular expression from a `TemplateLiteral` AST node.

@see {@link getTemplateLiteralCapturingRegExp} for a variant that captures the pattern.

@since 3.10.0
/
const getTemplateLiteralRegExp = ast => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
/**
Generates a regular expression that captures the pattern defined by the given `TemplateLiteral` AST.

@see {@link getTemplateLiteralRegExp} for a variant that does not capture the pattern.

@since 3.10.0

## getTemplateLiteralCapturingRegExp

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `getTemplateLiteralCapturingRegExp(= getTemplateLiteralCapturingRegExp;
const getPropertySignatures = ast => {
  const annotation = getSurrogateAnnotation(ast)`

JSDoc:

@since 3.10.0

## record

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `record(= record;
const pick = (ast, keys)`

JSDoc:

@internal */
const getNumberIndexedAccess = ast => {
  switch (ast._tag) {
    case "TupleType":
      {
        let hasOptional = false;
        let out = [];
        for (const e of ast.elements) {
          if (e.isOptional) {
            hasOptional = true;
          }
          out.push(e.type);
        }
        if (hasOptional) {
          out.push(undefinedKeyword);
        }
        out = out.concat(getRestASTs(ast.rest));
        return Union.make(out);
      }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(errors_.getASTUnsupportedSchemaErrorMessage(ast));
};
exports.getNumberIndexedAccess = getNumberIndexedAccess;
const getTypeLiteralPropertySignature = (ast, name) => {
  // from property signatures...
  const ops = Arr.findFirst(ast.propertySignatures, ps => ps.name === name);
  if (Option.isSome(ops)) {
    return ops.value;
  }
  // from index signatures...
  if (Predicate.isString(name)) {
    let out = undefined;
    for (const is of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is.parameter);
      switch (encodedParameter._tag) {
        case "TemplateLiteral":
          {
            const regex = getTemplateLiteralRegExp(encodedParameter);
            if (regex.test(name)) {
              return new PropertySignature(name, is.type, false, true);
            }
            break;
          }
        case "StringKeyword":
          {
            if (out === undefined) {
              out = new PropertySignature(name, is.type, false, true);
            }
          }
      }
    }
    if (out) {
      return out;
    }
  } else if (Predicate.isSymbol(name)) {
    for (const is of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is.parameter);
      if (isSymbolKeyword(encodedParameter)) {
        return new PropertySignature(name, is.type, false, true);
      }
    }
  }
};
/** @internal */
const getPropertyKeyIndexedAccess = (ast, name) => {
  const annotation = getSurrogateAnnotation(ast);
  if (Option.isSome(annotation)) {
    return getPropertyKeyIndexedAccess(annotation.value, name);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      {
        const ps = getTypeLiteralPropertySignature(ast, name);
        if (ps) {
          return ps;
        }
        break;
      }
    case "Union":
      return new PropertySignature(name, Union.make(ast.types.map(ast => getPropertyKeyIndexedAccess(ast, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
    case "Refinement":
      return getPropertyKeyIndexedAccess(ast.from, name);
  }
  throw new Error(errors_.getASTUnsupportedSchemaErrorMessage(ast));
};
exports.getPropertyKeyIndexedAccess = getPropertyKeyIndexedAccess;
const getPropertyKeys = ast => {
  const annotation = getSurrogateAnnotation(ast);
  if (Option.isSome(annotation)) {
    return getPropertyKeys(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map(ps => ps.name);
    case "Union":
      return ast.types.slice(1).reduce((out, ast) => Arr.intersection(out, getPropertyKeys(ast)), getPropertyKeys(ast.types[0]));
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Refinement":
      return getPropertyKeys(ast.from);
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
};
/** @internal */
const record = (key, value) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go = key => {
    switch (key._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key, value, true));
        break;
      case "Literal":
        if (Predicate.isString(key.literal) || Predicate.isNumber(key.literal)) {
          propertySignatures.push(new PropertySignature(key.literal, value, false, true));
        } else {
          throw new Error(errors_.getASTUnsupportedLiteralErrorMessage(key.literal));
        }
        break;
      case "Enums":
        {
          for (const [_, name] of key.enums) {
            propertySignatures.push(new PropertySignature(name, value, false, true));
          }
          break;
        }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key.symbol, value, false, true));
        break;
      case "Union":
        key.types.forEach(go);
        break;
      default:
        throw new Error(errors_.getASTUnsupportedKeySchemaErrorMessage(key));
    }
  };
  go(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
/**
Equivalent at runtime to the built-in TypeScript utility type `Pick`.

@since 3.10.0

## pick

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `pick(= pick;
const omit = (ast, keys)`

JSDoc:

Equivalent at runtime to the built-in TypeScript utility type `Omit`.

@since 3.10.0

## omit

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `omit(= omit;
const orUndefined = ast => Union.make([ast, undefinedKeyword])`

JSDoc:

@internal

## orUndefined

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `orUndefined(= orUndefined;
const partial = (ast, options)`

JSDoc:

Equivalent at runtime to the built-in TypeScript utility type `Partial`.

@since 3.10.0

## partial

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `partial(= partial;
const required = ast => {
  switch (ast._tag)`

JSDoc:

Equivalent at runtime to the built-in TypeScript utility type `Required`.

@since 3.10.0

## required

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `required(= required;
const mutable = ast => {
  switch (ast._tag)`

JSDoc:

Creates a new AST with shallow mutability applied to its properties.

@since 3.10.0

## mutable

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `mutable(= mutable;
const getCompiler = match => {
  const compile = (ast, path)`

JSDoc:

@since 3.10.0

## getCompiler

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `getCompiler(= getCompiler;
const pickAnnotations = annotationIds => annotated => {
  let out = undefined;
  for (const id of annotationIds)`

JSDoc:

@internal

## pickAnnotations

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `pickAnnotations(= pickAnnotations;
const omitAnnotations = annotationIds => annotated => {
  const out = {
    ...annotated.annotations
  };
  for (const id of annotationIds)`

JSDoc:

@internal

## encodedAST

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `encodedAST(= encodedAST;
const encodedBoundAST = ast => encodedAST_(ast, true)`

JSDoc:

@since 3.10.0
/
const typeAST = ast => {
  switch (ast._tag) {
    case "Declaration":
      {
        const typeParameters = changeMap(ast.typeParameters, typeAST);
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
    case "TupleType":
      {
        const elements = changeMap(ast.elements, e => {
          const type = typeAST(e.type);
          return type === e.type ? e : new OptionalType(type, e.isOptional);
        });
        const restASTs = getRestASTs(ast.rest);
        const rest = changeMap(restASTs, typeAST);
        return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map(type => new Type(type)), ast.isReadonly, ast.annotations);
      }
    case "TypeLiteral":
      {
        const propertySignatures = changeMap(ast.propertySignatures, p => {
          const type = typeAST(p.type);
          return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, is => {
          const type = typeAST(is.type);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
      }
    case "Union":
      {
        const types = changeMap(ast.types, typeAST);
        return types === ast.types ? ast : Union.make(types, ast.annotations);
      }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement":
      {
        const from = typeAST(ast.from);
        return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
      }
    case "Transformation":
      {
        const preserve = preserveTransformationAnnotations(ast);
        return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
      }
  }
  return ast;
};
// To generate a JSON Schema from a recursive schema, an `identifier` annotation
// is required. So, when we calculate the encodedAST, we need to preserve the
// annotation in the form of an internal custom annotation that acts as a
// surrogate for the identifier, which the JSON Schema compiler can then read.
exports.typeAST = typeAST;
const createJSONIdentifierAnnotation = annotated => Option.match(getJSONIdentifier(annotated), {
  onNone: () => undefined,
  onSome: identifier => ({
    [JSONIdentifierAnnotationId]: identifier
  })
});
function changeMap(as, f) {
  let changed = false;
  const out = Arr.allocate(as.length);
  for (let i = 0; i < as.length; i++) {
    const a = as[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as;
}
/**
Returns the from part of a transformation if it exists

@internal
/
const getTransformationFrom = ast => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
exports.getTransformationFrom = getTransformationFrom;
const encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration":
      {
        const typeParameters = changeMap(ast.typeParameters, ast => encodedAST_(ast, isBound));
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
    case "TupleType":
      {
        const elements = changeMap(ast.elements, e => {
          const type = encodedAST_(e.type, isBound);
          return type === e.type ? e : new OptionalType(type, e.isOptional);
        });
        const restASTs = getRestASTs(ast.rest);
        const rest = changeMap(restASTs, ast => encodedAST_(ast, isBound));
        return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map(ast => new Type(ast)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
      }
    case "TypeLiteral":
      {
        const propertySignatures = changeMap(ast.propertySignatures, ps => {
          const type = encodedAST_(ps.type, isBound);
          return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, is => {
          const type = encodedAST_(is.type, isBound);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
      }
    case "Union":
      {
        const types = changeMap(ast.types, ast => encodedAST_(ast, isBound));
        return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
      }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement":
      {
        const from = encodedAST_(ast.from, isBound);
        if (isBound) {
          if (from === ast.from) {
            return ast;
          }
          if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
            return new Refinement(from, ast.filter, ast.annotations);
          }
        }
        const identifier = createJSONIdentifierAnnotation(ast);
        return identifier ? annotations(from, identifier) : from;
      }
    case "Transformation":
      {
        const identifier = createJSONIdentifierAnnotation(ast);
        return encodedAST_(identifier ? annotations(ast.from, identifier) : ast.from, isBound);
      }
  }
  return ast;
};
/**
@since 3.10.0
/
const encodedAST = ast => encodedAST_(ast, false);
/**
@since 3.10.0

## getEncodedParameter

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `getEncodedParameter(= getEncodedParameter;
const equals = (self, that)`

JSDoc:

@internal */
const getEncodedParameter = ast => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
/** @internal

## compose

Source: `my-backend/node_modules/effect/dist/cjs/SchemaAST.js`

Signature: `compose(= compose;
const rename = (ast, mapping)`

JSDoc:

@internal */
const compose = (ab, cd) => new Transformation(ab, cd, composeTransformation);
/** @internal

## isSortedMap

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `isSortedMap(= isSortedMap;
const empty = ord => makeImpl(RBT.empty(ord)`

JSDoc:

@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/SortedMap");
const SortedMapProto = {
  [TypeId]: {
    _K: _ => _,
    _V: _ => _
  },
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(this.tree), Hash.combine(Hash.hash("effect/SortedMap")), Hash.cached(this));
  },
  [Equal.symbol](that) {
    return isSortedMap(that) && Equal.equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const makeImpl = tree => {
  const self = Object.create(SortedMapProto);
  self.tree = tree;
  return self;
};
/**
@since 2.0.0
@category refinements
/
const isSortedMap = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
@since 2.0.0
@category constructors

## empty

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `empty(= empty;
const fromIterable = exports.fromIterable = /*#__PURE__*/Dual.dual(2, (iterable, ord)`

JSDoc:

Creates a new `SortedMap` from an iterable collection of key/value pairs.

@since 2.0.0
@category constructors

## make

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `make(= make;
const isEmpty = self => size(self)`

JSDoc:

@since 2.0.0
@category constructors
/
const make = ord => (...entries) => fromIterable(ord)(entries);
/**
@since 2.0.0
@category predicates

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `isEmpty(= isEmpty;
const isNonEmpty = self => size(self)`

JSDoc:

@since 2.0.0
@category predicates

## isNonEmpty

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `isNonEmpty(= isNonEmpty;
const get = exports.get = /*#__PURE__*/Dual.dual(2, (self, key)`

JSDoc:

@since 2.0.0
@category elements

## getOrder

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `getOrder(= getOrder;
const has = exports.has = /*#__PURE__*/Dual.dual(2, (self, key)`

JSDoc:

Gets the `Order<K>` that the `SortedMap<K, V>` is using.

@since 2.0.0
@category getters
/
const getOrder = self => RBT.getOrder(self.tree);
/**
@since 2.0.0
@category elements

## headOption

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `headOption(= headOption;
const map = exports.map = /*#__PURE__*/Dual.dual(2, (self, f)`

JSDoc:

@since 2.0.0
@category elements
/
const headOption = self => RBT.first(self.tree);
/**
@since 2.0.0
@category mapping

## size

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `size(= size;
const keys = self => RBT.keys(self.tree)`

JSDoc:

@since 2.0.0
@category folding
/
const reduce = exports.reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => RBT.reduce(self.tree, zero, f));
/**
@since 2.0.0
@category elements
/
const remove = exports.remove = /*#__PURE__*/Dual.dual(2, (self, key) => makeImpl(RBT.removeFirst(self.tree, key)));
/**
@since 2.0.0
@category elements
/
const set = exports.set = /*#__PURE__*/Dual.dual(3, (self, key, value) => RBT.has(self.tree, key) ? makeImpl(RBT.insert(RBT.removeFirst(self.tree, key), key, value)) : makeImpl(RBT.insert(self.tree, key, value)));
/**
@since 2.0.0
@category getters
/
const size = self => RBT.size(self.tree);
/**
@since 2.0.0
@category getters

## keys

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `keys(= keys;
const values = self => RBT.values(self.tree)`

JSDoc:

@since 2.0.0
@category getters

## values

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `values(= values;
const entries = self => {
  const iterator = self.tree[Symbol.iterator]()`

JSDoc:

@since 2.0.0
@category getters

## entries

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `entries(= entries;
const lastOption = self => RBT.last(self.tree)`

JSDoc:

@since 3.1.0
@category elements

## lastOption

Source: `my-backend/node_modules/effect/dist/cjs/SortedMap.js`

Signature: `lastOption(= lastOption;
const partition = exports.partition = /*#__PURE__*/Dual.dual(2, (self, predicate)`

JSDoc:

@since 3.1.0
@category filtering

## isSortedSet

Source: `my-backend/node_modules/effect/dist/cjs/SortedSet.js`

Signature: `isSortedSet(= isSortedSet;
const empty = O => fromTree(RBT.empty(O)`

JSDoc:

@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/SortedSet");
const SortedSetProto = {
  [TypeId]: {
    _A: _ => _
  },
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(this.keyTree), Hash.combine(Hash.hash(TypeId)), Hash.cached(this));
  },
  [Equal.symbol](that) {
    return isSortedSet(that) && Equal.equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return RBT.keys(this.keyTree);
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const fromTree = keyTree => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
/**
@since 2.0.0
@category refinements
/
const isSortedSet = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
@since 2.0.0
@category constructors

## empty

Source: `my-backend/node_modules/effect/dist/cjs/SortedSet.js`

Signature: `empty(= empty;
const fromIterable = exports.fromIterable = /*#__PURE__*/Dual.dual(2, (iterable, ord)`

JSDoc:

Creates a new `SortedSet` from an iterable collection of values.

@since 2.0.0
@category constructors

## make

Source: `my-backend/node_modules/effect/dist/cjs/SortedSet.js`

Signature: `make(= make;
const add = exports.add = /*#__PURE__*/Dual.dual(2, (self, value)`

JSDoc:

@since 2.0.0
@category constructors
/
const make = ord => (...entries) => fromIterable(entries, ord);
/**
@since 2.0.0
@category elements

## size

Source: `my-backend/node_modules/effect/dist/cjs/SortedSet.js`

Signature: `size(= size;
const some = exports.some = /*#__PURE__*/Dual.dual(2, (self, predicate)`

JSDoc:

@since 2.0.0
/
const difference = exports.difference = /*#__PURE__*/Dual.dual(2, (self, that) => {
  let out = self;
  for (const value of that) {
    out = remove(out, value);
  }
  return out;
});
/**
Check if a predicate holds true for every `SortedSet` element.

@since 2.0.0
@category elements
/
const every = exports.every = /*#__PURE__*/Dual.dual(2, (self, predicate) => {
  for (const value of self) {
    if (!predicate(value)) {
      return false;
    }
  }
  return true;
});
/**
@since 2.0.0
@category filtering
/
const filter = exports.filter = /*#__PURE__*/Dual.dual(2, (self, predicate) => {
  const ord = RBT.getOrder(self.keyTree);
  let out = empty(ord);
  for (const value of self) {
    if (predicate(value)) {
      out = add(out, value);
    }
  }
  return out;
});
/**
@since 2.0.0
@category sequencing
/
const flatMap = exports.flatMap = /*#__PURE__*/Dual.dual(3, (self, O, f) => {
  let out = empty(O);
  forEach(self, a => {
    for (const b of f(a)) {
      out = add(out, b);
    }
  });
  return out;
});
/**
@since 2.0.0
@category traversing
/
const forEach = exports.forEach = /*#__PURE__*/Dual.dual(2, (self, f) => RBT.forEach(self.keyTree, f));
/**
@since 2.0.0
@category elements
/
const has = exports.has = /*#__PURE__*/Dual.dual(2, (self, value) => RBT.has(self.keyTree, value));
/**
@since 2.0.0
/
const intersection = exports.intersection = /*#__PURE__*/Dual.dual(2, (self, that) => {
  const ord = RBT.getOrder(self.keyTree);
  let out = empty(ord);
  for (const value of that) {
    if (has(self, value)) {
      out = add(out, value);
    }
  }
  return out;
});
/**
@since 2.0.0
@category elements
/
const isSubset = exports.isSubset = /*#__PURE__*/Dual.dual(2, (self, that) => every(self, a => has(that, a)));
/**
@since 2.0.0
@category mapping
/
const map = exports.map = /*#__PURE__*/Dual.dual(3, (self, O, f) => {
  let out = empty(O);
  forEach(self, a => {
    const b = f(a);
    if (!has(out, b)) {
      out = add(out, b);
    }
  });
  return out;
});
/**
@since 2.0.0
@category filtering
/
const partition = exports.partition = /*#__PURE__*/Dual.dual(2, (self, predicate) => {
  const ord = RBT.getOrder(self.keyTree);
  let right = empty(ord);
  let left = empty(ord);
  for (const value of self) {
    if (predicate(value)) {
      right = add(right, value);
    } else {
      left = add(left, value);
    }
  }
  return [left, right];
});
/**
@since 2.0.0
@category elements
/
const remove = exports.remove = /*#__PURE__*/Dual.dual(2, (self, value) => fromTree(RBT.removeFirst(self.keyTree, value)));
/**
@since 2.0.0
@category getters
/
const size = self => RBT.size(self.keyTree);
/**
Check if a predicate holds true for some `SortedSet` element.

@since 2.0.0
@category elements

## values

Source: `my-backend/node_modules/effect/dist/cjs/SortedSet.js`

Signature: `values(= values;
const getEquivalence = ()`

JSDoc:

@since 2.0.0
@category elements
/
const toggle = exports.toggle = /*#__PURE__*/Dual.dual(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value));
/**
@since 2.0.0
/
const union = exports.union = /*#__PURE__*/Dual.dual(2, (self, that) => {
  const ord = RBT.getOrder(self.keyTree);
  let out = empty(ord);
  for (const value of self) {
    out = add(value)(out);
  }
  for (const value of that) {
    out = add(value)(out);
  }
  return out;
});
/**
@since 2.0.0
@category getters
/
const values = self => RBT.keys(self.keyTree);
/**
@since 2.0.0
@category equivalence

## toUpperCase

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `toUpperCase(= toUpperCase;
const toLowerCase = self => self.toLowerCase()`

JSDoc:

This module provides utility functions and type class instances for working with the `string` type in TypeScript.
It includes functions for basic string manipulation, as well as type class instances for
`Equivalence` and `Order`.

@since 2.0.0
/

/**
Tests if a value is a `string`.

@example
```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.isString("a"), true)
assert.deepStrictEqual(String.isString(1), false)
```

@category guards
@since 2.0.0
/
const isString = exports.isString = predicate.isString;
/**
@category instances
@since 2.0.0
/
const Equivalence = exports.Equivalence = equivalence.string;
/**
@category instances
@since 2.0.0
/
const Order = exports.Order = order.string;
/**
The empty string `""`.

@since 2.0.0
/
const empty = exports.empty = "";
/**
Concatenates two strings at runtime.

@since 2.0.0
/
const concat = exports.concat = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self + that);
/**
@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe('a', String.toUpperCase), 'A')
```

@since 2.0.0
/
const toUpperCase = self => self.toUpperCase();
/**
@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe('A', String.toLowerCase), 'a')
```

@since 2.0.0

## toLowerCase

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `toLowerCase(= toLowerCase;
const capitalize = self => {
  if (self.length === 0)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe('abc', String.capitalize), 'Abc')
```

@since 2.0.0

## capitalize

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `capitalize(= capitalize;
const uncapitalize = self => {
  if (self.length === 0)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe('ABC', String.uncapitalize), 'aBC')
```

@since 2.0.0

## uncapitalize

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `uncapitalize(= uncapitalize;
const replace = (searchValue, replaceValue)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe('abc', String.replace('b', 'd')), 'adc')
```

@since 2.0.0

## replace

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `replace(= replace;
const trim = self => self.trim()`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.trim(' a '), 'a')
```

@since 2.0.0

## trim

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `trim(= trim;
const trimStart = self => self.trimStart()`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.trimStart(' a '), 'a ')
```

@since 2.0.0

## trimStart

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `trimStart(= trimStart;
const trimEnd = self => self.trimEnd()`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.trimEnd(' a '), ' a')
```

@since 2.0.0

## trimEnd

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `trimEnd(= trimEnd;
const slice = (start, end)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe('abcd', String.slice(1, 3)), 'bc')
```

@since 2.0.0

## slice

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `slice(= slice;
const isEmpty = self => self.length === 0;
/**
 * Test whether a `string` is non empty.
 *
 * @since 2.0.0
 */
exports.isEmpty = isEmpty;
const isNonEmpty = self => self.length > 0;
/**
 * Calculate the number of characters in a `string`.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { String } from "effect"
 *
 * assert.deepStrictEqual(String.length('abc')`

JSDoc:

Test whether a `string` is empty.

@example
```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.isEmpty(''), true)
assert.deepStrictEqual(String.isEmpty('a'), false)
```

@since 2.0.0

## length

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `length(= length;
const split = exports.split = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe('abc', String.split('')), ['a', 'b', 'c'])
assert.deepStrictEqual(pipe('', String.split('')), [''])
```

@since 2.0.0

## includes

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `includes(= includes;
const startsWith = (searchString, position)`

JSDoc:

Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are
greater than or equal to `position`; otherwise, returns `false`.

@since 2.0.0
/
const includes = (searchString, position) => self => self.includes(searchString, position);
/**
@since 2.0.0

## startsWith

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `startsWith(= startsWith;
const endsWith = (searchString, position)`

JSDoc:

@since 2.0.0

## endsWith

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `endsWith(= endsWith;
const charCodeAt = exports.charCodeAt = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String, Option } from "effect"

assert.deepStrictEqual(pipe("abc", String.charCodeAt(1)), Option.some(98))
assert.deepStrictEqual(pipe("abc", String.charCodeAt(4)), Option.none())
```

@since 2.0.0

## substring

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `substring(= substring;
const at = exports.at = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String, Option } from "effect"

assert.deepStrictEqual(pipe("abcd", String.substring(1)), "bcd")
assert.deepStrictEqual(pipe("abcd", String.substring(1, 3)), "bc")
```

@since 2.0.0
/
const substring = (start, end) => self => self.substring(start, end);
/**
@example
```ts
import * as assert from "node:assert"
import { pipe, String, Option } from "effect"

assert.deepStrictEqual(pipe("abc", String.at(1)), Option.some("b"))
assert.deepStrictEqual(pipe("abc", String.at(4)), Option.none())
```

@since 2.0.0

## indexOf

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `indexOf(= indexOf;
const lastIndexOf = searchString => self => Option.filter(Option.some(self.lastIndexOf(searchString)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String, Option } from "effect"

assert.deepStrictEqual(pipe("abc", String.charAt(1)), Option.some("b"))
assert.deepStrictEqual(pipe("abc", String.charAt(4)), Option.none())
```

@since 2.0.0
/
const charAt = exports.charAt = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => Option.filter(Option.some(self.charAt(index)), isNonEmpty));
/**
@example
```ts
import * as assert from "node:assert"
import { pipe, String, Option } from "effect"

assert.deepStrictEqual(pipe("abc", String.codePointAt(1)), Option.some(98))
```

@since 2.0.0
/
const codePointAt = exports.codePointAt = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => Option.fromNullable(self.codePointAt(index)));
/**
@example
```ts
import * as assert from "node:assert"
import { pipe, String, Option } from "effect"

assert.deepStrictEqual(pipe("abbbc", String.indexOf("b")), Option.some(1))
```

@since 2.0.0
/
const indexOf = searchString => self => Option.filter(Option.some(self.indexOf(searchString)), number.greaterThanOrEqualTo(0));
/**
@example
```ts
import * as assert from "node:assert"
import { pipe, String, Option } from "effect"

assert.deepStrictEqual(pipe("abbbc", String.lastIndexOf("b")), Option.some(3))
assert.deepStrictEqual(pipe("abbbc", String.lastIndexOf("d")), Option.none())
```

@since 2.0.0

## lastIndexOf

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `lastIndexOf(= lastIndexOf;
const localeCompare = (that, locales, options)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe("a", String.localeCompare("b")), -1)
assert.deepStrictEqual(pipe("b", String.localeCompare("a")), 1)
assert.deepStrictEqual(pipe("a", String.localeCompare("a")), 0)
```

@since 2.0.0

## localeCompare

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `localeCompare(= localeCompare;
const match = regexp => self => Option.fromNullable(self.match(regexp)`

JSDoc:

It is the `pipe`-able version of the native `match` method.

@since 2.0.0

## match

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `match(= match;
const matchAll = regexp => self => self.matchAll(regexp)`

JSDoc:

It is the `pipe`-able version of the native `matchAll` method.

@since 2.0.0

## matchAll

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `matchAll(= matchAll;
const normalize = form => self => self.normalize(form)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

const str = "\u1E9B\u0323";
assert.deepStrictEqual(pipe(str, String.normalize()), "\u1E9B\u0323")
assert.deepStrictEqual(pipe(str, String.normalize("NFC")), "\u1E9B\u0323")
assert.deepStrictEqual(pipe(str, String.normalize("NFD")), "\u017F\u0323\u0307")
assert.deepStrictEqual(pipe(str, String.normalize("NFKC")), "\u1E69")
assert.deepStrictEqual(pipe(str, String.normalize("NFKD")), "\u0073\u0323\u0307")
```

@since 2.0.0

## normalize

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `normalize(= normalize;
const padEnd = (maxLength, fillString)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe("a", String.padEnd(5)), "a    ")
assert.deepStrictEqual(pipe("a", String.padEnd(5, "_")), "a____")
```

@since 2.0.0

## padEnd

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `padEnd(= padEnd;
const padStart = (maxLength, fillString)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe("a", String.padStart(5)), "    a")
assert.deepStrictEqual(pipe("a", String.padStart(5, "_")), "____a")
```

@since 2.0.0

## padStart

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `padStart(= padStart;
const repeat = count => self => self.repeat(count)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe("a", String.repeat(5)), "aaaaa")
```

@since 2.0.0

## repeat

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `repeat(= repeat;
const replaceAll = (searchValue, replaceValue)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

assert.deepStrictEqual(pipe("ababb", String.replaceAll("b", "c")), "acacc")
assert.deepStrictEqual(pipe("ababb", String.replaceAll(/ba/g, "cc")), "accbb")
```

@since 2.0.0

## replaceAll

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `replaceAll(= replaceAll;
const search = exports.search = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String, Option } from "effect"

assert.deepStrictEqual(pipe("ababb", String.search("b")), Option.some(1))
assert.deepStrictEqual(pipe("ababb", String.search(/abb/)), Option.some(2))
assert.deepStrictEqual(pipe("ababb", String.search("d")), Option.none())
```

@since 2.0.0

## toLocaleLowerCase

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `toLocaleLowerCase(= toLocaleLowerCase;
const toLocaleUpperCase = locale => self => self.toLocaleUpperCase(locale)`

JSDoc:

@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

const str = "\u0130"
assert.deepStrictEqual(pipe(str, String.toLocaleLowerCase("tr")), "i")
```

@since 2.0.0
/
const toLocaleLowerCase = locale => self => self.toLocaleLowerCase(locale);
/**
@example
```ts
import * as assert from "node:assert"
import { pipe, String } from "effect"

const str = "i\u0307"
assert.deepStrictEqual(pipe(str, String.toLocaleUpperCase("lt-LT")), "I")
```

@since 2.0.0

## toLocaleUpperCase

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `toLocaleUpperCase(= toLocaleUpperCase;
const takeLeft = exports.takeLeft = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Keep the specified number of characters from the start of a string.

If `n` is larger than the available number of characters, the string will
be returned whole.

If `n` is not a positive number, an empty string will be returned.

If `n` is a float, it will be rounded down to the nearest integer.

@example
```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.takeLeft("Hello World", 5), "Hello")
```

@since 2.0.0

## linesIterator

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `linesIterator(= linesIterator;
const linesWithSeparators = s => linesSeparated(s, false)`

JSDoc:

Keep the specified number of characters from the end of a string.

If `n` is larger than the available number of characters, the string will
be returned whole.

If `n` is not a positive number, an empty string will be returned.

If `n` is a float, it will be rounded down to the nearest integer.

@example
```ts
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.takeRight("Hello World", 5), "World")
```

@since 2.0.0
/
const takeRight = exports.takeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));
const CR = 0x0d;
const LF = 0x0a;
/**
Returns an `IterableIterator` which yields each line contained within the
string, trimming off the trailing newline character.

@since 2.0.0
/
const linesIterator = self => linesSeparated(self, true);
/**
Returns an `IterableIterator` which yields each line contained within the
string as well as the trailing newline character.

@since 2.0.0

## linesWithSeparators

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `linesWithSeparators(= linesWithSeparators;
const stripMarginWith = exports.stripMarginWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

For every line in this string, strip a leading prefix consisting of blanks
or control characters followed by the character specified by `marginChar`
from the line.

@since 2.0.0

## stripMargin

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `stripMargin(= stripMargin;
const snakeToCamel = self => {
  let str = self[0];
  for (let i = 1; i < self.length; i++)`

JSDoc:

For every line in this string, strip a leading prefix consisting of blanks
or control characters followed by the `"|"` character from the line.

@since 2.0.0
/
const stripMargin = self => stripMarginWith(self, "|");
/**
@since 2.0.0

## snakeToCamel

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `snakeToCamel(= snakeToCamel;
const snakeToPascal = self => {
  let str = self[0].toUpperCase()`

JSDoc:

@since 2.0.0

## snakeToPascal

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `snakeToPascal(= snakeToPascal;
const snakeToKebab = self => self.replace(/_/g, "-")`

JSDoc:

@since 2.0.0

## snakeToKebab

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `snakeToKebab(= snakeToKebab;
const camelToSnake = self => self.replace(/([A-Z])`

JSDoc:

@since 2.0.0

## camelToSnake

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `camelToSnake(= camelToSnake;
const pascalToSnake = self => (self.slice(0, 1)`

JSDoc:

@since 2.0.0

## pascalToSnake

Source: `my-backend/node_modules/effect/dist/cjs/String.js`

Signature: `pascalToSnake(= pascalToSnake;
const kebabToSnake = self => self.replace(/-/g, "_")`

JSDoc:

@since 2.0.0

## get

Source: `my-backend/node_modules/effect/dist/cjs/Struct.js`

Signature: `get(= get;
const keys = o => Object.keys(o)`

JSDoc:

This module provides utility functions for working with structs in TypeScript.

@since 2.0.0
/

/**
Create a new object by picking properties of an existing object.

@example
```ts
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.pick("a", "b")), { a: "a", b: 1 })
assert.deepStrictEqual(Struct.pick({ a: "a", b: 1, c: true }, "a", "b"), { a: "a", b: 1 })
```

@since 2.0.0
/
const pick = exports.pick = /*#__PURE__*/(0, _Function.dual)(args => Predicate.isObject(args[0]), (s, ...keys) => {
  const out = {};
  for (const k of keys) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
/**
Create a new object by omitting properties of an existing object.

@example
```ts
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.omit("c")), { a: "a", b: 1 })
assert.deepStrictEqual(Struct.omit({ a: "a", b: 1, c: true }, "c"), { a: "a", b: 1 })
```

@since 2.0.0
/
const omit = exports.omit = /*#__PURE__*/(0, _Function.dual)(args => Predicate.isObject(args[0]), (s, ...keys) => {
  const out = {
    ...s
  };
  for (const k of keys) {
    delete out[k];
  }
  return out;
});
/**
Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct
by applying each `Equivalence` to the corresponding property of the struct.

Alias of {@link Equivalence.struct}.

@example
```ts
import * as assert from "node:assert"
import { Struct, String, Number } from "effect"

const PersonEquivalence = Struct.getEquivalence({
  name: String.Equivalence,
  age: Number.Equivalence
})

assert.deepStrictEqual(
  PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 25 }),
  true
)
assert.deepStrictEqual(
  PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 40 }),
  false
)
```

@category combinators
@since 2.0.0
/
const getEquivalence = exports.getEquivalence = Equivalence.struct;
/**
This function creates and returns a new `Order` for a struct of values based on the given `Order`s
for each property in the struct.

Alias of {@link order.struct}.

@category combinators
@since 2.0.0
/
const getOrder = exports.getOrder = order.struct;
/**
Transforms the values of a Struct provided a transformation function for each key.
If no transformation function is provided for a key, it will return the origional value for that key.

@example
```ts
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(
  pipe(
    { a: 'a', b: 1, c: 3 },
    Struct.evolve({
      a: (a) => a.length,
      b: (b) => b * 2
    })
  ),
  { a: 1, b: 2, c: 3 }
)
```

@since 2.0.0
/
const evolve = exports.evolve = /*#__PURE__*/(0, _Function.dual)(2, (obj, t) => {
  const out = {
    ...obj
  };
  for (const k in t) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      // @ts-expect-error
      out[k] = t[k](obj[k]);
    }
  }
  return out;
});
/**
Retrieves the value associated with the specified key from a struct.

@example
```ts
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

const value = pipe({ a: 1, b: 2 }, Struct.get("a"))

assert.deepStrictEqual(value, 1)
```

@since 2.0.0
/
const get = key => s => s[key];
/**
Retrieves the object keys that are strings in a typed manner

@example
```ts
import * as assert from "node:assert"
import { Struct } from "effect"

const symbol: unique symbol = Symbol()

const value = {
  a: 1,
  b: 2,
  [symbol]: 3
}

const keys: Array<"a" | "b"> = Struct.keys(value)

assert.deepStrictEqual(keys, ["a", "b"])
```

@since 3.6.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/Subscribable.js`

Signature: `make(= make;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
@category type ids
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Subscribable");
/**
@since 2.0.0
@category refinements
/
const isSubscribable = u => (0, _Predicate.hasProperty)(u, TypeId);
exports.isSubscribable = isSubscribable;
const Proto = {
  [Readable.TypeId]: Readable.TypeId,
  [TypeId]: TypeId,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/**
@since 2.0.0
@category constructors
/
const make = options => Object.assign(Object.create(Proto), options);
/**
@since 2.0.0
@category combinators

## isTestAnnotation

Source: `my-backend/node_modules/effect/dist/cjs/TestAnnotation.js`

Signature: `isTestAnnotation(= isTestAnnotation;
const make = (identifier, initial, combine)`

JSDoc:

@since 2.0.0
/

/** @internal */
const TestAnnotationSymbolKey = "effect/TestAnnotation";
/**
@since 2.0.0
/
const TestAnnotationTypeId = exports.TestAnnotationTypeId = /*#__PURE__*/Symbol.for(TestAnnotationSymbolKey);
/** @internal */
class TestAnnotationImpl {
  identifier;
  initial;
  combine;
  [TestAnnotationTypeId] = {
    _A: _ => _
  };
  constructor(identifier, initial, combine) {
    this.identifier = identifier;
    this.initial = initial;
    this.combine = combine;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(TestAnnotationSymbolKey), Hash.combine(Hash.hash(this.identifier)), Hash.cached(this));
  }
  [Equal.symbol](that) {
    return isTestAnnotation(that) && this.identifier === that.identifier;
  }
}
/**
@since 2.0.0
/
const isTestAnnotation = u => (0, _Predicate.hasProperty)(u, TestAnnotationTypeId);
/**
@since 2.0.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/TestAnnotation.js`

Signature: `make(= make;
const compose = (left, right)`

JSDoc:

@since 2.0.0

## compose

Source: `my-backend/node_modules/effect/dist/cjs/TestAnnotation.js`

Signature: `compose(= compose;
const fibers = exports.fibers = /*#__PURE__*/make("fibers", /*#__PURE__*/Either.left(0)`

JSDoc:

@since 2.0.0

## isTestAnnotationMap

Source: `my-backend/node_modules/effect/dist/cjs/TestAnnotationMap.js`

Signature: `isTestAnnotationMap(= isTestAnnotationMap;
const empty = ()`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
/
const TestAnnotationMapTypeId = exports.TestAnnotationMapTypeId = /*#__PURE__*/Symbol.for("effect/TestAnnotationMap");
/** @internal */
class TestAnnotationMapImpl {
  map;
  [TestAnnotationMapTypeId] = TestAnnotationMapTypeId;
  constructor(map) {
    this.map = map;
  }
}
/**
@since 2.0.0
/
const isTestAnnotationMap = u => (0, _Predicate.hasProperty)(u, TestAnnotationMapTypeId);
/**
@since 2.0.0

## empty

Source: `my-backend/node_modules/effect/dist/cjs/TestAnnotationMap.js`

Signature: `empty(= empty;
const make = map => {
  return new TestAnnotationMapImpl(map)`

JSDoc:

@since 2.0.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/TestAnnotationMap.js`

Signature: `make(= make;
const overwrite = exports.overwrite = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@since 2.0.0

## isTestAnnotations

Source: `my-backend/node_modules/effect/dist/cjs/TestAnnotations.js`

Signature: `isTestAnnotations(= isTestAnnotations;
const make = ref => new AnnotationsImpl(ref)`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
/
const TestAnnotationsTypeId = exports.TestAnnotationsTypeId = /*#__PURE__*/Symbol.for("effect/TestAnnotations");
/** @internal */
class AnnotationsImpl {
  ref;
  [TestAnnotationsTypeId] = TestAnnotationsTypeId;
  constructor(ref) {
    this.ref = ref;
  }
  get(key) {
    return core.map(Ref.get(this.ref), TestAnnotationMap.get(key));
  }
  annotate(key, value) {
    return Ref.update(this.ref, TestAnnotationMap.annotate(key, value));
  }
  get supervisedFibers() {
    return effect.descriptorWith(descriptor => core.flatMap(this.get(TestAnnotation.fibers), either => {
      switch (either._tag) {
        case "Left":
          {
            return core.succeed(SortedSet.empty(fiber.Order));
          }
        case "Right":
          {
            return (0, _Function.pipe)(either.right, core.forEachSequential(ref => core.sync(() => MutableRef.get(ref))), core.map(RA.reduce(SortedSet.empty(fiber.Order), (a, b) => SortedSet.union(a, b))), core.map(SortedSet.filter(fiber => !Equal.equals(fiber.id(), descriptor.id))));
          }
      }
    }));
  }
}
/**
@since 2.0.0
/
const TestAnnotations = exports.TestAnnotations = /*#__PURE__*/Context.GenericTag("effect/Annotations");
/**
@since 2.0.0
/
const isTestAnnotations = u => (0, _Predicate.hasProperty)(u, TestAnnotationsTypeId);
/**
@since 2.0.0

## makeData

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `makeData(= makeData;
const TestClock = exports.TestClock = /*#__PURE__*/Context.GenericTag("effect/TestClock")`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
/
const makeData = (instant, sleeps) => ({
  instant,
  sleeps
});
/**
@since 2.0.0

## TestClockImpl

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `TestClockImpl(= TestClockImpl;
const live = data => layer.scoped(TestClock, core.gen(function* ($)`

JSDoc:

The warning message that will be displayed if a test is using time but is
not advancing the `TestClock`.

@internal
/
const warning = "Warning: A test is using time, but is not advancing " + "the test clock, which may result in the test hanging. Use TestClock.adjust to " + "manually advance the time.";
/**
The warning message that will be displayed if a test is advancing the clock
but a fiber is still running.

@internal
/
const suspendedWarning = "Warning: A test is advancing the test clock, " + "but a fiber is not suspending, which may result in the test hanging. Use " + "TestAspect.diagnose to identity the fiber that is not suspending.";
/** @internal */
class TestClockImpl {
  clockState;
  live;
  annotations;
  warningState;
  suspendedWarningState;
  [clock.ClockTypeId] = clock.ClockTypeId;
  constructor(clockState, live, annotations, warningState, suspendedWarningState) {
    this.clockState = clockState;
    this.live = live;
    this.annotations = annotations;
    this.warningState = warningState;
    this.suspendedWarningState = suspendedWarningState;
    this.currentTimeMillis = core.map(ref.get(this.clockState), data => data.instant);
    this.currentTimeNanos = core.map(ref.get(this.clockState), data => BigInt(data.instant * 1000000));
  }
  /**
Unsafely returns the current time in milliseconds.
/
  unsafeCurrentTimeMillis() {
    return ref.unsafeGet(this.clockState).instant;
  }
  /**
Unsafely returns the current time in nanoseconds.
/
  unsafeCurrentTimeNanos() {
    return BigInt(ref.unsafeGet(this.clockState).instant * 1000000);
  }
  /**
Returns the current clock time in milliseconds.
/
  currentTimeMillis;
  /**
Returns the current clock time in nanoseconds.
/
  currentTimeNanos;
  /**
Saves the `TestClock`'s current state in an effect which, when run, will
restore the `TestClock` state to the saved state.
/
  get save() {
    return core.map(ref.get(this.clockState), data => ref.set(this.clockState, data));
  }
  /**
Sets the current clock time to the specified instant. Any effects that
were scheduled to occur on or before the new time will be run in order.
/
  setTime(instant) {
    return core.zipRight(this.warningDone(), this.run(() => instant));
  }
  /**
Semantically blocks the current fiber until the clock time is equal to or
greater than the specified duration. Once the clock time is adjusted to
on or after the duration, the fiber will automatically be resumed.
/
  sleep(durationInput) {
    const duration = Duration.decode(durationInput);
    return core.flatMap(core.deferredMake(), deferred => (0, _Function.pipe)(ref.modify(this.clockState, data => {
      const end = data.instant + Duration.toMillis(duration);
      if (end > data.instant) {
        return [true, makeData(data.instant, (0, _Function.pipe)(data.sleeps, Chunk.prepend([end, deferred])))];
      }
      return [false, data];
    }), core.flatMap(shouldAwait => shouldAwait ? (0, _Function.pipe)(this.warningStart(), core.zipRight(core.deferredAwait(deferred))) : (0, _Function.pipe)(core.deferredSucceed(deferred, void 0), core.asVoid))));
  }
  /**
Returns a list of the times at which all queued effects are scheduled to
resume.
/
  get sleeps() {
    return core.map(ref.get(this.clockState), data => Chunk.map(data.sleeps, _ => _[0]));
  }
  /**
Increments the current clock time by the specified duration. Any effects
that were scheduled to occur on or before the new time will be run in
order.
/
  adjust(durationInput) {
    const duration = Duration.decode(durationInput);
    return core.zipRight(this.warningDone(), this.run(n => n + Duration.toMillis(duration)));
  }
  /**
Increments the current clock time by the specified duration. Any effects
that were scheduled to occur on or before the new time will be run in
order.
/
  adjustWith(durationInput) {
    const duration = Duration.decode(durationInput);
    return effect => fiberRuntime.zipLeftOptions(effect, this.adjust(duration), {
      concurrent: true
    });
  }
  /**
Returns a set of all fibers in this test.
/
  supervisedFibers() {
    return this.annotations.supervisedFibers;
  }
  /**
Captures a "snapshot" of the identifier and status of all fibers in this
test other than the current fiber. Fails with the `void` value if any of
these fibers are not done or suspended. Note that because we cannot
synchronize on the status of multiple fibers at the same time this
snapshot may not be fully consistent.
/
  freeze() {
    return core.flatMap(this.supervisedFibers(), fibers => (0, _Function.pipe)(fibers, effect.reduce(HashMap.empty(), (map, fiber) => (0, _Function.pipe)(fiber.status, core.flatMap(status => {
      if (FiberStatus.isDone(status)) {
        return core.succeed(HashMap.set(map, fiber.id(), status));
      }
      if (FiberStatus.isSuspended(status)) {
        return core.succeed(HashMap.set(map, fiber.id(), status));
      }
      return core.fail(void 0);
    })))));
  }
  /**
Forks a fiber that will display a warning message if a test is using time
but is not advancing the `TestClock`.
/
  warningStart() {
    return synchronized.updateSomeEffect(this.warningState, data => WarningData.isStart(data) ? Option.some((0, _Function.pipe)(this.live.provide((0, _Function.pipe)(effect.logWarning(warning), effect.delay(Duration.seconds(5)))), core.interruptible, fiberRuntime.fork, core.map(fiber => WarningData.pending(fiber)))) : Option.none());
  }
  /**
Cancels the warning message that is displayed if a test is using time but
is not advancing the `TestClock`.
/
  warningDone() {
    return synchronized.updateSomeEffect(this.warningState, warningData => {
      if (WarningData.isStart(warningData)) {
        return Option.some(core.succeed(WarningData.done));
      }
      if (WarningData.isPending(warningData)) {
        return Option.some((0, _Function.pipe)(core.interruptFiber(warningData.fiber), core.as(WarningData.done)));
      }
      return Option.none();
    });
  }
  yieldTimer = /*#__PURE__*/core.async(resume => {
    const timer = setTimeout(() => {
      resume(core.void);
    }, 0);
    return core.sync(() => clearTimeout(timer));
  });
  /**
Returns whether all descendants of this fiber are done or suspended.
/
  suspended() {
    return (0, _Function.pipe)(this.freeze(), core.zip((0, _Function.pipe)(this.yieldTimer, core.zipRight(this.freeze()))), core.flatMap(([first, last]) => Equal.equals(first, last) ? core.succeed(first) : core.fail(void 0)));
  }
  /**
Polls until all descendants of this fiber are done or suspended.
/
  awaitSuspended() {
    return (0, _Function.pipe)(this.suspendedWarningStart(), core.zipRight((0, _Function.pipe)(this.suspended(), core.zipWith((0, _Function.pipe)(this.yieldTimer, core.zipRight(this.suspended())), Equal.equals), effect.filterOrFail(_Function.identity, _Function.constVoid), effect.eventually)), core.zipRight(this.suspendedWarningDone()));
  }
  /**
Forks a fiber that will display a warning message if a test is advancing
the `TestClock` but a fiber is not suspending.
/
  suspendedWarningStart() {
    return synchronized.updateSomeEffect(this.suspendedWarningState, suspendedWarningData => {
      if (SuspendedWarningData.isStart(suspendedWarningData)) {
        return Option.some((0, _Function.pipe)(this.live.provide((0, _Function.pipe)(effect.logWarning(suspendedWarning), core.zipRight(ref.set(this.suspendedWarningState, SuspendedWarningData.done)), effect.delay(Duration.seconds(5)))), core.interruptible, fiberRuntime.fork, core.map(fiber => SuspendedWarningData.pending(fiber))));
      }
      return Option.none();
    });
  }
  /**
Cancels the warning message that is displayed if a test is advancing the
`TestClock` but a fiber is not suspending.
/
  suspendedWarningDone() {
    return synchronized.updateSomeEffect(this.suspendedWarningState, suspendedWarningData => {
      if (SuspendedWarningData.isPending(suspendedWarningData)) {
        return Option.some((0, _Function.pipe)(core.interruptFiber(suspendedWarningData.fiber), core.as(SuspendedWarningData.start)));
      }
      return Option.none();
    });
  }
  /**
Runs all effects scheduled to occur on or before the specified instant,
which may depend on the current time, in order.
/
  run(f) {
    return (0, _Function.pipe)(this.awaitSuspended(), core.zipRight((0, _Function.pipe)(ref.modify(this.clockState, data => {
      const end = f(data.instant);
      const sorted = (0, _Function.pipe)(data.sleeps, Chunk.sort((0, _Function.pipe)(number.Order, Order.mapInput(_ => _[0]))));
      if (Chunk.isNonEmpty(sorted)) {
        const [instant, deferred] = Chunk.headNonEmpty(sorted);
        if (instant <= end) {
          return [Option.some([end, deferred]), makeData(instant, Chunk.tailNonEmpty(sorted))];
        }
      }
      return [Option.none(), makeData(end, data.sleeps)];
    }), core.flatMap(option => {
      switch (option._tag) {
        case "None":
          {
            return core.void;
          }
        case "Some":
          {
            const [end, deferred] = option.value;
            return (0, _Function.pipe)(core.deferredSucceed(deferred, void 0), core.zipRight(core.yieldNow()), core.zipRight(this.run(() => end)));
          }
      }
    }))));
  }
}
/**
@since 2.0.0

## live

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `live(= live;
const defaultTestClock = exports.defaultTestClock = /*#__PURE__*/live(/*#__PURE__*/makeData(/*#__PURE__*/new Date(0)`

JSDoc:

@since 2.0.0

## adjust

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `adjust(= adjust;
const adjustWith = exports.adjustWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Accesses a `TestClock` instance in the context and increments the time
by the specified duration, running any actions scheduled for on or before
the new time in order.

@since 2.0.0
/
const adjust = durationInput => {
  const duration = Duration.decode(durationInput);
  return testClockWith(testClock => testClock.adjust(duration));
};
/**
@since 2.0.0

## save

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `save(= save;
const setTime = input => testClockWith(testClock => testClock.setTime(typeof input === "number" ? input : DateTime.unsafeMake(input)`

JSDoc:

Accesses a `TestClock` instance in the context and saves the clock
state in an effect which, when run, will restore the `TestClock` to the
saved state.

@since 2.0.0
/
const save = () => testClockWith(testClock => testClock.save);
/**
Accesses a `TestClock` instance in the context and sets the clock time
to the specified `Instant` or `Date`, running any actions scheduled for on or before
the new time in order.

@since 2.0.0

## setTime

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `setTime(= setTime;
const sleep = durationInput => {
  const duration = Duration.decode(durationInput)`

JSDoc:

Semantically blocks the current fiber until the clock time is equal to or
greater than the specified duration. Once the clock time is adjusted to
on or after the duration, the fiber will automatically be resumed.

@since 2.0.0

## sleep

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `sleep(= sleep;
const sleeps = ()`

JSDoc:

Accesses a `TestClock` instance in the context and returns a list of
times that effects are scheduled to run.

@since 2.0.0

## sleeps

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `sleeps(= sleeps;
const testClock = ()`

JSDoc:

Retrieves the `TestClock` service for this test.

@since 2.0.0

## testClock

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `testClock(= testClock;
const testClockWith = f => core.fiberRefGetWith(defaultServices.currentServices, services => f((0, _Function.pipe)`

JSDoc:

Retrieves the `TestClock` service for this test and uses it to run the
specified workflow.

@since 2.0.0

## testClockWith

Source: `my-backend/node_modules/effect/dist/cjs/TestClock.js`

Signature: `testClockWith(= testClockWith;
const currentTimeMillis = exports.currentTimeMillis = /*#__PURE__*/testClockWith(testClock => testClock.currentTimeMillis)`

JSDoc:

Accesses the current time of a `TestClock` instance in the context in
milliseconds.

@since 2.0.0

## annotations

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `annotations(= annotations;
const annotationsWith = f => core.fiberRefGetWith(currentServices, services => f(Context.get(services, Annotations.TestAnnotations)`

JSDoc:

@since 2.0.0
/

/**
The default Effect test services.

@since 2.0.0
/
const liveServices = exports.liveServices = /*#__PURE__*/(0, _Function.pipe)(/*#__PURE__*/Context.make(Annotations.TestAnnotations, /*#__PURE__*/Annotations.make(/*#__PURE__*/ref.unsafeMake(/*#__PURE__*/TestAnnotationMap.empty()))), /*#__PURE__*/Context.add(Live.TestLive, /*#__PURE__*/Live.make(defaultServices.liveServices)), /*#__PURE__*/Context.add(Sized.TestSized, /*#__PURE__*/Sized.make(100)), /*#__PURE__*/Context.add(TestConfig.TestConfig, /*#__PURE__*/TestConfig.make({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1000
})));
/**
@since 2.0.0
/
const currentServices = exports.currentServices = /*#__PURE__*/core.fiberRefUnsafeMakeContext(liveServices);
/**
Retrieves the `Annotations` service for this test.

@since 2.0.0
/
const annotations = () => annotationsWith(core.succeed);
/**
Retrieves the `Annotations` service for this test and uses it to run the
specified workflow.

@since 2.0.0

## annotationsWith

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `annotationsWith(= annotationsWith;
const withAnnotations = exports.withAnnotations = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Executes the specified workflow with the specified implementation of the
annotations service.

@since 2.0.0

## withAnnotationsScoped

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `withAnnotationsScoped(= withAnnotationsScoped;
const annotationsLayer = ()`

JSDoc:

Sets the implementation of the annotations service to the specified value
and restores it to its original value when the scope is closed.

@since 2.0.0
/
const withAnnotationsScoped = annotations => fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(Annotations.TestAnnotations, annotations));
/**
Constructs a new `Annotations` service wrapped in a layer.

@since 2.0.0

## annotationsLayer

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `annotationsLayer(= annotationsLayer;
const get = key => annotationsWith(annotations => annotations.get(key)`

JSDoc:

Accesses an `Annotations` instance in the context and retrieves the
annotation of the specified type, or its default value if there is none.

@since 2.0.0

## get

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `get(= get;
const annotate = (key, value)`

JSDoc:

Accesses an `Annotations` instance in the context and appends the
specified annotation to the annotation map.

@since 2.0.0

## annotate

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `annotate(= annotate;
const supervisedFibers = ()`

JSDoc:

Returns the set of all fibers in this test.

@since 2.0.0

## supervisedFibers

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `supervisedFibers(= supervisedFibers;
const liveWith = f => core.fiberRefGetWith(currentServices, services => f(Context.get(services, Live.TestLive)`

JSDoc:

Retrieves the `Live` service for this test and uses it to run the specified
workflow.

@since 2.0.0

## liveWith

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `liveWith(= liveWith;
const live = exports.live = /*#__PURE__*/liveWith(core.succeed)`

JSDoc:

Retrieves the `Live` service for this test.

@since 2.0.0

## withLiveScoped

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `withLiveScoped(= withLiveScoped;
const liveLayer = ()`

JSDoc:

Executes the specified workflow with the specified implementation of the
live service.

@since 2.0.0
/
const withLive = exports.withLive = /*#__PURE__*/(0, _Function.dual)(2, (effect, live) => core.fiberRefLocallyWith(currentServices, Context.add(Live.TestLive, live))(effect));
/**
Sets the implementation of the live service to the specified value and
restores it to its original value when the scope is closed.

@since 2.0.0
/
const withLiveScoped = live => fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(Live.TestLive, live));
/**
Constructs a new `Live` service wrapped in a layer.

@since 2.0.0

## liveLayer

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `liveLayer(= liveLayer;
const provideLive = effect => liveWith(live => live.provide(effect)`

JSDoc:

Provides a workflow with the "live" default Effect services.

@since 2.0.0

## provideLive

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `provideLive(= provideLive;
const provideWithLive = exports.provideWithLive = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Runs a transformation function with the live default Effect services while
ensuring that the workflow itself is run with the test services.

@since 2.0.0

## sizedWith

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `sizedWith(= sizedWith;
const sized = exports.sized = /*#__PURE__*/sizedWith(core.succeed)`

JSDoc:

Retrieves the `Sized` service for this test and uses it to run the
specified workflow.

@since 2.0.0
/
const sizedWith = f => core.fiberRefGetWith(currentServices, services => f(Context.get(services, Sized.TestSized)));
/**
Retrieves the `Sized` service for this test.

@since 2.0.0

## withSizedScoped

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `withSizedScoped(= withSizedScoped;
const sizedLayer = size => layer.scoped(Sized.TestSized, (0, _Function.pipe)`

JSDoc:

Executes the specified workflow with the specified implementation of the
sized service.

@since 2.0.0
/
const withSized = exports.withSized = /*#__PURE__*/(0, _Function.dual)(2, (effect, sized) => core.fiberRefLocallyWith(currentServices, Context.add(Sized.TestSized, sized))(effect));
/**
Sets the implementation of the sized service to the specified value and
restores it to its original value when the scope is closed.

@since 2.0.0
/
const withSizedScoped = sized => fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(Sized.TestSized, sized));
/**
@since 2.0.0

## sizedLayer

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `sizedLayer(= sizedLayer;
const size = exports.size = /*#__PURE__*/sizedWith(sized => sized.size)`

JSDoc:

@since 2.0.0

## testConfigWith

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `testConfigWith(= testConfigWith;
const testConfig = exports.testConfig = /*#__PURE__*/testConfigWith(core.succeed)`

JSDoc:

@since 2.0.0
/
const withSize = exports.withSize = /*#__PURE__*/(0, _Function.dual)(2, (effect, size) => sizedWith(sized => sized.withSize(size)(effect)));
/**
Retrieves the `TestConfig` service for this test and uses it to run the
specified workflow.

@since 2.0.0
/
const testConfigWith = f => core.fiberRefGetWith(currentServices, services => f(Context.get(services, TestConfig.TestConfig)));
/**
Retrieves the `TestConfig` service for this test.

@since 2.0.0

## withTestConfigScoped

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `withTestConfigScoped(= withTestConfigScoped;
const testConfigLayer = params => layer.scoped(TestConfig.TestConfig, Effect.suspend(()`

JSDoc:

Executes the specified workflow with the specified implementation of the
config service.

@since 2.0.0
/
const withTestConfig = exports.withTestConfig = /*#__PURE__*/(0, _Function.dual)(2, (effect, config) => core.fiberRefLocallyWith(currentServices, Context.add(TestConfig.TestConfig, config))(effect));
/**
Sets the implementation of the config service to the specified value and
restores it to its original value when the scope is closed.

@since 2.0.0
/
const withTestConfigScoped = config => fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(TestConfig.TestConfig, config));
/**
Constructs a new `TestConfig` service with the specified settings.

@since 2.0.0

## testConfigLayer

Source: `my-backend/node_modules/effect/dist/cjs/TestServices.js`

Signature: `testConfigLayer(= testConfigLayer;
const repeats = exports.repeats = /*#__PURE__*/testConfigWith(config => core.succeed(config.repeats)`

JSDoc:

The number of times to repeat tests to ensure they are stable.

@since 2.0.0

## make

Source: `my-backend/node_modules/effect/dist/cjs/TestSized.js`

Signature: `make(= make;
const fromFiberRef = fiberRef => new SizedImpl(fiberRef)`

JSDoc:

@since 2.0.0
/

/**
@since 2.0.0
/
const TestSizedTypeId = exports.TestSizedTypeId = /*#__PURE__*/Symbol.for("effect/TestSized");
/**
@since 2.0.0
/
const TestSized = exports.TestSized = /*#__PURE__*/Context.GenericTag("effect/TestSized");
/** @internal */
class SizedImpl {
  fiberRef;
  [TestSizedTypeId] = TestSizedTypeId;
  constructor(fiberRef) {
    this.fiberRef = fiberRef;
  }
  get size() {
    return core.fiberRefGet(this.fiberRef);
  }
  withSize(size) {
    return effect => core.fiberRefLocally(this.fiberRef, size)(effect);
  }
}
/**
@since 2.0.0
/
const make = size => new SizedImpl(core.fiberRefUnsafeMake(size));
/**
@since 2.0.0

## toEntries

Source: `my-backend/node_modules/effect/dist/cjs/Trie.js`

Signature: `toEntries(= toEntries;
const keysWithPrefix = exports.keysWithPrefix = TR.keysWithPrefix;
/**
 * Returns an `IterableIterator` of the values within the `Trie`
 * that have `prefix` as prefix (`prefix` included if it exists)`

JSDoc:

Creates an empty `Trie`.

@example
```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<string>()

assert.equal(Trie.size(trie), 0)
assert.deepStrictEqual(Array.from(trie), [])
```

@since 2.0.0
@category constructors
/
const empty = exports.empty = TR.empty;
/**
Creates a new `Trie` from an iterable collection of key/value pairs (e.g. `Array<[string, V]>`).

@example
```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const iterable: Array<readonly [string, number]> = [["call", 0], ["me", 1], ["mind", 2], ["mid", 3]]
const trie = Trie.fromIterable(iterable)

// The entries in the `Trie` are extracted in alphabetical order, regardless of the insertion order
assert.deepStrictEqual(Array.from(trie), [["call", 0], ["me", 1], ["mid", 3], ["mind", 2]])
assert.equal(Equal.equals(Trie.make(["call", 0], ["me", 1], ["mind", 2], ["mid", 3]), trie), true)
```

@since 2.0.0
@category constructors
/
const fromIterable = exports.fromIterable = TR.fromIterable;
/**
Constructs a new `Trie` from the specified entries (`[string, V]`).

@example
```ts
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.make(["ca", 0], ["me", 1])

assert.deepStrictEqual(Array.from(trie), [["ca", 0], ["me", 1]])
assert.equal(Equal.equals(Trie.fromIterable([["ca", 0], ["me", 1]]), trie), true)
```

@since 2.0.0
@category constructors
/
const make = exports.make = TR.make;
/**
Insert a new entry in the `Trie`.

@example
```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie1 = Trie.empty<number>().pipe(
  Trie.insert("call", 0)
)
const trie2 = trie1.pipe(Trie.insert("me", 1))
const trie3 = trie2.pipe(Trie.insert("mind", 2))
const trie4 = trie3.pipe(Trie.insert("mid", 3))

assert.deepStrictEqual(Array.from(trie1), [["call", 0]])
assert.deepStrictEqual(Array.from(trie2), [["call", 0], ["me", 1]])
assert.deepStrictEqual(Array.from(trie3), [["call", 0], ["me", 1], ["mind", 2]])
assert.deepStrictEqual(Array.from(trie4), [["call", 0], ["me", 1], ["mid", 3], ["mind", 2]])
```

@since 2.0.0
@category mutations
/
const insert = exports.insert = TR.insert;
/**
Returns an `IterableIterator` of the keys within the `Trie`.

The keys are returned in alphabetical order, regardless of insertion order.

@example
```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("cab", 0),
  Trie.insert("abc", 1),
  Trie.insert("bca", 2)
)

const result = Array.from(Trie.keys(trie))
assert.deepStrictEqual(result, ["abc", "bca", "cab"])
```

@since 2.0.0
@category getters
/
const keys = exports.keys = TR.keys;
/**
Returns an `IterableIterator` of the values within the `Trie`.

Values are ordered based on their key in alphabetical order, regardless of insertion order.

@example
```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("and", 2)
)

const result = Array.from(Trie.values(trie))
assert.deepStrictEqual(result, [2, 0, 1])
```

@since 2.0.0
@category getters
/
const values = exports.values = TR.values;
/**
Returns an `IterableIterator` of the entries within the `Trie`.

The entries are returned by keys in alphabetical order, regardless of insertion order.

@example
```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1)
)

const result = Array.from(Trie.entries(trie))
assert.deepStrictEqual(result, [["call", 0], ["me", 1]])
```

@since 2.0.0
@category getters
/
const entries = exports.entries = TR.entries;
/**
Returns an `Array<[K, V]>` of the entries within the `Trie`.

Equivalent to `Array.from(Trie.entries(trie))`.

@example
```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1)
)
const result = Trie.toEntries(trie)

assert.deepStrictEqual(result, [["call", 0], ["me", 1]])
```

@since 2.0.0
@category getters
/
const toEntries = self => Array.from(entries(self));
/**
Returns an `IterableIterator` of the keys within the `Trie`
that have `prefix` as prefix (`prefix` included if it exists).

@example
```ts
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.keysWithPrefix(trie, "she"))
assert.deepStrictEqual(result, ["she", "shells"])
```

@since 2.0.0
@category getters

## make

Source: `my-backend/node_modules/effect/dist/cjs/Tuple.js`

Signature: `make(= make;
const getFirst = self => self[0];
/**
 * Return the second element of a tuple.
 *
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { getSecond } from "effect/Tuple"
 *
 * assert.deepStrictEqual(getSecond(["hello", 42])`

JSDoc:

This module provides utility functions for working with tuples in TypeScript.

@since 2.0.0
/

/**
Constructs a new tuple from the provided values.

@example
```ts
import * as assert from "node:assert"
import { make } from "effect/Tuple"

assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])
```

@category constructors
@since 2.0.0
/
const make = (...elements) => elements;
/**
Return the first element of a tuple.

@example
```ts
import * as assert from "node:assert"
import { getFirst } from "effect/Tuple"

assert.deepStrictEqual(getFirst(["hello", 42]), "hello")
```

@category getters
@since 2.0.0

## getSecond

Source: `my-backend/node_modules/effect/dist/cjs/Tuple.js`

Signature: `getSecond(= getSecond;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Transforms each element of tuple using the given function, treating tuple homomorphically

@example
```ts
import * as assert from "node:assert"
import { pipe, Tuple } from "effect"

const result = pipe(
  ["a", 1, false] as const,
  Tuple.map((el) => el.toString().toUpperCase())
)
assert.deepStrictEqual(result, ['A', '1', 'FALSE'])
```

@category mapping
@since 3.9.0

## swap

Source: `my-backend/node_modules/effect/dist/cjs/Tuple.js`

Signature: `swap(= swap;
const getEquivalence = exports.getEquivalence = Equivalence.tuple;
/**
 * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
 * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
 * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
 * of the tuple.
 *
 * @category combinators
 * @since 2.0.0
 */
const getOrder = exports.getOrder = order.tuple;
/**
 * Appends an element to the end of a tuple.
 *
 * @category concatenating
 * @since 2.0.0
 */
const appendElement = exports.appendElement = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

Transforms both elements of a tuple using the given functions.

@example
```ts
import * as assert from "node:assert"
import { mapBoth } from "effect/Tuple"

assert.deepStrictEqual(
  mapBoth(["hello", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),
  ["HELLO", "42"]
)
```

@category mapping
@since 2.0.0
/
const mapBoth = exports.mapBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFirst,
  onSecond
}) => [onFirst(self[0]), onSecond(self[1])]);
/**
Transforms the first component of a tuple using a given function.

@example
```ts
import * as assert from "node:assert"
import { mapFirst } from "effect/Tuple"

assert.deepStrictEqual(
  mapFirst(["hello", 42], s => s.toUpperCase()),
  ["HELLO", 42]
)
```

@category mapping
@since 2.0.0
/
const mapFirst = exports.mapFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => [f(self[0]), self[1]]);
/**
Transforms the second component of a tuple using a given function.

@example
```ts
import * as assert from "node:assert"
import { mapSecond } from "effect/Tuple"

assert.deepStrictEqual(
  mapSecond(["hello", 42], n => n.toString()),
  ["hello", "42"]
)
```

@category mapping
@since 2.0.0
/
const mapSecond = exports.mapSecond = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => [self[0], f(self[1])]);
/**
Swaps the two elements of a tuple.

@example
```ts
import * as assert from "node:assert"
import { swap } from "effect/Tuple"

assert.deepStrictEqual(swap(["hello", 42]), [42, "hello"])
```

@since 2.0.0
/
const swap = self => [self[1], self[0]];
/**
Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
by applying each `Equivalence` to the corresponding element of the tuple.

@category combinators
@since 2.0.0

## isGenKind

Source: `my-backend/node_modules/effect/dist/cjs/Utils.js`

Signature: `isGenKind(= isGenKind;
class GenKindImpl {
  value;
  constructor(
  /**
   * @since 2.0.0
   */
  value)`

JSDoc:

@since 2.0.0
/

/*
Copyright 2014 Thom Chiovoloni, released under the MIT license.

A random number generator based on the basic implementation of the PCG algorithm,
as described here: http://www.pcg-random.org/

Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random

forked from https://github.com/frptools

@since 2.0.0
/
/**
@category symbols
@since 2.0.0
/
const GenKindTypeId = exports.GenKindTypeId = /*#__PURE__*/Symbol.for("effect/Gen/GenKind");
/**
@category predicates
@since 3.0.6
/
const isGenKind = u => (0, _Predicate.isObject)(u) && GenKindTypeId in u;
/**
@category constructors
@since 2.0.0

## GenKindImpl

Source: `my-backend/node_modules/effect/dist/cjs/Utils.js`

Signature: `GenKindImpl(= GenKindImpl;
class SingleShotGen {
  self;
  called = false;
  constructor(self)`

JSDoc:

@since 2.0.0
/
  get _F() {
    return _Function.identity;
  }
  /**
@since 2.0.0
/
  get _R() {
    return _ => _;
  }
  /**
@since 2.0.0
/
  get _O() {
    return _ => _;
  }
  /**
@since 2.0.0
/
  get _E() {
    return _ => _;
  }
  /**
@since 2.0.0
/
  [GenKindTypeId] = GenKindTypeId;
  /**
@since 2.0.0
/
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
}
/**
@category constructors
@since 2.0.0

## SingleShotGen

Source: `my-backend/node_modules/effect/dist/cjs/Utils.js`

Signature: `SingleShotGen(= SingleShotGen;
const makeGenKind = kind => new GenKindImpl(kind)`

JSDoc:

@since 2.0.0
/
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
@since 2.0.0
/
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
@since 2.0.0
/
  throw(e) {
    throw e;
  }
  /**
@since 2.0.0
/
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}
/**
@category constructors
@since 2.0.0

## makeGenKind

Source: `my-backend/node_modules/effect/dist/cjs/Utils.js`

Signature: `makeGenKind(= makeGenKind;
const adapter = ()`

JSDoc:

@category adapters
@since 2.0.0

## YieldWrap

Source: `my-backend/node_modules/effect/dist/cjs/Utils.js`

Signature: `YieldWrap(= YieldWrap;
function yieldWrapGet(self)`

JSDoc:

PCG is a family of simple fast space-efficient statistically good algorithms
for random number generation. Unlike many general-purpose RNGs, they are also
hard to predict.

@category model
@since 2.0.0
/
class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if ((0, _Predicate.isNullable)(seedLo) && (0, _Predicate.isNullable)(seedHi)) {
      seedLo = Math.random() * 0xffffffff >>> 0;
      seedHi = 0;
    } else if ((0, _Predicate.isNullable)(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if ((0, _Predicate.isNullable)(incLo) && (0, _Predicate.isNullable)(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if ((0, _Predicate.isNullable)(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
Returns a copy of the internal state of this random number generator as a
JavaScript Array.

@category getters
@since 2.0.0
/
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
Restore state previously retrieved using `getState()`.

@since 2.0.0
/
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
Get a uniformly distributed 32 bit integer between [0, max).

@category getter
@since 2.0.0
/
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  /**
Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
53 bits of precision (every bit of the mantissa is randomized).

@category getters
@since 2.0.0
/
  number() {
    const hi = (this._next() & 0x03ffffff) * 1.0;
    const lo = (this._next() & 0x07ffffff) * 1.0;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    // save current state (what we'll use for this number)
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    // churn LCG.
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    // rotate xorshifted right a random amount, based on the most sig. 5 bits
    // bits of the old state.
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
exports.PCGRandom = PCGRandom;
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;
  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
// add two 64 bit numbers (given in parts), and store the result in `out`.
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
/**
@since 3.0.6
/
const YieldWrapTypeId = exports.YieldWrapTypeId = /*#__PURE__*/Symbol.for("effect/Utils/YieldWrap");
/**
@since 3.0.6
/
class YieldWrap {
  /**
@since 3.0.6
/
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
@since 3.0.6
/
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
/**
@since 3.0.6

## par

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `par(= par;
const seq = (self, that)`

JSDoc:

@internal */
const empty = exports.empty = {
  _tag: "Empty"
};
/**
Combines this collection of blocked requests with the specified collection
of blocked requests, in parallel.

@internal
/
const par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
/**
Combines this collection of blocked requests with the specified collection
of blocked requests, in sequence.

@internal

## seq

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `seq(= seq;
const single = (dataSource, blockedRequest)`

JSDoc:

Constructs a collection of blocked requests from the specified blocked
request and data source.

@internal

## single

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `single(= single;
const MapRequestResolversReducer = f => ({
  emptyCase: ()`

JSDoc:

@internal

## MapRequestResolversReducer

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `MapRequestResolversReducer(= MapRequestResolversReducer;
const mapRequestResolvers = (self, f)`

JSDoc:

Transforms all data sources with the specified data source aspect, which
can change the environment type of data sources but must preserve the
request type of each data source.

@internal

## mapRequestResolvers

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `mapRequestResolvers(= mapRequestResolvers;
const reduce = (self, reducer)`

JSDoc:

Folds over the cases of this collection of blocked requests with the
specified functions.

@internal

## reduce

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `reduce(= reduce;
const flatten = self => {
  let current = List.of(self)`

JSDoc:

Flattens a collection of blocked requests into a collection of pipelined
and batched requests that can be submitted for execution.

@internal

## flatten

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `flatten(= flatten;
const step = requests => {
  let current = requests;
  let parallel = parallelCollectionEmpty()`

JSDoc:

Takes one step in evaluating a collection of blocked requests, returning a
collection of blocked requests that can be performed in parallel and a list
of blocked requests that must be performed sequentially after those
requests.

## isEntry

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `isEntry(= isEntry;
const makeEntry = options => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state)`

JSDoc:

Merges a collection of requests that must be executed sequentially with a
collection of requests that can be executed in parallel. If the collections
are both from the same single data source then the requests can be
pipelined while preserving ordering guarantees.
/
const merge = (sequential, parallel) => {
  if (List.isNil(sequential)) {
    return List.of(parallelCollectionToSequentialCollection(parallel));
  }
  if (parallelCollectionIsEmpty(parallel)) {
    return sequential;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential.head);
  const parKeys = parallelCollectionKeys(parallel);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && Equal.equals(seqHeadKeys[0], parKeys[0])) {
    return List.cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
  }
  return List.cons(parallelCollectionToSequentialCollection(parallel), sequential);
};
//
// circular
//
/** @internal */
const EntryTypeId = exports.EntryTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock/Entry");
/** @internal */
class EntryImpl {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request, result, listeners, ownerId, state) {
    this.request = request;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
}
const blockedRequestVariance = {
  /* c8 ignore next */
  _R: _ => _
};
/** @internal */
const isEntry = u => (0, _Predicate.hasProperty)(u, EntryTypeId);
/** @internal

## makeEntry

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `makeEntry(= makeEntry;
const RequestBlockParallelTypeId = exports.RequestBlockParallelTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock/RequestBlockParallel")`

JSDoc:

@internal

## parallelCollectionEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `parallelCollectionEmpty(= parallelCollectionEmpty;
const parallelCollectionMake = (dataSource, blockedRequest)`

JSDoc:

@internal */
const parallelCollectionEmpty = () => new ParallelImpl(HashMap.empty());
/** @internal

## parallelCollectionMake

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `parallelCollectionMake(= parallelCollectionMake;
const parallelCollectionAdd = (self, blockedRequest)`

JSDoc:

@internal

## parallelCollectionAdd

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `parallelCollectionAdd(= parallelCollectionAdd;
const parallelCollectionCombine = (self, that)`

JSDoc:

@internal

## parallelCollectionCombine

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `parallelCollectionCombine(= parallelCollectionCombine;
const parallelCollectionIsEmpty = self => HashMap.isEmpty(self.map)`

JSDoc:

@internal

## parallelCollectionIsEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `parallelCollectionIsEmpty(= parallelCollectionIsEmpty;
const parallelCollectionKeys = self => Array.from(HashMap.keys(self.map)`

JSDoc:

@internal

## parallelCollectionKeys

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `parallelCollectionKeys(= parallelCollectionKeys;
const parallelCollectionToSequentialCollection = self => sequentialCollectionMake(HashMap.map(self.map, x => Chunk.of(x)`

JSDoc:

@internal

## parallelCollectionToSequentialCollection

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `parallelCollectionToSequentialCollection(= parallelCollectionToSequentialCollection;
const SequentialCollectionTypeId = exports.SequentialCollectionTypeId = /*#__PURE__*/Symbol.for("effect/RequestBlock/RequestBlockSequential")`

JSDoc:

@internal */
// export const parallelCollectionToChunk = <R>(
//   self: ParallelCollection<R>
// ): Array<[RequestResolver.RequestResolver<unknown, R>, Array<Request.Entry<unknown>>]> => Array.from(self.map) as any
/** @internal

## sequentialCollectionMake

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `sequentialCollectionMake(= sequentialCollectionMake;
const sequentialCollectionCombine = (self, that)`

JSDoc:

@internal */
const sequentialCollectionMake = map => new SequentialImpl(map);
/** @internal

## sequentialCollectionCombine

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `sequentialCollectionCombine(= sequentialCollectionCombine;
const sequentialCollectionIsEmpty = self => HashMap.isEmpty(self.map)`

JSDoc:

@internal

## sequentialCollectionIsEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `sequentialCollectionIsEmpty(= sequentialCollectionIsEmpty;
const sequentialCollectionKeys = self => Array.from(HashMap.keys(self.map)`

JSDoc:

@internal

## sequentialCollectionKeys

Source: `my-backend/node_modules/effect/dist/cjs/internal/blockedRequests.js`

Signature: `sequentialCollectionKeys(= sequentialCollectionKeys;
const sequentialCollectionToChunk = self => Array.from(self.map)`

JSDoc:

@internal

## complete

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `complete(= complete;
const pending = (key, deferred)`

JSDoc:

@internal */
const complete = (key, exit, entryStats, timeToLiveMillis) => Data.struct({
  _tag: "Complete",
  key,
  exit,
  entryStats,
  timeToLiveMillis
});
/** @internal

## pending

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `pending(= pending;
const refreshing = (deferred, complete)`

JSDoc:

@internal

## refreshing

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `refreshing(= refreshing;
const MapKeyTypeId = exports.MapKeyTypeId = /*#__PURE__*/Symbol.for("effect/Cache/MapKey")`

JSDoc:

@internal

## makeMapKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `makeMapKey(= makeMapKey;
const isMapKey = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const makeMapKey = current => new MapKeyImpl(current);
/** @internal

## makeKeySet

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `makeKeySet(= makeKeySet;
const makeCacheState = (map, keys, accesses, updating, hits, misses)`

JSDoc:

@internal */
const makeKeySet = () => new KeySetImpl();
/**
Constructs a new `CacheState` from the specified values.

@internal

## makeCacheState

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `makeCacheState(= makeCacheState;
const initialCacheState = ()`

JSDoc:

Constructs an initial cache state.

@internal

## initialCacheState

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `initialCacheState(= initialCacheState;
const CacheSymbolKey = "effect/Cache";
/** @internal */
const CacheTypeId = exports.CacheTypeId = /*#__PURE__*/Symbol.for(CacheSymbolKey)`

JSDoc:

@internal

## makeCacheStats

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `makeCacheStats(= makeCacheStats;
const makeEntryStats = loadedMillis => ({
  loadedMillis
})`

JSDoc:

@internal */
const ConsumerCacheSymbolKey = "effect/ConsumerCache";
/** @internal */
const ConsumerCacheTypeId = exports.ConsumerCacheTypeId = /*#__PURE__*/Symbol.for(ConsumerCacheSymbolKey);
const consumerCacheVariance = {
  /* c8 ignore next */
  _Key: _ => _,
  /* c8 ignore next */
  _Error: _ => _,
  /* c8 ignore next */
  _Value: _ => _
};
/** @internal */
const makeCacheStats = options => options;
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `make(= make;
const makeWith = options => core.map(fiberRuntime.all([core.context()`

JSDoc:

@internal */
const make = options => {
  const timeToLive = Duration.decode(options.timeToLive);
  return makeWith({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
/** @internal

## makeWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/cache.js`

Signature: `makeWith(= makeWith;
const unsafeMakeWith = (capacity, lookup, timeToLive)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `fail(= fail;
const die = defect => {
  const o = Object.create(proto)`

JSDoc:

@internal */
const CauseSymbolKey = "effect/Cause";
/** @internal */
const CauseTypeId = exports.CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);
const variance = {
  /* c8 ignore next */
  _E: _ => _
};
/** @internal */
const proto = {
  [CauseTypeId]: variance,
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(CauseSymbolKey), Hash.combine(Hash.hash(flattenCause(this))), Hash.cached(this));
  },
  [Equal.symbol](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: (0, _Inspectable.toJSON)(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: (0, _Inspectable.toJSON)(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: (0, _Inspectable.toJSON)(this.left),
          right: (0, _Inspectable.toJSON)(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
};
// -----------------------------------------------------------------------------
// Constructors
// -----------------------------------------------------------------------------
/** @internal */
const empty = exports.empty = /*#__PURE__*/(() => {
  const o = /*#__PURE__*/Object.create(proto);
  o._tag = OpCodes.OP_EMPTY;
  return o;
})();
/** @internal */
const fail = error => {
  const o = Object.create(proto);
  o._tag = OpCodes.OP_FAIL;
  o.error = error;
  return o;
};
/** @internal

## die

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `die(= die;
const interrupt = fiberId => {
  const o = Object.create(proto)`

JSDoc:

@internal

## interrupt

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `interrupt(= interrupt;
const parallel = (left, right)`

JSDoc:

@internal

## parallel

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `parallel(= parallel;
const sequential = (left, right)`

JSDoc:

@internal

## sequential

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `sequential(= sequential;
const isCause = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `isCause(= isCause;
const isEmptyType = self => self._tag === OpCodes.OP_EMPTY;
/** @internal */
exports.isEmptyType = isEmptyType;
const isFailType = self => self._tag === OpCodes.OP_FAIL;
/** @internal */
exports.isFailType = isFailType;
const isDieType = self => self._tag === OpCodes.OP_DIE;
/** @internal */
exports.isDieType = isDieType;
const isInterruptType = self => self._tag === OpCodes.OP_INTERRUPT;
/** @internal */
exports.isInterruptType = isInterruptType;
const isSequentialType = self => self._tag === OpCodes.OP_SEQUENTIAL;
/** @internal */
exports.isSequentialType = isSequentialType;
const isParallelType = self => self._tag === OpCodes.OP_PARALLEL;
// -----------------------------------------------------------------------------
// Getters
// -----------------------------------------------------------------------------
/** @internal */
exports.isParallelType = isParallelType;
const size = self => reduceWithContext(self, void 0, SizeCauseReducer)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `size(= size;
const isEmpty = self => {
  if (self._tag === OpCodes.OP_EMPTY)`

JSDoc:

@internal

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `isEmpty(= isEmpty;
const isFailure = self => Option.isSome(failureOption(self)`

JSDoc:

@internal

## isFailure

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `isFailure(= isFailure;
const isDie = self => Option.isSome(dieOption(self)`

JSDoc:

@internal

## isDie

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `isDie(= isDie;
const isInterrupted = self => Option.isSome(interruptOption(self)`

JSDoc:

@internal

## isInterrupted

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `isInterrupted(= isInterrupted;
const isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)`

JSDoc:

@internal

## isInterruptedOnly

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `isInterruptedOnly(= isInterruptedOnly;
const failures = self => Chunk.reverse(reduce(self, Chunk.empty()`

JSDoc:

@internal

## failures

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `failures(= failures;
const defects = self => Chunk.reverse(reduce(self, Chunk.empty()`

JSDoc:

@internal

## defects

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `defects(= defects;
const interruptors = self => reduce(self, HashSet.empty()`

JSDoc:

@internal

## interruptors

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `interruptors(= interruptors;
const failureOption = self => find(self, cause => cause._tag === OpCodes.OP_FAIL ? Option.some(cause.error)`

JSDoc:

@internal

## failureOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `failureOption(= failureOption;
const failureOrCause = self => {
  const option = failureOption(self)`

JSDoc:

@internal

## failureOrCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `failureOrCause(= failureOrCause;
const dieOption = self => find(self, cause => cause._tag === OpCodes.OP_DIE ? Option.some(cause.defect)`

JSDoc:

@internal

## dieOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `dieOption(= dieOption;
const flipCauseOption = self => match(self, {
  onEmpty: Option.some(empty)`

JSDoc:

@internal

## flipCauseOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `flipCauseOption(= flipCauseOption;
const interruptOption = self => find(self, cause => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(cause.fiberId)`

JSDoc:

@internal

## interruptOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `interruptOption(= interruptOption;
const keepDefects = self => match(self, {
  onEmpty: Option.none()`

JSDoc:

@internal

## keepDefects

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `keepDefects(= keepDefects;
const keepDefectsAndElectFailures = self => match(self, {
  onEmpty: Option.none()`

JSDoc:

@internal

## keepDefectsAndElectFailures

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `keepDefectsAndElectFailures(= keepDefectsAndElectFailures;
const linearize = self => match(self, {
  onEmpty: HashSet.empty()`

JSDoc:

@internal

## linearize

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `linearize(= linearize;
const stripFailures = self => match(self, {
  onEmpty: empty,
  onFail: ()`

JSDoc:

@internal

## stripFailures

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `stripFailures(= stripFailures;
const electFailures = self => match(self, {
  onEmpty: empty,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
})`

JSDoc:

@internal

## electFailures

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `electFailures(= electFailures;
const stripSomeDefects = exports.stripSomeDefects = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## flatten

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `flatten(= flatten;
const andThen = exports.andThen = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const as = exports.as = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => map(self, () => error));
/** @internal */
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => flatMap(self, e => fail(f(e))));
// -----------------------------------------------------------------------------
// Sequencing
// -----------------------------------------------------------------------------
/** @internal */
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => match(self, {
  onEmpty: empty,
  onFail: error => f(error),
  onDie: defect => die(defect),
  onInterrupt: fiberId => interrupt(fiberId),
  onSequential: (left, right) => sequential(left, right),
  onParallel: (left, right) => parallel(left, right)
}));
/** @internal */
const flatten = self => flatMap(self, _Function.identity);
/** @internal

## PrettyError

Source: `my-backend/node_modules/effect/dist/cjs/internal/cause.js`

Signature: `PrettyError(= PrettyError;
const prettyErrorMessage = u => {
  // 1)`

JSDoc:

@internal */
const contains = exports.contains = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (that._tag === OpCodes.OP_EMPTY || self === that) {
    return true;
  }
  return reduce(self, false, (accumulator, cause) => {
    return Option.some(accumulator || causeEquals(cause, that));
  });
});
/** @internal */
const causeEquals = (left, right) => {
  let leftStack = Chunk.of(left);
  let rightStack = Chunk.of(right);
  while (Chunk.isNonEmpty(leftStack) && Chunk.isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = (0, _Function.pipe)(Chunk.headNonEmpty(leftStack), reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return Option.some([(0, _Function.pipe)(parallel, HashSet.union(par)), (0, _Function.pipe)(sequential, Chunk.appendAll(seq))]);
    }));
    const [rightParallel, rightSequential] = (0, _Function.pipe)(Chunk.headNonEmpty(rightStack), reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return Option.some([(0, _Function.pipe)(parallel, HashSet.union(par)), (0, _Function.pipe)(sequential, Chunk.appendAll(seq))]);
    }));
    if (!Equal.equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
// -----------------------------------------------------------------------------
// Flattening
// -----------------------------------------------------------------------------
/**
Flattens a cause to a sequence of sets of causes, where each set represents
causes that fail in parallel and sequential sets represent causes that fail
after each other.

@internal
/
const flattenCause = cause => {
  return flattenCauseLoop(Chunk.of(cause), Chunk.empty());
};
/** @internal */
const flattenCauseLoop = (causes, flattened) => {
  // eslint-disable-next-line no-constant-condition
  while (1) {
    const [parallel, sequential] = (0, _Function.pipe)(causes, Arr.reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {
      const [par, seq] = evaluateCause(cause);
      return [(0, _Function.pipe)(parallel, HashSet.union(par)), (0, _Function.pipe)(sequential, Chunk.appendAll(seq))];
    }));
    const updated = HashSet.size(parallel) > 0 ? (0, _Function.pipe)(flattened, Chunk.prepend(parallel)) : flattened;
    if (Chunk.isEmpty(sequential)) {
      return Chunk.reverse(updated);
    }
    causes = sequential;
    flattened = updated;
  }
  throw new Error((0, _errors.getBugErrorMessage)("Cause.flattenCauseLoop"));
};
// -----------------------------------------------------------------------------
// Finding
// -----------------------------------------------------------------------------
/** @internal */
const find = exports.find = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option = pf(item);
    switch (option._tag) {
      case "None":
        {
          switch (item._tag) {
            case OpCodes.OP_SEQUENTIAL:
            case OpCodes.OP_PARALLEL:
              {
                stack.push(item.right);
                stack.push(item.left);
                break;
              }
          }
          break;
        }
      case "Some":
        {
          return option;
        }
    }
  }
  return Option.none();
});
// -----------------------------------------------------------------------------
// Filtering
// -----------------------------------------------------------------------------
/** @internal */
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));
// -----------------------------------------------------------------------------
// Evaluation
// -----------------------------------------------------------------------------
/**
Takes one step in evaluating a cause, returning a set of causes that fail
in parallel and a list of causes that fail sequentially after those causes.

@internal
/
const evaluateCause = self => {
  let cause = self;
  const stack = [];
  let _parallel = HashSet.empty();
  let _sequential = Chunk.empty();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OpCodes.OP_EMPTY:
        {
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OpCodes.OP_FAIL:
        {
          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.error));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OpCodes.OP_DIE:
        {
          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.defect));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OpCodes.OP_INTERRUPT:
        {
          _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.fiberId));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
      case OpCodes.OP_SEQUENTIAL:
        {
          switch (cause.left._tag) {
            case OpCodes.OP_EMPTY:
              {
                cause = cause.right;
                break;
              }
            case OpCodes.OP_SEQUENTIAL:
              {
                cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
                break;
              }
            case OpCodes.OP_PARALLEL:
              {
                cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
                break;
              }
            default:
              {
                _sequential = Chunk.prepend(_sequential, cause.right);
                cause = cause.left;
                break;
              }
          }
          break;
        }
      case OpCodes.OP_PARALLEL:
        {
          stack.push(cause.right);
          cause = cause.left;
          break;
        }
    }
  }
  throw new Error((0, _errors.getBugErrorMessage)("Cause.evaluateCauseLoop"));
};
// -----------------------------------------------------------------------------
// Reducing
// -----------------------------------------------------------------------------
/** @internal */
const SizeCauseReducer = {
  emptyCase: () => 0,
  failCase: () => 1,
  dieCase: () => 1,
  interruptCase: () => 1,
  sequentialCase: (_, left, right) => left + right,
  parallelCase: (_, left, right) => left + right
};
/** @internal */
const IsInterruptedOnlyCauseReducer = {
  emptyCase: _Function.constTrue,
  failCase: _Function.constFalse,
  dieCase: _Function.constFalse,
  interruptCase: _Function.constTrue,
  sequentialCase: (_, left, right) => left && right,
  parallelCase: (_, left, right) => left && right
};
/** @internal */
const FilterCauseReducer = predicate => ({
  emptyCase: () => empty,
  failCase: (_, error) => fail(error),
  dieCase: (_, defect) => die(defect),
  interruptCase: (_, fiberId) => interrupt(fiberId),
  sequentialCase: (_, left, right) => {
    if (predicate(left)) {
      if (predicate(right)) {
        return sequential(left, right);
      }
      return left;
    }
    if (predicate(right)) {
      return right;
    }
    return empty;
  },
  parallelCase: (_, left, right) => {
    if (predicate(left)) {
      if (predicate(right)) {
        return parallel(left, right);
      }
      return left;
    }
    if (predicate(right)) {
      return right;
    }
    return empty;
  }
});
const OP_SEQUENTIAL_CASE = "SequentialCase";
const OP_PARALLEL_CASE = "ParallelCase";
/** @internal */
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error) => onFail(error),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId) => onInterrupt(fiberId),
    sequentialCase: (_, left, right) => onSequential(left, right),
    parallelCase: (_, left, right) => onParallel(left, right)
  });
});
/** @internal */
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, pf) => {
  let accumulator = zero;
  let cause = self;
  const causes = [];
  while (cause !== undefined) {
    const option = pf(accumulator, cause);
    accumulator = Option.isSome(option) ? option.value : accumulator;
    switch (cause._tag) {
      case OpCodes.OP_SEQUENTIAL:
        {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
      case OpCodes.OP_PARALLEL:
        {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
      default:
        {
          cause = undefined;
          break;
        }
    }
    if (cause === undefined && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
/** @internal */
const reduceWithContext = exports.reduceWithContext = /*#__PURE__*/(0, _Function.dual)(3, (self, context, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OpCodes.OP_EMPTY:
        {
          output.push(Either.right(reducer.emptyCase(context)));
          break;
        }
      case OpCodes.OP_FAIL:
        {
          output.push(Either.right(reducer.failCase(context, cause.error)));
          break;
        }
      case OpCodes.OP_DIE:
        {
          output.push(Either.right(reducer.dieCase(context, cause.defect)));
          break;
        }
      case OpCodes.OP_INTERRUPT:
        {
          output.push(Either.right(reducer.interruptCase(context, cause.fiberId)));
          break;
        }
      case OpCodes.OP_SEQUENTIAL:
        {
          input.push(cause.right);
          input.push(cause.left);
          output.push(Either.left({
            _tag: OP_SEQUENTIAL_CASE
          }));
          break;
        }
      case OpCodes.OP_PARALLEL:
        {
          input.push(cause.right);
          input.push(cause.left);
          output.push(Either.left({
            _tag: OP_PARALLEL_CASE
          }));
          break;
        }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either = output.pop();
    switch (either._tag) {
      case "Left":
        {
          switch (either.left._tag) {
            case OP_SEQUENTIAL_CASE:
              {
                const left = accumulator.pop();
                const right = accumulator.pop();
                const value = reducer.sequentialCase(context, left, right);
                accumulator.push(value);
                break;
              }
            case OP_PARALLEL_CASE:
              {
                const left = accumulator.pop();
                const right = accumulator.pop();
                const value = reducer.parallelCase(context, left, right);
                accumulator.push(value);
                break;
              }
          }
          break;
        }
      case "Right":
        {
          accumulator.push(either.right);
          break;
        }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
// -----------------------------------------------------------------------------
// Pretty Printing
// -----------------------------------------------------------------------------
/** @internal */
const pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function (e) {
    if (options?.renderErrorCause !== true || e.cause === undefined) {
      return e.stack;
    }
    return `${e.stack} {\n${renderErrorCause(e.cause, "  ")}\n}`;
  }).join("\n");
};
exports.pretty = pretty;
const renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `\n${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {\n${renderErrorCause(cause.cause, `${prefix}  `)}\n${prefix}}`;
  }
  return stack;
};
/** @internal */
class PrettyError extends globalThis.Error {
  span = undefined;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new PrettyError(originalError.cause)
    } : undefined);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach(key => {
        if (!(key in this)) {
          // @ts-expect-error
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
}
/**
A utility function for generating human-readable error messages from a generic error of type `unknown`.

Rules:

1) If the input `u` is already a string, it's considered a message.
2) If `u` is an Error instance with a message defined, it uses the message.
3) If `u` has a user-defined `toString()` method, it uses that method.
4) Otherwise, it uses `Inspectable.stringifyCircular` to produce a string representation and uses it as the error message,
  with "Error" added as a prefix.

@internal

## readUpstream

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/channelExecutor.js`

Signature: `readUpstream(= readUpstream;
const runIn = exports.runIn = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
class ChannelExecutor {
  _activeSubexecutor = undefined;
  _cancelled = undefined;
  _closeLastSubstream = undefined;
  _currentChannel;
  _done = undefined;
  _doneStack = [];
  _emitted = undefined;
  _executeCloseLastSubstream;
  _input = undefined;
  _inProgressFinalizer = undefined;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = undefined;
    while (result === undefined) {
      if (this._cancelled !== undefined) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== undefined) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === undefined) {
            result = ChannelState.Done();
          } else {
            if (Effect.isEffect(this._currentChannel)) {
              this._currentChannel = core.fromEffect(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case ChannelOpCodes.OP_BRACKET_OUT:
                {
                  result = this.runBracketOut(this._currentChannel);
                  break;
                }
              case ChannelOpCodes.OP_BRIDGE:
                {
                  const bridgeInput = this._currentChannel.input;
                  // PipeTo(left, Bridge(queue, channel))
                  // In a fiber: repeatedly run left and push its outputs to the queue
                  // Add a finalizer to interrupt the fiber and close the executor
                  this._currentChannel = this._currentChannel.channel;
                  if (this._input !== undefined) {
                    const inputExecutor = this._input;
                    this._input = undefined;
                    const drainer = () => Effect.flatMap(bridgeInput.awaitRead(), () => Effect.suspend(() => {
                      const state = inputExecutor.run();
                      switch (state._tag) {
                        case ChannelStateOpCodes.OP_DONE:
                          {
                            return Exit.match(inputExecutor.getDone(), {
                              onFailure: cause => bridgeInput.error(cause),
                              onSuccess: value => bridgeInput.done(value)
                            });
                          }
                        case ChannelStateOpCodes.OP_EMIT:
                          {
                            return Effect.flatMap(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                          }
                        case ChannelStateOpCodes.OP_FROM_EFFECT:
                          {
                            return Effect.matchCauseEffect(state.effect, {
                              onFailure: cause => bridgeInput.error(cause),
                              onSuccess: () => drainer()
                            });
                          }
                        case ChannelStateOpCodes.OP_READ:
                          {
                            return readUpstream(state, () => drainer(), cause => bridgeInput.error(cause));
                          }
                      }
                    }));
                    result = ChannelState.fromEffect(Effect.flatMap(Effect.forkDaemon(Effect.interruptible(drainer())), fiber => Effect.sync(() => this.addFinalizer(exit => Effect.flatMap(Fiber.interrupt(fiber), () => Effect.suspend(() => {
                      const effect = this.restorePipe(exit, inputExecutor);
                      return effect !== undefined ? effect : Effect.void;
                    }))))));
                  }
                  break;
                }
              case ChannelOpCodes.OP_CONCAT_ALL:
                {
                  const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, effect => Effect.sync(() => {
                    const prevLastClose = this._closeLastSubstream === undefined ? Effect.void : this._closeLastSubstream;
                    this._closeLastSubstream = (0, _Function.pipe)(prevLastClose, Effect.zipRight(effect));
                  }));
                  executor._input = this._input;
                  const channel = this._currentChannel;
                  this._activeSubexecutor = new Subexecutor.PullFromUpstream(executor, value => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), request => channel.onPull(request), value => channel.onEmit(value));
                  this._closeLastSubstream = undefined;
                  this._currentChannel = undefined;
                  break;
                }
              case ChannelOpCodes.OP_EMIT:
                {
                  this._emitted = this._currentChannel.out;
                  this._currentChannel = this._activeSubexecutor !== undefined ? undefined : core.void;
                  result = ChannelState.Emit();
                  break;
                }
              case ChannelOpCodes.OP_ENSURING:
                {
                  this.runEnsuring(this._currentChannel);
                  break;
                }
              case ChannelOpCodes.OP_FAIL:
                {
                  result = this.doneHalt(this._currentChannel.error());
                  break;
                }
              case ChannelOpCodes.OP_FOLD:
                {
                  this._doneStack.push(this._currentChannel.k);
                  this._currentChannel = this._currentChannel.channel;
                  break;
                }
              case ChannelOpCodes.OP_FROM_EFFECT:
                {
                  const effect = this._providedEnv === undefined ? this._currentChannel.effect() : (0, _Function.pipe)(this._currentChannel.effect(), Effect.provide(this._providedEnv));
                  result = ChannelState.fromEffect(Effect.matchCauseEffect(effect, {
                    onFailure: cause => {
                      const state = this.doneHalt(cause);
                      return state !== undefined && ChannelState.isFromEffect(state) ? state.effect : Effect.void;
                    },
                    onSuccess: value => {
                      const state = this.doneSucceed(value);
                      return state !== undefined && ChannelState.isFromEffect(state) ? state.effect : Effect.void;
                    }
                  }));
                  break;
                }
              case ChannelOpCodes.OP_PIPE_TO:
                {
                  const previousInput = this._input;
                  const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, effect => this._executeCloseLastSubstream(effect));
                  leftExec._input = previousInput;
                  this._input = leftExec;
                  this.addFinalizer(exit => {
                    const effect = this.restorePipe(exit, previousInput);
                    return effect !== undefined ? effect : Effect.void;
                  });
                  this._currentChannel = this._currentChannel.right();
                  break;
                }
              case ChannelOpCodes.OP_PROVIDE:
                {
                  const previousEnv = this._providedEnv;
                  this._providedEnv = this._currentChannel.context();
                  this._currentChannel = this._currentChannel.inner;
                  this.addFinalizer(() => Effect.sync(() => {
                    this._providedEnv = previousEnv;
                  }));
                  break;
                }
              case ChannelOpCodes.OP_READ:
                {
                  const read = this._currentChannel;
                  result = ChannelState.Read(this._input, _Function.identity, emitted => {
                    try {
                      this._currentChannel = read.more(emitted);
                    } catch (error) {
                      this._currentChannel = read.done.onExit(Exit.die(error));
                    }
                    return undefined;
                  }, exit => {
                    const onExit = exit => {
                      return read.done.onExit(exit);
                    };
                    this._currentChannel = onExit(exit);
                    return undefined;
                  });
                  break;
                }
              case ChannelOpCodes.OP_SUCCEED:
                {
                  result = this.doneSucceed(this._currentChannel.evaluate());
                  break;
                }
              case ChannelOpCodes.OP_SUCCEED_NOW:
                {
                  result = this.doneSucceed(this._currentChannel.terminal);
                  break;
                }
              case ChannelOpCodes.OP_SUSPEND:
                {
                  this._currentChannel = this._currentChannel.channel();
                  break;
                }
            }
          }
        } catch (error) {
          this._currentChannel = core.failCause(Cause.die(error));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit) {
    this._cancelled = exit;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = undefined;
  }
  storeInProgressFinalizer(finalizer) {
    this._inProgressFinalizer = finalizer;
  }
  popAllFinalizers(exit) {
    const finalizers = [];
    let next = this._doneStack.pop();
    while (next) {
      if (next._tag === "ContinuationFinalizer") {
        finalizers.push(next.finalizer);
      }
      next = this._doneStack.pop();
    }
    const effect = finalizers.length === 0 ? Effect.void : runFinalizers(finalizers, exit);
    this.storeInProgressFinalizer(effect);
    return effect;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === ContinuationOpCodes.OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== undefined) {
      const effect = currInput.close(exit);
      return effect;
    }
    return Effect.void;
  }
  close(exit) {
    let runInProgressFinalizers = undefined;
    const finalizer = this._inProgressFinalizer;
    if (finalizer !== undefined) {
      runInProgressFinalizers = (0, _Function.pipe)(finalizer, Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = undefined;
    const selfFinalizers = this.popAllFinalizers(exit);
    if (selfFinalizers !== undefined) {
      closeSelf = (0, _Function.pipe)(selfFinalizers, Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit);
    if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {
      return undefined;
    }
    return (0, _Function.pipe)(Effect.exit(ifNotNull(closeSubexecutors)), Effect.zip(Effect.exit(ifNotNull(runInProgressFinalizers))), Effect.zip(Effect.exit(ifNotNull(closeSelf))), Effect.map(([[exit1, exit2], exit3]) => (0, _Function.pipe)(exit1, Exit.zipRight(exit2), Exit.zipRight(exit3))), Effect.uninterruptible,
    // TODO: remove
    Effect.flatMap(exit => Effect.suspend(() => exit)));
  }
  doneSucceed(value) {
    if (this._doneStack.length === 0) {
      this._done = Exit.succeed(value);
      this._currentChannel = undefined;
      return ChannelState.Done();
    }
    const head = this._doneStack[this._doneStack.length - 1];
    if (head._tag === ContinuationOpCodes.OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head.onSuccess(value);
      return undefined;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = Exit.succeed(value);
      this._currentChannel = undefined;
      return ChannelState.Done();
    }
    const finalizerEffect = runFinalizers(finalizers.map(f => f.finalizer), Exit.succeed(value));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect = (0, _Function.pipe)(finalizerEffect, Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer())), Effect.uninterruptible, Effect.flatMap(() => Effect.sync(() => this.doneSucceed(value))));
    return ChannelState.fromEffect(effect);
  }
  doneHalt(cause) {
    if (this._doneStack.length === 0) {
      this._done = Exit.failCause(cause);
      this._currentChannel = undefined;
      return ChannelState.Done();
    }
    const head = this._doneStack[this._doneStack.length - 1];
    if (head._tag === ContinuationOpCodes.OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head.onHalt(cause);
      } catch (error) {
        this._currentChannel = core.failCause(Cause.die(error));
      }
      return undefined;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = Exit.failCause(cause);
      this._currentChannel = undefined;
      return ChannelState.Done();
    }
    const finalizerEffect = runFinalizers(finalizers.map(f => f.finalizer), Exit.failCause(cause));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect = (0, _Function.pipe)(finalizerEffect, Effect.ensuring(Effect.sync(() => this.clearInProgressFinalizer())), Effect.uninterruptible, Effect.flatMap(() => Effect.sync(() => this.doneHalt(cause))));
    return ChannelState.fromEffect(effect);
  }
  processCancellation() {
    this._currentChannel = undefined;
    this._done = this._cancelled;
    this._cancelled = undefined;
    return ChannelState.Done();
  }
  runBracketOut(bracketOut) {
    const effect = Effect.uninterruptible(Effect.matchCauseEffect(this.provide(bracketOut.acquire()), {
      onFailure: cause => Effect.sync(() => {
        this._currentChannel = core.failCause(cause);
      }),
      onSuccess: out => Effect.sync(() => {
        this.addFinalizer(exit => this.provide(bracketOut.finalizer(out, exit)));
        this._currentChannel = core.write(out);
      })
    }));
    return ChannelState.fromEffect(effect);
  }
  provide(effect) {
    if (this._providedEnv === undefined) {
      return effect;
    }
    return (0, _Function.pipe)(effect, Effect.provide(this._providedEnv));
  }
  runEnsuring(ensuring) {
    this.addFinalizer(ensuring.finalizer);
    this._currentChannel = ensuring.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new Continuation.ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case Subexecutor.OP_PULL_FROM_CHILD:
        {
          return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
        }
      case Subexecutor.OP_PULL_FROM_UPSTREAM:
        {
          return this.pullFromUpstream(subexecutor);
        }
      case Subexecutor.OP_DRAIN_CHILD_EXECUTORS:
        {
          return this.drainChildExecutors(subexecutor);
        }
      case Subexecutor.OP_EMIT:
        {
          this._emitted = subexecutor.value;
          this._activeSubexecutor = subexecutor.next;
          return ChannelState.Emit();
        }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = undefined;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit) {
    const state = Exit.match(exit, {
      onFailure: cause => this.doneHalt(cause),
      onSuccess: value => this.doneSucceed(value)
    });
    this._activeSubexecutor = undefined;
    return state === undefined ? Effect.void : ChannelState.effect(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => (0, _Function.pipe)(closeFuncs, Effect.forEach(closeFunc => (0, _Function.pipe)(Effect.sync(() => closeFunc(subexecutorDone)), Effect.flatMap(closeEffect => closeEffect !== undefined ? closeEffect : Effect.void)), {
      discard: true
    })));
    const state = (0, _Function.pipe)(subexecutorDone, Exit.match({
      onFailure: cause => this.doneHalt(cause),
      onSuccess: value => this.doneSucceed(value)
    }));
    this._activeSubexecutor = undefined;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case UpstreamPullStrategyOpCodes.OP_PULL_AFTER_NEXT:
        {
          const shouldPrepend = !upstreamFinished || queue.some(subexecutor => subexecutor !== undefined);
          return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];
        }
      case UpstreamPullStrategyOpCodes.OP_PULL_AFTER_ALL_ENQUEUED:
        {
          const shouldEnqueue = !upstreamFinished || queue.some(subexecutor => subexecutor !== undefined);
          return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];
        }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return ChannelState.Read(childExecutor, _Function.identity, emitted => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case ChildExecutorDecisionOpCodes.OP_CONTINUE:
          {
            break;
          }
        case ChildExecutorDecisionOpCodes.OP_CLOSE:
          {
            this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
            break;
          }
        case ChildExecutorDecisionOpCodes.OP_YIELD:
          {
            const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
            this.replaceSubexecutor(modifiedParent);
            break;
          }
      }
      this._activeSubexecutor = new Subexecutor.Emit(emitted, this._activeSubexecutor);
      return undefined;
    }, Exit.match({
      onFailure: cause => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause);
        return state === undefined ? undefined : ChannelState.effectOrUndefinedIgnored(state);
      },
      onSuccess: doneValue => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return undefined;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case Subexecutor.OP_PULL_FROM_UPSTREAM:
        {
          const modifiedParent = new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
          this._closeLastSubstream = childExecutor.close(Exit.succeed(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      case Subexecutor.OP_DRAIN_CHILD_EXECUTORS:
        {
          const modifiedParent = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
          this._closeLastSubstream = childExecutor.close(Exit.succeed(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      default:
        {
          break;
        }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause) {
    return this.finishSubexecutorWithCloseEffect(Exit.failCause(cause), exit => parentSubexecutor.close(exit), exit => childExecutor.close(exit));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === undefined) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new Subexecutor.PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return undefined;
  }
  performPullFromUpstream(subexecutor) {
    return ChannelState.Read(subexecutor.upstreamExecutor, effect => {
      const closeLastSubstream = this._closeLastSubstream === undefined ? Effect.void : this._closeLastSubstream;
      this._closeLastSubstream = undefined;
      return (0, _Function.pipe)(this._executeCloseLastSubstream(closeLastSubstream), Effect.zipRight(effect));
    }, emitted => {
      if (this._closeLastSubstream !== undefined) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = undefined;
        return (0, _Function.pipe)(this._executeCloseLastSubstream(closeLastSubstream), Effect.map(() => {
          const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor._input = this._input;
          const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(upstreamPullRequest.Pulled(emitted)));
          this._activeSubexecutor = new Subexecutor.PullFromChild(childExecutor, new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (Option.isSome(emitSeparator)) {
            this._activeSubexecutor = new Subexecutor.Emit(emitSeparator.value, this._activeSubexecutor);
          }
          return undefined;
        }));
      }
      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(upstreamPullRequest.Pulled(emitted)));
      this._activeSubexecutor = new Subexecutor.PullFromChild(childExecutor, new Subexecutor.PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (Option.isSome(emitSeparator)) {
        this._activeSubexecutor = new Subexecutor.Emit(emitSeparator.value, this._activeSubexecutor);
      }
      return undefined;
    }, exit => {
      if (subexecutor.activeChildExecutors.some(subexecutor => subexecutor !== undefined)) {
        const drain = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== undefined) {
          const closeLastSubstream = this._closeLastSubstream;
          this._closeLastSubstream = undefined;
          return (0, _Function.pipe)(this._executeCloseLastSubstream(closeLastSubstream), Effect.map(() => this.replaceSubexecutor(drain)));
        }
        this.replaceSubexecutor(drain);
        return undefined;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect((0, _Function.pipe)(exit, Exit.map(a => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, exit => subexecutor.upstreamExecutor.close(exit));
      return state === undefined ? undefined :
      // NOTE: assuming finalizers cannot fail
      ChannelState.effectOrUndefinedIgnored(state);
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== undefined) {
        this.addFinalizer(() => Effect.succeed(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, exit => subexecutor.upstreamExecutor.close(exit));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === undefined) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(upstreamPullRequest.NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));
      this.replaceSubexecutor(new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (Option.isSome(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return ChannelState.Emit();
      }
      return undefined;
    }
    const parentSubexecutor = new Subexecutor.DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new Subexecutor.PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return undefined;
  }
}
exports.ChannelExecutor = ChannelExecutor;
const ifNotNull = effect => effect !== undefined ? effect : Effect.void;
const runFinalizers = (finalizers, exit) => {
  return (0, _Function.pipe)(Effect.forEach(finalizers, fin => Effect.exit(fin(exit))), Effect.map(exits => (0, _Function.pipe)(Exit.all(exits), Option.getOrElse(() => Exit.void))), Effect.flatMap(exit => Effect.suspend(() => exit)));
};
/**
@internal
/
const readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read = () => {
    const current = readStack.pop();
    if (current === undefined || current.upstream === undefined) {
      return Effect.dieMessage("Unexpected end of input for channel execution");
    }
    const state = current.upstream.run();
    switch (state._tag) {
      case ChannelStateOpCodes.OP_EMIT:
        {
          const emitEffect = current.onEmit(current.upstream.getEmit());
          if (readStack.length === 0) {
            if (emitEffect === undefined) {
              return Effect.suspend(onSuccess);
            }
            return (0, _Function.pipe)(emitEffect, Effect.matchCauseEffect({
              onFailure,
              onSuccess
            }));
          }
          if (emitEffect === undefined) {
            return Effect.suspend(() => read());
          }
          return (0, _Function.pipe)(emitEffect, Effect.matchCauseEffect({
            onFailure,
            onSuccess: () => read()
          }));
        }
      case ChannelStateOpCodes.OP_DONE:
        {
          const doneEffect = current.onDone(current.upstream.getDone());
          if (readStack.length === 0) {
            if (doneEffect === undefined) {
              return Effect.suspend(onSuccess);
            }
            return (0, _Function.pipe)(doneEffect, Effect.matchCauseEffect({
              onFailure,
              onSuccess
            }));
          }
          if (doneEffect === undefined) {
            return Effect.suspend(() => read());
          }
          return (0, _Function.pipe)(doneEffect, Effect.matchCauseEffect({
            onFailure,
            onSuccess: () => read()
          }));
        }
      case ChannelStateOpCodes.OP_FROM_EFFECT:
        {
          readStack.push(current);
          return (0, _Function.pipe)(current.onEffect(state.effect), Effect.catchAllCause(cause => Effect.suspend(() => {
            const doneEffect = current.onDone(Exit.failCause(cause));
            return doneEffect === undefined ? Effect.void : doneEffect;
          })), Effect.matchCauseEffect({
            onFailure,
            onSuccess: () => read()
          }));
        }
      case ChannelStateOpCodes.OP_READ:
        {
          readStack.push(current);
          readStack.push(state);
          return Effect.suspend(() => read());
        }
    }
  };
  return read();
};
/** @internal

## Done

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/channelState.js`

Signature: `Done(= Done;
const Emit = ()`

JSDoc:

@internal */
const ChannelStateTypeId = exports.ChannelStateTypeId = /*#__PURE__*/Symbol.for("effect/ChannelState");
const channelStateVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
/** @internal */
const proto = {
  [ChannelStateTypeId]: channelStateVariance
};
/** @internal */
const Done = () => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_DONE;
  return op;
};
/** @internal

## Emit

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/channelState.js`

Signature: `Emit(= Emit;
const fromEffect = effect => {
  const op = Object.create(proto)`

JSDoc:

@internal

## fromEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/channelState.js`

Signature: `fromEffect(= fromEffect;
const Read = (upstream, onEffect, onEmit, onDone)`

JSDoc:

@internal

## Read

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/channelState.js`

Signature: `Read(= Read;
const isChannelState = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isChannelState

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/channelState.js`

Signature: `isChannelState(= isChannelState;
const isDone = self => self._tag === OpCodes.OP_DONE;
/** @internal */
exports.isDone = isDone;
const isEmit = self => self._tag === OpCodes.OP_EMIT;
/** @internal */
exports.isEmit = isEmit;
const isFromEffect = self => self._tag === OpCodes.OP_FROM_EFFECT;
/** @internal */
exports.isFromEffect = isFromEffect;
const isRead = self => self._tag === OpCodes.OP_READ;
/** @internal */
exports.isRead = isRead;
const effect = self => isFromEffect(self)`

JSDoc:

@internal

## effect

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/channelState.js`

Signature: `effect(= effect;
const effectOrUndefinedIgnored = self => isFromEffect(self)`

JSDoc:

@internal

## Continue

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/childExecutorDecision.js`

Signature: `Continue(= Continue;
const Close = value => {
  const op = Object.create(proto)`

JSDoc:

@internal */
const ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
/** @internal */
const ChildExecutorDecisionTypeId = exports.ChildExecutorDecisionTypeId = /*#__PURE__*/Symbol.for(ChildExecutorDecisionSymbolKey);
/** @internal */
const proto = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
/** @internal */
const Continue = _ => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_CONTINUE;
  return op;
};
/** @internal

## Close

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/childExecutorDecision.js`

Signature: `Close(= Close;
const Yield = _ => {
  const op = Object.create(proto)`

JSDoc:

@internal

## Yield

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/childExecutorDecision.js`

Signature: `Yield(= Yield;
const isChildExecutorDecision = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isChildExecutorDecision

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/childExecutorDecision.js`

Signature: `isChildExecutorDecision(= isChildExecutorDecision;
const isContinue = self => self._tag === OpCodes.OP_CONTINUE;
/** @internal */
exports.isContinue = isContinue;
const isClose = self => self._tag === OpCodes.OP_CLOSE;
/** @internal */
exports.isClose = isClose;
const isYield = self => self._tag === OpCodes.OP_YIELD;
/** @internal */
exports.isYield = isYield;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## ContinuationKImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/continuation.js`

Signature: `ContinuationKImpl(= ContinuationKImpl;
class ContinuationFinalizerImpl {
  finalizer;
  _tag = OpCodes.OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer)`

JSDoc:

@internal */
const ContinuationTypeId = exports.ContinuationTypeId = /*#__PURE__*/Symbol.for("effect/ChannelContinuation");
const continuationVariance = {
  /* c8 ignore next */
  _Env: _ => _,
  /* c8 ignore next */
  _InErr: _ => _,
  /* c8 ignore next */
  _InElem: _ => _,
  /* c8 ignore next */
  _InDone: _ => _,
  /* c8 ignore next */
  _OutErr: _ => _,
  /* c8 ignore next */
  _OutDone: _ => _,
  /* c8 ignore next */
  _OutErr2: _ => _,
  /* c8 ignore next */
  _OutElem: _ => _,
  /* c8 ignore next */
  _OutDone2: _ => _
};
/** @internal */
class ContinuationKImpl {
  onSuccess;
  onHalt;
  _tag = OpCodes.OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit) {
    return Exit.isFailure(exit) ? this.onHalt(exit.cause) : this.onSuccess(exit.value);
  }
}
/** @internal

## Done

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeDecision.js`

Signature: `Done(= Done;
const Await = f => {
  const op = Object.create(proto)`

JSDoc:

@internal */
const MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
/** @internal */
const MergeDecisionTypeId = exports.MergeDecisionTypeId = /*#__PURE__*/Symbol.for(MergeDecisionSymbolKey);
/** @internal */
const proto = {
  [MergeDecisionTypeId]: {
    _R: _ => _,
    _E0: _ => _,
    _Z0: _ => _,
    _E: _ => _,
    _Z: _ => _
  }
};
/** @internal */
const Done = effect => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_DONE;
  op.effect = effect;
  return op;
};
/** @internal

## Await

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeDecision.js`

Signature: `Await(= Await;
const AwaitConst = effect => Await(()`

JSDoc:

@internal

## AwaitConst

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeDecision.js`

Signature: `AwaitConst(= AwaitConst;
const isMergeDecision = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isMergeDecision

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeDecision.js`

Signature: `isMergeDecision(= isMergeDecision;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## BothRunning

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeState.js`

Signature: `BothRunning(= BothRunning;
const LeftDone = f => {
  const op = Object.create(proto)`

JSDoc:

@internal */
const MergeStateSymbolKey = "effect/ChannelMergeState";
/** @internal */
const MergeStateTypeId = exports.MergeStateTypeId = /*#__PURE__*/Symbol.for(MergeStateSymbolKey);
/** @internal */
const proto = {
  [MergeStateTypeId]: MergeStateTypeId
};
/** @internal */
const BothRunning = (left, right) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_BOTH_RUNNING;
  op.left = left;
  op.right = right;
  return op;
};
/** @internal

## LeftDone

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeState.js`

Signature: `LeftDone(= LeftDone;
const RightDone = f => {
  const op = Object.create(proto)`

JSDoc:

@internal

## RightDone

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeState.js`

Signature: `RightDone(= RightDone;
const isMergeState = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isMergeState

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeState.js`

Signature: `isMergeState(= isMergeState;
const isBothRunning = self => {
  return self._tag === OpCodes.OP_BOTH_RUNNING;
};
/** @internal */
exports.isBothRunning = isBothRunning;
const isLeftDone = self => {
  return self._tag === OpCodes.OP_LEFT_DONE;
};
/** @internal */
exports.isLeftDone = isLeftDone;
const isRightDone = self => {
  return self._tag === OpCodes.OP_RIGHT_DONE;
};
/** @internal */
exports.isRightDone = isRightDone;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## BackPressure

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeStrategy.js`

Signature: `BackPressure(= BackPressure;
const BufferSliding = _ => {
  const op = Object.create(proto)`

JSDoc:

@internal */
const MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
/** @internal */
const MergeStrategyTypeId = exports.MergeStrategyTypeId = /*#__PURE__*/Symbol.for(MergeStrategySymbolKey);
/** @internal */
const proto = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
/** @internal */
const BackPressure = _ => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_BACK_PRESSURE;
  return op;
};
/** @internal

## BufferSliding

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeStrategy.js`

Signature: `BufferSliding(= BufferSliding;
const isMergeStrategy = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isMergeStrategy

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/mergeStrategy.js`

Signature: `isMergeStrategy(= isMergeStrategy;
const isBackPressure = self => self._tag === OpCodes.OP_BACK_PRESSURE;
/** @internal */
exports.isBackPressure = isBackPressure;
const isBufferSliding = self => self._tag === OpCodes.OP_BUFFER_SLIDING;
/** @internal */
exports.isBufferSliding = isBufferSliding;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## PullFromChild

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/subexecutor.js`

Signature: `PullFromChild(= PullFromChild;
class PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit)`

JSDoc:

@internal */
const OP_PULL_FROM_CHILD = exports.OP_PULL_FROM_CHILD = "PullFromChild";
/** @internal */
const OP_PULL_FROM_UPSTREAM = exports.OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
/** @internal */
const OP_DRAIN_CHILD_EXECUTORS = exports.OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
/** @internal */
const OP_EMIT = exports.OP_EMIT = "Emit";
/**
Execute the `childExecutor` and on each emitted value, decide what to do by
`onEmit`.

@internal
/
class PullFromChild {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit) {
    const fin1 = this.childExecutor.close(exit);
    const fin2 = this.parentSubexecutor.close(exit);
    if (fin1 !== undefined && fin2 !== undefined) {
      return Effect.zipWith(Effect.exit(fin1), Effect.exit(fin2), (exit1, exit2) => (0, _Function.pipe)(exit1, Exit.zipRight(exit2)));
    } else if (fin1 !== undefined) {
      return fin1;
    } else if (fin2 !== undefined) {
      return fin2;
    } else {
      return undefined;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}
/**
Execute `upstreamExecutor` and for each emitted element, spawn a child
channel and continue with processing it by `PullFromChild`.

@internal

## PullFromUpstream

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/subexecutor.js`

Signature: `PullFromUpstream(= PullFromUpstream;
class DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull)`

JSDoc:

Transformed from `PullFromUpstream` when upstream has finished but there
are still active child executors.

@internal

## DrainChildExecutors

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/subexecutor.js`

Signature: `DrainChildExecutors(= DrainChildExecutors;
class Emit {
  value;
  next;
  _tag = OP_EMIT;
  constructor(value, next)`

JSDoc:

@internal

## Pulled

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/upstreamPullRequest.js`

Signature: `Pulled(= Pulled;
const NoUpstream = activeDownstreamCount => {
  const op = Object.create(proto)`

JSDoc:

@internal */
const UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
/** @internal */
const UpstreamPullRequestTypeId = exports.UpstreamPullRequestTypeId = /*#__PURE__*/Symbol.for(UpstreamPullRequestSymbolKey);
const upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const proto = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
/** @internal */
const Pulled = value => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_PULLED;
  op.value = value;
  return op;
};
/** @internal

## NoUpstream

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/upstreamPullRequest.js`

Signature: `NoUpstream(= NoUpstream;
const isUpstreamPullRequest = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isUpstreamPullRequest

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/upstreamPullRequest.js`

Signature: `isUpstreamPullRequest(= isUpstreamPullRequest;
const isPulled = self => self._tag === OpCodes.OP_PULLED;
/** @internal */
exports.isPulled = isPulled;
const isNoUpstream = self => self._tag === OpCodes.OP_NO_UPSTREAM;
/** @internal */
exports.isNoUpstream = isNoUpstream;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## PullAfterNext

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/upstreamPullStrategy.js`

Signature: `PullAfterNext(= PullAfterNext;
const PullAfterAllEnqueued = emitSeparator => {
  const op = Object.create(proto)`

JSDoc:

@internal */
const UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
/** @internal */
const UpstreamPullStrategyTypeId = exports.UpstreamPullStrategyTypeId = /*#__PURE__*/Symbol.for(UpstreamPullStrategySymbolKey);
const upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const proto = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
/** @internal */
const PullAfterNext = emitSeparator => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};
/** @internal

## PullAfterAllEnqueued

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/upstreamPullStrategy.js`

Signature: `PullAfterAllEnqueued(= PullAfterAllEnqueued;
const isUpstreamPullStrategy = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isUpstreamPullStrategy

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel/upstreamPullStrategy.js`

Signature: `isUpstreamPullStrategy(= isUpstreamPullStrategy;
const isPullAfterNext = self => self._tag === OpCodes.OP_PULL_AFTER_NEXT;
/** @internal */
exports.isPullAfterNext = isPullAfterNext;
const isPullAfterAllEnqueued = self => self._tag === OpCodes.OP_PULL_AFTER_ALL_ENQUEUED;
/** @internal */
exports.isPullAfterAllEnqueued = isPullAfterAllEnqueued;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## acquireUseRelease

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `acquireUseRelease(= acquireUseRelease;
const as = exports.as = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const acquireUseRelease = (acquire, use, release) => core.flatMap(core.fromEffect(Ref.make(() => Effect.void)), ref => (0, _Function.pipe)(core.fromEffect(Effect.uninterruptible(Effect.tap(acquire, a => Ref.set(ref, exit => release(a, exit))))), core.flatMap(use), core.ensuringWith(exit => Effect.flatMap(Ref.get(ref), f => f(exit)))));
/** @internal

## asVoid

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `asVoid(= asVoid;
const buffer = options => core.suspend(()`

JSDoc:

@internal */
const asVoid = self => map(self, _Function.constVoid);
/** @internal

## buffer

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `buffer(= buffer;
const bufferChunk = ref => buffer({
  empty: Chunk.empty()`

JSDoc:

@internal

## bufferChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `bufferChunk(= bufferChunk;
const catchAll = exports.catchAll = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## concatOut

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `concatOut(= concatOut;
const mapInput = exports.mapInput = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const concatMap = exports.concatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.concatMapWith(self, f, () => void 0, () => void 0));
/** @internal */
const collect = exports.collect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => {
  const collector = core.readWith({
    onInput: out => Option.match(pf(out), {
      onNone: () => collector,
      onSome: out2 => core.flatMap(core.write(out2), () => collector)
    }),
    onFailure: core.fail,
    onDone: core.succeedNow
  });
  return core.pipeTo(self, collector);
});
/** @internal */
const concatOut = self => core.concatAll(self);
/** @internal

## doneCollect

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `doneCollect(= doneCollect;
const doneCollectReader = builder => {
  return core.readWith({
    onInput: outElem => core.flatMap(core.sync(()`

JSDoc:

@internal */
const mapInputEffect = exports.mapInputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const reader = core.readWith({
    onInput: inElem => core.flatMap(core.write(inElem), () => reader),
    onFailure: core.fail,
    onDone: done => core.fromEffect(f(done))
  });
  return core.pipeTo(reader, self);
});
/** @internal */
const mapInputError = exports.mapInputError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const reader = core.readWith({
    onInput: inElem => core.flatMap(core.write(inElem), () => reader),
    onFailure: error => core.fail(f(error)),
    onDone: core.succeedNow
  });
  return core.pipeTo(reader, self);
});
/** @internal */
const mapInputErrorEffect = exports.mapInputErrorEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const reader = core.readWith({
    onInput: inElem => core.flatMap(core.write(inElem), () => reader),
    onFailure: error => core.fromEffect(f(error)),
    onDone: core.succeedNow
  });
  return core.pipeTo(reader, self);
});
/** @internal */
const mapInputIn = exports.mapInputIn = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const reader = core.readWith({
    onInput: inElem => core.flatMap(core.write(f(inElem)), () => reader),
    onFailure: core.fail,
    onDone: core.succeedNow
  });
  return core.pipeTo(reader, self);
});
/** @internal */
const mapInputInEffect = exports.mapInputInEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const reader = core.readWith({
    onInput: inElem => core.flatMap(core.flatMap(core.fromEffect(f(inElem)), core.write), () => reader),
    onFailure: core.fail,
    onDone: core.succeedNow
  });
  return core.pipeTo(reader, self);
});
/** @internal */
const doneCollect = self => core.suspend(() => {
  const builder = [];
  return (0, _Function.pipe)(core.pipeTo(self, doneCollectReader(builder)), core.flatMap(outDone => core.succeed([Chunk.unsafeFromArray(builder), outDone])));
});
/** @internal

## drain

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `drain(= drain;
const emitCollect = self => core.flatMap(doneCollect(self)`

JSDoc:

@internal */
const drain = self => {
  const drainer = core.readWithCause({
    onInput: () => drainer,
    onFailure: core.failCause,
    onDone: core.succeed
  });
  return core.pipeTo(self, drainer);
};
/** @internal

## emitCollect

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `emitCollect(= emitCollect;
const ensuring = exports.ensuring = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## context

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `context(= context;
const contextWith = f => map(context()`

JSDoc:

@internal */
const context = () => core.fromEffect(Effect.context());
/** @internal

## contextWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `contextWith(= contextWith;
const contextWithChannel = f => core.flatMap(context()`

JSDoc:

@internal

## contextWithChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `contextWithChannel(= contextWithChannel;
const contextWithEffect = f => mapEffect(context()`

JSDoc:

@internal

## contextWithEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `contextWithEffect(= contextWithEffect;
const flatten = self => core.flatMap(self, _Function.identity)`

JSDoc:

@internal

## flatten

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `flatten(= flatten;
const foldChannel = exports.foldChannel = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fromEither

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `fromEither(= fromEither;
const fromInput = input => unwrap(input.takeWith(core.failCause, elem => core.flatMap(core.write(elem)`

JSDoc:

@internal */
const fromEither = either => core.suspend(() => Either.match(either, {
  onLeft: core.fail,
  onRight: core.succeed
}));
/** @internal

## fromInput

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `fromInput(= fromInput;
const fromPubSub = pubsub => unwrapScoped(Effect.map(PubSub.subscribe(pubsub)`

JSDoc:

@internal

## fromPubSub

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `fromPubSub(= fromPubSub;
const fromPubSubScoped = pubsub => Effect.map(PubSub.subscribe(pubsub)`

JSDoc:

@internal

## fromPubSubScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `fromPubSubScoped(= fromPubSubScoped;
const fromOption = option => core.suspend(()`

JSDoc:

@internal

## fromOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `fromOption(= fromOption;
const fromQueue = queue => core.suspend(()`

JSDoc:

@internal

## fromQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `fromQueue(= fromQueue;
const fromQueueInternal = queue => (0, _Function.pipe)`

JSDoc:

@internal

## identityChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `identityChannel(= identityChannel;
const interruptWhen = exports.interruptWhen = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const identityChannel = () => core.readWith({
  onInput: input => core.flatMap(core.write(input), () => identityChannel()),
  onFailure: core.fail,
  onDone: core.succeedNow
});
/** @internal

## mergeAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `mergeAll(= mergeAll;
const mergeAllUnbounded = channels => mergeAllWith({
  concurrency: "unbounded"
})`

JSDoc:

@internal */
const interruptWhenDeferred = exports.interruptWhenDeferred = /*#__PURE__*/(0, _Function.dual)(2, (self, deferred) => interruptWhen(self, Deferred.await(deferred)));
/** @internal */
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.flatMap(self, a => core.sync(() => f(a))));
/** @internal */
const mapEffect = exports.mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.flatMap(self, z => core.fromEffect(f(z))));
/** @internal */
const mapError = exports.mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapErrorCause(self, Cause.map(f)));
/** @internal */
const mapErrorCause = exports.mapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.catchAllCause(self, cause => core.failCause(f(cause))));
/** @internal */
const mapOut = exports.mapOut = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const reader = core.readWith({
    onInput: outElem => core.flatMap(core.write(f(outElem)), () => reader),
    onFailure: core.fail,
    onDone: core.succeedNow
  });
  return core.pipeTo(self, reader);
});
/** @internal */
const mapOutEffect = exports.mapOutEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const reader = core.readWithCause({
    onInput: outElem => (0, _Function.pipe)(core.fromEffect(f(outElem)), core.flatMap(core.write), core.flatMap(() => reader)),
    onFailure: core.failCause,
    onDone: core.succeedNow
  });
  return core.pipeTo(self, reader);
});
/** @internal */
const mapOutEffectPar = exports.mapOutEffectPar = /*#__PURE__*/(0, _Function.dual)(3, (self, f, n) => unwrapScopedWith(scope => Effect.gen(function* () {
  const input = yield* singleProducerAsyncInput.make();
  const queueReader = fromInput(input);
  const queue = yield* Queue.bounded(n);
  yield* Scope.addFinalizer(scope, Queue.shutdown(queue));
  const errorSignal = yield* Deferred.make();
  const withPermits = n === Number.POSITIVE_INFINITY ? _ => _Function.identity : (yield* Effect.makeSemaphore(n)).withPermits;
  const pull = yield* queueReader.pipe(core.pipeTo(self), toPullIn(scope));
  yield* pull.pipe(Effect.matchCauseEffect({
    onFailure: cause => Queue.offer(queue, Effect.failCause(cause)),
    onSuccess: Either.match({
      onLeft: outDone => Effect.zipRight(Effect.interruptible(withPermits(n)(Effect.void)), Effect.asVoid(Queue.offer(queue, Effect.succeed(Either.left(outDone))))),
      onRight: outElem => Effect.gen(function* () {
        const deferred = yield* Deferred.make();
        const latch = yield* Deferred.make();
        yield* Queue.offer(queue, Effect.map(Deferred.await(deferred), Either.right));
        yield* Deferred.succeed(latch, void 0).pipe(Effect.zipRight(Effect.uninterruptibleMask(restore => Effect.exit(restore(Deferred.await(errorSignal))).pipe(Effect.raceFirst(Effect.exit(restore(f(outElem)))), Effect.flatMap(_Function.identity))).pipe(Effect.tapErrorCause(cause => Deferred.failCause(errorSignal, cause)), Effect.intoDeferred(deferred))), withPermits(1), Effect.forkIn(scope));
        yield* Deferred.await(latch);
      })
    })
  }), Effect.forever, Effect.interruptible, Effect.forkIn(scope));
  const consumer = unwrap(Effect.matchCause(Effect.flatten(Queue.take(queue)), {
    onFailure: core.failCause,
    onSuccess: Either.match({
      onLeft: core.succeedNow,
      onRight: outElem => core.flatMap(core.write(outElem), () => consumer)
    })
  }));
  return core.embedInput(consumer, input);
})));
/** @internal */
const mergeAll = options => {
  return channels => mergeAllWith(options)(channels, _Function.constVoid);
};
/** @internal

## mergeAllUnbounded

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `mergeAllUnbounded(= mergeAllUnbounded;
const mergeAllUnboundedWith = (channels, f)`

JSDoc:

@internal

## mergeAllUnboundedWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `mergeAllUnboundedWith(= mergeAllUnboundedWith;
const mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = mergeStrategy_.BackPressure()`

JSDoc:

@internal

## mergeAllWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `mergeAllWith(= mergeAllWith;
const mergeMap = exports.mergeMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## read

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `read(= read;
const repeated = self => core.flatMap(self, ()`

JSDoc:

@internal */
const mergeOut = exports.mergeOut = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => mergeAll({
  concurrency: n
})(mapOut(self, _Function.identity)));
/** @internal */
const mergeOutWith = exports.mergeOutWith = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => mergeAllWith({
  concurrency: n
})(mapOut(self, _Function.identity), f));
/** @internal */
const mergeWith = exports.mergeWith = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  function merge(scope) {
    return Effect.gen(function* () {
      const input = yield* singleProducerAsyncInput.make();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(core.pipeTo(queueReader, self), scope);
      const pullR = yield* toPullIn(core.pipeTo(queueReader, options.other), scope);
      function handleSide(exit, fiber, pull) {
        return (done, both, single) => {
          function onDecision(decision) {
            const op = decision;
            if (op._tag === MergeDecisionOpCodes.OP_DONE) {
              return Effect.succeed(core.fromEffect(Effect.zipRight(Fiber.interrupt(fiber), op.effect)));
            }
            return Effect.map(Fiber.await(fiber), Exit.match({
              onFailure: cause => core.fromEffect(op.f(Exit.failCause(cause))),
              onSuccess: Either.match({
                onLeft: done => core.fromEffect(op.f(Exit.succeed(done))),
                onRight: elem => zipRight(core.write(elem), go(single(op.f)))
              })
            }));
          }
          return Exit.match(exit, {
            onFailure: cause => onDecision(done(Exit.failCause(cause))),
            onSuccess: Either.match({
              onLeft: z => onDecision(done(Exit.succeed(z))),
              onRight: elem => Effect.succeed(core.flatMap(core.write(elem), () => core.flatMap(core.fromEffect(Effect.forkIn(Effect.interruptible(pull), scope)), leftFiber => go(both(leftFiber, fiber)))))
            })
          });
        };
      }
      function go(state) {
        switch (state._tag) {
          case MergeStateOpCodes.OP_BOTH_RUNNING:
            {
              const leftJoin = Effect.interruptible(Fiber.join(state.left));
              const rightJoin = Effect.interruptible(Fiber.join(state.right));
              return unwrap(Effect.raceWith(leftJoin, rightJoin, {
                onSelfDone: (leftExit, rf) => Effect.zipRight(Fiber.interrupt(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, mergeState.BothRunning, f => mergeState.LeftDone(f))),
                onOtherDone: (rightExit, lf) => Effect.zipRight(Fiber.interrupt(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left, right) => mergeState.BothRunning(right, left), f => mergeState.RightDone(f)))
              }));
            }
          case MergeStateOpCodes.OP_LEFT_DONE:
            {
              return unwrap(Effect.map(Effect.exit(pullR), Exit.match({
                onFailure: cause => core.fromEffect(state.f(Exit.failCause(cause))),
                onSuccess: Either.match({
                  onLeft: done => core.fromEffect(state.f(Exit.succeed(done))),
                  onRight: elem => core.flatMap(core.write(elem), () => go(mergeState.LeftDone(state.f)))
                })
              })));
            }
          case MergeStateOpCodes.OP_RIGHT_DONE:
            {
              return unwrap(Effect.map(Effect.exit(pullL), Exit.match({
                onFailure: cause => core.fromEffect(state.f(Exit.failCause(cause))),
                onSuccess: Either.match({
                  onLeft: done => core.fromEffect(state.f(Exit.succeed(done))),
                  onRight: elem => core.flatMap(core.write(elem), () => go(mergeState.RightDone(state.f)))
                })
              })));
            }
        }
      }
      return core.fromEffect(Effect.withFiberRuntime(parent => {
        const inherit = Effect.withFiberRuntime(state => {
          ;
          state.transferChildren(parent.scope());
          return Effect.void;
        });
        const leftFiber = Effect.interruptible(pullL).pipe(Effect.ensuring(inherit), Effect.forkIn(scope));
        const rightFiber = Effect.interruptible(pullR).pipe(Effect.ensuring(inherit), Effect.forkIn(scope));
        return Effect.zipWith(leftFiber, rightFiber, (left, right) => mergeState.BothRunning(left, right));
      })).pipe(core.flatMap(go), core.embedInput(input));
    });
  }
  return unwrapScopedWith(merge);
});
/** @internal */
const never = exports.never = /*#__PURE__*/core.fromEffect(Effect.never);
/** @internal */
const orDie = exports.orDie = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => orDieWith(self, error));
/** @internal */
const orDieWith = exports.orDieWith = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAll(self, e => core.failCauseSync(() => Cause.die(f(e)))));
/** @internal */
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => catchAll(self, that));
/** @internal */
const pipeToOrFail = exports.pipeToOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => core.suspend(() => {
  let channelException = undefined;
  const reader = core.readWith({
    onInput: outElem => core.flatMap(core.write(outElem), () => reader),
    onFailure: outErr => {
      channelException = ChannelException(outErr);
      return core.failCause(Cause.die(channelException));
    },
    onDone: core.succeedNow
  });
  const writer = core.readWithCause({
    onInput: outElem => (0, _Function.pipe)(core.write(outElem), core.flatMap(() => writer)),
    onFailure: cause => Cause.isDieType(cause) && isChannelException(cause.defect) && Equal.equals(cause.defect, channelException) ? core.fail(cause.defect.error) : core.failCause(cause),
    onDone: core.succeedNow
  });
  return core.pipeTo(core.pipeTo(core.pipeTo(self, reader), that), writer);
}));
/** @internal */
const provideService = exports.provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, service) => {
  return core.flatMap(context(), context => core.provideContext(self, Context.add(context, tag, service)));
});
/** @internal */
const provideLayer = exports.provideLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) => unwrapScopedWith(scope => Effect.map(Layer.buildWithScope(layer, scope), context => core.provideContext(self, context))));
/** @internal */
const mapInputContext = exports.mapInputContext = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contextWithChannel(context => core.provideContext(self, f(context))));
/** @internal */
const provideSomeLayer = exports.provideSomeLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) =>
// @ts-expect-error
provideLayer(self, Layer.merge(Layer.context(), layer)));
/** @internal */
const read = () => core.readOrFail(Option.none());
/** @internal

## repeated

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `repeated(= repeated;
const run = self => Effect.scopedWith(scope => executor.runIn(self, scope)`

JSDoc:

@internal

## run

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `run(= run;
const runCollect = self => run(core.collectElements(self)`

JSDoc:

@internal

## runCollect

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `runCollect(= runCollect;
const runDrain = self => run(drain(self)`

JSDoc:

@internal

## runDrain

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `runDrain(= runDrain;
const runScoped = self => Effect.scopeWith(scope => executor.runIn(self, scope)`

JSDoc:

@internal

## runScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `runScoped(= runScoped;
const scoped = effect => unwrap(Effect.uninterruptibleMask(restore => Effect.map(Scope.make()`

JSDoc:

@internal

## scoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `scoped(= scoped;
const scopedWith = f => unwrapScoped(Effect.map(Effect.scope, scope => core.flatMap(core.fromEffect(f(scope)`

JSDoc:

@internal

## scopedWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `scopedWith(= scopedWith;
const service = tag => core.fromEffect(tag)`

JSDoc:

@internal

## service

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `service(= service;
const serviceWith = tag => f => map(service(tag)`

JSDoc:

@internal

## serviceWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `serviceWith(= serviceWith;
const serviceWithChannel = tag => f => core.flatMap(service(tag)`

JSDoc:

@internal

## serviceWithChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `serviceWithChannel(= serviceWithChannel;
const serviceWithEffect = tag => f => mapEffect(service(tag)`

JSDoc:

@internal

## serviceWithEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `serviceWithEffect(= serviceWithEffect;
const splitLines = ()`

JSDoc:

@internal

## splitLines

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `splitLines(= splitLines;
const toPubSub = pubsub => toQueue(pubsub)`

JSDoc:

@internal

## toPubSub

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `toPubSub(= toPubSub;
const toPull = self => Effect.flatMap(Effect.scope, scope => toPullIn(self, scope)`

JSDoc:

@internal

## toPull

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `toPull(= toPull;
const toPullIn = exports.toPullIn = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## toQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `toQueue(= toQueue;
const toQueueInternal = queue => {
  return core.readWithCause({
    onInput: elem => core.flatMap(core.fromEffect(Queue.offer(queue, Either.right(elem)`

JSDoc:

@internal */
const interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case ChannelStateOpCodes.OP_DONE:
      {
        return Exit.match(exec.getDone(), {
          onFailure: Effect.failCause,
          onSuccess: done => Effect.succeed(Either.left(done))
        });
      }
    case ChannelStateOpCodes.OP_EMIT:
      {
        return Effect.succeed(Either.right(exec.getEmit()));
      }
    case ChannelStateOpCodes.OP_FROM_EFFECT:
      {
        return (0, _Function.pipe)(state.effect, Effect.flatMap(() => interpretToPull(exec.run(), exec)));
      }
    case ChannelStateOpCodes.OP_READ:
      {
        return executor.readUpstream(state, () => interpretToPull(exec.run(), exec), cause => Effect.failCause(cause));
      }
  }
};
/** @internal */
const toQueue = queue => core.suspend(() => toQueueInternal(queue));
/** @internal

## unwrap

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `unwrap(= unwrap;
const unwrapScoped = self => core.concatAllWith(scoped(self)`

JSDoc:

@internal */
const unwrap = channel => flatten(core.fromEffect(channel));
/** @internal

## unwrapScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `unwrapScoped(= unwrapScoped;
const unwrapScopedWith = f => core.concatAllWith(scopedWith(f)`

JSDoc:

@internal

## unwrapScopedWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `unwrapScopedWith(= unwrapScopedWith;
const updateService = exports.updateService = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## withSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `withSpan(= withSpan;
const writeAll = (...outs)`

JSDoc:

@internal */
const withSpan = function () {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire = Effect.all([Effect.makeSpan(name, options), Effect.context(), Effect.clock, FiberRef.get(FiberRef.currentTracerTimingEnabled)]);
  if (dataFirst) {
    const self = arguments[0];
    return acquireUseRelease(acquire, ([span, context]) => core.provideContext(self, Context.add(context, tracer.spanTag, span)), ([span,, clock, timingEnabled], exit) => coreEffect.endSpan(span, exit, clock, timingEnabled));
  }
  return self => acquireUseRelease(acquire, ([span, context]) => core.provideContext(self, Context.add(context, tracer.spanTag, span)), ([span,, clock, timingEnabled], exit) => coreEffect.endSpan(span, exit, clock, timingEnabled));
};
/** @internal

## writeAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `writeAll(= writeAll;
const writeChunk = outs => writeChunkWriter(0, outs.length, outs)`

JSDoc:

@internal

## writeChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `writeChunk(= writeChunk;
const writeChunkWriter = (idx, len, chunk)`

JSDoc:

@internal

## ChannelException

Source: `my-backend/node_modules/effect/dist/cjs/internal/channel.js`

Signature: `ChannelException(= ChannelException;
const isChannelException = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)(args => core.isChannel(args[1]), (self, that, options) => options?.concurrent ? mergeWith(self, {
  other: that,
  onSelfDone: exit1 => mergeDecision.Await(exit2 => Effect.suspend(() => Exit.zip(exit1, exit2))),
  onOtherDone: exit2 => mergeDecision.Await(exit1 => Effect.suspend(() => Exit.zip(exit1, exit2)))
}) : core.flatMap(self, a => map(that, b => [a, b])));
/** @internal */
const zipLeft = exports.zipLeft = /*#__PURE__*/(0, _Function.dual)(args => core.isChannel(args[1]), (self, that, options) => options?.concurrent ? map(zip(self, that, {
  concurrent: true
}), tuple => tuple[0]) : core.flatMap(self, z => as(that, z)));
/** @internal */
const zipRight = exports.zipRight = /*#__PURE__*/(0, _Function.dual)(args => core.isChannel(args[1]), (self, that, options) => options?.concurrent ? map(zip(self, that, {
  concurrent: true
}), tuple => tuple[1]) : core.flatMap(self, () => that));
/** @internal */
const ChannelExceptionTypeId = exports.ChannelExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Channel/ChannelException");
/** @internal */
const ChannelException = error => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error
});
/** @internal

## match

Source: `my-backend/node_modules/effect/dist/cjs/internal/concurrency.js`

Signature: `match(= match;
const matchSimple = (concurrency, sequential, concurrent)`

JSDoc:

@internal */
const match = (concurrency, sequential, unbounded, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential();
    case "unbounded":
      return unbounded();
    case "inherit":
      return core.fiberRefGetWith(core.currentConcurrency, concurrency => concurrency === "unbounded" ? unbounded() : concurrency > 1 ? bounded(concurrency) : sequential());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential();
  }
};
/** @internal

## boolean

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `boolean(= boolean;
const url = name => {
  const config = primitive("an URL property", text => Either.try({
    try: ()`

JSDoc:

@internal */
const ConfigTypeId = exports.ConfigTypeId = /*#__PURE__*/Symbol.for(ConfigSymbolKey);
const configVariance = {
  /* c8 ignore next */
  _A: _ => _
};
const proto = {
  ...effectable.CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return defaultServices.config(this);
  }
};
/** @internal */
const boolean = name => {
  const config = primitive("a boolean property", text => {
    switch (text) {
      case "true":
      case "yes":
      case "on":
      case "1":
        {
          return Either.right(true);
        }
      case "false":
      case "no":
      case "off":
      case "0":
        {
          return Either.right(false);
        }
      default:
        {
          const error = configError.InvalidData([], `Expected a boolean value but received ${text}`);
          return Either.left(error);
        }
    }
  });
  return name === undefined ? config : nested(config, name);
};
/** @internal

## url

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `url(= url;
const port = name => {
  const config = primitive("a network port property", text => {
    const result = Number(text)`

JSDoc:

@internal

## port

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `port(= port;
const array = (config, name)`

JSDoc:

@internal

## array

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `array(= array;
const chunk = (config, name)`

JSDoc:

@internal

## chunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `chunk(= chunk;
const date = name => {
  const config = primitive("a date property", text => {
    const result = Date.parse(text)`

JSDoc:

@internal

## date

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `date(= date;
const fail = message => {
  const fail = Object.create(proto)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `fail(= fail;
const number = name => {
  const config = primitive("a number property", text => {
    const result = Number(text)`

JSDoc:

@internal

## number

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `number(= number;
const integer = name => {
  const config = primitive("an integer property", text => {
    const result = Number(text)`

JSDoc:

@internal

## integer

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `integer(= integer;
const literal = (...literals)`

JSDoc:

@internal

## literal

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `literal(= literal;
const logLevel = name => {
  const config = mapOrFail(string()`

JSDoc:

@internal

## logLevel

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `logLevel(= logLevel;
const duration = name => {
  const config = mapOrFail(string()`

JSDoc:

@internal

## duration

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `duration(= duration;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## option

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `option(= option;
const primitive = (description, parse)`

JSDoc:

@internal */
const mapAttempt = exports.mapAttempt = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapOrFail(self, a => {
  try {
    return Either.right(f(a));
  } catch (error) {
    return Either.left(configError.InvalidData([], error instanceof Error ? error.message : `${error}`));
  }
}));
/** @internal */
const mapOrFail = exports.mapOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const mapOrFail = Object.create(proto);
  mapOrFail._tag = OpCodes.OP_MAP_OR_FAIL;
  mapOrFail.original = self;
  mapOrFail.mapOrFail = f;
  return mapOrFail;
});
/** @internal */
const nested = exports.nested = /*#__PURE__*/(0, _Function.dual)(2, (self, name) => {
  const nested = Object.create(proto);
  nested._tag = OpCodes.OP_NESTED;
  nested.name = name;
  nested.config = self;
  return nested;
});
/** @internal */
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  const fallback = Object.create(proto);
  fallback._tag = OpCodes.OP_FALLBACK;
  fallback.first = self;
  fallback.second = suspend(that);
  fallback.condition = _Function.constTrue;
  return fallback;
});
/** @internal */
const orElseIf = exports.orElseIf = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const fallback = Object.create(proto);
  fallback._tag = OpCodes.OP_FALLBACK;
  fallback.first = self;
  fallback.second = suspend(options.orElse);
  fallback.condition = options.if;
  return fallback;
});
/** @internal */
const option = self => {
  return (0, _Function.pipe)(self, map(Option.some), orElseIf({
    orElse: () => succeed(Option.none()),
    if: ConfigError.isMissingDataOnly
  }));
};
/** @internal

## primitive

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `primitive(= primitive;
const repeat = self => {
  const repeat = Object.create(proto)`

JSDoc:

@internal

## repeat

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `repeat(= repeat;
const secret = name => {
  const config = primitive("a secret property", text => Either.right(InternalSecret.fromString(text)`

JSDoc:

@internal

## secret

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `secret(= secret;
const redacted = nameOrConfig => {
  const config = isConfig(nameOrConfig)`

JSDoc:

@internal

## redacted

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `redacted(= redacted;
const branded = exports.branded = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## hashSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `hashSet(= hashSet;
const string = name => {
  const config = primitive("a text property", Either.right)`

JSDoc:

@internal */
const hashSet = (config, name) => {
  const newConfig = map(chunk(config), HashSet.fromIterable);
  return name === undefined ? newConfig : nested(newConfig, name);
};
/** @internal

## string

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `string(= string;
const nonEmptyString = name => {
  const config = primitive("a non-empty text property", Either.liftPredicate(text => text.length > 0, ()`

JSDoc:

@internal

## nonEmptyString

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `nonEmptyString(= nonEmptyString;
const all = arg => {
  if (Array.isArray(arg)`

JSDoc:

@internal

## succeed

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `succeed(= succeed;
const suspend = config => {
  const lazy = Object.create(proto)`

JSDoc:

@internal */
const succeed = value => {
  const constant = Object.create(proto);
  constant._tag = OpCodes.OP_CONSTANT;
  constant.value = value;
  constant.parse = () => Either.right(value);
  return constant;
};
/** @internal

## suspend

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `suspend(= suspend;
const sync = value => {
  return suspend(()`

JSDoc:

@internal

## sync

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `sync(= sync;
const hashMap = (config, name)`

JSDoc:

@internal

## hashMap

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `hashMap(= hashMap;
const isConfig = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isConfig

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `isConfig(= isConfig;
const tuple = tuple => {
  if (tuple.length === 0)`

JSDoc:

@internal

## unwrap

Source: `my-backend/node_modules/effect/dist/cjs/internal/config.js`

Signature: `unwrap(= unwrap;
const validate = exports.validate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal
/
const unwrap = wrapped => {
  if (isConfig(wrapped)) {
    return wrapped;
  }
  return struct(Object.fromEntries(Object.entries(wrapped).map(([k, a]) => [k, unwrap(a)])));
};
/** @internal

## And

Source: `my-backend/node_modules/effect/dist/cjs/internal/configError.js`

Signature: `And(= And;
const Or = (self, that)`

JSDoc:

@internal */
const ConfigErrorSymbolKey = "effect/ConfigError";
/** @internal */
const ConfigErrorTypeId = exports.ConfigErrorTypeId = /*#__PURE__*/Symbol.for(ConfigErrorSymbolKey);
/** @internal */
const proto = exports.proto = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
/** @internal */
const And = (self, that) => {
  const error = Object.create(proto);
  error._op = OpCodes.OP_AND;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
/** @internal

## Or

Source: `my-backend/node_modules/effect/dist/cjs/internal/configError.js`

Signature: `Or(= Or;
const InvalidData = (path, message, options = {
  pathDelim: "."
})`

JSDoc:

@internal

## InvalidData

Source: `my-backend/node_modules/effect/dist/cjs/internal/configError.js`

Signature: `InvalidData(= InvalidData;
const MissingData = (path, message, options = {
  pathDelim: "."
})`

JSDoc:

@internal

## MissingData

Source: `my-backend/node_modules/effect/dist/cjs/internal/configError.js`

Signature: `MissingData(= MissingData;
const SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
})`

JSDoc:

@internal

## SourceUnavailable

Source: `my-backend/node_modules/effect/dist/cjs/internal/configError.js`

Signature: `SourceUnavailable(= SourceUnavailable;
const Unsupported = (path, message, options = {
  pathDelim: "."
})`

JSDoc:

@internal

## Unsupported

Source: `my-backend/node_modules/effect/dist/cjs/internal/configError.js`

Signature: `Unsupported(= Unsupported;
const isConfigError = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isConfigError

Source: `my-backend/node_modules/effect/dist/cjs/internal/configError.js`

Signature: `isConfigError(= isConfigError;
const isAnd = self => self._op === OpCodes.OP_AND;
/** @internal */
exports.isAnd = isAnd;
const isOr = self => self._op === OpCodes.OP_OR;
/** @internal */
exports.isOr = isOr;
const isInvalidData = self => self._op === OpCodes.OP_INVALID_DATA;
/** @internal */
exports.isInvalidData = isInvalidData;
const isMissingData = self => self._op === OpCodes.OP_MISSING_DATA;
/** @internal */
exports.isMissingData = isMissingData;
const isSourceUnavailable = self => self._op === OpCodes.OP_SOURCE_UNAVAILABLE;
/** @internal */
exports.isSourceUnavailable = isSourceUnavailable;
const isUnsupported = self => self._op === OpCodes.OP_UNSUPPORTED;
/** @internal */
exports.isUnsupported = isUnsupported;
const prefixed = exports.prefixed = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `make(= make;
const makeFlat = options => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split = true)`

JSDoc:

@internal */
const ConfigProviderSymbolKey = "effect/ConfigProvider";
/** @internal */
const ConfigProviderTypeId = exports.ConfigProviderTypeId = /*#__PURE__*/Symbol.for(ConfigProviderSymbolKey);
/** @internal */
const configProviderTag = exports.configProviderTag = /*#__PURE__*/Context.GenericTag("effect/ConfigProvider");
/** @internal */
const FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
/** @internal */
const FlatConfigProviderTypeId = exports.FlatConfigProviderTypeId = /*#__PURE__*/Symbol.for(FlatConfigProviderSymbolKey);
/** @internal */
const make = options => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  ...options
});
/** @internal

## makeFlat

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `makeFlat(= makeFlat;
const fromFlat = flat => make({
  load: config => core.flatMap(fromFlatLoop(flat, Arr.empty()`

JSDoc:

@internal

## fromFlat

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `fromFlat(= fromFlat;
const fromEnv = options => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options)`

JSDoc:

@internal

## fromEnv

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `fromEnv(= fromEnv;
const fromMap = (map, config)`

JSDoc:

@internal

## constantCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `constantCase(= constantCase;
const kebabCase = self => mapInputPath(self, StringUtils.kebabCase)`

JSDoc:

@internal */
const mapInputPath = exports.mapInputPath = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)));
const mapInputPathFlat = (self, f) => makeFlat({
  load: (path, config, split = true) => self.load(path, config, split),
  enumerateChildren: path => self.enumerateChildren(path),
  patch: pathPatch.mapName(self.patch, f)
});
/** @internal */
const nested = exports.nested = /*#__PURE__*/(0, _Function.dual)(2, (self, name) => fromFlat(makeFlat({
  load: (path, config) => self.flattened.load(path, config, true),
  enumerateChildren: path => self.flattened.enumerateChildren(path),
  patch: pathPatch.nested(self.flattened.patch, name)
})));
/** @internal */
const unnested = exports.unnested = /*#__PURE__*/(0, _Function.dual)(2, (self, name) => fromFlat(makeFlat({
  load: (path, config) => self.flattened.load(path, config, true),
  enumerateChildren: path => self.flattened.enumerateChildren(path),
  patch: pathPatch.unnested(self.flattened.patch, name)
})));
/** @internal */
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));
const orElseFlat = (self, that) => makeFlat({
  load: (path, config, split) => (0, _Function.pipe)(pathPatch.patch(path, self.patch), core.flatMap(patch => self.load(patch, config, split)), core.catchAll(error1 => (0, _Function.pipe)(core.sync(that), core.flatMap(that => (0, _Function.pipe)(pathPatch.patch(path, that.patch), core.flatMap(patch => that.load(patch, config, split)), core.catchAll(error2 => core.fail(configError.Or(error1, error2)))))))),
  enumerateChildren: path => (0, _Function.pipe)(pathPatch.patch(path, self.patch), core.flatMap(patch => self.enumerateChildren(patch)), core.either, core.flatMap(left => (0, _Function.pipe)(core.sync(that), core.flatMap(that => (0, _Function.pipe)(pathPatch.patch(path, that.patch), core.flatMap(patch => that.enumerateChildren(patch)), core.either, core.flatMap(right => {
    if (Either.isLeft(left) && Either.isLeft(right)) {
      return core.fail(configError.And(left.left, right.left));
    }
    if (Either.isLeft(left) && Either.isRight(right)) {
      return core.succeed(right.right);
    }
    if (Either.isRight(left) && Either.isLeft(right)) {
      return core.succeed(left.right);
    }
    if (Either.isRight(left) && Either.isRight(right)) {
      return core.succeed((0, _Function.pipe)(left.right, HashSet.union(right.right)));
    }
    throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
  })))))),
  patch: pathPatch.empty
});
/** @internal */
const constantCase = self => mapInputPath(self, StringUtils.constantCase);
/** @internal

## kebabCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `kebabCase(= kebabCase;
const lowerCase = self => mapInputPath(self, StringUtils.lowerCase)`

JSDoc:

@internal

## lowerCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `lowerCase(= lowerCase;
const snakeCase = self => mapInputPath(self, StringUtils.snakeCase)`

JSDoc:

@internal

## snakeCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `snakeCase(= snakeCase;
const upperCase = self => mapInputPath(self, StringUtils.upperCase)`

JSDoc:

@internal

## upperCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/configProvider.js`

Signature: `upperCase(= upperCase;
const within = exports.within = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## consoleWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `consoleWith(= consoleWith;
const withConsole = exports.withConsole = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const console = exports.console = /*#__PURE__*/core.map(/*#__PURE__*/core.fiberRefGet(defaultServices.currentServices), /*#__PURE__*/Context.get(defaultConsole.consoleTag));
/** @internal */
const consoleWith = f => core.fiberRefGetWith(defaultServices.currentServices, services => f(Context.get(services, defaultConsole.consoleTag)));
/** @internal

## withConsoleScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `withConsoleScoped(= withConsoleScoped;
const setConsole = console => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(defaultConsole.consoleTag, console)`

JSDoc:

@internal */
const withConsoleScoped = console => fiberRuntime.fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(defaultConsole.consoleTag, console));
/** @internal

## setConsole

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `setConsole(= setConsole;
const assert = (condition, ...args)`

JSDoc:

@internal

## assert

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `assert(= assert;
const clear = exports.clear = /*#__PURE__*/consoleWith(_ => _.clear)`

JSDoc:

@internal

## count

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `count(= count;
const countReset = label => consoleWith(_ => _.countReset(label)`

JSDoc:

@internal */
const count = label => consoleWith(_ => _.count(label));
/** @internal

## countReset

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `countReset(= countReset;
const debug = (...args)`

JSDoc:

@internal

## debug

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `debug(= debug;
const dir = (item, options)`

JSDoc:

@internal

## dir

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `dir(= dir;
const dirxml = (...args)`

JSDoc:

@internal

## dirxml

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `dirxml(= dirxml;
const error = (...args)`

JSDoc:

@internal

## error

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `error(= error;
const group = options => consoleWith(_ => fiberRuntime.acquireRelease(_.group(options)`

JSDoc:

@internal

## group

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `group(= group;
const info = (...args)`

JSDoc:

@internal

## info

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `info(= info;
const log = (...args)`

JSDoc:

@internal

## log

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `log(= log;
const table = (tabularData, properties)`

JSDoc:

@internal

## table

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `table(= table;
const time = label => consoleWith(_ => fiberRuntime.acquireRelease(_.time(label)`

JSDoc:

@internal

## time

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `time(= time;
const timeLog = (label, ...args)`

JSDoc:

@internal

## timeLog

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `timeLog(= timeLog;
const trace = (...args)`

JSDoc:

@internal

## trace

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `trace(= trace;
const warn = (...args)`

JSDoc:

@internal

## warn

Source: `my-backend/node_modules/effect/dist/cjs/internal/console.js`

Signature: `warn(= warn;
const withGroup = exports.withGroup = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## makeGenericTag

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `makeGenericTag(= makeGenericTag;
const Tag = id => ()`

JSDoc:

@internal */
const TagTypeId = exports.TagTypeId = /*#__PURE__*/Symbol.for("effect/Context/Tag");
/** @internal */
const ReferenceTypeId = exports.ReferenceTypeId = /*#__PURE__*/Symbol.for("effect/Context/Reference");
/** @internal */
const STMSymbolKey = "effect/STM";
/** @internal */
const STMTypeId = exports.STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);
/** @internal */
const TagProto = exports.TagProto = {
  ..._effectable.EffectPrototype,
  _op: "Tag",
  [STMTypeId]: _effectable.effectVariance,
  [TagTypeId]: {
    _Service: _ => _,
    _Identifier: _ => _
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make(this, self);
  }
};
const ReferenceProto = exports.ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
/** @internal */
const makeGenericTag = key => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
/** @internal

## Tag

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `Tag(= Tag;
const Reference = ()`

JSDoc:

@internal

## Reference

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `Reference(= Reference;
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Context")`

JSDoc:

@internal

## isContext

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `isContext(= isContext;
const isTag = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const ContextProto = exports.ContextProto = {
  [TypeId]: {
    _Services: _ => _
  },
  [Equal.symbol](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !Equal.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [Hash.symbol]() {
    return Hash.cached(this, Hash.number(this.unsafeMap.size));
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
};
/** @internal */
const makeContext = unsafeMap => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
};
exports.makeContext = makeContext;
const serviceNotFoundError = tag => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split("\n");
    lines.splice(1, 3);
    error.stack = lines.join("\n");
  }
  return error;
};
/** @internal */
const isContext = u => (0, _Predicate.hasProperty)(u, TypeId);
/** @internal

## isTag

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `isTag(= isTag;
const isReference = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `empty(= empty;
const make = (tag, service)`

JSDoc:

@internal */
const empty = () => _empty;
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `make(= make;
const add = exports.add = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## unsafeGetReference

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `unsafeGetReference(= unsafeGetReference;
const unsafeGet = exports.unsafeGet = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const unsafeGetReference = (self, tag) => {
  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
/** @internal

## mergeAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `mergeAll(= mergeAll;
const pick = (...tags)`

JSDoc:

@internal */
const get = exports.get = unsafeGet;
/** @internal */
const getOrElse = exports.getOrElse = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, orElse) => {
  if (!self.unsafeMap.has(tag.key)) {
    return isReference(tag) ? getDefaultValue(tag) : orElse();
  }
  return self.unsafeMap.get(tag.key);
});
/** @internal */
const getOption = exports.getOption = /*#__PURE__*/(0, _Function.dual)(2, (self, tag) => {
  if (!self.unsafeMap.has(tag.key)) {
    return isReference(tag) ? option.some(getDefaultValue(tag)) : option.none;
  }
  return option.some(self.unsafeMap.get(tag.key));
});
/** @internal */
const merge = exports.merge = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  const map = new Map(self.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map.set(tag, s);
  }
  return makeContext(map);
});
/** @internal */
const mergeAll = (...ctxs) => {
  const map = new Map();
  for (const ctx of ctxs) {
    for (const [tag, s] of ctx.unsafeMap) {
      map.set(tag, s);
    }
  }
  return makeContext(map);
};
/** @internal

## pick

Source: `my-backend/node_modules/effect/dist/cjs/internal/context.js`

Signature: `pick(= pick;
const omit = (...tags)`

JSDoc:

@internal

## cause

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `cause(= cause;
const clockWith = exports.clockWith = Clock.clockWith;
/* @internal */
const clock = exports.clock = /*#__PURE__*/clockWith(core.succeed)`

JSDoc:

@internal */
const catchTags = exports.catchTags = /*#__PURE__*/(0, _Function.dual)(2, (self, cases) => {
  let keys;
  return core.catchIf(self, e => {
    keys ??= Object.keys(cases);
    return Predicate.hasProperty(e, "_tag") && Predicate.isString(e["_tag"]) && keys.includes(e["_tag"]);
  }, e => cases[e["_tag"]](e));
});
/* @internal */
const cause = self => core.matchCause(self, {
  onFailure: _Function.identity,
  onSuccess: () => internalCause.empty
});
/* @internal

## firstSuccessOf

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `firstSuccessOf(= firstSuccessOf;
const flipWith = exports.flipWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const liftPredicate = exports.liftPredicate = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, orFailWith) => core.suspend(() => predicate(self) ? core.succeed(self) : core.fail(orFailWith(self))));
/* @internal */
const filterOrFail = exports.filterOrFail = /*#__PURE__*/(0, _Function.dual)(args => core.isEffect(args[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, a => orFailWith === undefined ? core.fail(new core.NoSuchElementException()) : core.failSync(() => orFailWith(a))));
/* @internal */
const findFirst = exports.findFirst = /*#__PURE__*/(0, _Function.dual)(2, (elements, predicate) => core.suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, predicate, next.value);
  }
  return core.succeed(Option.none());
}));
const findLoop = (iterator, index, f, value) => core.flatMap(f(value, index), result => {
  if (result) {
    return core.succeed(Option.some(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index + 1, f, next.value);
  }
  return core.succeed(Option.none());
});
/* @internal */
const firstSuccessOf = effects => core.suspend(() => {
  const list = Chunk.fromIterable(effects);
  if (!Chunk.isNonEmpty(list)) {
    return core.dieSync(() => new core.IllegalArgumentException(`Received an empty collection of effects`));
  }
  return (0, _Function.pipe)(Chunk.tailNonEmpty(list), Arr.reduce(Chunk.headNonEmpty(list), (left, right) => core.orElse(left, () => right)));
});
/* @internal

## iterate

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `iterate(= iterate;
const logWithLevel = level => (...message)`

JSDoc:

@internal

## logWithLevel

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `logWithLevel(= logWithLevel;
const log = exports.log = /*#__PURE__*/logWithLevel()`

JSDoc:

@internal

## memoize

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `memoize(= memoize;
const merge = self => core.matchEffect(self, {
  onFailure: e => core.succeed(e)`

JSDoc:

@internal */
const logTrace = exports.logTrace = /*#__PURE__*/logWithLevel(LogLevel.Trace);
/** @internal */
const logDebug = exports.logDebug = /*#__PURE__*/logWithLevel(LogLevel.Debug);
/** @internal */
const logInfo = exports.logInfo = /*#__PURE__*/logWithLevel(LogLevel.Info);
/** @internal */
const logWarning = exports.logWarning = /*#__PURE__*/logWithLevel(LogLevel.Warning);
/** @internal */
const logError = exports.logError = /*#__PURE__*/logWithLevel(LogLevel.Error);
/** @internal */
const logFatal = exports.logFatal = /*#__PURE__*/logWithLevel(LogLevel.Fatal);
/* @internal */
const withLogSpan = exports.withLogSpan = /*#__PURE__*/(0, _Function.dual)(2, (effect, label) => core.flatMap(Clock.currentTimeMillis, now => core.fiberRefLocallyWith(effect, core.currentLogSpan, List.prepend(LogSpan.make(label, now)))));
/* @internal */
const logAnnotations = exports.logAnnotations = /*#__PURE__*/core.fiberRefGet(core.currentLogAnnotations);
/* @internal */
const loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : core.map(loopInternal(initial, options.while, options.step, options.body), Arr.fromIterable);
exports.loop = loop;
const loopInternal = (initial, cont, inc, body) => core.suspend(() => cont(initial) ? core.flatMap(body(initial), a => core.map(loopInternal(inc(initial), cont, inc, body), List.prepend(a))) : core.sync(() => List.empty()));
const loopDiscard = (initial, cont, inc, body) => core.suspend(() => cont(initial) ? core.flatMap(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : core.void);
/* @internal */
const mapAccum = exports.mapAccum = /*#__PURE__*/(0, _Function.dual)(3, (elements, initial, f) => core.suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = core.succeed(initial);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index = i++;
    const value = next.value;
    result = core.flatMap(result, state => core.map(f(state, value, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return core.map(result, z => [z, builder]);
}));
/* @internal */
const mapErrorCause = exports.mapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.matchCauseEffect(self, {
  onFailure: c => core.failCauseSync(() => f(c)),
  onSuccess: core.succeed
}));
/* @internal */
const memoize = self => (0, _Function.pipe)(core.deferredMake(), core.flatMap(deferred => (0, _Function.pipe)(diffFiberRefsAndRuntimeFlags(self), core.intoDeferred(deferred), once, core.map(complete => core.zipRight(complete, (0, _Function.pipe)(core.deferredAwait(deferred), core.flatMap(([patch, a]) => core.as(core.zip(patchFiberRefs(patch[0]), core.updateRuntimeFlags(patch[1])), a))))))));
/* @internal

## tryPromise

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `tryPromise(= tryPromise;
const tryMap = exports.tryMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const tracer = exports.tracer = /*#__PURE__*/tracerWith(core.succeed);
/* @internal */
const tryPromise = arg => {
  let evaluate;
  let catcher = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    catcher = arg.catch;
  }
  const fail = e => catcher ? core.failSync(() => catcher(e)) : core.fail(new core.UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate.length >= 1) {
    return core.async((resolve, signal) => {
      try {
        evaluate(signal).then(a => resolve(core.exitSucceed(a)), e => resolve(fail(e)));
      } catch (e) {
        resolve(fail(e));
      }
    });
  }
  return core.async(resolve => {
    try {
      evaluate().then(a => resolve(core.exitSucceed(a)), e => resolve(fail(e)));
    } catch (e) {
      resolve(fail(e));
    }
  });
};
/* @internal

## serviceFunctionEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `serviceFunctionEffect(= serviceFunctionEffect;
const serviceFunction = (getService, f)`

JSDoc:

@internal */
const serviceFunctionEffect = (getService, f) => (...args) => core.flatMap(getService, a => f(a)(...args));
/** @internal

## serviceFunction

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `serviceFunction(= serviceFunction;
const serviceFunctions = getService => new Proxy({}, {
  get(_target, prop, _receiver)`

JSDoc:

@internal

## serviceFunctions

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `serviceFunctions(= serviceFunctions;
const serviceConstants = getService => new Proxy({}, {
  get(_target, prop, _receiver)`

JSDoc:

@internal

## serviceConstants

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `serviceConstants(= serviceConstants;
const serviceMembers = getService => ({
  functions: serviceFunctions(getService)`

JSDoc:

@internal

## serviceMembers

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `serviceMembers(= serviceMembers;
const serviceOption = tag => core.map(core.context()`

JSDoc:

@internal

## serviceOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `serviceOption(= serviceOption;
const serviceOptional = tag => core.flatMap(core.context()`

JSDoc:

@internal

## unsafeMakeSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `unsafeMakeSpan(= unsafeMakeSpan;
const makeSpan = (name, options)`

JSDoc:

@internal */
const currentParentSpan = exports.currentParentSpan = /*#__PURE__*/serviceOptional(internalTracer.spanTag);
/** @internal */
const currentSpan = exports.currentSpan = /*#__PURE__*/core.flatMap(/*#__PURE__*/core.context(), context => {
  const span = context.unsafeMap.get(internalTracer.spanTag.key);
  return span !== undefined && span._tag === "Span" ? core.succeed(span) : core.fail(new core.NoSuchElementException());
});
/* @internal */
const linkSpans = exports.linkSpans = /*#__PURE__*/(0, _Function.dual)(args => core.isEffect(args[0]), (self, span, attributes) => core.fiberRefLocallyWith(self, core.currentTracerSpanLinks, Chunk.append({
  _tag: "SpanLink",
  span,
  attributes: attributes ?? {}
})));
const bigint0 = /*#__PURE__*/BigInt(0);
const filterDisablePropagation = /*#__PURE__*/Option.flatMap(span => Context.get(span.context, internalTracer.DisablePropagation) ? span._tag === "Span" ? filterDisablePropagation(span.parent) : Option.none() : Option.some(span));
/** @internal */
const unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(core.currentTracerEnabled) || options.context && Context.get(options.context, internalTracer.DisablePropagation);
  const context = fiber.getFiberRef(core.currentContext);
  const parent = options.parent ? Option.some(options.parent) : options.root ? Option.none() : filterDisablePropagation(Context.getOption(context, internalTracer.spanTag));
  let span;
  if (disablePropagation) {
    span = core.noopSpan({
      name,
      parent,
      context: Context.add(options.context ?? Context.empty(), internalTracer.DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(defaultServices.currentServices);
    const tracer = Context.get(services, internalTracer.tracerTag);
    const clock = Context.get(services, Clock.Clock);
    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled);
    const fiberRefs = fiber.getFiberRefs();
    const annotationsFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanAnnotations);
    const linksFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [...Chunk.toReadonlyArray(linksFromEnv.value), ...(options.links ?? [])] : Chunk.toReadonlyArray(linksFromEnv.value) : options.links ?? Arr.empty();
    span = tracer.span(name, parent, options.context ?? Context.empty(), links, timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      HashMap.forEach(annotationsFromEnv.value, (value, key) => span.attribute(key, value));
    }
    if (options.attributes !== undefined) {
      Object.entries(options.attributes).forEach(([k, v]) => span.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    internalCause.spanToTrace.set(span, options.captureStackTrace);
  }
  return span;
};
/** @internal

## endSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `endSpan(= endSpan;
const useSpan = (name, ...args)`

JSDoc:

@internal */
const endSpan = (span, exit, clock, timingEnabled) => core.sync(() => {
  if (span.status._tag === "Ended") {
    return;
  }
  if (core.exitIsFailure(exit) && internalCause.spanToTrace.has(span)) {
    span.attribute("code.stacktrace", internalCause.spanToTrace.get(span)());
  }
  span.end(timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, exit);
});
/** @internal

## useSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `useSpan(= useSpan;
const withParentSpan = exports.withParentSpan = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## functionWithSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-effect.js`

Signature: `functionWithSpan(= functionWithSpan;
const fromNullable = value => value == null ? core.fail(new core.NoSuchElementException()`

JSDoc:

@internal */
const withSpan = function () {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = internalTracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan(name, options, span => withParentSpan(self, span));
  }
  return self => useSpan(name, options, span => withParentSpan(self, span));
};
exports.withSpan = withSpan;
const functionWithSpan = options => function () {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error();
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error.stack) {
        const stack = error.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    };
  }
  return core.suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(core.suspend(() => (0, _Utils.internalCall)(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
// -------------------------------------------------------------------------------------
// optionality
// -------------------------------------------------------------------------------------
/* @internal

## isChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `isChannel(= isChannel;
const acquireReleaseOut = exports.acquireReleaseOut = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const ChannelSymbolKey = "effect/Channel";
/** @internal */
const ChannelTypeId = exports.ChannelTypeId = /*#__PURE__*/Symbol.for(ChannelSymbolKey);
const channelVariance = {
  /* c8 ignore next */
  _Env: _ => _,
  /* c8 ignore next */
  _InErr: _ => _,
  /* c8 ignore next */
  _InElem: _ => _,
  /* c8 ignore next */
  _InDone: _ => _,
  /* c8 ignore next */
  _OutErr: _ => _,
  /* c8 ignore next */
  _OutElem: _ => _,
  /* c8 ignore next */
  _OutDone: _ => _
};
/** @internal */
const proto = {
  [ChannelTypeId]: channelVariance,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const isChannel = u => (0, _Predicate.hasProperty)(u, ChannelTypeId) || Effect.isEffect(u);
/** @internal

## collectElements

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `collectElements(= collectElements;
const collectElementsReader = builder => readWith({
  onInput: outElem => flatMap(sync(()`

JSDoc:

@internal */
const catchAllCause = exports.catchAllCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FOLD;
  op.channel = self;
  op.k = new _continuation.ContinuationKImpl(succeed, f);
  return op;
});
/** @internal */
const collectElements = self => {
  return suspend(() => {
    const builder = [];
    return flatMap(pipeTo(self, collectElementsReader(builder)), value => sync(() => [Chunk.fromIterable(builder), value]));
  });
};
/** @internal

## concatAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `concatAll(= concatAll;
const concatAllWith = (channels, f, g)`

JSDoc:

@internal */
const concatAll = channels => concatAllWith(channels, _Function.constVoid, _Function.constVoid);
/** @internal

## concatAllWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `concatAllWith(= concatAllWith;
const concatMapWith = exports.concatMapWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `fail(= fail;
const failSync = evaluate => failCauseSync(()`

JSDoc:

@internal */
const concatMapWithCustom = exports.concatMapWithCustom = /*#__PURE__*/(0, _Function.dual)(6, (self, f, g, h, onPull, onEmit) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = onPull;
  op.onEmit = onEmit;
  op.value = () => self;
  op.k = f;
  return op;
});
/** @internal */
const embedInput = exports.embedInput = /*#__PURE__*/(0, _Function.dual)(2, (self, input) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
/** @internal */
const ensuringWith = exports.ensuringWith = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer;
  return op;
});
/** @internal */
const fail = error => failCause(Cause.fail(error));
/** @internal

## failSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `failSync(= failSync;
const failCause = cause => failCauseSync(()`

JSDoc:

@internal

## failCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `failCause(= failCause;
const failCauseSync = evaluate => {
  const op = Object.create(proto)`

JSDoc:

@internal

## failCauseSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `failCauseSync(= failCauseSync;
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fromEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `fromEffect(= fromEffect;
const pipeTo = exports.pipeTo = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const foldCauseChannel = exports.foldCauseChannel = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FOLD;
  op.channel = self;
  op.k = new _continuation.ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
/** @internal */
const fromEffect = effect => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_FROM_EFFECT;
  op.effect = () => effect;
  return op;
};
/** @internal

## readOrFail

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `readOrFail(= readOrFail;
const readWith = options => readWithCause({
  onInput: options.onInput,
  onFailure: cause => Either.match(Cause.failureOrCause(cause)`

JSDoc:

@internal */
const provideContext = exports.provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, env) => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_PROVIDE;
  op.context = () => env;
  op.inner = self;
  return op;
});
/** @internal */
const readOrFail = error => {
  const op = Object.create(proto);
  op._tag = OpCodes.OP_READ;
  op.more = succeed;
  op.done = new _continuation.ContinuationKImpl(() => fail(error), () => fail(error));
  return op;
};
/** @internal

## readWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `readWith(= readWith;
const readWithCause = options => {
  const op = Object.create(proto)`

JSDoc:

@internal

## readWithCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `readWithCause(= readWithCause;
const succeed = value => sync(()`

JSDoc:

@internal

## succeed

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `succeed(= succeed;
const succeedNow = result => {
  const op = Object.create(proto)`

JSDoc:

@internal

## succeedNow

Source: `my-backend/node_modules/effect/dist/cjs/internal/core-stream.js`

Signature: `succeedNow(= succeedNow;
const suspend = evaluate => {
  const op = Object.create(proto)`

JSDoc:

@internal

## blocked

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `blocked(= blocked;
const runRequestBlock = blockedRequests => {
  const effect = new EffectPrimitive("RunBlocked")`

JSDoc:

@internal
/
const blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
};
/**
@internal

## runRequestBlock

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `runRequestBlock(= runRequestBlock;
const EffectTypeId = exports.EffectTypeId = /*#__PURE__*/Symbol.for("effect/Effect")`

JSDoc:

@internal

## isEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isEffect(= isEffect;
const withFiberRuntime = withRuntime => {
  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME)`

JSDoc:

@internal */
class RevertFlags {
  patch;
  op;
  _op = OpCodes.OP_REVERT_FLAGS;
  constructor(patch, op) {
    this.patch = patch;
    this.op = op;
  }
}
exports.RevertFlags = RevertFlags;
class EffectPrimitive {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId] = _effectable.effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [Equal.symbol](that) {
    return this === that;
  }
  [Hash.symbol]() {
    return Hash.cached(this, Hash.random(this));
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: (0, _Inspectable.toJSON)(this.effect_instruction_i0),
      effect_instruction_i1: (0, _Inspectable.toJSON)(this.effect_instruction_i1),
      effect_instruction_i2: (0, _Inspectable.toJSON)(this.effect_instruction_i2)
    };
  }
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  }
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new _singleShotGen.SingleShotGen(new _Utils.YieldWrap(this));
  }
}
/** @internal */
class EffectPrimitiveFailure {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId] = _effectable.effectVariance;
  constructor(_op) {
    this._op = _op;
    // @ts-expect-error
    this._tag = _op;
  }
  [Equal.symbol](that) {
    return exitIsExit(that) && that._op === "Failure" &&
    // @ts-expect-error
    Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(
    // @ts-expect-error
    Hash.string(this._tag),
    // @ts-expect-error
    Hash.combine(Hash.hash(this.effect_instruction_i0)), Hash.cached(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  }
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new _singleShotGen.SingleShotGen(new _Utils.YieldWrap(this));
  }
}
/** @internal */
class EffectPrimitiveSuccess {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId] = _effectable.effectVariance;
  constructor(_op) {
    this._op = _op;
    // @ts-expect-error
    this._tag = _op;
  }
  [Equal.symbol](that) {
    return exitIsExit(that) && that._op === "Success" &&
    // @ts-expect-error
    Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(
    // @ts-expect-error
    Hash.string(this._tag),
    // @ts-expect-error
    Hash.combine(Hash.hash(this.effect_instruction_i0)), Hash.cached(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: (0, _Inspectable.toJSON)(this.value)
    };
  }
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  }
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new _singleShotGen.SingleShotGen(new _Utils.YieldWrap(this));
  }
}
/** @internal */
const isEffect = u => (0, _Predicate.hasProperty)(u, EffectTypeId);
/* @internal

## gen

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `gen(= gen;
const fnUntraced = (body, ...pipeables)`

JSDoc:

@internal

## yieldNow

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `yieldNow(= yieldNow;
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const withTracerEnabled = exports.withTracerEnabled = /*#__PURE__*/(0, _Function.dual)(2, (effect, enabled) => fiberRefLocally(effect, currentTracerEnabled, enabled));
/** @internal */
const withTracerTiming = exports.withTracerTiming = /*#__PURE__*/(0, _Function.dual)(2, (effect, enabled) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled));
/* @internal */
const yieldNow = options => {
  const effect = new EffectPrimitive(OpCodes.OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
/* @internal

## fiberRefGet

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `fiberRefGet(= fiberRefGet;
const fiberRefGetAndSet = exports.fiberRefGetAndSet = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const logLevelAll = exports.logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const logLevelFatal = exports.logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 50000,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const logLevelError = exports.logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 40000,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const logLevelWarning = exports.logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 30000,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const logLevelInfo = exports.logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 20000,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const logLevelDebug = exports.logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 10000,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const logLevelTrace = exports.logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const logLevelNone = exports.logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const allLogLevels = exports.allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
// -----------------------------------------------------------------------------
// FiberRef
// -----------------------------------------------------------------------------
/** @internal */
const FiberRefSymbolKey = "effect/FiberRef";
/** @internal */
const FiberRefTypeId = exports.FiberRefTypeId = /*#__PURE__*/Symbol.for(FiberRefSymbolKey);
const fiberRefVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/* @internal */
const fiberRefGet = self => withFiberRuntime(fiber => exitSucceed(fiber.getFiberRef(self)));
/* @internal

## RequestResolverImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `RequestResolverImpl(= RequestResolverImpl;
const isRequestResolver = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const RequestResolverSymbolKey = "effect/RequestResolver";
/** @internal */
const RequestResolverTypeId = exports.RequestResolverTypeId = /*#__PURE__*/Symbol.for(RequestResolverSymbolKey);
const requestResolverVariance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
/** @internal */
class RequestResolverImpl {
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target) {
    this.runAll = runAll;
    this.target = target;
  }
  [Hash.symbol]() {
    return Hash.cached(this, this.target ? Hash.hash(this.target) : Hash.random(this));
  }
  [Equal.symbol](that) {
    return this.target ? isRequestResolver(that) && Equal.equals(this.target, that.target) : this === that;
  }
  identified(...ids) {
    return new RequestResolverImpl(this.runAll, Chunk.fromIterable(ids));
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## isRequestResolver

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isRequestResolver(= isRequestResolver;
const resolverLocally = exports.resolverLocally = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fiberRefUnsafeMake

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `fiberRefUnsafeMake(= fiberRefUnsafeMake;
const fiberRefUnsafeMakeHashSet = initial => {
  const differ = internalDiffer.hashSet()`

JSDoc:

@internal */
const requestBlockLocally = (self, ref, value) => blockedRequests_.reduce(self, LocallyReducer(ref, value));
exports.requestBlockLocally = requestBlockLocally;
const LocallyReducer = (ref, value) => ({
  emptyCase: () => blockedRequests_.empty,
  parCase: (left, right) => blockedRequests_.par(left, right),
  seqCase: (left, right) => blockedRequests_.seq(left, right),
  singleCase: (dataSource, blockedRequest) => blockedRequests_.single(resolverLocally(dataSource, ref, value), blockedRequest)
});
/* @internal */
const fiberRefLocally = exports.fiberRefLocally = /*#__PURE__*/(0, _Function.dual)(3, (use, self, value) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, oldValue => fiberRefSet(self, oldValue)));
/* @internal */
const fiberRefLocallyWith = exports.fiberRefLocallyWith = /*#__PURE__*/(0, _Function.dual)(3, (use, self, f) => fiberRefGetWith(self, a => fiberRefLocally(use, self, f(a))));
/** @internal */
const fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: internalDiffer.update(),
  fork: options?.fork ?? _Function.identity,
  join: options?.join
});
/** @internal

## fiberRefUnsafeMakeHashSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `fiberRefUnsafeMakeHashSet(= fiberRefUnsafeMakeHashSet;
const fiberRefUnsafeMakeReadonlyArray = initial => {
  const differ = internalDiffer.readonlyArray(internalDiffer.update()`

JSDoc:

@internal

## fiberRefUnsafeMakeReadonlyArray

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `fiberRefUnsafeMakeReadonlyArray(= fiberRefUnsafeMakeReadonlyArray;
const fiberRefUnsafeMakeContext = initial => {
  const differ = internalDiffer.environment()`

JSDoc:

@internal

## fiberRefUnsafeMakeContext

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `fiberRefUnsafeMakeContext(= fiberRefUnsafeMakeContext;
const fiberRefUnsafeMakePatch = (initial, options)`

JSDoc:

@internal

## fiberRefUnsafeMakePatch

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `fiberRefUnsafeMakePatch(= fiberRefUnsafeMakePatch;
const fiberRefUnsafeMakeRuntimeFlags = initial => fiberRefUnsafeMakePatch(initial, {
  differ: runtimeFlags_.differ,
  fork: runtimeFlags_.differ.empty
})`

JSDoc:

@internal

## fiberRefUnsafeMakeRuntimeFlags

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `fiberRefUnsafeMakeRuntimeFlags(= fiberRefUnsafeMakeRuntimeFlags;
const currentContext = exports.currentContext = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@internal

## scopeAddFinalizer

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `scopeAddFinalizer(= scopeAddFinalizer;
const scopeAddFinalizerExit = (self, finalizer)`

JSDoc:

@internal */
const currentSchedulingPriority = exports.currentSchedulingPriority = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
/** @internal */
const currentMaxOpsBeforeYield = exports.currentMaxOpsBeforeYield = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
/** @internal */
const currentLogAnnotations = exports.currentLogAnnotations = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(HashMap.empty()));
/** @internal */
const currentLogLevel = exports.currentLogLevel = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
/** @internal */
const currentLogSpan = exports.currentLogSpan = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(List.empty()));
/** @internal */
const withSchedulingPriority = exports.withSchedulingPriority = /*#__PURE__*/(0, _Function.dual)(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
/** @internal */
const withMaxOpsBeforeYield = exports.withMaxOpsBeforeYield = /*#__PURE__*/(0, _Function.dual)(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
/** @internal */
const currentConcurrency = exports.currentConcurrency = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
/**
@internal
/
const currentRequestBatching = exports.currentRequestBatching = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentUnhandledErrorLogLevel = exports.currentUnhandledErrorLogLevel = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(Option.some(logLevelDebug)));
/** @internal */
const withUnhandledErrorLogLevel = exports.withUnhandledErrorLogLevel = /*#__PURE__*/(0, _Function.dual)(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
/** @internal */
const currentMetricLabels = exports.currentMetricLabels = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(Arr.empty()));
/* @internal */
const metricLabels = exports.metricLabels = /*#__PURE__*/fiberRefGet(currentMetricLabels);
/** @internal */
const currentForkScopeOverride = exports.currentForkScopeOverride = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(Option.none(), {
  fork: () => Option.none(),
  join: (parent, _) => parent
}));
/** @internal */
const currentInterruptedCause = exports.currentInterruptedCause = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(internalCause.empty, {
  fork: () => internalCause.empty,
  join: (parent, _) => parent
}));
/** @internal */
const currentTracerEnabled = exports.currentTracerEnabled = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentTracerTimingEnabled = exports.currentTracerTimingEnabled = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentTracerSpanAnnotations = exports.currentTracerSpanAnnotations = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(HashMap.empty()));
/** @internal */
const currentTracerSpanLinks = exports.currentTracerSpanLinks = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(Chunk.empty()));
// -----------------------------------------------------------------------------
// Scope
// -----------------------------------------------------------------------------
/** @internal */
const ScopeTypeId = exports.ScopeTypeId = /*#__PURE__*/Symbol.for("effect/Scope");
/** @internal */
const CloseableScopeTypeId = exports.CloseableScopeTypeId = /*#__PURE__*/Symbol.for("effect/CloseableScope");
/* @internal */
const scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid(finalizer));
/* @internal

## scopeFork

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `scopeFork(= scopeFork;
const causeSquash = self => {
  return causeSquashWith(_Function.identity)`

JSDoc:

@internal

## causeSquash

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `causeSquash(= causeSquash;
const causeSquashWith = exports.causeSquashWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## isRuntimeException

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isRuntimeException(= isRuntimeException;
const InterruptedExceptionTypeId = exports.InterruptedExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/InterruptedException")`

JSDoc:

@internal */
const YieldableError = exports.YieldableError = /*#__PURE__*/function () {
  class YieldableError extends globalThis.Error {
    commit() {
      return fail(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [_Inspectable.NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}\n${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return internalCause.pretty(internalCause.fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  // @effect-diagnostics-next-line floatingEffect:off
  Object.assign(YieldableError.prototype, _effectable.StructuralCommitPrototype);
  return YieldableError;
}();
const makeException = (proto, tag) => {
  class Base extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base.prototype, proto);
  Base.prototype.name = tag;
  return Base;
};
/** @internal */
const RuntimeExceptionTypeId = exports.RuntimeExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/RuntimeException");
/** @internal */
const RuntimeException = exports.RuntimeException = /*#__PURE__*/makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
/** @internal */
const isRuntimeException = u => (0, _Predicate.hasProperty)(u, RuntimeExceptionTypeId);
/** @internal

## isInterruptedException

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isInterruptedException(= isInterruptedException;
const IllegalArgumentExceptionTypeId = exports.IllegalArgumentExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/IllegalArgument")`

JSDoc:

@internal */
const InterruptedException = exports.InterruptedException = /*#__PURE__*/makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
/** @internal */
const isInterruptedException = u => (0, _Predicate.hasProperty)(u, InterruptedExceptionTypeId);
/** @internal

## isIllegalArgumentException

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isIllegalArgumentException(= isIllegalArgumentException;
const NoSuchElementExceptionTypeId = exports.NoSuchElementExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/NoSuchElement")`

JSDoc:

@internal */
const IllegalArgumentException = exports.IllegalArgumentException = /*#__PURE__*/makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
/** @internal */
const isIllegalArgumentException = u => (0, _Predicate.hasProperty)(u, IllegalArgumentExceptionTypeId);
/** @internal

## isNoSuchElementException

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isNoSuchElementException(= isNoSuchElementException;
const InvalidPubSubCapacityExceptionTypeId = exports.InvalidPubSubCapacityExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException")`

JSDoc:

@internal */
const NoSuchElementException = exports.NoSuchElementException = /*#__PURE__*/makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
/** @internal */
const isNoSuchElementException = u => (0, _Predicate.hasProperty)(u, NoSuchElementExceptionTypeId);
/** @internal

## isExceededCapacityException

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isExceededCapacityException(= isExceededCapacityException;
const isInvalidCapacityError = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const InvalidPubSubCapacityException = exports.InvalidPubSubCapacityException = /*#__PURE__*/makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
/** @internal */
const ExceededCapacityExceptionTypeId = exports.ExceededCapacityExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/ExceededCapacityException");
/** @internal */
const ExceededCapacityException = exports.ExceededCapacityException = /*#__PURE__*/makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
/** @internal */
const isExceededCapacityException = u => (0, _Predicate.hasProperty)(u, ExceededCapacityExceptionTypeId);
/** @internal

## isInvalidCapacityError

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isInvalidCapacityError(= isInvalidCapacityError;
const TimeoutExceptionTypeId = exports.TimeoutExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/Timeout")`

JSDoc:

@internal

## timeoutExceptionFromDuration

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `timeoutExceptionFromDuration(= timeoutExceptionFromDuration;
const isTimeoutException = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const TimeoutException = exports.TimeoutException = /*#__PURE__*/makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
/** @internal */
const timeoutExceptionFromDuration = duration => new TimeoutException(`Operation timed out after '${Duration.format(duration)}'`);
/** @internal

## isTimeoutException

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isTimeoutException(= isTimeoutException;
const UnknownExceptionTypeId = exports.UnknownExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Cause/errors/UnknownException")`

JSDoc:

@internal

## isUnknownException

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `isUnknownException(= isUnknownException;
const exitIsExit = u => isEffect(u)`

JSDoc:

@internal */
const UnknownException = exports.UnknownException = /*#__PURE__*/function () {
  class UnknownException extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause, message) {
      super(message ?? "An unknown error occurred", {
        cause
      });
      this.error = cause;
    }
  }
  Object.assign(UnknownException.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException;
}();
/** @internal */
const isUnknownException = u => (0, _Predicate.hasProperty)(u, UnknownExceptionTypeId);
// -----------------------------------------------------------------------------
// Exit
// -----------------------------------------------------------------------------
/** @internal

## exitIsExit

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitIsExit(= exitIsExit;
const exitIsFailure = self => self._tag === "Failure";
/** @internal */
exports.exitIsFailure = exitIsFailure;
const exitIsSuccess = self => self._tag === "Success";
/** @internal */
exports.exitIsSuccess = exitIsSuccess;
const exitIsInterrupted = self => {
  switch (self._tag)`

JSDoc:

@internal

## exitIsInterrupted

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitIsInterrupted(= exitIsInterrupted;
const exitAs = exports.exitAs = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## exitAsVoid

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitAsVoid(= exitAsVoid;
const exitCauseOption = self => {
  switch (self._tag)`

JSDoc:

@internal */
const exitAsVoid = self => exitAs(self, void 0);
/** @internal

## exitCauseOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitCauseOption(= exitCauseOption;
const exitCollectAll = (exits, options)`

JSDoc:

@internal

## exitCollectAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitCollectAll(= exitCollectAll;
const exitDie = defect => exitFailCause(internalCause.die(defect)`

JSDoc:

@internal

## exitDie

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitDie(= exitDie;
const exitExists = exports.exitExists = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## exitFail

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitFail(= exitFail;
const exitFailCause = cause => {
  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE)`

JSDoc:

@internal */
const exitFail = error => exitFailCause(internalCause.fail(error));
/** @internal

## exitFailCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitFailCause(= exitFailCause;
const exitFlatMap = exports.exitFlatMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## exitFlatten

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitFlatten(= exitFlatten;
const exitForEachEffect = exports.exitForEachEffect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const exitFlatMapEffect = exports.exitFlatMapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  switch (self._tag) {
    case OpCodes.OP_FAILURE:
      {
        return succeed(exitFailCause(self.effect_instruction_i0));
      }
    case OpCodes.OP_SUCCESS:
      {
        return f(self.effect_instruction_i0);
      }
  }
});
/** @internal */
const exitFlatten = self => (0, _Function.pipe)(self, exitFlatMap(_Function.identity));
/** @internal

## exitFromEither

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitFromEither(= exitFromEither;
const exitFromOption = option => {
  switch (option._tag)`

JSDoc:

@internal */
const exitFromEither = either => {
  switch (either._tag) {
    case "Left":
      return exitFail(either.left);
    case "Right":
      return exitSucceed(either.right);
  }
};
/** @internal

## exitFromOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitFromOption(= exitFromOption;
const exitGetOrElse = exports.exitGetOrElse = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## exitInterrupt

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitInterrupt(= exitInterrupt;
const exitMap = exports.exitMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const exitInterrupt = fiberId => exitFailCause(internalCause.interrupt(fiberId));
/** @internal

## exitSucceed

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `exitSucceed(= exitSucceed;
const exitVoid = exports.exitVoid = /*#__PURE__*/exitSucceed(void 0)`

JSDoc:

@internal */
const exitMapBoth = exports.exitMapBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OpCodes.OP_FAILURE:
      return exitFailCause((0, _Function.pipe)(self.effect_instruction_i0, internalCause.map(onFailure)));
    case OpCodes.OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
/** @internal */
const exitMapError = exports.exitMapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  switch (self._tag) {
    case OpCodes.OP_FAILURE:
      return exitFailCause((0, _Function.pipe)(self.effect_instruction_i0, internalCause.map(f)));
    case OpCodes.OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
/** @internal */
const exitMapErrorCause = exports.exitMapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  switch (self._tag) {
    case OpCodes.OP_FAILURE:
      return exitFailCause(f(self.effect_instruction_i0));
    case OpCodes.OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
/** @internal */
const exitMatch = exports.exitMatch = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OpCodes.OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OpCodes.OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
/** @internal */
const exitMatchEffect = exports.exitMatchEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OpCodes.OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OpCodes.OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
/** @internal */
const exitSucceed = value => {
  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
/** @internal

## deferredUnsafeMake

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `deferredUnsafeMake(= deferredUnsafeMake;
const deferredMake = ()`

JSDoc:

@internal */
const exitZip = exports.exitZip = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: internalCause.sequential
}));
/** @internal */
const exitZipLeft = exports.exitZipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: internalCause.sequential
}));
/** @internal */
const exitZipRight = exports.exitZipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: internalCause.sequential
}));
/** @internal */
const exitZipPar = exports.exitZipPar = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: internalCause.parallel
}));
/** @internal */
const exitZipParLeft = exports.exitZipParLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: internalCause.parallel
}));
/** @internal */
const exitZipParRight = exports.exitZipParRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: internalCause.parallel
}));
/** @internal */
const exitZipWith = exports.exitZipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OpCodes.OP_FAILURE:
      {
        switch (that._tag) {
          case OpCodes.OP_SUCCESS:
            return exitFailCause(self.effect_instruction_i0);
          case OpCodes.OP_FAILURE:
            {
              return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
            }
        }
      }
    case OpCodes.OP_SUCCESS:
      {
        switch (that._tag) {
          case OpCodes.OP_SUCCESS:
            return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
          case OpCodes.OP_FAILURE:
            return exitFailCause(that.effect_instruction_i0);
        }
      }
  }
});
const exitCollectAllInternal = (exits, combineCauses) => {
  const list = Chunk.fromIterable(exits);
  if (!Chunk.isNonEmpty(list)) {
    return Option.none();
  }
  return (0, _Function.pipe)(Chunk.tailNonEmpty(list), Arr.reduce((0, _Function.pipe)(Chunk.headNonEmpty(list), exitMap(Chunk.of)), (accumulator, current) => (0, _Function.pipe)(accumulator, exitZipWith(current, {
    onSuccess: (list, value) => (0, _Function.pipe)(list, Chunk.prepend(value)),
    onFailure: combineCauses
  }))), exitMap(Chunk.reverse), exitMap(chunk => Chunk.toReadonlyArray(chunk)), Option.some);
};
// -----------------------------------------------------------------------------
// Deferred
// -----------------------------------------------------------------------------
/** @internal */
const deferredUnsafeMake = fiberId => {
  const _deferred = {
    ..._effectable.CommitPrototype,
    [deferred.DeferredTypeId]: deferred.deferredVariance,
    state: MutableRef.make(deferred.pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId
  };
  return _deferred;
};
/* @internal

## context

Source: `my-backend/node_modules/effect/dist/cjs/internal/core.js`

Signature: `context(= context;
const contextWith = f => map(context()`

JSDoc:

@internal */
const deferredUnsafeDone = (self, effect) => {
  const state = MutableRef.get(self.state);
  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {
    MutableRef.set(self.state, deferred.done(effect));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect);
    }
  }
};
exports.deferredUnsafeDone = deferredUnsafeDone;
const deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = MutableRef.get(self.state);
  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      // we can splice here as the internal state is mutable
      state.joiners.splice(index, 1);
    }
  }
});
// -----------------------------------------------------------------------------
// Context
// -----------------------------------------------------------------------------
const constContext = /*#__PURE__*/withFiberRuntime(fiber => exitSucceed(fiber.currentContext));
/* @internal */
const context = () => constContext;
/* @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/dataSource.js`

Signature: `make(= make;
const makeWithEntry = runAll => new core.RequestResolverImpl(requests => runAll(requests)`

JSDoc:

@internal */
const make = runAll => new core.RequestResolverImpl(requests => runAll(requests.map(_ => _.map(_ => _.request))));
/** @internal

## makeWithEntry

Source: `my-backend/node_modules/effect/dist/cjs/internal/dataSource.js`

Signature: `makeWithEntry(= makeWithEntry;
const makeBatched = run => new core.RequestResolverImpl(requests => {
  if (requests.length > 1)`

JSDoc:

@internal

## makeBatched

Source: `my-backend/node_modules/effect/dist/cjs/internal/dataSource.js`

Signature: `makeBatched(= makeBatched;
const around = exports.around = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fromFunction

Source: `my-backend/node_modules/effect/dist/cjs/internal/dataSource.js`

Signature: `fromFunction(= fromFunction;
const fromFunctionBatched = f => makeBatched(as => Effect.forEach(f(as)`

JSDoc:

@internal */
const aroundRequests = exports.aroundRequests = /*#__PURE__*/(0, _Function.dual)(3, (self, before, after) => new core.RequestResolverImpl(requests => {
  const flatRequests = requests.flatMap(chunk => chunk.map(entry => entry.request));
  return core.acquireUseRelease(before(flatRequests), () => self.runAll(requests), a2 => after(flatRequests, a2));
}, Chunk.make("AroundRequests", self, before, after)));
/** @internal */
const batchN = exports.batchN = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => new core.RequestResolverImpl(requests => {
  return n < 1 ? core.die(new Cause.IllegalArgumentException("RequestResolver.batchN: n must be at least 1")) : self.runAll(Array.from(Chunk.map(RA.reduce(requests, Chunk.empty(), (acc, chunk) => Chunk.appendAll(acc, Chunk.chunksOf(Chunk.unsafeFromArray(chunk), n))), chunk => Array.from(chunk))));
}, Chunk.make("BatchN", self, n)));
/** @internal */
const mapInputContext = exports.mapInputContext = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new core.RequestResolverImpl(requests => core.mapInputContext(self.runAll(requests), context => f(context)), Chunk.make("MapInputContext", self, f)));
/** @internal */
const eitherWith = exports.eitherWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => new core.RequestResolverImpl(batch => (0, _Function.pipe)(core.forEachSequential(batch, requests => {
  const [as, bs] = (0, _Function.pipe)(requests, RA.partitionMap(f));
  return (0, _fiberRuntime.zipWithOptions)(self.runAll(Array.of(as)), that.runAll(Array.of(bs)), () => void 0, {
    concurrent: true
  });
})), Chunk.make("EitherWith", self, that, f)));
/** @internal */
const fromFunction = f => makeBatched(requests => core.forEachSequentialDiscard(requests, request => (0, _request.complete)(request, core.exitSucceed(f(request))))).identified("FromFunction", f);
/** @internal

## fromFunctionBatched

Source: `my-backend/node_modules/effect/dist/cjs/internal/dataSource.js`

Signature: `fromFunctionBatched(= fromFunctionBatched;
const fromEffect = f => makeBatched(requests => Effect.forEach(requests, a => Effect.flatMap(Effect.exit(f(a)`

JSDoc:

@internal

## fromEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/dataSource.js`

Signature: `fromEffect(= fromEffect;
const fromEffectTagged = ()`

JSDoc:

@internal

## fromEffectTagged

Source: `my-backend/node_modules/effect/dist/cjs/internal/dataSource.js`

Signature: `fromEffectTagged(= fromEffectTagged;
const never = exports.never = /*#__PURE__*/make(()`

JSDoc:

@internal

## makeZonedProto

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `makeZonedProto(= makeZonedProto;
const isDateTime = u => Predicate.hasProperty(u, TypeId)`

JSDoc:

@internal */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/DateTime");
/** @internal */
const TimeZoneTypeId = exports.TimeZoneTypeId = /*#__PURE__*/Symbol.for("effect/DateTime/TimeZone");
const Proto = {
  [TypeId]: TypeId,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  [Inspectable.NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
const ProtoUtc = {
  ...Proto,
  _tag: "Utc",
  [Hash.symbol]() {
    return Hash.cached(this, Hash.number(this.epochMillis));
  },
  [Equal.symbol](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
const ProtoZoned = {
  ...Proto,
  _tag: "Zoned",
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.number(this.epochMillis), Hash.combine(Hash.hash(this.zone)), Hash.cached(this));
  },
  [Equal.symbol](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && Equal.equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
const ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [Inspectable.NodeInspectSymbol]() {
    return this.toString();
  }
};
const ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [Hash.symbol]() {
    return Hash.cached(this, Hash.string(`Named:${this.id}`));
  },
  [Equal.symbol](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
const ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [Hash.symbol]() {
    return Hash.cached(this, Hash.string(`Offset:${this.offset}`));
  },
  [Equal.symbol](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
/** @internal */
const makeZonedProto = (epochMillis, zone, partsUtc) => {
  const self = Object.create(ProtoZoned);
  self.epochMillis = epochMillis;
  self.zone = zone;
  Object.defineProperty(self, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "adjustedEpochMillis", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "partsAdjusted", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  return self;
};
// =============================================================================
// guards
// =============================================================================
/** @internal

## isTimeZone

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `isTimeZone(= isTimeZone;
const isTimeZoneOffset = u => isTimeZone(u)`

JSDoc:

@internal */
const isTimeZone = u => Predicate.hasProperty(u, TimeZoneTypeId);
/** @internal

## isTimeZoneOffset

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `isTimeZoneOffset(= isTimeZoneOffset;
const isTimeZoneNamed = u => isTimeZone(u)`

JSDoc:

@internal

## isTimeZoneNamed

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `isTimeZoneNamed(= isTimeZoneNamed;
const isUtc = self => self._tag === "Utc";
/** @internal */
exports.isUtc = isUtc;
const isZoned = self => self._tag === "Zoned";
// =============================================================================
// instances
// =============================================================================
/** @internal */
exports.isZoned = isZoned;
const Equivalence = exports.Equivalence = /*#__PURE__*/equivalence.make((a, b)`

JSDoc:

@internal

## unsafeFromDate

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `unsafeFromDate(= unsafeFromDate;
const unsafeMake = input => {
  if (isDateTime(input)`

JSDoc:

@internal */
const Order = exports.Order = /*#__PURE__*/order.make((self, that) => self.epochMillis < that.epochMillis ? -1 : self.epochMillis > that.epochMillis ? 1 : 0);
/** @internal */
const clamp = exports.clamp = /*#__PURE__*/order.clamp(Order);
// =============================================================================
// constructors
// =============================================================================
const makeUtc = epochMillis => {
  const self = Object.create(ProtoUtc);
  self.epochMillis = epochMillis;
  Object.defineProperty(self, "partsUtc", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  return self;
};
/** @internal */
const unsafeFromDate = date => {
  const epochMillis = date.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new _Cause.IllegalArgumentException("Invalid date");
  }
  return makeUtc(epochMillis);
};
/** @internal

## unsafeMakeZoned

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `unsafeMakeZoned(= unsafeMakeZoned;
const makeZoned = exports.makeZoned = /*#__PURE__*/Option.liftThrowable(unsafeMakeZoned)`

JSDoc:

@internal */
const unsafeMakeZoned = (input, options) => {
  if (options?.timeZone === undefined && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self = unsafeMake(input);
  if (self.epochMillis < minEpochMillis || self.epochMillis > maxEpochMillis) {
    throw new _Cause.IllegalArgumentException(`Epoch millis out of range: ${self.epochMillis}`);
  }
  let zone;
  if (options?.timeZone === undefined) {
    const offset = new Date(self.epochMillis).getTimezoneOffset() * -60 * 1000;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options?.timeZone)) {
    zone = options.timeZone;
  } else if (typeof options?.timeZone === "number") {
    zone = zoneMakeOffset(options.timeZone);
  } else {
    const parsedZone = zoneFromString(options.timeZone);
    if (Option.isNone(parsedZone)) {
      throw new _Cause.IllegalArgumentException(`Invalid time zone: ${options.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if (options?.adjustForTimeZone !== true) {
    return makeZonedProto(self.epochMillis, zone, self.partsUtc);
  }
  return makeZonedFromAdjusted(self.epochMillis, zone);
};
/** @internal

## makeZonedFromString

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `makeZonedFromString(= makeZonedFromString;
const now = exports.now = /*#__PURE__*/core.map(Clock.currentTimeMillis, makeUtc)`

JSDoc:

@internal */
const make = exports.make = /*#__PURE__*/Option.liftThrowable(unsafeMake);
const zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
/** @internal */
const makeZonedFromString = input => {
  const match = zonedStringRegex.exec(input);
  if (match === null) {
    const offset = parseOffset(input);
    return offset !== null ? makeZoned(input, {
      timeZone: offset
    }) : Option.none();
  }
  const [, isoString, timeZone] = match;
  return makeZoned(isoString, {
    timeZone
  });
};
/** @internal

## unsafeNow

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `unsafeNow(= unsafeNow;
const toUtc = self => makeUtc(self.epochMillis)`

JSDoc:

@internal */
const nowAsDate = exports.nowAsDate = /*#__PURE__*/core.map(Clock.currentTimeMillis, millis => new Date(millis));
/** @internal */
const unsafeNow = () => makeUtc(Date.now());
// =============================================================================
// time zones
// =============================================================================
/** @internal

## toUtc

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `toUtc(= toUtc;
const setZone = exports.setZone = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## zoneUnsafeMakeNamed

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `zoneUnsafeMakeNamed(= zoneUnsafeMakeNamed;
const zoneMakeOffset = offset => {
  const zone = Object.create(ProtoTimeZoneOffset)`

JSDoc:

@internal */
const setZoneOffset = exports.setZoneOffset = /*#__PURE__*/(0, _Function.dual)(isDateTimeArgs, (self, offset, options) => setZone(self, zoneMakeOffset(offset), options));
const validZoneCache = /*#__PURE__*/(0, _GlobalValue.globalValue)("effect/DateTime/validZoneCache", () => new Map());
const formatOptions = {
  day: "numeric",
  month: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZoneName: "longOffset",
  fractionalSecondDigits: 3,
  hourCycle: "h23"
};
const zoneMakeIntl = format => {
  const zoneId = format.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format;
  validZoneCache.set(zoneId, zone);
  return zone;
};
/** @internal */
const zoneUnsafeMakeNamed = zoneId => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new _Cause.IllegalArgumentException(`Invalid time zone: ${zoneId}`);
  }
};
/** @internal

## zoneMakeOffset

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `zoneMakeOffset(= zoneMakeOffset;
const zoneMakeNamed = exports.zoneMakeNamed = /*#__PURE__*/Option.liftThrowable(zoneUnsafeMakeNamed)`

JSDoc:

@internal

## zoneMakeNamedEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `zoneMakeNamedEffect(= zoneMakeNamedEffect;
const zoneMakeLocal = ()`

JSDoc:

@internal */
const zoneMakeNamedEffect = zoneId => internalEffect.try_({
  try: () => zoneUnsafeMakeNamed(zoneId),
  catch: e => e
});
/** @internal

## zoneFromString

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `zoneFromString(= zoneFromString;
const zoneToString = self => {
  if (self._tag === "Offset")`

JSDoc:

@internal */
const zoneFromString = zone => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? Option.none() : Option.some(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
};
/** @internal

## zoneToString

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `zoneToString(= zoneToString;
const setZoneNamed = exports.setZoneNamed = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## isFuture

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `isFuture(= isFuture;
const unsafeIsFuture = self => lessThan(unsafeNow()`

JSDoc:

@internal */
const unsafeSetZoneNamed = exports.unsafeSetZoneNamed = /*#__PURE__*/(0, _Function.dual)(isDateTimeArgs, (self, zoneId, options) => setZone(self, zoneUnsafeMakeNamed(zoneId), options));
// =============================================================================
// comparisons
// =============================================================================
/** @internal */
const distance = exports.distance = /*#__PURE__*/(0, _Function.dual)(2, (self, other) => toEpochMillis(other) - toEpochMillis(self));
/** @internal */
const distanceDurationEither = exports.distanceDurationEither = /*#__PURE__*/(0, _Function.dual)(2, (self, other) => {
  const diffMillis = distance(self, other);
  return diffMillis > 0 ? Either.right(Duration.millis(diffMillis)) : Either.left(Duration.millis(-diffMillis));
});
/** @internal */
const distanceDuration = exports.distanceDuration = /*#__PURE__*/(0, _Function.dual)(2, (self, other) => Duration.millis(Math.abs(distance(self, other))));
/** @internal */
const min = exports.min = /*#__PURE__*/order.min(Order);
/** @internal */
const max = exports.max = /*#__PURE__*/order.max(Order);
/** @internal */
const greaterThan = exports.greaterThan = /*#__PURE__*/order.greaterThan(Order);
/** @internal */
const greaterThanOrEqualTo = exports.greaterThanOrEqualTo = /*#__PURE__*/order.greaterThanOrEqualTo(Order);
/** @internal */
const lessThan = exports.lessThan = /*#__PURE__*/order.lessThan(Order);
/** @internal */
const lessThanOrEqualTo = exports.lessThanOrEqualTo = /*#__PURE__*/order.lessThanOrEqualTo(Order);
/** @internal */
const between = exports.between = /*#__PURE__*/order.between(Order);
/** @internal */
const isFuture = self => core.map(now, lessThan(self));
/** @internal

## unsafeIsFuture

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `unsafeIsFuture(= unsafeIsFuture;
const isPast = self => core.map(now, greaterThan(self)`

JSDoc:

@internal

## isPast

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `isPast(= isPast;
const unsafeIsPast = self => greaterThan(unsafeNow()`

JSDoc:

@internal

## unsafeIsPast

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `unsafeIsPast(= unsafeIsPast;
const toDateUtc = self => new Date(self.epochMillis)`

JSDoc:

@internal

## toDateUtc

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `toDateUtc(= toDateUtc;
const toDate = self => {
  if (self._tag === "Utc")`

JSDoc:

@internal

## toDate

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `toDate(= toDate;
const zonedOffset = self => {
  const date = toDate(self)`

JSDoc:

@internal

## zonedOffsetIso

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `zonedOffsetIso(= zonedOffsetIso;
const toEpochMillis = self => self.epochMillis;
/** @internal */
exports.toEpochMillis = toEpochMillis;
const removeTime = self => withDate(self, date => {
  date.setUTCHours(0, 0, 0, 0)`

JSDoc:

@internal */
const zonedOffsetIso = self => offsetToString(zonedOffset(self));
/** @internal

## toParts

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `toParts(= toParts;
const toPartsUtc = self => {
  if (self.partsUtc !== undefined)`

JSDoc:

@internal */
const toParts = self => {
  if (self._tag === "Utc") {
    return toPartsUtc(self);
  } else if (self.partsAdjusted !== undefined) {
    return self.partsAdjusted;
  }
  self.partsAdjusted = withDate(self, dateToParts);
  return self.partsAdjusted;
};
/** @internal

## toPartsUtc

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `toPartsUtc(= toPartsUtc;
const getPartUtc = exports.getPartUtc = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## formatIso

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `formatIso(= formatIso;
const formatIsoDate = self => toDate(self)`

JSDoc:

@internal */
const getPart = exports.getPart = /*#__PURE__*/(0, _Function.dual)(2, (self, part) => toParts(self)[part]);
const setPartsDate = (date, parts) => {
  if (parts.year !== undefined) {
    date.setUTCFullYear(parts.year);
  }
  if (parts.month !== undefined) {
    date.setUTCMonth(parts.month - 1);
  }
  if (parts.day !== undefined) {
    date.setUTCDate(parts.day);
  }
  if (parts.weekDay !== undefined) {
    const diff = parts.weekDay - date.getUTCDay();
    date.setUTCDate(date.getUTCDate() + diff);
  }
  if (parts.hours !== undefined) {
    date.setUTCHours(parts.hours);
  }
  if (parts.minutes !== undefined) {
    date.setUTCMinutes(parts.minutes);
  }
  if (parts.seconds !== undefined) {
    date.setUTCSeconds(parts.seconds);
  }
  if (parts.millis !== undefined) {
    date.setUTCMilliseconds(parts.millis);
  }
};
/** @internal */
const setParts = exports.setParts = /*#__PURE__*/(0, _Function.dual)(2, (self, parts) => mutate(self, date => setPartsDate(date, parts)));
/** @internal */
const setPartsUtc = exports.setPartsUtc = /*#__PURE__*/(0, _Function.dual)(2, (self, parts) => mutateUtc(self, date => setPartsDate(date, parts)));
// =============================================================================
// mapping
// =============================================================================
const makeZonedFromAdjusted = (adjustedMillis, zone) => {
  const offset = zone._tag === "Offset" ? zone.offset : calculateNamedOffset(adjustedMillis, zone);
  return makeZonedProto(adjustedMillis - offset, zone);
};
const offsetRegex = /([+-])(\d{2}):(\d{2})$/;
const parseOffset = offset => {
  const match = offsetRegex.exec(offset);
  if (match === null) {
    return null;
  }
  const [, sign, hours, minutes] = match;
  return (sign === "+" ? 1 : -1) * (Number(hours) * 60 + Number(minutes)) * 60 * 1000;
};
const calculateNamedOffset = (adjustedMillis, zone) => {
  const offset = zone.format.formatToParts(adjustedMillis).find(_ => _.type === "timeZoneName")?.value ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    // fallback to using the adjusted date
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
};
/** @internal */
const mutate = exports.mutate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  if (self._tag === "Utc") {
    const date = toDateUtc(self);
    f(date);
    return makeUtc(date.getTime());
  }
  const adjustedDate = toDate(self);
  const newAdjustedDate = new Date(adjustedDate.getTime());
  f(newAdjustedDate);
  return makeZonedFromAdjusted(newAdjustedDate.getTime(), self.zone);
});
/** @internal */
const mutateUtc = exports.mutateUtc = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapEpochMillis(self, millis => {
  const date = new Date(millis);
  f(date);
  return date.getTime();
}));
/** @internal */
const mapEpochMillis = exports.mapEpochMillis = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const millis = f(toEpochMillis(self));
  return self._tag === "Utc" ? makeUtc(millis) : makeZonedProto(millis, self.zone);
});
/** @internal */
const withDate = exports.withDate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => f(toDate(self)));
/** @internal */
const withDateUtc = exports.withDateUtc = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => f(toDateUtc(self)));
/** @internal */
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => self._tag === "Utc" ? options.onUtc(self) : options.onZoned(self));
// =============================================================================
// math
// =============================================================================
/** @internal */
const addDuration = exports.addDuration = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => mapEpochMillis(self, millis => millis + Duration.toMillis(duration)));
/** @internal */
const subtractDuration = exports.subtractDuration = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => mapEpochMillis(self, millis => millis - Duration.toMillis(duration)));
const addMillis = (date, amount) => {
  date.setTime(date.getTime() + amount);
};
/** @internal */
const add = exports.add = /*#__PURE__*/(0, _Function.dual)(2, (self, parts) => mutate(self, date => {
  if (parts.millis) {
    addMillis(date, parts.millis);
  }
  if (parts.seconds) {
    addMillis(date, parts.seconds * 1000);
  }
  if (parts.minutes) {
    addMillis(date, parts.minutes * 60 * 1000);
  }
  if (parts.hours) {
    addMillis(date, parts.hours * 60 * 60 * 1000);
  }
  if (parts.days) {
    date.setUTCDate(date.getUTCDate() + parts.days);
  }
  if (parts.weeks) {
    date.setUTCDate(date.getUTCDate() + parts.weeks * 7);
  }
  if (parts.months) {
    const day = date.getUTCDate();
    date.setUTCMonth(date.getUTCMonth() + parts.months + 1, 0);
    if (day < date.getUTCDate()) {
      date.setUTCDate(day);
    }
  }
  if (parts.years) {
    const day = date.getUTCDate();
    const month = date.getUTCMonth();
    date.setUTCFullYear(date.getUTCFullYear() + parts.years, month + 1, 0);
    if (day < date.getUTCDate()) {
      date.setUTCDate(day);
    }
  }
}));
/** @internal */
const subtract = exports.subtract = /*#__PURE__*/(0, _Function.dual)(2, (self, parts) => {
  const newParts = {};
  for (const key in parts) {
    newParts[key] = -1 * parts[key];
  }
  return add(self, newParts);
});
const startOfDate = (date, part, options) => {
  switch (part) {
    case "second":
      {
        date.setUTCMilliseconds(0);
        break;
      }
    case "minute":
      {
        date.setUTCSeconds(0, 0);
        break;
      }
    case "hour":
      {
        date.setUTCMinutes(0, 0, 0);
        break;
      }
    case "day":
      {
        date.setUTCHours(0, 0, 0, 0);
        break;
      }
    case "week":
      {
        const weekStartsOn = options?.weekStartsOn ?? 0;
        const day = date.getUTCDay();
        const diff = (day - weekStartsOn + 7) % 7;
        date.setUTCDate(date.getUTCDate() - diff);
        date.setUTCHours(0, 0, 0, 0);
        break;
      }
    case "month":
      {
        date.setUTCDate(1);
        date.setUTCHours(0, 0, 0, 0);
        break;
      }
    case "year":
      {
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
        break;
      }
  }
};
/** @internal */
const startOf = exports.startOf = /*#__PURE__*/(0, _Function.dual)(isDateTimeArgs, (self, part, options) => mutate(self, date => startOfDate(date, part, options)));
const endOfDate = (date, part, options) => {
  switch (part) {
    case "second":
      {
        date.setUTCMilliseconds(999);
        break;
      }
    case "minute":
      {
        date.setUTCSeconds(59, 999);
        break;
      }
    case "hour":
      {
        date.setUTCMinutes(59, 59, 999);
        break;
      }
    case "day":
      {
        date.setUTCHours(23, 59, 59, 999);
        break;
      }
    case "week":
      {
        const weekStartsOn = options?.weekStartsOn ?? 0;
        const day = date.getUTCDay();
        const diff = (day - weekStartsOn + 7) % 7;
        date.setUTCDate(date.getUTCDate() - diff + 6);
        date.setUTCHours(23, 59, 59, 999);
        break;
      }
    case "month":
      {
        date.setUTCMonth(date.getUTCMonth() + 1, 0);
        date.setUTCHours(23, 59, 59, 999);
        break;
      }
    case "year":
      {
        date.setUTCMonth(11, 31);
        date.setUTCHours(23, 59, 59, 999);
        break;
      }
  }
};
/** @internal */
const endOf = exports.endOf = /*#__PURE__*/(0, _Function.dual)(isDateTimeArgs, (self, part, options) => mutate(self, date => endOfDate(date, part, options)));
/** @internal */
const nearest = exports.nearest = /*#__PURE__*/(0, _Function.dual)(isDateTimeArgs, (self, part, options) => mutate(self, date => {
  if (part === "milli") return;
  const millis = date.getTime();
  const start = new Date(millis);
  startOfDate(start, part, options);
  const startMillis = start.getTime();
  const end = new Date(millis);
  endOfDate(end, part, options);
  const endMillis = end.getTime() + 1;
  const diffStart = millis - startMillis;
  const diffEnd = endMillis - millis;
  if (diffStart < diffEnd) {
    date.setTime(startMillis);
  } else {
    date.setTime(endMillis);
  }
}));
// =============================================================================
// formatting
// =============================================================================
const intlTimeZone = self => {
  if (self._tag === "Named") {
    return self.id;
  }
  return offsetToString(self.offset);
};
/** @internal */
const format = exports.format = /*#__PURE__*/(0, _Function.dual)(isDateTimeArgs, (self, options) => {
  try {
    return new Intl.DateTimeFormat(options?.locale, {
      timeZone: self._tag === "Utc" ? "UTC" : intlTimeZone(self.zone),
      ...options
    }).format(self.epochMillis);
  } catch {
    return new Intl.DateTimeFormat(options?.locale, {
      timeZone: "UTC",
      ...options
    }).format(toDate(self));
  }
});
/** @internal */
const formatLocal = exports.formatLocal = /*#__PURE__*/(0, _Function.dual)(isDateTimeArgs, (self, options) => new Intl.DateTimeFormat(options?.locale, options).format(self.epochMillis));
/** @internal */
const formatUtc = exports.formatUtc = /*#__PURE__*/(0, _Function.dual)(isDateTimeArgs, (self, options) => new Intl.DateTimeFormat(options?.locale, {
  ...options,
  timeZone: "UTC"
}).format(self.epochMillis));
/** @internal */
const formatIntl = exports.formatIntl = /*#__PURE__*/(0, _Function.dual)(2, (self, format) => format.format(self.epochMillis));
/** @internal */
const formatIso = self => toDateUtc(self).toISOString();
/** @internal

## formatIsoDate

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `formatIsoDate(= formatIsoDate;
const formatIsoDateUtc = self => toDateUtc(self)`

JSDoc:

@internal

## formatIsoDateUtc

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `formatIsoDateUtc(= formatIsoDateUtc;
const formatIsoOffset = self => {
  const date = toDate(self)`

JSDoc:

@internal

## formatIsoOffset

Source: `my-backend/node_modules/effect/dist/cjs/internal/dateTime.js`

Signature: `formatIsoOffset(= formatIsoOffset;
const formatIsoZoned = self => self.zone._tag === "Offset" ? formatIsoOffset(self)`

JSDoc:

@internal

## sleep

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `sleep(= sleep;
const defaultServicesWith = f => core.withFiberRuntime(fiber => f(fiber.currentDefaultServices)`

JSDoc:

@internal */
const liveServices = exports.liveServices = /*#__PURE__*/(0, _Function.pipe)(/*#__PURE__*/Context.empty(), /*#__PURE__*/Context.add(clock.clockTag, /*#__PURE__*/clock.make()), /*#__PURE__*/Context.add(console_.consoleTag, console_.defaultConsole), /*#__PURE__*/Context.add(random.randomTag, /*#__PURE__*/random.make(/*#__PURE__*/Math.random())), /*#__PURE__*/Context.add(configProvider.configProviderTag, /*#__PURE__*/configProvider.fromEnv()), /*#__PURE__*/Context.add(tracer.tracerTag, tracer.nativeTracer));
/**
The `FiberRef` holding the default `Effect` services.

@since 2.0.0
@category fiberRefs
/
const currentServices = exports.currentServices = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/DefaultServices/currentServices"), () => core.fiberRefUnsafeMakeContext(liveServices));
// circular with Clock
/** @internal */
const sleep = duration => {
  const decodedDuration = Duration.decode(duration);
  return clockWith(clock => clock.sleep(decodedDuration));
};
/** @internal

## defaultServicesWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `defaultServicesWith(= defaultServicesWith;
const clockWith = f => defaultServicesWith(services => f(services.unsafeMap.get(clock.clockTag.key)`

JSDoc:

@internal

## clockWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `clockWith(= clockWith;
const currentTimeMillis = exports.currentTimeMillis = /*#__PURE__*/clockWith(clock => clock.currentTimeMillis)`

JSDoc:

@internal

## configProviderWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `configProviderWith(= configProviderWith;
const config = config => configProviderWith(_ => _.load(config)`

JSDoc:

@internal */
const currentTimeNanos = exports.currentTimeNanos = /*#__PURE__*/clockWith(clock => clock.currentTimeNanos);
/** @internal */
const withClock = exports.withClock = /*#__PURE__*/(0, _Function.dual)(2, (effect, c) => core.fiberRefLocallyWith(currentServices, Context.add(clock.clockTag, c))(effect));
// circular with ConfigProvider
/** @internal */
const withConfigProvider = exports.withConfigProvider = /*#__PURE__*/(0, _Function.dual)(2, (self, provider) => core.fiberRefLocallyWith(currentServices, Context.add(configProvider.configProviderTag, provider))(self));
/** @internal */
const configProviderWith = f => defaultServicesWith(services => f(services.unsafeMap.get(configProvider.configProviderTag.key)));
/** @internal

## config

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `config(= config;
const configOrDie = config => core.orDie(configProviderWith(_ => _.load(config)`

JSDoc:

@internal

## configOrDie

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `configOrDie(= configOrDie;
const randomWith = f => defaultServicesWith(services => f(services.unsafeMap.get(random.randomTag.key)`

JSDoc:

@internal

## randomWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `randomWith(= randomWith;
const withRandom = exports.withRandom = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## nextRange

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `nextRange(= nextRange;
const nextIntBetween = (min, max)`

JSDoc:

@internal */
const next = exports.next = /*#__PURE__*/randomWith(random => random.next);
/** @internal */
const nextInt = exports.nextInt = /*#__PURE__*/randomWith(random => random.nextInt);
/** @internal */
const nextBoolean = exports.nextBoolean = /*#__PURE__*/randomWith(random => random.nextBoolean);
/** @internal */
const nextRange = (min, max) => randomWith(random => random.nextRange(min, max));
/** @internal

## nextIntBetween

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `nextIntBetween(= nextIntBetween;
const shuffle = elements => randomWith(random => random.shuffle(elements)`

JSDoc:

@internal

## shuffle

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `shuffle(= shuffle;
const choice = elements => {
  const array = Array.fromIterable(elements)`

JSDoc:

@internal

## choice

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `choice(= choice;
const tracerWith = f => defaultServicesWith(services => f(services.unsafeMap.get(tracer.tracerTag.key)`

JSDoc:

@internal

## tracerWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/defaultServices.js`

Signature: `tracerWith(= tracerWith;
const withTracer = exports.withTracer = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## pending

Source: `my-backend/node_modules/effect/dist/cjs/internal/deferred.js`

Signature: `pending(= pending;
const done = effect => {
  return {
    _tag: OpCodes.OP_STATE_DONE,
    effect
  };
};
exports.done = done;
//# sourceMappingURL=deferred.js.map)`

JSDoc:

@internal */
const DeferredSymbolKey = "effect/Deferred";
/** @internal */
const DeferredTypeId = exports.DeferredTypeId = /*#__PURE__*/Symbol.for(DeferredSymbolKey);
/** @internal */
const deferredVariance = exports.deferredVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const pending = joiners => {
  return {
    _tag: OpCodes.OP_STATE_PENDING,
    joiners
  };
};
/** @internal

## diff

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ/chunkPatch.js`

Signature: `diff(= diff;
const combine = exports.combine = /*#__PURE__*/Dual.dual(2, (self, that)`

JSDoc:

@internal */
const ChunkPatchTypeId = exports.ChunkPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferChunkPatch");
function variance(a) {
  return a;
}
const PatchProto = {
  ...Data.Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
const EmptyProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Empty"
});
const _empty = /*#__PURE__*/Object.create(EmptyProto);
/**
@internal
/
const empty = () => _empty;
exports.empty = empty;
const AndThenProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "AndThen"
});
const makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const AppendProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Append"
});
const makeAppend = values => {
  const o = Object.create(AppendProto);
  o.values = values;
  return o;
};
const SliceProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Slice"
});
const makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
const UpdateProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Update"
});
const makeUpdate = (index, patch) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch;
  return o;
};
/** @internal */
const diff = options => {
  let i = 0;
  let patch = empty();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = Chunk.unsafeGet(i)(options.oldValue);
    const newElement = Chunk.unsafeGet(i)(options.newValue);
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!Equal.equals(valuePatch, options.differ.empty)) {
      patch = (0, _Function.pipe)(patch, combine(makeUpdate(i, valuePatch)));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch = (0, _Function.pipe)(patch, combine(makeSlice(0, i)));
  }
  if (i < options.newValue.length) {
    patch = (0, _Function.pipe)(patch, combine(makeAppend(Chunk.drop(i)(options.newValue))));
  }
  return patch;
};
/** @internal

## diff

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ/contextPatch.js`

Signature: `diff(= diff;
const combine = exports.combine = /*#__PURE__*/Dual.dual(2, (self, that)`

JSDoc:

@internal */
const ContextPatchTypeId = exports.ContextPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferContextPatch");
function variance(a) {
  return a;
}
/** @internal */
const PatchProto = {
  ..._data.Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
const EmptyProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Empty"
});
const _empty = /*#__PURE__*/Object.create(EmptyProto);
/**
@internal
/
const empty = () => _empty;
exports.empty = empty;
const AndThenProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "AndThen"
});
const makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const AddServiceProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "AddService"
});
const makeAddService = (key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
};
const RemoveServiceProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "RemoveService"
});
const makeRemoveService = key => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
const UpdateServiceProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "UpdateService"
});
const makeUpdateService = (key, update) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update;
  return o;
};
/** @internal */
const diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = empty();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!Equal.equals(old, newService)) {
        patch = combine(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = combine(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = combine(makeRemoveService(tag))(patch);
  }
  return patch;
};
/** @internal

## diff

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ/hashMapPatch.js`

Signature: `diff(= diff;
const combine = exports.combine = /*#__PURE__*/Dual.dual(2, (self, that)`

JSDoc:

@internal */
const HashMapPatchTypeId = exports.HashMapPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferHashMapPatch");
function variance(a) {
  return a;
}
/** @internal */
const PatchProto = {
  ..._data.Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance,
    _Key: variance,
    _Patch: variance
  }
};
const EmptyProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Empty"
});
const _empty = /*#__PURE__*/Object.create(EmptyProto);
/** @internal */
const empty = () => _empty;
exports.empty = empty;
const AndThenProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "AndThen"
});
const makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const AddProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Add"
});
const makeAdd = (key, value) => {
  const o = Object.create(AddProto);
  o.key = key;
  o.value = value;
  return o;
};
const RemoveProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Remove"
});
const makeRemove = key => {
  const o = Object.create(RemoveProto);
  o.key = key;
  return o;
};
const UpdateProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Update"
});
const makeUpdate = (key, patch) => {
  const o = Object.create(UpdateProto);
  o.key = key;
  o.patch = patch;
  return o;
};
/** @internal */
const diff = options => {
  const [removed, patch] = HashMap.reduce([options.oldValue, empty()], ([map, patch], newValue, key) => {
    const option = HashMap.get(key)(map);
    switch (option._tag) {
      case "Some":
        {
          const valuePatch = options.differ.diff(option.value, newValue);
          if (Equal.equals(valuePatch, options.differ.empty)) {
            return [HashMap.remove(key)(map), patch];
          }
          return [HashMap.remove(key)(map), combine(makeUpdate(key, valuePatch))(patch)];
        }
      case "None":
        {
          return [map, combine(makeAdd(key, newValue))(patch)];
        }
    }
  })(options.newValue);
  return HashMap.reduce(patch, (patch, _, key) => combine(makeRemove(key))(patch))(removed);
};
/** @internal

## makeRemove

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ/hashSetPatch.js`

Signature: `makeRemove(= makeRemove;
const diff = (oldValue, newValue)`

JSDoc:

@internal */
const HashSetPatchTypeId = exports.HashSetPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferHashSetPatch");
function variance(a) {
  return a;
}
/** @internal */
const PatchProto = {
  ..._data.Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance,
    _Key: variance,
    _Patch: variance
  }
};
const EmptyProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Empty"
});
const _empty = /*#__PURE__*/Object.create(EmptyProto);
/** @internal */
const empty = () => _empty;
exports.empty = empty;
const AndThenProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "AndThen"
});
/** @internal */
const makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
exports.makeAndThen = makeAndThen;
const AddProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Add"
});
/** @internal */
const makeAdd = value => {
  const o = Object.create(AddProto);
  o.value = value;
  return o;
};
exports.makeAdd = makeAdd;
const RemoveProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Remove"
});
/** @internal */
const makeRemove = value => {
  const o = Object.create(RemoveProto);
  o.value = value;
  return o;
};
/** @internal

## diff

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ/hashSetPatch.js`

Signature: `diff(= diff;
const combine = exports.combine = /*#__PURE__*/Dual.dual(2, (self, that)`

JSDoc:

@internal

## makeUpdateRight

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ/orPatch.js`

Signature: `makeUpdateRight(= makeUpdateRight;
const diff = options => {
  switch (options.oldValue._tag)`

JSDoc:

@internal */
const OrPatchTypeId = exports.OrPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferOrPatch");
function variance(a) {
  return a;
}
/** @internal */
const PatchProto = {
  ..._data.Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance,
    _Key: variance,
    _Patch: variance
  }
};
const EmptyProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Empty"
});
const _empty = /*#__PURE__*/Object.create(EmptyProto);
/** @internal */
const empty = () => _empty;
exports.empty = empty;
const AndThenProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "AndThen"
});
/** @internal */
const makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
exports.makeAndThen = makeAndThen;
const SetLeftProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "SetLeft"
});
/** @internal */
const makeSetLeft = value => {
  const o = Object.create(SetLeftProto);
  o.value = value;
  return o;
};
exports.makeSetLeft = makeSetLeft;
const SetRightProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "SetRight"
});
/** @internal */
const makeSetRight = value => {
  const o = Object.create(SetRightProto);
  o.value = value;
  return o;
};
exports.makeSetRight = makeSetRight;
const UpdateLeftProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "UpdateLeft"
});
/** @internal */
const makeUpdateLeft = patch => {
  const o = Object.create(UpdateLeftProto);
  o.patch = patch;
  return o;
};
exports.makeUpdateLeft = makeUpdateLeft;
const UpdateRightProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "UpdateRight"
});
/** @internal */
const makeUpdateRight = patch => {
  const o = Object.create(UpdateRightProto);
  o.patch = patch;
  return o;
};
/** @internal

## diff

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ/orPatch.js`

Signature: `diff(= diff;
const combine = exports.combine = /*#__PURE__*/Dual.dual(2, (self, that)`

JSDoc:

@internal

## diff

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ/readonlyArrayPatch.js`

Signature: `diff(= diff;
const combine = exports.combine = /*#__PURE__*/Dual.dual(2, (self, that)`

JSDoc:

@internal */
const ReadonlyArrayPatchTypeId = exports.ReadonlyArrayPatchTypeId = /*#__PURE__*/Symbol.for("effect/DifferReadonlyArrayPatch");
function variance(a) {
  return a;
}
const PatchProto = {
  ...Data.Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
const EmptyProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Empty"
});
const _empty = /*#__PURE__*/Object.create(EmptyProto);
/**
@internal
/
const empty = () => _empty;
exports.empty = empty;
const AndThenProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "AndThen"
});
const makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
const AppendProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Append"
});
const makeAppend = values => {
  const o = Object.create(AppendProto);
  o.values = values;
  return o;
};
const SliceProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Slice"
});
const makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
const UpdateProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(PatchProto), {
  _tag: "Update"
});
const makeUpdate = (index, patch) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch;
  return o;
};
/** @internal */
const diff = options => {
  let i = 0;
  let patch = empty();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!Equal.equals(valuePatch, options.differ.empty)) {
      patch = combine(patch, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch = combine(patch, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch = combine(patch, makeAppend(Arr.drop(i)(options.newValue)));
  }
  return patch;
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ.js`

Signature: `make(= make;
const environment = ()`

JSDoc:

@internal */
const DifferTypeId = exports.DifferTypeId = /*#__PURE__*/Symbol.for("effect/Differ");
/** @internal */
const DifferProto = exports.DifferProto = {
  [DifferTypeId]: {
    _P: _Function.identity,
    _V: _Function.identity
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const make = params => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
};
/** @internal

## environment

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ.js`

Signature: `environment(= environment;
const chunk = differ => make({
  empty: ChunkPatch.empty()`

JSDoc:

@internal

## chunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ.js`

Signature: `chunk(= chunk;
const hashMap = differ => make({
  empty: HashMapPatch.empty()`

JSDoc:

@internal

## hashMap

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ.js`

Signature: `hashMap(= hashMap;
const hashSet = ()`

JSDoc:

@internal

## hashSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ.js`

Signature: `hashSet(= hashSet;
const orElseEither = exports.orElseEither = /*#__PURE__*/Dual.dual(2, (self, that)`

JSDoc:

@internal

## readonlyArray

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ.js`

Signature: `readonlyArray(= readonlyArray;
const transform = exports.transform = /*#__PURE__*/Dual.dual(2, (self, {
  toNew,
  toOld
})`

JSDoc:

@internal */
const readonlyArray = differ => make({
  empty: ReadonlyArrayPatch.empty(),
  combine: (first, second) => ReadonlyArrayPatch.combine(first, second),
  diff: (oldValue, newValue) => ReadonlyArrayPatch.diff({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch, oldValue) => ReadonlyArrayPatch.patch(patch, oldValue, differ)
});
/** @internal

## update

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ.js`

Signature: `update(= update;
const updateWith = f => make({
  empty: _Function.identity,
  combine: (first, second)`

JSDoc:

@internal */
const update = () => updateWith((_, a) => a);
/** @internal

## updateWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/differ.js`

Signature: `updateWith(= updateWith;
const zip = exports.zip = /*#__PURE__*/Dual.dual(2, (self, that)`

JSDoc:

@internal

## let_

Source: `my-backend/node_modules/effect/dist/cjs/internal/doNotation.js`

Signature: `let_(= let_;
const bindTo = map => (0, _Function.dual)`

JSDoc:

@internal */
const let_ = map => (0, _Function.dual)(3, (self, name, f) => map(self, a => ({
  ...a,
  [name]: f(a)
})));
/** @internal

## bindTo

Source: `my-backend/node_modules/effect/dist/cjs/internal/doNotation.js`

Signature: `bindTo(= bindTo;
const bind = (map, flatMap)`

JSDoc:

@internal

## unsafeMakeSemaphore

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `unsafeMakeSemaphore(= unsafeMakeSemaphore;
const makeSemaphore = permits => core.sync(()`

JSDoc:

@internal */
class Semaphore {
  permits;
  waiters = /*#__PURE__*/new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = n => core.asyncInterrupt(resume => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume(core.succeed(n));
      };
      this.waiters.add(observer);
      return core.sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume(core.succeed(n));
  });
  updateTaken = f => core.withFiberRuntime(fiber => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(_Scheduler.currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(core.currentSchedulingPriority));
    }
    return core.succeed(this.free);
  });
  release = n => this.updateTaken(taken => taken - n);
  releaseAll = /*#__PURE__*/this.updateTaken(_ => 0);
  withPermits = n => self => core.uninterruptibleMask(restore => core.flatMap(restore(this.take(n)), permits => fiberRuntime.ensuring(restore(self), this.release(permits))));
  withPermitsIfAvailable = n => self => core.uninterruptibleMask(restore => core.suspend(() => {
    if (this.free < n) {
      return effect.succeedNone;
    }
    this.taken += n;
    return fiberRuntime.ensuring(restore(effect.asSome(self)), this.release(n));
  }));
}
/** @internal */
const unsafeMakeSemaphore = permits => new Semaphore(permits);
/** @internal

## unsafeMakeLatch

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `unsafeMakeLatch(= unsafeMakeLatch;
const makeLatch = open => core.sync(()`

JSDoc:

@internal */
const unsafeMakeLatch = open => new Latch(open ?? false);
/** @internal

## makeLatch

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `makeLatch(= makeLatch;
const awaitAllChildren = self => ensuringChildren(self, fiberRuntime.fiberAwaitAll)`

JSDoc:

@internal

## awaitAllChildren

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `awaitAllChildren(= awaitAllChildren;
const cached = exports.cached = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## forkScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `forkScoped(= forkScoped;
const fromFiber = fiber => internalFiber.join(fiber)`

JSDoc:

@internal */
const cachedInvalidateWithTTL = exports.cachedInvalidateWithTTL = /*#__PURE__*/(0, _Function.dual)(2, (self, timeToLive) => {
  const duration = Duration.decode(timeToLive);
  return core.flatMap(core.context(), env => core.map(makeSynchronized(Option.none()), cache => [core.provideContext(getCachedValue(self, duration, cache), env), invalidateCache(cache)]));
});
/** @internal */
const computeCachedValue = (self, timeToLive, start) => {
  const timeToLiveMillis = Duration.toMillis(Duration.decode(timeToLive));
  return (0, _Function.pipe)(core.deferredMake(), core.tap(deferred => core.intoDeferred(self, deferred)), core.map(deferred => Option.some([start + timeToLiveMillis, deferred])));
};
/** @internal */
const getCachedValue = (self, timeToLive, cache) => core.uninterruptibleMask(restore => (0, _Function.pipe)(effect.clockWith(clock => clock.currentTimeMillis), core.flatMap(time => updateSomeAndGetEffectSynchronized(cache, option => {
  switch (option._tag) {
    case "None":
      {
        return Option.some(computeCachedValue(self, timeToLive, time));
      }
    case "Some":
      {
        const [end] = option.value;
        return end - time <= 0 ? Option.some(computeCachedValue(self, timeToLive, time)) : Option.none();
      }
  }
})), core.flatMap(option => Option.isNone(option) ? core.dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(core.deferredAwait(option.value[1])))));
/** @internal */
const invalidateCache = cache => internalRef.set(cache, Option.none());
/** @internal */
const ensuringChild = exports.ensuringChild = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => ensuringChildren(self, children => f(fiberRuntime.fiberAll(children))));
/** @internal */
const ensuringChildren = exports.ensuringChildren = /*#__PURE__*/(0, _Function.dual)(2, (self, children) => core.flatMap(supervisor.track, supervisor => (0, _Function.pipe)(supervised(self, supervisor), fiberRuntime.ensuring(core.flatMap(supervisor.value, children)))));
/** @internal */
const forkAll = exports.forkAll = /*#__PURE__*/(0, _Function.dual)(args => Predicate.isIterable(args[0]), (effects, options) => options?.discard ? core.forEachSequentialDiscard(effects, fiberRuntime.fork) : core.map(core.forEachSequential(effects, fiberRuntime.fork), fiberRuntime.fiberAll));
/** @internal */
const forkIn = exports.forkIn = /*#__PURE__*/(0, _Function.dual)(2, (self, scope) => core.withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope;
  const fiber = fiberRuntime.unsafeFork(self, parent, parentStatus.runtimeFlags, _fiberScope.globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer = () => core.fiberIdWith(fiberId => Equal.equals(fiberId, fiber.id()) ? core.void : core.asVoid(core.interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return core.succeed(fiber);
}));
/** @internal */
const forkScoped = self => fiberRuntime.scopeWith(scope => forkIn(self, scope));
/** @internal

## fromFiber

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `fromFiber(= fromFiber;
const fromFiberEffect = fiber => core.suspend(()`

JSDoc:

@internal

## cachedFunction

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `cachedFunction(= cachedFunction;
const raceFirst = exports.raceFirst = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const cachedFunction = (f, eq) => {
  return (0, _Function.pipe)(core.sync(() => MutableHashMap.empty()), core.flatMap(makeSynchronized), core.map(ref => a => (0, _Function.pipe)(ref.modifyEffect(map => {
    const result = (0, _Function.pipe)(map, MutableHashMap.get(new Key(a, eq)));
    if (Option.isNone(result)) {
      return (0, _Function.pipe)(core.deferredMake(), core.tap(deferred => (0, _Function.pipe)(effect.diffFiberRefs(f(a)), core.intoDeferred(deferred), fiberRuntime.fork)), core.map(deferred => [deferred, (0, _Function.pipe)(map, MutableHashMap.set(new Key(a, eq), deferred))]));
    }
    return core.succeed([result.value, map]);
  }), core.flatMap(core.deferredAwait), core.flatMap(([patch, b]) => (0, _Function.pipe)(effect.patchFiberRefs(patch), core.as(b))))));
};
/** @internal

## makeSynchronized

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `makeSynchronized(= makeSynchronized;
const unsafeMakeSynchronized = value => {
  const ref = internalRef.unsafeMake(value)`

JSDoc:

@internal */
const supervised = exports.supervised = /*#__PURE__*/(0, _Function.dual)(2, (self, supervisor) => {
  const supervise = core.fiberRefLocallyWith(fiberRuntime.currentSupervisor, s => s.zip(supervisor));
  return supervise(self);
});
/** @internal */
const timeout = exports.timeout = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => timeoutFail(self, {
  onTimeout: () => core.timeoutExceptionFromDuration(duration),
  duration
}));
/** @internal */
const timeoutFail = exports.timeoutFail = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  duration,
  onTimeout
}) => core.flatten(timeoutTo(self, {
  onTimeout: () => core.failSync(onTimeout),
  onSuccess: core.succeed,
  duration
})));
/** @internal */
const timeoutFailCause = exports.timeoutFailCause = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  duration,
  onTimeout
}) => core.flatten(timeoutTo(self, {
  onTimeout: () => core.failCauseSync(onTimeout),
  onSuccess: core.succeed,
  duration
})));
/** @internal */
const timeoutOption = exports.timeoutOption = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => timeoutTo(self, {
  duration,
  onSuccess: Option.some,
  onTimeout: Option.none
}));
/** @internal */
const timeoutTo = exports.timeoutTo = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  duration,
  onSuccess,
  onTimeout
}) => core.fiberIdWith(parentFiberId => core.uninterruptibleMask(restore => fiberRuntime.raceFibersWith(restore(self), core.interruptible(effect.sleep(duration)), {
  onSelfWin: (winner, loser) => core.flatMap(winner.await, exit => {
    if (exit._tag === "Success") {
      return core.flatMap(winner.inheritAll, () => core.as(core.interruptAsFiber(loser, parentFiberId), onSuccess(exit.value)));
    } else {
      return core.flatMap(core.interruptAsFiber(loser, parentFiberId), () => core.exitFailCause(exit.cause));
    }
  }),
  onOtherWin: (winner, loser) => core.flatMap(winner.await, exit => {
    if (exit._tag === "Success") {
      return core.flatMap(winner.inheritAll, () => core.as(core.interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return core.flatMap(core.interruptAsFiber(loser, parentFiberId), () => core.exitFailCause(exit.cause));
    }
  }),
  otherScope: _fiberScope.globalScope
}))));
// circular with Synchronized
/** @internal */
const SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
/** @internal */
const SynchronizedTypeId = exports.SynchronizedTypeId = /*#__PURE__*/Symbol.for(SynchronizedSymbolKey);
/** @internal */
const synchronizedVariance = exports.synchronizedVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class SynchronizedImpl extends Effectable.Class {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [internalRef.RefTypeId] = internalRef.refVariance;
  [Readable.TypeId] = Readable.TypeId;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = internalRef.get(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect(a => core.succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock((0, _Function.pipe)(core.flatMap(internalRef.get(this.ref), f), core.flatMap(([b, a]) => core.as(internalRef.set(this.ref, a), b))));
  }
}
/** @internal */
const makeSynchronized = value => core.sync(() => unsafeMakeSynchronized(value));
/** @internal

## unsafeMakeSynchronized

Source: `my-backend/node_modules/effect/dist/cjs/internal/effect/circular.js`

Signature: `unsafeMakeSynchronized(= unsafeMakeSynchronized;
const updateSomeAndGetEffectSynchronized = exports.updateSomeAndGetEffectSynchronized = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## isEither

Source: `my-backend/node_modules/effect/dist/cjs/internal/either.js`

Signature: `isEither(= isEither;
const isLeft = ma => ma._tag === "Left";
/** @internal */
exports.isLeft = isLeft;
const isRight = ma => ma._tag === "Right";
/** @internal */
exports.isRight = isRight;
const left = left => {
  const a = Object.create(LeftProto)`

JSDoc:

@since 2.0.0
/

/**
@internal
/
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Either");
const CommonProto = {
  ..._effectable.EffectPrototype,
  [TypeId]: {
    _R: _ => _
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  }
};
const RightProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(CommonProto), {
  _tag: "Right",
  _op: "Right",
  [Equal.symbol](that) {
    return isEither(that) && isRight(that) && Equal.equals(this.right, that.right);
  },
  [Hash.symbol]() {
    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: (0, _Inspectable.toJSON)(this.right)
    };
  }
});
const LeftProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(CommonProto), {
  _tag: "Left",
  _op: "Left",
  [Equal.symbol](that) {
    return isEither(that) && isLeft(that) && Equal.equals(this.left, that.left);
  },
  [Hash.symbol]() {
    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: (0, _Inspectable.toJSON)(this.left)
    };
  }
});
/** @internal */
const isEither = input => (0, _Predicate.hasProperty)(input, TypeId);
/** @internal

## left

Source: `my-backend/node_modules/effect/dist/cjs/internal/either.js`

Signature: `left(= left;
const right = right => {
  const a = Object.create(RightProto)`

JSDoc:

@internal

## right

Source: `my-backend/node_modules/effect/dist/cjs/internal/either.js`

Signature: `right(= right;
const getLeft = self => isRight(self)`

JSDoc:

@internal

## getLeft

Source: `my-backend/node_modules/effect/dist/cjs/internal/either.js`

Signature: `getLeft(= getLeft;
const getRight = self => isLeft(self)`

JSDoc:

@internal

## getRight

Source: `my-backend/node_modules/effect/dist/cjs/internal/either.js`

Signature: `getRight(= getRight;
const fromOption = exports.fromOption = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## encode

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/base64.js`

Signature: `encode(= encode;
const decode = str => {
  const stripped = stripCrlf(str)`

JSDoc:

@internal */
const encode = bytes => {
  const length = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 0x0f) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 0x3f];
  }
  if (i === length + 1) {
    // 1 octet yet to write
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4];
    result += "==";
  }
  if (i === length) {
    // 2 octets yet to write
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 0x03) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 0x0f) << 2];
    result += "=";
  }
  return result;
};
/** @internal

## decode

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/base64.js`

Signature: `decode(= decode;
const stripCrlf = str => str.replace(/[\n\r]/g, "")`

JSDoc:

@internal

## stripCrlf

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/base64.js`

Signature: `stripCrlf(= stripCrlf;
function getBase64Code(charCode)`

JSDoc:

@internal

## encode

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/base64Url.js`

Signature: `encode(= encode;
const decode = str => {
  const stripped = Base64.stripCrlf(str)`

JSDoc:

@internal */
const encode = data => Base64.encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
/** @internal

## DecodeException

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/common.js`

Signature: `DecodeException(= DecodeException;
const isDecodeException = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const DecodeExceptionTypeId = exports.DecodeExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Encoding/errors/Decode");
/** @internal */
const DecodeException = (input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if ((0, _Predicate.isString)(message)) {
    out.message = message;
  }
  return out;
};
/** @internal

## isDecodeException

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/common.js`

Signature: `isDecodeException(= isDecodeException;
const EncodeExceptionTypeId = exports.EncodeExceptionTypeId = /*#__PURE__*/Symbol.for("effect/Encoding/errors/Encode")`

JSDoc:

@internal

## EncodeException

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/common.js`

Signature: `EncodeException(= EncodeException;
const isEncodeException = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const EncodeException = (input, message) => {
  const out = {
    _tag: "EncodeException",
    [EncodeExceptionTypeId]: EncodeExceptionTypeId,
    input
  };
  if ((0, _Predicate.isString)(message)) {
    out.message = message;
  }
  return out;
};
/** @internal

## isEncodeException

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/common.js`

Signature: `isEncodeException(= isEncodeException;
const encoder = exports.encoder = /*#__PURE__*/new TextEncoder()`

JSDoc:

@interal

## encode

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/hex.js`

Signature: `encode(= encode;
const decode = str => {
  const bytes = new TextEncoder()`

JSDoc:

@internal */
const encode = bytes => {
  let result = "";
  for (let i = 0; i < bytes.length; ++i) {
    result += bytesToHex[bytes[i]];
  }
  return result;
};
/** @internal

## decode

Source: `my-backend/node_modules/effect/dist/cjs/internal/encoding/hex.js`

Signature: `decode(= decode;
const bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
/** @internal */
const fromHexChar = byte => {
  // '0' <= byte && byte <= '9'
  if (48 <= byte && byte <= 57)`

JSDoc:

@internal

## isExecutionPlan

Source: `my-backend/node_modules/effect/dist/cjs/internal/executionPlan.js`

Signature: `isExecutionPlan(= isExecutionPlan;
const withExecutionPlan = exports.withExecutionPlan = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/ExecutionPlan");
/** @internal */
const isExecutionPlan = u => Predicate.hasProperty(u, TypeId);
/** @internal

## parallelN

Source: `my-backend/node_modules/effect/dist/cjs/internal/executionStrategy.js`

Signature: `parallelN(= parallelN;
const isSequential = self => self._tag === OP_SEQUENTIAL;
/** @internal */
exports.isSequential = isSequential;
const isParallel = self => self._tag === OP_PARALLEL;
/** @internal */
exports.isParallel = isParallel;
const isParallelN = self => self._tag === OP_PARALLEL_N;
/** @internal */
exports.isParallelN = isParallelN;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const OP_SEQUENTIAL = exports.OP_SEQUENTIAL = "Sequential";
/** @internal */
const OP_PARALLEL = exports.OP_PARALLEL = "Parallel";
/** @internal */
const OP_PARALLEL_N = exports.OP_PARALLEL_N = "ParallelN";
/** @internal */
const sequential = exports.sequential = {
  _tag: OP_SEQUENTIAL
};
/** @internal */
const parallel = exports.parallel = {
  _tag: OP_PARALLEL
};
/** @internal */
const parallelN = parallelism => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
/** @internal

## isFiber

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `isFiber(= isFiber;
const isRuntimeFiber = self => RuntimeFiberTypeId in self;
/** @internal */
exports.isRuntimeFiber = isRuntimeFiber;
const _await = self => self.await;
/** @internal */
exports._await = _await;
const children = self => self.children;
/** @internal */
exports.children = children;
const done = exit => {
  const _fiber = {
    ...effectable.CommitPrototype,
    commit()`

JSDoc:

@internal */
const FiberSymbolKey = "effect/Fiber";
/** @internal */
const FiberTypeId = exports.FiberTypeId = /*#__PURE__*/Symbol.for(FiberSymbolKey);
/** @internal */
const fiberVariance = exports.fiberVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const fiberProto = {
  [FiberTypeId]: fiberVariance,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const RuntimeFiberSymbolKey = "effect/Fiber";
/** @internal */
const RuntimeFiberTypeId = exports.RuntimeFiberTypeId = /*#__PURE__*/Symbol.for(RuntimeFiberSymbolKey);
/** @internal */
const Order = exports.Order = /*#__PURE__*/(0, _Function.pipe)(/*#__PURE__*/order.tuple(number.Order, number.Order), /*#__PURE__*/order.mapInput(fiber => [fiber.id().startTimeMillis, fiber.id().id]));
/** @internal */
const isFiber = u => (0, _Predicate.hasProperty)(u, FiberTypeId);
/** @internal

## done

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `done(= done;
const dump = self => core.map(self.status, status => ({
  id: self.id()`

JSDoc:

@internal

## dump

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `dump(= dump;
const dumpAll = fibers => core.forEachSequential(fibers, dump)`

JSDoc:

@internal

## dumpAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `dumpAll(= dumpAll;
const fail = error => done(Exit.fail(error)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `fail(= fail;
const failCause = cause => done(Exit.failCause(cause)`

JSDoc:

@internal

## failCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `failCause(= failCause;
const fromEffect = effect => core.map(core.exit(effect)`

JSDoc:

@internal

## fromEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `fromEffect(= fromEffect;
const id = self => self.id()`

JSDoc:

@internal

## id

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `id(= id;
const inheritAll = self => self.inheritAll;
/** @internal */
exports.inheritAll = inheritAll;
const interrupted = fiberId => done(Exit.interrupt(fiberId)`

JSDoc:

@internal

## interrupted

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `interrupted(= interrupted;
const interruptAll = fibers => core.flatMap(core.fiberId, fiberId => (0, _Function.pipe)`

JSDoc:

@internal

## interruptAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `interruptAll(= interruptAll;
const interruptAllAs = exports.interruptAllAs = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## join

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `join(= join;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const interruptAsFork = exports.interruptAsFork = /*#__PURE__*/(0, _Function.dual)(2, (self, fiberId) => self.interruptAsFork(fiberId));
/** @internal */
const join = self => core.zipLeft(core.flatten(self.await), self.inheritAll);
/** @internal

## poll

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `poll(= poll;
const parseMs = milliseconds => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 86400000)`

JSDoc:

@internal */
const mapEffect = exports.mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const _fiber = {
    ...effectable.CommitPrototype,
    commit() {
      return join(this);
    },
    ...fiberProto,
    id: () => self.id(),
    await: core.flatMap(self.await, Exit.forEachEffect(f)),
    children: self.children,
    inheritAll: self.inheritAll,
    poll: core.flatMap(self.poll, result => {
      switch (result._tag) {
        case "None":
          return core.succeed(Option.none());
        case "Some":
          return (0, _Function.pipe)(Exit.forEachEffect(result.value, f), core.map(Option.some));
      }
    }),
    interruptAsFork: id => self.interruptAsFork(id)
  };
  return _fiber;
});
/** @internal */
const mapFiber = exports.mapFiber = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.map(self.await, Exit.match({
  onFailure: cause => failCause(cause),
  onSuccess: a => f(a)
})));
/** @internal */
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self)) {
    return onRuntimeFiber(self);
  }
  return onFiber(self);
});
/** @internal */
const _never = {
  ...effectable.CommitPrototype,
  commit() {
    return join(this);
  },
  ...fiberProto,
  id: () => FiberId.none,
  await: core.never,
  children: /*#__PURE__*/core.succeed([]),
  inheritAll: core.never,
  poll: /*#__PURE__*/core.succeed(/*#__PURE__*/Option.none()),
  interruptAsFork: () => core.never
};
/** @internal */
const never = exports.never = _never;
/** @internal */
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => ({
  ...effectable.CommitPrototype,
  commit() {
    return join(this);
  },
  ...fiberProto,
  id: () => FiberId.getOrElse(self.id(), that.id()),
  await: core.zipWith(self.await, that.await, (exit1, exit2) => Exit.isSuccess(exit1) ? exit1 : exit2),
  children: self.children,
  inheritAll: core.zipRight(that.inheritAll, self.inheritAll),
  poll: core.zipWith(self.poll, that.poll, (option1, option2) => {
    switch (option1._tag) {
      case "None":
        {
          return Option.none();
        }
      case "Some":
        {
          return Exit.isSuccess(option1.value) ? option1 : option2;
        }
    }
  }),
  interruptAsFork: id => (0, _Function.pipe)(core.interruptAsFiber(self, id), core.zipRight((0, _Function.pipe)(that, core.interruptAsFiber(id))), core.asVoid)
}));
/** @internal */
const orElseEither = exports.orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => orElse(map(self, Either.left), map(that, Either.right)));
/** @internal */
const poll = self => self.poll;
// forked from https://github.com/sindresorhus/parse-ms/blob/4da2ffbdba02c6e288c08236695bdece0adca173/index.js
// MIT License
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
/** @internal

## pretty

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `pretty(= pretty;
const unsafeRoots = ()`

JSDoc:

@internal */
const renderStatus = status => {
  if (FiberStatus.isDone(status)) {
    return "Done";
  }
  if (FiberStatus.isRunning(status)) {
    return "Running";
  }
  const isInterruptible = runtimeFlags.interruptible(status.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
};
/** @internal */
const pretty = self => core.flatMap(Clock.currentTimeMillis, now => core.map(dump(self), dump => {
  const time = now - dump.id.startTimeMillis;
  const {
    days,
    hours,
    milliseconds,
    minutes,
    seconds
  } = parseMs(time);
  const lifeMsg = (days === 0 ? "" : `${days}d`) + (days === 0 && hours === 0 ? "" : `${hours}h`) + (days === 0 && hours === 0 && minutes === 0 ? "" : `${minutes}m`) + (days === 0 && hours === 0 && minutes === 0 && seconds === 0 ? "" : `${seconds}s`) + `${milliseconds}ms`;
  const waitMsg = FiberStatus.isSuspended(dump.status) ? (() => {
    const ids = FiberId.ids(dump.status.blockingOn);
    return HashSet.size(ids) > 0 ? `waiting on ` + Array.from(ids).map(id => `${id}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump.status);
  return `[Fiber](#${dump.id.id}) (${lifeMsg}) ${waitMsg}\n   Status: ${statusMsg}`;
}));
/** @internal

## unsafeRoots

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `unsafeRoots(= unsafeRoots;
const roots = exports.roots = /*#__PURE__*/core.sync(unsafeRoots)`

JSDoc:

@internal

## status

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiber.js`

Signature: `status(= status;
const succeed = value => done(Exit.succeed(value)`

JSDoc:

@internal */
const status = self => self.status;
/** @internal

## runtime

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `runtime(= runtime;
const composite = (left, right)`

JSDoc:

@internal */
const FiberIdSymbolKey = "effect/FiberId";
/** @internal */
const FiberIdTypeId = exports.FiberIdTypeId = /*#__PURE__*/Symbol.for(FiberIdSymbolKey);
/** @internal */
const OP_NONE = "None";
/** @internal */
const OP_RUNTIME = "Runtime";
/** @internal */
const OP_COMPOSITE = "Composite";
const emptyHash = /*#__PURE__*/Hash.string(`${FiberIdSymbolKey}-${OP_NONE}`);
/** @internal */
class None {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [Hash.symbol]() {
    return emptyHash;
  }
  [Equal.symbol](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/** @internal */
class Runtime {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [Hash.symbol]() {
    return Hash.cached(this, Hash.string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [Equal.symbol](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/** @internal */
class Composite {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
  _hash;
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.string(`${FiberIdSymbolKey}-${this._tag}`), Hash.combine(Hash.hash(this.left)), Hash.combine(Hash.hash(this.right)), Hash.cached(this));
  }
  [Equal.symbol](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && Equal.equals(this.left, that.left) && Equal.equals(this.right, that.right);
  }
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: (0, _Inspectable.toJSON)(this.left),
      right: (0, _Inspectable.toJSON)(this.right)
    };
  }
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/** @internal */
const none = exports.none = /*#__PURE__*/new None();
/** @internal */
const runtime = (id, startTimeMillis) => {
  return new Runtime(id, startTimeMillis);
};
/** @internal

## composite

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `composite(= composite;
const isFiberId = self => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isFiberId

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `isFiberId(= isFiberId;
const isNone = self => {
  return self._tag === OP_NONE || (0, _Function.pipe)`

JSDoc:

@internal

## isNone

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `isNone(= isNone;
const isRuntime = self => {
  return self._tag === OP_RUNTIME;
};
/** @internal */
exports.isRuntime = isRuntime;
const isComposite = self => {
  return self._tag === OP_COMPOSITE;
};
/** @internal */
exports.isComposite = isComposite;
const combine = exports.combine = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## combineAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `combineAll(= combineAll;
const getOrElse = exports.getOrElse = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const combineAll = fiberIds => {
  return (0, _Function.pipe)(fiberIds, HashSet.reduce(none, (a, b) => combine(b)(a)));
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `make(= make;
const threadName = self => {
  const identifiers = Array.from(ids(self)`

JSDoc:

@internal */
const ids = self => {
  switch (self._tag) {
    case OP_NONE:
      {
        return HashSet.empty();
      }
    case OP_RUNTIME:
      {
        return HashSet.make(self.id);
      }
    case OP_COMPOSITE:
      {
        return (0, _Function.pipe)(ids(self.left), HashSet.union(ids(self.right)));
      }
  }
};
exports.ids = ids;
const _fiberCounter = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/Fiber/Id/_fiberCounter"), () => MutableRef.make(0));
/** @internal */
const make = (id, startTimeSeconds) => {
  return new Runtime(id, startTimeSeconds);
};
/** @internal

## threadName

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `threadName(= threadName;
const toOption = self => {
  const fiberIds = toSet(self)`

JSDoc:

@internal

## toOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `toOption(= toOption;
const toSet = self => {
  switch (self._tag)`

JSDoc:

@internal

## toSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberId.js`

Signature: `toSet(= toSet;
const unsafeMake = ()`

JSDoc:

@internal

## interruptSignal

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberMessage.js`

Signature: `interruptSignal(= interruptSignal;
const stateful = onFiber => ({
  _tag: OP_STATEFUL,
  onFiber
})`

JSDoc:

@internal */
const OP_INTERRUPT_SIGNAL = exports.OP_INTERRUPT_SIGNAL = "InterruptSignal";
/** @internal */
const OP_STATEFUL = exports.OP_STATEFUL = "Stateful";
/** @internal */
const OP_RESUME = exports.OP_RESUME = "Resume";
/** @internal */
const OP_YIELD_NOW = exports.OP_YIELD_NOW = "YieldNow";
/** @internal */
const interruptSignal = cause => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause
});
/** @internal

## stateful

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberMessage.js`

Signature: `stateful(= stateful;
const resume = effect => ({
  _tag: OP_RESUME,
  effect
})`

JSDoc:

@internal

## resume

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberMessage.js`

Signature: `resume(= resume;
const yieldNow = ()`

JSDoc:

@internal

## diff

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRefs/patch.js`

Signature: `diff(= diff;
const combine = exports.combine = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const OP_EMPTY = exports.OP_EMPTY = "Empty";
/** @internal */
const OP_ADD = exports.OP_ADD = "Add";
/** @internal */
const OP_REMOVE = exports.OP_REMOVE = "Remove";
/** @internal */
const OP_UPDATE = exports.OP_UPDATE = "Update";
/** @internal */
const OP_AND_THEN = exports.OP_AND_THEN = "AndThen";
/** @internal */
const empty = exports.empty = {
  _tag: OP_EMPTY
};
/** @internal */
const diff = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch = empty;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue = Arr.headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue = Arr.headNonEmpty(old)[1];
      if (!(0, _Equal.equals)(oldValue, newValue)) {
        patch = combine({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue, newValue)
        })(patch);
      }
    } else {
      patch = combine({
        _tag: OP_ADD,
        fiberRef,
        value: newValue
      })(patch);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch = combine({
      _tag: OP_REMOVE,
      fiberRef
    })(patch);
  }
  return patch;
};
/** @internal

## FiberRefsImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRefs.js`

Signature: `FiberRefsImpl(= FiberRefsImpl;
const findAncestor = (_ref, _parentStack, _childStack, _childModified = false)`

JSDoc:

@internal */
function unsafeMake(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
/** @internal */
function empty() {
  return unsafeMake(new Map());
}
/** @internal */
const FiberRefsSym = exports.FiberRefsSym = /*#__PURE__*/Symbol.for("effect/FiberRefs");
/** @internal */
class FiberRefsImpl {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## fiberRefs

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRefs.js`

Signature: `fiberRefs(= fiberRefs;
const setAll = self => core.forEachSequentialDiscard(fiberRefs(self)`

JSDoc:

@internal */
const joinAs = exports.joinAs = /*#__PURE__*/(0, _Function.dual)(3, (self, fiberId, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][Equal.symbol](fiberId)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (Equal.equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch)(oldValue));
        if (!Equal.equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[Equal.symbol](fiberId)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
/** @internal */
const forkAs = exports.forkAs = /*#__PURE__*/(0, _Function.dual)(2, (self, childId) => {
  const map = new Map();
  unsafeForkAs(self, map, childId);
  return new FiberRefsImpl(map);
});
const unsafeForkAs = (self, map, fiberId) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (Equal.equals(oldValue, newValue)) {
      map.set(fiberRef, stack);
    } else {
      map.set(fiberRef, [[fiberId, newValue], ...stack]);
    }
  });
};
/** @internal */
const fiberRefs = self => HashSet.fromIterable(self.locals.keys());
/** @internal

## setAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRefs.js`

Signature: `setAll(= setAll;
const delete_ = exports.delete_ = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## FiberRuntime

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `FiberRuntime(= FiberRuntime;
const currentMinimumLogLevel = exports.currentMinimumLogLevel = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@internal */
const fiberStarted = exports.fiberStarted = /*#__PURE__*/metric.counter("effect_fiber_started", {
  incremental: true
});
/** @internal */
const fiberActive = exports.fiberActive = /*#__PURE__*/metric.counter("effect_fiber_active");
/** @internal */
const fiberSuccesses = exports.fiberSuccesses = /*#__PURE__*/metric.counter("effect_fiber_successes", {
  incremental: true
});
/** @internal */
const fiberFailures = exports.fiberFailures = /*#__PURE__*/metric.counter("effect_fiber_failures", {
  incremental: true
});
/** @internal */
const fiberLifetimes = exports.fiberLifetimes = /*#__PURE__*/metric.tagged(/*#__PURE__*/metric.histogram("effect_fiber_lifetimes", /*#__PURE__*/metricBoundaries.exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
/** @internal */
const EvaluationSignalContinue = "Continue";
/** @internal */
const EvaluationSignalDone = "Done";
/** @internal */
const EvaluationSignalYieldNow = "Yield";
const runtimeFiberVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
const absurd = _ => {
  throw new Error(`BUG: FiberRuntime - ${Inspectable.toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
const YieldedOp = /*#__PURE__*/Symbol.for("effect/internal/fiberRuntime/YieldedOp");
const yieldedOpChannel = /*#__PURE__*/(0, _GlobalValue.globalValue)("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
const contOpSuccess = {
  [OpCodes.OP_ON_SUCCESS]: (_, cont, value) => {
    return (0, _Utils.internalCall)(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: (_, _cont, value) => {
    return core.exitSucceed(core.exitSucceed(value));
  },
  [OpCodes.OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
    return (0, _Utils.internalCall)(() => cont.effect_instruction_i2(value));
  },
  [OpCodes.OP_REVERT_FLAGS]: (self, cont, value) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (runtimeFlags_.interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return core.exitFailCause(self.getInterruptedCause());
    } else {
      return core.exitSucceed(value);
    }
  },
  [OpCodes.OP_WHILE]: (self, cont, value) => {
    (0, _Utils.internalCall)(() => cont.effect_instruction_i2(value));
    if ((0, _Utils.internalCall)(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return (0, _Utils.internalCall)(() => cont.effect_instruction_i1());
    } else {
      return core.void;
    }
  },
  [OpCodes.OP_ITERATOR]: (self, cont, value) => {
    const state = (0, _Utils.internalCall)(() => cont.effect_instruction_i0.next(value));
    if (state.done) return core.exitSucceed(state.value);
    self.pushStack(cont);
    return (0, _Utils.yieldWrapGet)(state.value);
  }
};
const drainQueueWhileRunningTable = {
  [FiberMessage.OP_INTERRUPT_SIGNAL]: (self, runtimeFlags, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return runtimeFlags_.interruptible(runtimeFlags) ? core.exitFailCause(message.cause) : cur;
  },
  [FiberMessage.OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [FiberMessage.OP_STATEFUL]: (self, runtimeFlags, cur, message) => {
    message.onFiber(self, FiberStatus.running(runtimeFlags));
    return cur;
  },
  [FiberMessage.OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return core.flatMap(core.yieldNow(), () => cur);
  }
};
/**
Executes all requests, submitting requests to each data source in parallel.
/
const runBlockedRequests = self => core.forEachSequentialDiscard(RequestBlock_.flatten(self), requestsByRequestResolver => forEachConcurrentDiscard(RequestBlock_.sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential]) => {
  const map = new Map();
  const arr = [];
  for (const block of sequential) {
    arr.push(Chunk.toReadonlyArray(block));
    for (const entry of block) {
      map.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return core.fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach(entry => {
    entry.listeners.interrupted = true;
  })), _completedRequestMap.currentRequestMap, map);
}, false, false));
const _version = /*#__PURE__*/version.getCurrentVersion();
/** @internal */
class FiberRuntime extends Effectable.Class {
  [internalFiber.FiberTypeId] = internalFiber.fiberVariance;
  [internalFiber.RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /*#__PURE__*/new Array();
  _children = null;
  _observers = /*#__PURE__*/new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId;
    this._fiberRefs = fiberRefs0;
    if (runtimeFlags_.runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(core.currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return internalFiber.join(this);
  }
  /**
The identity of the fiber.
/
  id() {
    return this._fiberId;
  }
  /**
Begins execution of the effect associated with this fiber on in the
background. This can be called to "kick off" execution of a fiber after
it has been created.
/
  resume(effect) {
    this.tell(FiberMessage.resume(effect));
  }
  /**
The status of the fiber.
/
  get status() {
    return this.ask((_, status) => status);
  }
  /**
Gets the fiber runtime flags.
/
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (FiberStatus.isDone(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  /**
Returns the current `FiberScope` for the fiber.
/
  scope() {
    return fiberScope.unsafeMake(this);
  }
  /**
Retrieves the immediate children of the fiber.
/
  get children() {
    return this.ask(fiber => Array.from(fiber.getChildren()));
  }
  /**
Gets the fiber's set of children.
/
  getChildren() {
    if (this._children === null) {
      this._children = new Set();
    }
    return this._children;
  }
  /**
Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
if the fiber has not been interrupted.

**NOTE**: This method is safe to invoke on any fiber, but if not invoked
on this fiber, then values derived from the fiber's state (including the
log annotations and log level) may not be up-to-date.
/
  getInterruptedCause() {
    return this.getFiberRef(core.currentInterruptedCause);
  }
  /**
Retrieves the whole set of fiber refs.
/
  fiberRefs() {
    return this.ask(fiber => fiber.getFiberRefs());
  }
  /**
Returns an effect that will contain information computed from the fiber
state and status while running on the fiber.

This allows the outside world to interact safely with mutable fiber state
without locks or immutable data.
/
  ask(f) {
    return core.suspend(() => {
      const deferred = core.deferredUnsafeMake(this._fiberId);
      this.tell(FiberMessage.stateful((fiber, status) => {
        core.deferredUnsafeDone(deferred, core.sync(() => f(fiber, status)));
      }));
      return core.deferredAwait(deferred);
    });
  }
  /**
Adds a message to be processed by the fiber on the fiber.
/
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return core.async(resume => {
      const cb = exit => resume(core.succeed(exit));
      this.tell(FiberMessage.stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return core.sync(() => this.tell(FiberMessage.stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return core.withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = fiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch = (0, _Function.pipe)(runtimeFlags_.diff(parentRuntimeFlags, updatedRuntimeFlags),
      // Do not inherit WindDown or Interruption!
      RuntimeFlagsPatch.exclude(runtimeFlags_.Interruption), RuntimeFlagsPatch.exclude(runtimeFlags_.WindDown));
      return core.updateRuntimeFlags(patch);
    });
  }
  /**
Tentatively observes the fiber, but returns immediately if it is not
already done.
/
  get poll() {
    return core.sync(() => Option.fromNullable(this._exitValue));
  }
  /**
Unsafely observes the fiber, but returns immediately if it is not
already done.
/
  unsafePoll() {
    return this._exitValue;
  }
  /**
In the background, interrupts the fiber as if interrupted from the specified fiber.
/
  interruptAsFork(fiberId) {
    return core.sync(() => this.tell(FiberMessage.interruptSignal(internalCause.interrupt(fiberId))));
  }
  /**
In the background, interrupts the fiber as if interrupted from the specified fiber.
/
  unsafeInterruptAsFork(fiberId) {
    this.tell(FiberMessage.interruptSignal(internalCause.interrupt(fiberId)));
  }
  /**
Adds an observer to the list of observers.

**NOTE**: This method must be invoked by the fiber itself.
/
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
Removes the specified observer from the list of observers that will be
notified when the fiber exits.

**NOTE**: This method must be invoked by the fiber itself.
/
  removeObserver(observer) {
    this._observers = this._observers.filter(o => o !== observer);
  }
  /**
Retrieves all fiber refs of the fiber.

**NOTE**: This method is safe to invoke on any fiber, but if not invoked
on this fiber, then values derived from the fiber's state (including the
log annotations and log level) may not be up-to-date.
/
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
Deletes the specified fiber ref.

**NOTE**: This method must be invoked by the fiber itself.
/
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = fiberRefs.delete_(this._fiberRefs, fiberRef);
  }
  /**
Retrieves the state of the fiber ref, or else its initial value.

**NOTE**: This method is safe to invoke on any fiber, but if not invoked
on this fiber, then values derived from the fiber's state (including the
log annotations and log level) may not be up-to-date.
/
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
Sets the fiber ref to the specified value.

**NOTE**: This method must be invoked by the fiber itself.
/
  setFiberRef(fiberRef, value) {
    this._fiberRefs = fiberRefs.updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(defaultServices.currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracer.tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(_Scheduler.currentScheduler);
    this.currentContext = this.getFiberRef(core.currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(tracer.spanTag.key);
  }
  /**
Wholesale replaces all fiber refs of this fiber.

**NOTE**: This method must be invoked by the fiber itself.
/
  setFiberRefs(fiberRefs) {
    this._fiberRefs = fiberRefs;
    this.refreshRefCache();
  }
  /**
Adds a reference to the specified fiber inside the children set.

**NOTE**: This method must be invoked by the fiber itself.
/
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
Removes a reference to the specified fiber inside the children set.

**NOTE**: This method must be invoked by the fiber itself.
/
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
Transfers all children of this fiber that are currently running to the
specified fiber scope.

**NOTE**: This method must be invoked by the fiber itself after it has
evaluated the effects but prior to exiting.
/
  transferChildren(scope) {
    const children = this._children;
    // Clear the children of the current fiber
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        // If the child is still running, add it to the scope
        if (child._exitValue === null) {
          scope.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
On the current thread, executes all messages in the fiber's inbox. This
method may return before all work is done, in the event the fiber executes
an asynchronous operation.

**NOTE**: This method must be invoked by the fiber itself.
/
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[internalFiber.currentFiberURI];
      globalThis[internalFiber.currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[internalFiber.currentFiberURI] = prev;
      }
      // Maybe someone added something to the queue between us checking, and us
      // giving up the drain. If so, we need to restart the draining, but only
      // if we beat everyone else to the restart:
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
Schedules the execution of all messages in the fiber's inbox.

This method will return immediately after the scheduling
operation is completed, but potentially before such messages have been
executed.

**NOTE**: This method must be invoked by the fiber itself.
/
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(core.currentSchedulingPriority));
  }
  /**
Drains the fiber's message queue while the fiber is actively running,
returning the next effect to execute, which may be the input effect if no
additional effect needs to be executed.

**NOTE**: This method must be invoked by the fiber itself.
/
  drainQueueWhileRunning(runtimeFlags, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      // @ts-expect-error
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message);
    }
    return cur;
  }
  /**
Determines if the fiber is interrupted.

**NOTE**: This method is safe to invoke on any fiber, but if not invoked
on this fiber, then values derived from the fiber's state (including the
log annotations and log level) may not be up-to-date.
/
  isInterrupted() {
    return !internalCause.isEmpty(this.getFiberRef(core.currentInterruptedCause));
  }
  /**
Adds an interruptor to the set of interruptors that are interrupting this
fiber.

**NOTE**: This method must be invoked by the fiber itself.
/
  addInterruptedCause(cause) {
    const oldSC = this.getFiberRef(core.currentInterruptedCause);
    this.setFiberRef(core.currentInterruptedCause, internalCause.sequential(oldSC, cause));
  }
  /**
Processes a new incoming interrupt signal.

**NOTE**: This method must be invoked by the fiber itself.
/
  processNewInterruptSignal(cause) {
    this.addInterruptedCause(cause);
    this.sendInterruptSignalToAllChildren();
  }
  /**
Interrupts all children of the current fiber, returning an effect that will
await the exit of the children. This method will return null if the fiber
has no children.

**NOTE**: This method must be invoked by the fiber itself.
/
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(FiberMessage.interruptSignal(internalCause.interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
Interrupts all children of the current fiber, returning an effect that will
await the exit of the children. This method will return null if the fiber
has no children.

**NOTE**: This method must be invoked by the fiber itself.
/
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return core.asVoid(next.value.await);
        } else {
          return core.sync(() => {
            isDone = true;
          });
        }
      };
      return core.whileLoop({
        while: () => !isDone,
        body,
        step: () => {
          //
        }
      });
    }
    return null;
  }
  reportExitValue(exit) {
    if (runtimeFlags_.runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(core.currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit._tag) {
        case OpCodes.OP_SUCCESS:
          {
            fiberSuccesses.unsafeUpdate(1, tags);
            break;
          }
        case OpCodes.OP_FAILURE:
          {
            fiberFailures.unsafeUpdate(1, tags);
            break;
          }
      }
    }
    if (exit._tag === "Failure") {
      const level = this.getFiberRef(core.currentUnhandledErrorLogLevel);
      if (!internalCause.isInterruptedOnly(exit.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit.cause, level);
      }
    }
  }
  setExitValue(exit) {
    this._exitValue = exit;
    this.reportExitValue(exit);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause, overrideLogLevel) {
    const logLevel = Option.isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(core.currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (LogLevel.greaterThan(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(core.currentLogSpan);
    const annotations = this.getFiberRef(core.currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (HashSet.size(loggers) > 0) {
      const clockService = Context.get(this.getFiberRef(defaultServices.currentServices), clock.clockTag);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      Inspectable.withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause,
            context: contextMap,
            spans,
            annotations,
            date
          });
        }
      });
    }
  }
  /**
Evaluates a single message on the current thread, while the fiber is
suspended. This method should only be called while evaluation of the
fiber's effect is suspended due to an asynchronous operation.

**NOTE**: This method must be invoked by the fiber itself.
/
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case FiberMessage.OP_YIELD_NOW:
        {
          return EvaluationSignalYieldNow;
        }
      case FiberMessage.OP_INTERRUPT_SIGNAL:
        {
          this.processNewInterruptSignal(message.cause);
          if (this._asyncInterruptor !== null) {
            this._asyncInterruptor(core.exitFailCause(message.cause));
            this._asyncInterruptor = null;
          }
          return EvaluationSignalContinue;
        }
      case FiberMessage.OP_RESUME:
        {
          this._asyncInterruptor = null;
          this._asyncBlockingOn = null;
          this.evaluateEffect(message.effect);
          return EvaluationSignalContinue;
        }
      case FiberMessage.OP_STATEFUL:
        {
          message.onFiber(this, this._exitValue !== null ? FiberStatus.done : FiberStatus.suspended(this.currentRuntimeFlags, this._asyncBlockingOn));
          return EvaluationSignalContinue;
        }
      default:
        {
          return absurd(message);
        }
    }
  }
  /**
Evaluates an effect until completion, potentially asynchronously.

**NOTE**: This method must be invoked by the fiber itself.
/
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? core.exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit = this.runLoop(eff);
        if (exit === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OpCodes.OP_YIELD) {
            if (runtimeFlags_.cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(FiberMessage.yieldNow());
              this.tell(FiberMessage.resume(core.exitVoid));
              effect = null;
            } else {
              effect = core.exitVoid;
            }
          } else if (op._op === OpCodes.OP_ASYNC) {
            // Terminate this evaluation, async resumption will continue evaluation:
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = (0, _Function.pipe)(this.currentRuntimeFlags, runtimeFlags_.enable(runtimeFlags_.WindDown));
          const interruption = this.interruptAllChildren();
          if (interruption !== null) {
            effect = core.flatMap(interruption, () => exit);
          } else {
            if (this._queue.length === 0) {
              // No more messages to process, so we will allow the fiber to end life:
              this.setExitValue(exit);
            } else {
              // There are messages, possibly added by the final op executed by
              // the fiber. To be safe, we should execute those now before we
              // allow the fiber to end life:
              this.tell(FiberMessage.resume(exit));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
Begins execution of the effect associated with this fiber on the current
thread. This can be called to "kick off" execution of a fiber after it has
been created, in hopes that the effect can be executed synchronously.

This is not the normal way of starting a fiber, but it is useful when the
express goal of executing the fiber is to synchronously produce its exit.
/
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[internalFiber.currentFiberURI];
      globalThis[internalFiber.currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[internalFiber.currentFiberURI] = prev;
        // Because we're special casing `start`, we have to be responsible
        // for spinning up the fiber if there were new messages added to
        // the queue between the completion of the effect and the transition
        // to the not running state.
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(FiberMessage.resume(effect));
    }
  }
  /**
Begins execution of the effect associated with this fiber on in the
background, and on the correct thread pool. This can be called to "kick
off" execution of a fiber after it has been created, in hopes that the
effect can be executed synchronously.
/
  startFork(effect) {
    this.tell(FiberMessage.resume(effect));
  }
  /**
Takes the current runtime flags, patches them to return the new runtime
flags, and then makes any changes necessary to fiber state based on the
specified patch.

**NOTE**: This method must be invoked by the fiber itself.
/
  patchRuntimeFlags(oldRuntimeFlags, patch) {
    const newRuntimeFlags = runtimeFlags_.patch(oldRuntimeFlags, patch);
    globalThis[internalFiber.currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
Initiates an asynchronous operation, by building a callback that will
resume execution, and then feeding that callback to the registration
function, handling error cases and repeated resumptions appropriately.

**NOTE**: This method must be invoked by the fiber itself.
/
  initiateAsync(runtimeFlags, asyncRegister) {
    let alreadyCalled = false;
    const callback = effect => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(FiberMessage.resume(effect));
      }
    };
    if (runtimeFlags_.interruptible(runtimeFlags)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(core.failCause(internalCause.die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OpCodes.OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OpCodes.OP_ON_SUCCESS && frame._op !== OpCodes.OP_WHILE && frame._op !== OpCodes.OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OpCodes.OP_TAG](op) {
    return core.sync(() => Context.unsafeGet(this.currentContext, op));
  }
  ["Left"](op) {
    return core.fail(op.left);
  }
  ["None"](_) {
    return core.fail(new core.NoSuchElementException());
  }
  ["Right"](op) {
    return core.exitSucceed(op.right);
  }
  ["Some"](op) {
    return core.exitSucceed(op.value);
  }
  ["Micro"](op) {
    return core.unsafeAsync(microResume => {
      let resume = microResume;
      const fiber = Micro.runFork(Micro.provideContext(op, this.currentContext));
      fiber.addObserver(exit => {
        if (exit._tag === "Success") {
          return resume(core.exitSucceed(exit.value));
        }
        switch (exit.cause._tag) {
          case "Interrupt":
            {
              return resume(core.exitFailCause(internalCause.interrupt(FiberId.none)));
            }
          case "Fail":
            {
              return resume(core.fail(exit.cause.error));
            }
          case "Die":
            {
              return resume(core.die(exit.cause.defect));
            }
        }
      });
      return core.unsafeAsync(abortResume => {
        resume = _ => {
          abortResume(core.void);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OpCodes.OP_SYNC](op) {
    const value = (0, _Utils.internalCall)(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        // @ts-expect-error
        absurd(cont);
      }
      // @ts-expect-error
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = core.exitSucceed(value);
      return YieldedOp;
    }
  }
  [OpCodes.OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        // @ts-expect-error
        absurd(cont);
      }
      // @ts-expect-error
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OpCodes.OP_FAILURE](op) {
    const cause = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== undefined) {
      switch (cont._op) {
        case OpCodes.OP_ON_FAILURE:
        case OpCodes.OP_ON_SUCCESS_AND_FAILURE:
          {
            if (!(runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
              return (0, _Utils.internalCall)(() => cont.effect_instruction_i1(cause));
            } else {
              return core.exitFailCause(internalCause.stripFailures(cause));
            }
          }
        case "OnStep":
          {
            if (!(runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
              return core.exitSucceed(core.exitFailCause(cause));
            } else {
              return core.exitFailCause(internalCause.stripFailures(cause));
            }
          }
        case OpCodes.OP_REVERT_FLAGS:
          {
            this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
            if (runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
              return core.exitFailCause(internalCause.sequential(cause, this.getInterruptedCause()));
            } else {
              return core.exitFailCause(cause);
            }
          }
        default:
          {
            absurd(cont);
          }
      }
    } else {
      yieldedOpChannel.currentOp = core.exitFailCause(cause);
      return YieldedOp;
    }
  }
  [OpCodes.OP_WITH_RUNTIME](op) {
    return (0, _Utils.internalCall)(() => op.effect_instruction_i0(this, FiberStatus.running(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = FiberRefsPatch.diff(snap.refs, refs);
      const patchFlags = runtimeFlags_.diff(snap.flags, flags);
      return core.exitSucceed(core.blocked(op.effect_instruction_i0, core.withFiberRuntime(newFiber => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(FiberRefsPatch.patch(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = runtimeFlags_.patch(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return core.uninterruptibleMask(restore => core.flatMap(forkDaemon(core.runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OpCodes.OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = runtimeFlags_.patch(oldRuntimeFlags, updateFlags);
    // One more chance to short circuit: if we're immediately going
    // to interrupt. Interruption will cause immediate reversion of
    // the flag, so as long as we "peek ahead", there's no need to
    // set them to begin with.
    if (runtimeFlags_.interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return core.exitFailCause(this.getInterruptedCause());
    } else {
      // Impossible to short circuit, so record the changes
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        // Since we updated the flags, we need to revert them
        const revertFlags = runtimeFlags_.diff(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new core.RevertFlags(revertFlags, op));
        return (0, _Utils.internalCall)(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return core.exitVoid;
      }
    }
  }
  [OpCodes.OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OpCodes.OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OpCodes.OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OpCodes.OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OpCodes.OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OpCodes.OP_WHILE](op) {
    const check = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check()) {
      this.pushStack(op);
      return body();
    } else {
      return core.exitVoid;
    }
  }
  [OpCodes.OP_ITERATOR](op) {
    return contOpSuccess[OpCodes.OP_ITERATOR](this, op, undefined);
  }
  [OpCodes.OP_COMMIT](op) {
    return (0, _Utils.internalCall)(() => op.commit());
  }
  /**
The main run-loop for evaluating effects.

**NOTE**: This method must be invoked by the fiber itself.
/
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & _runtimeFlags2.OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = core.flatMap(core.yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        // @ts-expect-error
        cur = this.currentTracer.context(() => {
          if (_version !== cur[core.EffectTypeId]._V) {
            return core.dieMessage(`Cannot execute an Effect versioned ${cur[core.EffectTypeId]._V} with a Runtime of version ${version.getCurrentVersion()}`);
          }
          // @ts-expect-error
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OpCodes.OP_YIELD || op._op === OpCodes.OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OpCodes.OP_SUCCESS || op._op === OpCodes.OP_FAILURE ? op : core.exitFailCause(internalCause.die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !Predicate.hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = core.dieMessage(`Not a valid effect: ${Inspectable.toStringUnknown(cur)}`);
        } else if (core.isInterruptedException(e)) {
          cur = core.exitFailCause(internalCause.sequential(internalCause.die(e), internalCause.interrupt(FiberId.none)));
        } else {
          cur = core.die(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
}
// circular with Logger
/** @internal

## loggerWithConsoleLog

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `loggerWithConsoleLog(= loggerWithConsoleLog;
const loggerWithLeveledLog = self => internalLogger.makeLogger(opts => {
  const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices)`

JSDoc:

@internal */
const loggerWithConsoleLog = self => internalLogger.makeLogger(opts => {
  const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices);
  Context.get(services, _console.consoleTag).unsafe.log(self.log(opts));
});
/** @internal

## loggerWithLeveledLog

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `loggerWithLeveledLog(= loggerWithLeveledLog;
const loggerWithConsoleError = self => internalLogger.makeLogger(opts => {
  const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices)`

JSDoc:

@internal

## loggerWithConsoleError

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `loggerWithConsoleError(= loggerWithConsoleError;
const defaultLogger = exports.defaultLogger = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@internal

## loggerWithSpanAnnotations

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `loggerWithSpanAnnotations(= loggerWithSpanAnnotations;
const currentLoggers = exports.currentLoggers = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@internal */
const jsonLogger = exports.jsonLogger = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/Logger/jsonLogger"), () => loggerWithConsoleLog(internalLogger.jsonLogger));
/** @internal */
const logFmtLogger = exports.logFmtLogger = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/Logger/logFmtLogger"), () => loggerWithConsoleLog(internalLogger.logfmtLogger));
/** @internal */
const prettyLogger = exports.prettyLogger = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/Logger/prettyLogger"), () => internalLogger.prettyLoggerDefault);
/** @internal */
const structuredLogger = exports.structuredLogger = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/Logger/structuredLogger"), () => loggerWithConsoleLog(internalLogger.structuredLogger));
/** @internal */
const tracerLogger = exports.tracerLogger = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/Logger/tracerLogger"), () => internalLogger.makeLogger(({
  annotations,
  cause,
  context,
  fiberId,
  logLevel,
  message
}) => {
  const span = Context.getOption(fiberRefs.getOrDefault(context, core.currentContext), tracer.spanTag);
  if (span._tag === "None" || span.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = Context.unsafeGet(fiberRefs.getOrDefault(context, defaultServices.currentServices), clock.clockTag);
  const attributes = {};
  for (const [key, value] of annotations) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = FiberId.threadName(fiberId);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause !== null && cause._tag !== "Empty") {
    attributes["effect.cause"] = internalCause.pretty(cause, {
      renderErrorCause: true
    });
  }
  span.value.event(Inspectable.toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
/** @internal */
const loggerWithSpanAnnotations = self => internalLogger.mapInputOptions(self, options => {
  const span = Option.flatMap(fiberRefs.get(options.context, core.currentContext), Context.getOption(tracer.spanTag));
  if (span._tag === "None") {
    return options;
  }
  return {
    ...options,
    annotations: (0, _Function.pipe)(options.annotations, HashMap.set("effect.traceId", span.value.traceId), HashMap.set("effect.spanId", span.value.spanId), span.value._tag === "Span" ? HashMap.set("effect.spanName", span.value.name) : _Function.identity)
  };
});
/** @internal

## annotateLogsScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `annotateLogsScoped(= annotateLogsScoped;
const whenLogLevel = exports.whenLogLevel = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const batchedLogger = exports.batchedLogger = /*#__PURE__*/(0, _Function.dual)(3, (self, window, f) => core.flatMap(scope, scope => {
  let buffer = [];
  const flush = core.suspend(() => {
    if (buffer.length === 0) {
      return core.void;
    }
    const arr = buffer;
    buffer = [];
    return f(arr);
  });
  return core.uninterruptibleMask(restore => (0, _Function.pipe)(internalEffect.sleep(window), core.zipRight(flush), internalEffect.forever, restore, forkDaemon, core.flatMap(fiber => core.scopeAddFinalizer(scope, core.interruptFiber(fiber))), core.zipRight(addFinalizer(() => flush)), core.as(internalLogger.makeLogger(options => {
    buffer.push(self.log(options));
  }))));
}));
const annotateLogsScoped = function () {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(core.currentLogAnnotations, HashMap.set(arguments[0], arguments[1]));
  }
  const entries = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(core.currentLogAnnotations, HashMap.mutate(annotations => {
    for (let i = 0; i < entries.length; i++) {
      const [key, value] = entries[i];
      HashMap.set(annotations, key, value);
    }
    return annotations;
  }));
};
/** @internal

## daemonChildren

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `daemonChildren(= daemonChildren;
const _existsParFound = /*#__PURE__*/Symbol.for("effect/Effect/existsPar/found")`

JSDoc:

@internal

## forEachParUnbounded

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `forEachParUnbounded(= forEachParUnbounded;
const forEachConcurrentDiscard = (self, f, batching, processAll, n)`

JSDoc:

@internal

## unsafeFork

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `unsafeFork(= unsafeFork;
const unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null)`

JSDoc:

@internal */
const unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
};
/** @internal

## unsafeForkUnstarted

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `unsafeForkUnstarted(= unsafeForkUnstarted;
const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null)`

JSDoc:

@internal

## scopeWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `scopeWith(= scopeWith;
const scopedWith = f => core.flatMap(scopeMake()`

JSDoc:

@internal

## withClockScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `withClockScoped(= withClockScoped;
const withRandomScoped = value => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(_random.randomTag, value)`

JSDoc:

@internal */
const validate = exports.validate = /*#__PURE__*/(0, _Function.dual)(args => core.isEffect(args[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
/** @internal */
const validateWith = exports.validateWith = /*#__PURE__*/(0, _Function.dual)(args => core.isEffect(args[1]), (self, that, f, options) => core.flatten(zipWithOptions(core.exit(self), core.exit(that), (ea, eb) => core.exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options?.concurrent ? internalCause.parallel(ca, cb) : internalCause.sequential(ca, cb)
}), options)));
/* @internal */
const validateAllPar = exports.validateAllPar = /*#__PURE__*/(0, _Function.dual)(2, (elements, f) => core.flatMap(partition(elements, f), ([es, bs]) => es.length === 0 ? core.succeed(bs) : core.fail(es)));
/* @internal */
const validateAllParDiscard = exports.validateAllParDiscard = /*#__PURE__*/(0, _Function.dual)(2, (elements, f) => core.flatMap(partition(elements, f), ([es, _]) => es.length === 0 ? core.void : core.fail(es)));
/* @internal */
const validateFirst = exports.validateFirst = /*#__PURE__*/(0, _Function.dual)(args => Predicate.isIterable(args[0]), (elements, f, options) => core.flip(forEach(elements, (a, i) => core.flip(f(a, i)), options)));
/* @internal */
const withClockScoped = c => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(clock.clockTag, c));
/* @internal

## withEarlyRelease

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `withEarlyRelease(= withEarlyRelease;
const zipOptions = exports.zipOptions = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## withRuntimeFlagsScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `withRuntimeFlagsScoped(= withRuntimeFlagsScoped;
const scopeTag = exports.scopeTag = /*#__PURE__*/Context.GenericTag("effect/Scope")`

JSDoc:

@internal */
const zipLeftOptions = exports.zipLeftOptions = /*#__PURE__*/(0, _Function.dual)(args => core.isEffect(args[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return core.zipLeft(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options);
});
/** @internal */
const zipRightOptions = exports.zipRightOptions = /*#__PURE__*/(0, _Function.dual)(args => core.isEffect(args[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return core.zipRight(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options);
});
/** @internal */
const zipWithOptions = exports.zipWithOptions = /*#__PURE__*/(0, _Function.dual)(args => core.isEffect(args[1]), (self, that, f, options) => core.map(all([self, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
/* @internal */
const withRuntimeFlagsScoped = update => {
  if (update === RuntimeFlagsPatch.empty) {
    return core.void;
  }
  return (0, _Function.pipe)(core.runtimeFlags, core.flatMap(runtimeFlags => {
    const updatedRuntimeFlags = runtimeFlags_.patch(runtimeFlags, update);
    const revertRuntimeFlags = runtimeFlags_.diff(updatedRuntimeFlags, runtimeFlags);
    return (0, _Function.pipe)(core.updateRuntimeFlags(update), core.zipRight(addFinalizer(() => core.updateRuntimeFlags(revertRuntimeFlags))), core.asVoid);
  }), core.uninterruptible);
};
// circular with Scope
/** @internal

## fiberRefUnsafeMakeSupervisor

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `fiberRefUnsafeMakeSupervisor(= fiberRefUnsafeMakeSupervisor;
const fiberRefLocallyScoped = exports.fiberRefLocallyScoped = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const fiberRefUnsafeMakeSupervisor = initial => core.fiberRefUnsafeMakePatch(initial, {
  differ: SupervisorPatch.differ,
  fork: SupervisorPatch.empty
});
// circular with FiberRef
/* @internal

## fiberRefMakeRuntimeFlags

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `fiberRefMakeRuntimeFlags(= fiberRefMakeRuntimeFlags;
const currentRuntimeFlags = exports.currentRuntimeFlags = /*#__PURE__*/core.fiberRefUnsafeMakeRuntimeFlags(runtimeFlags_.none)`

JSDoc:

@internal

## fiberAwaitAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `fiberAwaitAll(= fiberAwaitAll;
const fiberAll = fibers => {
  const _fiberAll = {
    ...Effectable.CommitPrototype,
    commit()`

JSDoc:

@internal */
const currentSupervisor = exports.currentSupervisor = /*#__PURE__*/fiberRefUnsafeMakeSupervisor(supervisor.none);
// circular with Fiber
/* @internal */
const fiberAwaitAll = fibers => forEach(fibers, internalFiber._await);
/** @internal

## fiberScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `fiberScoped(= fiberScoped;
const raceWith = exports.raceWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## disconnect

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `disconnect(= disconnect;
const race = exports.race = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const disconnect = self => core.uninterruptibleMask(restore => core.fiberIdWith(fiberId => core.flatMap(forkDaemon(restore(self)), fiber => (0, _Function.pipe)(restore(internalFiber.join(fiber)), core.onInterrupt(() => (0, _Function.pipe)(fiber, internalFiber.interruptAsFork(fiberId)))))));
/** @internal

## invokeWithInterrupt

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `invokeWithInterrupt(= invokeWithInterrupt;
const interruptWhenPossible = exports.interruptWhenPossible = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const raceFibersWith = exports.raceFibersWith = /*#__PURE__*/(0, _Function.dual)(3, (self, other, options) => core.withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = MRef.make(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return core.async(cb => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, FiberId.combine(leftFiber.id(), rightFiber.id()));
}));
const completeRace = (winner, loser, cont, ab, cb) => {
  if (MRef.compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
/** @internal */
const ensuring = exports.ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => core.uninterruptibleMask(restore => core.matchCauseEffect(restore(self), {
  onFailure: cause1 => core.matchCauseEffect(finalizer, {
    onFailure: cause2 => core.failCause(internalCause.sequential(cause1, cause2)),
    onSuccess: () => core.failCause(cause1)
  }),
  onSuccess: a => core.as(finalizer, a)
})));
/** @internal */
const invokeWithInterrupt = (self, entries, onInterrupt) => core.fiberIdWith(id => core.flatMap(core.flatMap(forkDaemon(core.interruptible(self)), processing => core.async(cb => {
  const counts = entries.map(_ => _.listeners.count);
  const checkDone = () => {
    if (counts.every(count => count === 0)) {
      if (entries.every(_ => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && core.exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && internalCause.isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach(f => f());
        onInterrupt?.();
        cb(core.interruptFiber(processing));
      }
    }
  };
  processing.addObserver(exit => {
    cleanup.forEach(f => f());
    cb(exit);
  });
  const cleanup = entries.map((r, i) => {
    const observer = count => {
      counts[i] = count;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return core.sync(() => {
    cleanup.forEach(f => f());
  });
})), () => core.suspend(() => {
  const residual = entries.flatMap(entry => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return core.forEachSequentialDiscard(residual, entry => (0, _request.complete)(entry.request, core.exitInterrupt(id)));
})));
/** @internal

## makeSpanScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `makeSpanScoped(= makeSpanScoped;
const withTracerScoped = value => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(tracer.tracerTag, value)`

JSDoc:

@internal */
const makeSpanScoped = (name, options) => {
  options = tracer.addSpanStackTrace(options);
  return core.uninterruptible(core.withFiberRuntime(fiber => {
    const scope = Context.unsafeGet(fiber.getFiberRef(core.currentContext), scopeTag);
    const span = internalEffect.unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled);
    const clock_ = Context.get(fiber.getFiberRef(defaultServices.currentServices), clock.clockTag);
    return core.as(core.scopeAddFinalizerExit(scope, exit => internalEffect.endSpan(span, exit, clock_, timingEnabled)), span);
  }));
};
/* @internal

## withTracerScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberRuntime.js`

Signature: `withTracerScoped(= withTracerScoped;
const withSpanScoped = function ()`

JSDoc:

@internal

## unsafeMake

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberScope.js`

Signature: `unsafeMake(= unsafeMake;
const globalScope = exports.globalScope = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@internal */
const FiberScopeSymbolKey = "effect/FiberScope";
/** @internal */
const FiberScopeTypeId = exports.FiberScopeTypeId = /*#__PURE__*/Symbol.for(FiberScopeSymbolKey);
/** @internal */
class Global {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = FiberId.none;
  roots = /*#__PURE__*/new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
}
/** @internal */
class Local {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId, parent) {
    this.fiberId = fiberId;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(FiberMessage.stateful(parentFiber => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
}
/** @internal */
const unsafeMake = fiber => {
  return new Local(fiber.id(), fiber);
};
/** @internal

## running

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberStatus.js`

Signature: `running(= running;
const suspended = (runtimeFlags, blockingOn)`

JSDoc:

@internal */
const FiberStatusTypeId = exports.FiberStatusTypeId = /*#__PURE__*/Symbol.for(FiberStatusSymbolKey);
/** @internal */
const OP_DONE = exports.OP_DONE = "Done";
/** @internal */
const OP_RUNNING = exports.OP_RUNNING = "Running";
/** @internal */
const OP_SUSPENDED = exports.OP_SUSPENDED = "Suspended";
const DoneHash = /*#__PURE__*/Hash.string(`${FiberStatusSymbolKey}-${OP_DONE}`);
/** @internal */
class Done {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [Hash.symbol]() {
    return DoneHash;
  }
  [Equal.symbol](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
}
/** @internal */
class Running {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags) {
    this.runtimeFlags = runtimeFlags;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(FiberStatusSymbolKey), Hash.combine(Hash.hash(this._tag)), Hash.combine(Hash.hash(this.runtimeFlags)), Hash.cached(this));
  }
  [Equal.symbol](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
}
/** @internal */
class Suspended {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags, blockingOn) {
    this.runtimeFlags = runtimeFlags;
    this.blockingOn = blockingOn;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(FiberStatusSymbolKey), Hash.combine(Hash.hash(this._tag)), Hash.combine(Hash.hash(this.runtimeFlags)), Hash.combine(Hash.hash(this.blockingOn)), Hash.cached(this));
  }
  [Equal.symbol](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && Equal.equals(this.blockingOn, that.blockingOn);
  }
}
/** @internal */
const done = exports.done = /*#__PURE__*/new Done();
/** @internal */
const running = runtimeFlags => new Running(runtimeFlags);
/** @internal

## suspended

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberStatus.js`

Signature: `suspended(= suspended;
const isFiberStatus = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isFiberStatus

Source: `my-backend/node_modules/effect/dist/cjs/internal/fiberStatus.js`

Signature: `isFiberStatus(= isFiberStatus;
const isDone = self => self._tag === OP_DONE;
/** @internal */
exports.isDone = isDone;
const isRunning = self => self._tag === OP_RUNNING;
/** @internal */
exports.isRunning = isRunning;
const isSuspended = self => self._tag === OP_SUSPENDED;
exports.isSuspended = isSuspended;
//# sourceMappingURL=fiberStatus.js.map)`

JSDoc:

@internal

## isGroupBy

Source: `my-backend/node_modules/effect/dist/cjs/internal/groupBy.js`

Signature: `isGroupBy(= isGroupBy;
const evaluate = exports.evaluate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const GroupBySymbolKey = "effect/GroupBy";
/** @internal */
const GroupByTypeId = exports.GroupByTypeId = /*#__PURE__*/Symbol.for(GroupBySymbolKey);
const groupByVariance = {
  /* c8 ignore next */
  _R: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _K: _ => _,
  /* c8 ignore next */
  _V: _ => _
};
/** @internal */
const isGroupBy = u => (0, _Predicate.hasProperty)(u, GroupByTypeId);
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/groupBy.js`

Signature: `make(= make;
const groupBy = exports.groupBy = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => make((0, _Function.pipe)(self.grouped, stream.filterEffect(tuple => {
  if (predicate(tuple[0])) {
    return (0, _Function.pipe)(Effect.succeed(tuple), Effect.as(true));
  }
  return (0, _Function.pipe)(Queue.shutdown(tuple[1]), Effect.as(false));
}))));
/** @internal */
const first = exports.first = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => make((0, _Function.pipe)(stream.zipWithIndex(self.grouped), stream.filterEffect(tuple => {
  const index = tuple[1];
  const queue = tuple[0][1];
  if (index < n) {
    return (0, _Function.pipe)(Effect.succeed(tuple), Effect.as(true));
  }
  return (0, _Function.pipe)(Queue.shutdown(queue), Effect.as(false));
}), stream.map(tuple => tuple[0]))));
/** @internal */
const make = grouped => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  grouped
});
// Circular with Stream
/** @internal

## EmptyNode

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap/node.js`

Signature: `EmptyNode(= EmptyNode;
function isEmptyNode(a)`

JSDoc:

@internal */
class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash, key, size) {
    const v = f(O.none());
    if (O.isNone(v)) return new EmptyNode();
    ++size.value;
    return new LeafNode(edit, hash, key, v);
  }
}
/** @internal

## LeafNode

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap/node.js`

Signature: `LeafNode(= LeafNode;
class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash, children)`

JSDoc:

@internal */
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
/** @internal */
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
/** @internal */
class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash, key, value) {
    this.edit = edit;
    this.hash = hash;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash, key, size) {
    if ((0, _Equal.equals)(key, this.key)) {
      const v = f(this.value);
      if (v === this.value) return this;else if (O.isNone(v)) {
        ;
        --size.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v;
        return this;
      }
      return new LeafNode(edit, hash, key, v);
    }
    const v = f(O.none());
    if (O.isNone(v)) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));
  }
}
/** @internal

## CollisionNode

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap/node.js`

Signature: `CollisionNode(= CollisionNode;
class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children)`

JSDoc:

@internal

## IndexedNode

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap/node.js`

Signature: `IndexedNode(= IndexedNode;
class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size, children)`

JSDoc:

@internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `empty(= empty;
const make = (...entries)`

JSDoc:

@internal */
const HashMapTypeId = exports.HashMapTypeId = /*#__PURE__*/Symbol.for(HashMapSymbolKey);
const HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [Hash.symbol]() {
    let hash = Hash.hash(HashMapSymbolKey);
    for (const item of this) {
      hash ^= (0, _Function.pipe)(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])));
    }
    return Hash.cached(this, hash);
  },
  [Equal.symbol](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = (0, _Function.pipe)(that, getHash(item[0], Hash.hash(item[0])));
        if (Option.isNone(elem)) {
          return false;
        } else {
          if (!Equal.equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const makeImpl = (editable, edit, root, size) => {
  const map = Object.create(HashMapProto);
  map._editable = editable;
  map._edit = edit;
  map._root = root;
  map._size = size;
  return map;
};
class HashMapIterator {
  map;
  f;
  v;
  constructor(map, f) {
    this.map = map;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, undefined);
  }
  next() {
    if (Option.isNone(this.v)) {
      return {
        done: true,
        value: undefined
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
const applyCont = cont => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : Option.none();
const visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode":
      {
        if (Option.isSome(node.value)) {
          return Option.some({
            value: f(node.key, node.value.value),
            cont
          });
        }
        return applyCont(cont);
      }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode":
      {
        const children = node.children;
        return visitLazyChildren(children.length, children, 0, f, cont);
      }
    default:
      {
        return applyCont(cont);
      }
  }
};
const visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !Node.isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
const _empty = /*#__PURE__*/makeImpl(false, 0, /*#__PURE__*/new Node.EmptyNode(), 0);
/** @internal */
const empty = () => _empty;
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `make(= make;
const fromIterable = entries => {
  const map = beginMutation(empty()`

JSDoc:

@internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `fromIterable(= fromIterable;
const isHashMap = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isHashMap

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `isHashMap(= isHashMap;
const isEmpty = self => self && Node.isEmptyNode(self._root)`

JSDoc:

@internal

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `isEmpty(= isEmpty;
const get = exports.get = /*#__PURE__*/Dual.dual(2, (self, key)`

JSDoc:

@internal

## keys

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `keys(= keys;
const values = self => new HashMapIterator(self, (_, value)`

JSDoc:

@internal */
const getHash = exports.getHash = /*#__PURE__*/Dual.dual(3, (self, key, hash) => {
  let node = self._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode":
        {
          return Equal.equals(key, node.key) ? node.value : Option.none();
        }
      case "CollisionNode":
        {
          if (hash === node.hash) {
            const children = node.children;
            for (let i = 0, len = children.length; i < len; ++i) {
              const child = children[i];
              if ("key" in child && Equal.equals(key, child.key)) {
                return child.value;
              }
            }
          }
          return Option.none();
        }
      case "IndexedNode":
        {
          const frag = (0, _bitwise.hashFragment)(shift, hash);
          const bit = (0, _bitwise.toBitmap)(frag);
          if (node.mask & bit) {
            node = node.children[(0, _bitwise.fromBitmap)(node.mask, bit)];
            shift += _config.SIZE;
            break;
          }
          return Option.none();
        }
      case "ArrayNode":
        {
          node = node.children[(0, _bitwise.hashFragment)(shift, hash)];
          if (node) {
            shift += _config.SIZE;
            break;
          }
          return Option.none();
        }
      default:
        return Option.none();
    }
  }
});
/** @internal */
const unsafeGet = exports.unsafeGet = /*#__PURE__*/Dual.dual(2, (self, key) => {
  const element = getHash(self, key, Hash.hash(key));
  if (Option.isNone(element)) {
    throw new Error("Expected map to contain key");
  }
  return element.value;
});
/** @internal */
const has = exports.has = /*#__PURE__*/Dual.dual(2, (self, key) => Option.isSome(getHash(self, key, Hash.hash(key))));
/** @internal */
const hasHash = exports.hasHash = /*#__PURE__*/Dual.dual(3, (self, key, hash) => Option.isSome(getHash(self, key, hash)));
/** @internal */
const hasBy = exports.hasBy = /*#__PURE__*/Dual.dual(2, (self, predicate) => Option.isSome(findFirst(self, predicate)));
/** @internal */
const set = exports.set = /*#__PURE__*/Dual.dual(3, (self, key, value) => modifyAt(self, key, () => Option.some(value)));
/** @internal */
const setTree = exports.setTree = /*#__PURE__*/Dual.dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
/** @internal */
const keys = self => new HashMapIterator(self, key => key);
/** @internal

## values

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `values(= values;
const entries = self => new HashMapIterator(self, (key, value)`

JSDoc:

@internal

## entries

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `entries(= entries;
const size = self => self._size;
/** @internal */
exports.size = size;
const beginMutation = self => makeImpl(true, self._edit + 1, self._root, self._size)`

JSDoc:

@internal

## beginMutation

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `beginMutation(= beginMutation;
const endMutation = self => {
  ;
  self._editable = false;
  return self;
};
/** @internal */
exports.endMutation = endMutation;
const mutate = exports.mutate = /*#__PURE__*/Dual.dual(2, (self, f)`

JSDoc:

@internal

## compact

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashMap.js`

Signature: `compact(= compact;
const filterMap = exports.filterMap = /*#__PURE__*/Dual.dual(2, (self, f)`

JSDoc:

@internal */
const modifyAt = exports.modifyAt = /*#__PURE__*/Dual.dual(3, (self, key, f) => modifyHash(self, key, Hash.hash(key), f));
/** @internal */
const modifyHash = exports.modifyHash = /*#__PURE__*/Dual.dual(4, (self, key, hash, f) => {
  const size = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash, key, size);
  return (0, _Function.pipe)(self, setTree(newRoot, size.value));
});
/** @internal */
const modify = exports.modify = /*#__PURE__*/Dual.dual(3, (self, key, f) => modifyAt(self, key, Option.map(f)));
/** @internal */
const union = exports.union = /*#__PURE__*/Dual.dual(2, (self, that) => {
  const result = beginMutation(self);
  forEach(that, (v, k) => set(result, k, v));
  return endMutation(result);
});
/** @internal */
const remove = exports.remove = /*#__PURE__*/Dual.dual(2, (self, key) => modifyAt(self, key, Option.none));
/** @internal */
const removeMany = exports.removeMany = /*#__PURE__*/Dual.dual(2, (self, keys) => mutate(self, map => {
  for (const key of keys) {
    remove(key)(map);
  }
}));
/**
Maps over the entries of the `HashMap` using the specified function.

@since 2.0.0
@category mapping
/
const map = exports.map = /*#__PURE__*/Dual.dual(2, (self, f) => reduce(self, empty(), (map, value, key) => set(map, key, f(value, key))));
/** @internal */
const flatMap = exports.flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => reduce(self, empty(), (zero, value, key) => mutate(zero, map => forEach(f(value, key), (value, key) => set(map, key, value)))));
/** @internal */
const forEach = exports.forEach = /*#__PURE__*/Dual.dual(2, (self, f) => reduce(self, void 0, (_, value, key) => f(value, key)));
/** @internal */
const reduce = exports.reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return Option.isSome(root.value) ? f(zero, root.value.value, root.key) : zero;
  }
  if (root._tag === "EmptyNode") {
    return zero;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length; i < len;) {
      const child = children[i++];
      if (child && !Node.isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (Option.isSome(child.value)) {
            zero = f(zero, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero;
});
/** @internal */
const filter = exports.filter = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), map => {
  for (const [k, a] of self) {
    if (f(a, k)) {
      set(map, k, a);
    }
  }
}));
/** @internal */
const compact = self => filterMap(self, _Function.identity);
/** @internal

## makeImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashSet.js`

Signature: `makeImpl(= makeImpl;
const isHashSet = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const HashSetTypeId = exports.HashSetTypeId = /*#__PURE__*/Symbol.for(HashSetSymbolKey);
const HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return HM.keys(this._keyMap);
  },
  [Hash.symbol]() {
    return Hash.cached(this, Hash.combine(Hash.hash(this._keyMap))(Hash.hash(HashSetSymbolKey)));
  },
  [Equal.symbol](that) {
    if (isHashSet(that)) {
      return HM.size(this._keyMap) === HM.size(that._keyMap) && Equal.equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const makeImpl = keyMap => {
  const set = Object.create(HashSetProto);
  set._keyMap = keyMap;
  return set;
};
/** @internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashSet.js`

Signature: `empty(= empty;
const fromIterable = elements => {
  const set = beginMutation(empty()`

JSDoc:

@internal */
const empty = () => _empty;
/** @internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashSet.js`

Signature: `fromIterable(= fromIterable;
const make = (...elements)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashSet.js`

Signature: `make(= make;
const has = exports.has = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## values

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashSet.js`

Signature: `values(= values;
const size = self => HM.size(self._keyMap)`

JSDoc:

@internal */
const some = exports.some = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  let found = false;
  for (const value of self) {
    found = f(value);
    if (found) {
      break;
    }
  }
  return found;
});
/** @internal */
const every = exports.every = /*#__PURE__*/(0, _Function.dual)(2, (self, refinement) => !some(self, a => !refinement(a)));
/** @internal */
const isSubset = exports.isSubset = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => every(self, value => has(that, value)));
/** @internal */
const values = self => HM.keys(self._keyMap);
/** @internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashSet.js`

Signature: `size(= size;
const beginMutation = self => makeImpl(HM.beginMutation(self._keyMap)`

JSDoc:

@internal

## beginMutation

Source: `my-backend/node_modules/effect/dist/cjs/internal/hashSet.js`

Signature: `beginMutation(= beginMutation;
const endMutation = self => {
  ;
  self._keyMap._editable = false;
  return self;
};
/** @internal */
exports.endMutation = endMutation;
const mutate = exports.mutate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/keyedPool.js`

Signature: `make(= make;
const makeWith = options => makeImpl(options.acquire, options.size, options.size, ()`

JSDoc:

@internal */
const KeyedPoolSymbolKey = "effect/KeyedPool";
/** @internal */
const KeyedPoolTypeId = exports.KeyedPoolTypeId = /*#__PURE__*/Symbol.for(KeyedPoolSymbolKey);
const KeyedPoolMapValueSymbol = /*#__PURE__*/Symbol.for("effect/KeyedPool/MapValue");
const keyedPoolVariance = {
  /* c8 ignore next */
  _K: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
class KeyedPoolImpl {
  getOrCreatePool;
  activePools;
  [KeyedPoolTypeId] = keyedPoolVariance;
  constructor(getOrCreatePool, activePools) {
    this.getOrCreatePool = getOrCreatePool;
    this.activePools = activePools;
  }
  get(key) {
    return core.flatMap(this.getOrCreatePool(key), pool.get);
  }
  invalidate(item) {
    return core.flatMap(this.activePools, core.forEachSequentialDiscard(pool => pool.invalidate(item)));
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
class Complete {
  pool;
  _tag = "Complete";
  [KeyedPoolMapValueSymbol] = KeyedPoolMapValueSymbol;
  constructor(pool) {
    this.pool = pool;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.string("effect/KeyedPool/Complete"), Hash.combine(Hash.hash(this.pool)), Hash.cached(this));
  }
  [Equal.symbol](u) {
    return isComplete(u) && Equal.equals(this.pool, u.pool);
  }
}
const isComplete = u => Predicate.isTagged(u, "Complete") && KeyedPoolMapValueSymbol in u;
class Pending {
  deferred;
  _tag = "Pending";
  [KeyedPoolMapValueSymbol] = KeyedPoolMapValueSymbol;
  constructor(deferred) {
    this.deferred = deferred;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.string("effect/KeyedPool/Pending"), Hash.combine(Hash.hash(this.deferred)), Hash.cached(this));
  }
  [Equal.symbol](u) {
    return isPending(u) && Equal.equals(this.deferred, u.deferred);
  }
}
const isPending = u => Predicate.isTagged(u, "Pending") && KeyedPoolMapValueSymbol in u;
const makeImpl = (get, min, max, timeToLive) => (0, _Function.pipe)(fiberRuntime.all([core.context(), core.fiberId, core.sync(() => MutableRef.make(HashMap.empty())), fiberRuntime.scopeMake()]), core.map(([context, fiberId, map, scope]) => {
  const getOrCreatePool = key => core.suspend(() => {
    let value = Option.getOrUndefined(HashMap.get(MutableRef.get(map), key));
    if (value === undefined) {
      return core.uninterruptibleMask(restore => {
        const deferred = core.deferredUnsafeMake(fiberId);
        value = new Pending(deferred);
        let previous = undefined;
        if (HashMap.has(MutableRef.get(map), key)) {
          previous = Option.getOrUndefined(HashMap.get(MutableRef.get(map), key));
        } else {
          MutableRef.update(map, HashMap.set(key, value));
        }
        if (previous === undefined) {
          return (0, _Function.pipe)(restore(fiberRuntime.scopeExtend(pool.makeWithTTL({
            acquire: core.provideContext(get(key), context),
            min: min(key),
            max: max(key),
            timeToLive: Option.getOrElse(timeToLive(key), () => Duration.infinity)
          }), scope)), core.matchCauseEffect({
            onFailure: cause => {
              const current = Option.getOrUndefined(HashMap.get(MutableRef.get(map), key));
              if (Equal.equals(current, value)) {
                MutableRef.update(map, HashMap.remove(key));
              }
              return core.zipRight(core.deferredFailCause(deferred, cause), core.failCause(cause));
            },
            onSuccess: pool => {
              MutableRef.update(map, HashMap.set(key, new Complete(pool)));
              return core.as(core.deferredSucceed(deferred, pool), pool);
            }
          }));
        }
        switch (previous._tag) {
          case "Complete":
            {
              return core.succeed(previous.pool);
            }
          case "Pending":
            {
              return restore(core.deferredAwait(previous.deferred));
            }
        }
      });
    }
    switch (value._tag) {
      case "Complete":
        {
          return core.succeed(value.pool);
        }
      case "Pending":
        {
          return core.deferredAwait(value.deferred);
        }
    }
  });
  const activePools = core.suspend(() => core.forEachSequential(HashMap.toValues(MutableRef.get(map)), value => {
    switch (value._tag) {
      case "Complete":
        {
          return core.succeed(value.pool);
        }
      case "Pending":
        {
          return core.deferredAwait(value.deferred);
        }
    }
  }));
  return new KeyedPoolImpl(getOrCreatePool, activePools);
}));
/** @internal */
const make = options => makeImpl(options.acquire, () => options.size, () => options.size, () => Option.none());
/** @internal

## makeWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/keyedPool.js`

Signature: `makeWith(= makeWith;
const makeWithTTL = options => {
  const timeToLive = Duration.decode(options.timeToLive)`

JSDoc:

@internal

## makeWithTTL

Source: `my-backend/node_modules/effect/dist/cjs/internal/keyedPool.js`

Signature: `makeWithTTL(= makeWithTTL;
const makeWithTTLBy = options => makeImpl(options.acquire, options.min, options.max, key => Option.some(Duration.decode(options.timeToLive(key)`

JSDoc:

@internal

## makeWithTTLBy

Source: `my-backend/node_modules/effect/dist/cjs/internal/keyedPool.js`

Signature: `makeWithTTLBy(= makeWithTTLBy;
const get = exports.get = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## minimumLogLevel

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `minimumLogLevel(= minimumLogLevel;
const withMinimumLogLevel = exports.withMinimumLogLevel = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const minimumLogLevel = level => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScoped(fiberRuntime.currentMinimumLogLevel, level));
/** @internal

## addLogger

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `addLogger(= addLogger;
const addLoggerEffect = effect => layer.unwrapEffect(core.map(effect, addLogger)`

JSDoc:

@internal */
const addLogger = logger => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentLoggers, HashSet.add(logger)));
/** @internal

## addLoggerEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `addLoggerEffect(= addLoggerEffect;
const addLoggerScoped = effect => layer.unwrapScoped(core.map(effect, addLogger)`

JSDoc:

@internal

## addLoggerScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `addLoggerScoped(= addLoggerScoped;
const removeLogger = logger => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentLoggers, HashSet.remove(logger)`

JSDoc:

@internal

## removeLogger

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `removeLogger(= removeLogger;
const replaceLogger = exports.replaceLogger = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## addSupervisor

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `addSupervisor(= addSupervisor;
const enableCooperativeYielding = exports.enableCooperativeYielding = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.enable(runtimeFlags.CooperativeYielding)`

JSDoc:

@internal */
const replaceLoggerEffect = exports.replaceLoggerEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => layer.flatMap(removeLogger(self), () => addLoggerEffect(that)));
/** @internal */
const replaceLoggerScoped = exports.replaceLoggerScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => layer.flatMap(removeLogger(self), () => addLoggerScoped(that)));
/** @internal */
const addSupervisor = supervisor => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentSupervisor, current => new supervisor_.Zip(current, supervisor)));
/** @internal

## setConfigProvider

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `setConfigProvider(= setConfigProvider;
const parentSpan = span => layer.succeedContext(Context.make(tracer.spanTag, span)`

JSDoc:

@internal */
const enableInterruption = exports.enableInterruption = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.enable(runtimeFlags.Interruption)));
/** @internal */
const enableOpSupervision = exports.enableOpSupervision = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.enable(runtimeFlags.OpSupervision)));
/** @internal */
const enableRuntimeMetrics = exports.enableRuntimeMetrics = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.enable(runtimeFlags.RuntimeMetrics)));
/** @internal */
const enableWindDown = exports.enableWindDown = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.enable(runtimeFlags.WindDown)));
/** @internal */
const disableCooperativeYielding = exports.disableCooperativeYielding = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.disable(runtimeFlags.CooperativeYielding)));
/** @internal */
const disableInterruption = exports.disableInterruption = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.disable(runtimeFlags.Interruption)));
/** @internal */
const disableOpSupervision = exports.disableOpSupervision = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.disable(runtimeFlags.OpSupervision)));
/** @internal */
const disableRuntimeMetrics = exports.disableRuntimeMetrics = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.disable(runtimeFlags.RuntimeMetrics)));
/** @internal */
const disableWindDown = exports.disableWindDown = /*#__PURE__*/layer.scopedDiscard(/*#__PURE__*/fiberRuntime.withRuntimeFlagsScoped(/*#__PURE__*/runtimeFlagsPatch.disable(runtimeFlags.WindDown)));
/** @internal */
const setConfigProvider = configProvider => layer.scopedDiscard(fiberRuntime.withConfigProviderScoped(configProvider));
/** @internal

## parentSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `parentSpan(= parentSpan;
const span = (name, options)`

JSDoc:

@internal

## span

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer/circular.js`

Signature: `span(= span;
const setTracer = tracer => layer.scopedDiscard(fiberRuntime.withTracerScoped(tracer)`

JSDoc:

@internal

## isLayer

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `isLayer(= isLayer;
const isFresh = self => {
  return self._op_layer === OpCodes.OP_FRESH;
};
// -----------------------------------------------------------------------------
// MemoMap
// -----------------------------------------------------------------------------
/** @internal */
exports.isFresh = isFresh;
class MemoMapImpl {
  ref;
  [MemoMapTypeId];
  constructor(ref)`

JSDoc:

@internal */
const LayerSymbolKey = "effect/Layer";
/** @internal */
const LayerTypeId = exports.LayerTypeId = /*#__PURE__*/Symbol.for(LayerSymbolKey);
const layerVariance = {
  /* c8 ignore next */
  _RIn: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _ROut: _ => _
};
/** @internal */
const proto = exports.proto = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const MemoMapTypeIdKey = "effect/Layer/MemoMap";
/** @internal */
const MemoMapTypeId = exports.MemoMapTypeId = /*#__PURE__*/Symbol.for(MemoMapTypeIdKey);
/** @internal */
const CurrentMemoMap = exports.CurrentMemoMap = /*#__PURE__*/Context.Reference()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
/** @internal */
const isLayer = u => (0, _Predicate.hasProperty)(u, LayerTypeId);
/** @internal

## unsafeMakeMemoMap

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `unsafeMakeMemoMap(= unsafeMakeMemoMap;
const build = self => fiberRuntime.scopeWith(scope => buildWithScope(self, scope)`

JSDoc:

Checks the memo map to see if a layer exists. If it is, immediately
returns it. Otherwise, obtains the layer, stores it in the memo map,
and adds a finalizer to the `Scope`.
/
  getOrElseMemoize(layer, scope) {
    return (0, _Function.pipe)(synchronized.modifyEffect(this.ref, map => {
      const inMap = map.get(layer);
      if (inMap !== undefined) {
        const [acquire, release] = inMap;
        const cached = (0, _Function.pipe)(acquire, core.flatMap(([patch, b]) => (0, _Function.pipe)(effect.patchFiberRefs(patch), core.as(b))), core.onExit(core.exitMatch({
          onFailure: () => core.void,
          onSuccess: () => core.scopeAddFinalizerExit(scope, release)
        })));
        return core.succeed([cached, map]);
      }
      return (0, _Function.pipe)(ref.make(0), core.flatMap(observers => (0, _Function.pipe)(core.deferredMake(), core.flatMap(deferred => (0, _Function.pipe)(ref.make(() => core.void), core.map(finalizerRef => {
        const resource = core.uninterruptibleMask(restore => (0, _Function.pipe)(fiberRuntime.scopeMake(), core.flatMap(innerScope => (0, _Function.pipe)(restore(core.flatMap(makeBuilder(layer, innerScope, true), f => effect.diffFiberRefs(f(this)))), core.exit, core.flatMap(exit => {
          switch (exit._tag) {
            case EffectOpCodes.OP_FAILURE:
              {
                return (0, _Function.pipe)(core.deferredFailCause(deferred, exit.effect_instruction_i0), core.zipRight(core.scopeClose(innerScope, exit)), core.zipRight(core.failCause(exit.effect_instruction_i0)));
              }
            case EffectOpCodes.OP_SUCCESS:
              {
                return (0, _Function.pipe)(ref.set(finalizerRef, exit => (0, _Function.pipe)(core.scopeClose(innerScope, exit), core.whenEffect(ref.modify(observers, n => [n === 1, n - 1])), core.asVoid)), core.zipRight(ref.update(observers, n => n + 1)), core.zipRight(core.scopeAddFinalizerExit(scope, exit => (0, _Function.pipe)(core.sync(() => map.delete(layer)), core.zipRight(ref.get(finalizerRef)), core.flatMap(finalizer => finalizer(exit))))), core.zipRight(core.deferredSucceed(deferred, exit.effect_instruction_i0)), core.as(exit.effect_instruction_i0[1]));
              }
          }
        })))));
        const memoized = [(0, _Function.pipe)(core.deferredAwait(deferred), core.onExit(core.exitMatchEffect({
          onFailure: () => core.void,
          onSuccess: () => ref.update(observers, n => n + 1)
        }))), exit => (0, _Function.pipe)(ref.get(finalizerRef), core.flatMap(finalizer => finalizer(exit)))];
        return [resource, isFresh(layer) ? map : map.set(layer, memoized)];
      }))))));
    }), core.flatten);
  }
}
/** @internal */
const makeMemoMap = exports.makeMemoMap = /*#__PURE__*/core.suspend(() => core.map(circular.makeSynchronized(new Map()), ref => new MemoMapImpl(ref)));
/** @internal */
const unsafeMakeMemoMap = () => new MemoMapImpl(circular.unsafeMakeSynchronized(new Map()));
/** @internal

## build

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `build(= build;
const buildWithScope = exports.buildWithScope = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## die

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `die(= die;
const dieSync = evaluate => failCauseSync(()`

JSDoc:

@internal */
const buildWithMemoMap = exports.buildWithMemoMap = /*#__PURE__*/(0, _Function.dual)(3, (self, memoMap, scope) => core.flatMap(makeBuilder(self, scope), run => effect.provideService(run(memoMap), CurrentMemoMap, memoMap)));
const makeBuilder = (self, scope, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally":
      {
        return core.sync(() => memoMap => op.f(memoMap.getOrElseMemoize(op.self, scope)));
      }
    case "ExtendScope":
      {
        return core.sync(() => memoMap => fiberRuntime.scopeWith(scope => memoMap.getOrElseMemoize(op.layer, scope)));
      }
    case "Fold":
      {
        return core.sync(() => memoMap => (0, _Function.pipe)(memoMap.getOrElseMemoize(op.layer, scope), core.matchCauseEffect({
          onFailure: cause => memoMap.getOrElseMemoize(op.failureK(cause), scope),
          onSuccess: value => memoMap.getOrElseMemoize(op.successK(value), scope)
        })));
      }
    case "Fresh":
      {
        return core.sync(() => _ => (0, _Function.pipe)(op.layer, buildWithScope(scope)));
      }
    case "FromEffect":
      {
        return inMemoMap ? core.sync(() => _ => op.effect) : core.sync(() => memoMap => memoMap.getOrElseMemoize(self, scope));
      }
    case "Provide":
      {
        return core.sync(() => memoMap => (0, _Function.pipe)(memoMap.getOrElseMemoize(op.first, scope), core.flatMap(env => (0, _Function.pipe)(memoMap.getOrElseMemoize(op.second, scope), core.provideContext(env)))));
      }
    case "Scoped":
      {
        return inMemoMap ? core.sync(() => _ => fiberRuntime.scopeExtend(op.effect, scope)) : core.sync(() => memoMap => memoMap.getOrElseMemoize(self, scope));
      }
    case "Suspend":
      {
        return core.sync(() => memoMap => memoMap.getOrElseMemoize(op.evaluate(), scope));
      }
    case "ProvideMerge":
      {
        return core.sync(() => memoMap => (0, _Function.pipe)(memoMap.getOrElseMemoize(op.first, scope), core.zipWith(memoMap.getOrElseMemoize(op.second, scope), op.zipK)));
      }
    case "ZipWith":
      {
        return core.sync(() => memoMap => (0, _Function.pipe)(memoMap.getOrElseMemoize(op.first, scope), fiberRuntime.zipWithOptions(memoMap.getOrElseMemoize(op.second, scope), op.zipK, {
          concurrent: true
        })));
      }
  }
};
// -----------------------------------------------------------------------------
// Layer
// -----------------------------------------------------------------------------
/** @internal */
const catchAll = exports.catchAll = /*#__PURE__*/(0, _Function.dual)(2, (self, onFailure) => match(self, {
  onFailure,
  onSuccess: succeedContext
}));
/** @internal */
const catchAllCause = exports.catchAllCause = /*#__PURE__*/(0, _Function.dual)(2, (self, onFailure) => matchCause(self, {
  onFailure,
  onSuccess: succeedContext
}));
/** @internal */
const die = defect => failCause(Cause.die(defect));
/** @internal

## dieSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `dieSync(= dieSync;
const discard = self => map(self, ()`

JSDoc:

@internal

## discard

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `discard(= discard;
const context = ()`

JSDoc:

@internal

## context

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `context(= context;
const extendScope = self => {
  const extendScope = Object.create(proto)`

JSDoc:

@internal

## extendScope

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `extendScope(= extendScope;
const fail = error => failCause(Cause.fail(error)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `fail(= fail;
const failSync = evaluate => failCauseSync(()`

JSDoc:

@internal

## failSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `failSync(= failSync;
const failCause = cause => fromEffectContext(core.failCause(cause)`

JSDoc:

@internal

## failCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `failCause(= failCause;
const failCauseSync = evaluate => fromEffectContext(core.failCauseSync(evaluate)`

JSDoc:

@internal

## failCauseSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `failCauseSync(= failCauseSync;
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fresh

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `fresh(= fresh;
const fromEffect = exports.fromEffect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const flatten = exports.flatten = /*#__PURE__*/(0, _Function.dual)(2, (self, tag) => flatMap(self, Context.get(tag)));
/** @internal */
const fresh = self => {
  const fresh = Object.create(proto);
  fresh._op_layer = OpCodes.OP_FRESH;
  fresh.layer = self;
  return fresh;
};
/** @internal

## fromEffectDiscard

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `fromEffectDiscard(= fromEffectDiscard;
function fromEffectContext(effect)`

JSDoc:

@internal */
const fromEffectDiscard = effect => fromEffectContext(core.map(effect, () => Context.empty()));
/** @internal

## fiberRefLocallyScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `fiberRefLocallyScoped(= fiberRefLocallyScoped;
const fiberRefLocallyScopedWith = (self, value)`

JSDoc:

@internal */
const fiberRefLocally = exports.fiberRefLocally = /*#__PURE__*/(0, _Function.dual)(3, (self, ref, value) => locallyEffect(self, core.fiberRefLocally(ref, value)));
/** @internal */
const locallyEffect = exports.locallyEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const locally = Object.create(proto);
  locally._op_layer = "Locally";
  locally.self = self;
  locally.f = f;
  return locally;
});
/** @internal */
const fiberRefLocallyWith = exports.fiberRefLocallyWith = /*#__PURE__*/(0, _Function.dual)(3, (self, ref, value) => locallyEffect(self, core.fiberRefLocallyWith(ref, value)));
/** @internal */
const fiberRefLocallyScoped = (self, value) => scopedDiscard(fiberRuntime.fiberRefLocallyScoped(self, value));
/** @internal

## fiberRefLocallyScopedWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `fiberRefLocallyScopedWith(= fiberRefLocallyScopedWith;
const fromFunction = (tagA, tagB, f)`

JSDoc:

@internal

## fromFunction

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `fromFunction(= fromFunction;
const launch = self => fiberRuntime.scopedEffect(core.zipRight(fiberRuntime.scopeWith(scope => (0, _Function.pipe)`

JSDoc:

@internal

## launch

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `launch(= launch;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## memoize

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `memoize(= memoize;
const merge = exports.merge = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const mapError = exports.mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAll(self, error => failSync(() => f(error))));
/** @internal */
const matchCause = exports.matchCause = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => {
  const fold = Object.create(proto);
  fold._op_layer = OpCodes.OP_FOLD;
  fold.layer = self;
  fold.failureK = onFailure;
  fold.successK = onSuccess;
  return fold;
});
/** @internal */
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => matchCause(self, {
  onFailure: cause => {
    const failureOrCause = Cause.failureOrCause(cause);
    switch (failureOrCause._tag) {
      case "Left":
        {
          return onFailure(failureOrCause.left);
        }
      case "Right":
        {
          return failCause(failureOrCause.right);
        }
    }
  },
  onSuccess
}));
/** @internal */
const memoize = self => fiberRuntime.scopeWith(scope => core.map(effect.memoize(buildWithScope(self, scope)), fromEffectContext));
/** @internal

## mergeAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `mergeAll(= mergeAll;
const orDie = self => catchAll(self, defect => die(defect)`

JSDoc:

@internal */
const mergeAll = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge(final, layers[i]);
  }
  return final;
};
/** @internal

## orDie

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `orDie(= orDie;
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## passthrough

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `passthrough(= passthrough;
const project = exports.project = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const passthrough = self => merge(context(), self);
/** @internal

## scopedDiscard

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `scopedDiscard(= scopedDiscard;
const scopedContext = effect => {
  const scoped = Object.create(proto)`

JSDoc:

@internal */
const retry = exports.retry = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => suspend(() => {
  const stateTag = Context.GenericTag("effect/Layer/retry/{ state: unknown }");
  return (0, _Function.pipe)(succeed(stateTag, {
    state: schedule.initial
  }), flatMap(env => retryLoop(self, schedule, stateTag, (0, _Function.pipe)(env, Context.get(stateTag)).state)));
}));
const retryLoop = (self, schedule, stateTag, state) => {
  return (0, _Function.pipe)(self, catchAll(error => (0, _Function.pipe)(retryUpdate(schedule, stateTag, error, state), flatMap(env => fresh(retryLoop(self, schedule, stateTag, (0, _Function.pipe)(env, Context.get(stateTag)).state))))));
};
const retryUpdate = (schedule, stateTag, error, state) => {
  return fromEffect(stateTag, (0, _Function.pipe)(Clock.currentTimeMillis, core.flatMap(now => (0, _Function.pipe)(schedule.step(now, error, state), core.flatMap(([state, _, decision]) => ScheduleDecision.isDone(decision) ? core.fail(error) : (0, _Function.pipe)(Clock.sleep(Duration.millis(Intervals.start(decision.intervals) - now)), core.as({
    state
  })))))));
};
/** @internal */
const scoped = exports.scoped = /*#__PURE__*/(0, _Function.dual)(2, (a, b) => {
  const tagFirst = Context.isTag(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return scopedContext(core.map(effect, service => Context.make(tag, service)));
});
/** @internal */
const scopedDiscard = effect => scopedContext((0, _Function.pipe)(effect, core.as(Context.empty())));
/** @internal

## scopedContext

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `scopedContext(= scopedContext;
const scope = exports.scope = /*#__PURE__*/scopedContext(/*#__PURE__*/core.map(/*#__PURE__*/fiberRuntime.acquireRelease(/*#__PURE__*/fiberRuntime.scopeMake()`

JSDoc:

@internal

## service

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `service(= service;
const succeed = exports.succeed = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const service = tag => fromEffect(tag, tag);
/** @internal

## succeedContext

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `succeedContext(= succeedContext;
const empty = exports.empty = /*#__PURE__*/succeedContext(/*#__PURE__*/Context.empty()`

JSDoc:

@internal */
const succeedContext = context => {
  return fromEffectContext(core.succeed(context));
};
/** @internal

## suspend

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `suspend(= suspend;
const sync = exports.sync = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const suspend = evaluate => {
  const suspend = Object.create(proto);
  suspend._op_layer = OpCodes.OP_SUSPEND;
  suspend.evaluate = evaluate;
  return suspend;
};
/** @internal

## syncContext

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `syncContext(= syncContext;
const tap = exports.tap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const syncContext = evaluate => {
  return fromEffectContext(core.sync(evaluate));
};
/** @internal

## toRuntime

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `toRuntime(= toRuntime;
const toRuntimeWithMemoMap = exports.toRuntimeWithMemoMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const tapError = exports.tapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAll(self, e => fromEffectContext(core.flatMap(f(e), () => core.fail(e)))));
/** @internal */
const tapErrorCause = exports.tapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAllCause(self, cause => fromEffectContext(core.flatMap(f(cause), () => core.failCause(cause)))));
/** @internal */
const toRuntime = self => (0, _Function.pipe)(fiberRuntime.scopeWith(scope => buildWithScope(self, scope)), core.flatMap(context => (0, _Function.pipe)(runtime.runtime(), core.provideContext(context))));
/** @internal

## unwrapEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `unwrapEffect(= unwrapEffect;
const unwrapScoped = self => {
  const tag = Context.GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>")`

JSDoc:

@internal */
const provide = exports.provide = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => suspend(() => {
  const provideTo = Object.create(proto);
  provideTo._op_layer = OpCodes.OP_PROVIDE;
  provideTo.first = Object.create(proto, {
    _op_layer: {
      value: OpCodes.OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll(...that) : that
    },
    zipK: {
      value: (a, b) => (0, _Function.pipe)(a, Context.merge(b))
    }
  });
  provideTo.second = self;
  return provideTo;
}));
/** @internal */
const provideMerge = exports.provideMerge = /*#__PURE__*/(0, _Function.dual)(2, (that, self) => {
  const zipWith = Object.create(proto);
  zipWith._op_layer = OpCodes.OP_PROVIDE_MERGE;
  zipWith.first = self;
  zipWith.second = provide(that, self);
  zipWith.zipK = (a, b) => {
    return (0, _Function.pipe)(a, Context.merge(b));
  };
  return zipWith;
});
/** @internal */
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => suspend(() => {
  const zipWith = Object.create(proto);
  zipWith._op_layer = OpCodes.OP_ZIP_WITH;
  zipWith.first = self;
  zipWith.second = that;
  zipWith.zipK = f;
  return zipWith;
}));
/** @internal */
const unwrapEffect = self => {
  const tag = Context.GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap(fromEffect(tag, self), context => Context.get(context, tag));
};
/** @internal

## withSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/layer.js`

Signature: `withSpan(= withSpan;
const withParentSpan = exports.withParentSpan = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const withSpan = function () {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return unwrapScoped(core.map(options?.onEnd ? core.tap(fiberRuntime.makeSpanScoped(name, options), span => fiberRuntime.addFinalizer(exit => options.onEnd(span, exit))) : fiberRuntime.makeSpanScoped(name, options), span => withParentSpan(self, span)));
  }
  return self => unwrapScoped(core.map(options?.onEnd ? core.tap(fiberRuntime.makeSpanScoped(name, options), span => fiberRuntime.addFinalizer(exit => options.onEnd(span, exit))) : fiberRuntime.makeSpanScoped(name, options), span => withParentSpan(self, span)));
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/logSpan.js`

Signature: `make(= make;
const formatLabel = key => key.replace(/[\s="]/g, "_")`

JSDoc:

@internal */
const make = (label, startTime) => ({
  label,
  startTime
});
/**
Sanitize a given string by replacing spaces, equal signs, and double quotes with underscores.

@internal

## formatLabel

Source: `my-backend/node_modules/effect/dist/cjs/internal/logSpan.js`

Signature: `formatLabel(= formatLabel;
const render = now => self => {
  const label = formatLabel(self.label)`

JSDoc:

@internal

## makeLogger

Source: `my-backend/node_modules/effect/dist/cjs/internal/logger.js`

Signature: `makeLogger(= makeLogger;
const mapInput = exports.mapInput = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const LoggerSymbolKey = "effect/Logger";
/** @internal */
const LoggerTypeId = exports.LoggerTypeId = /*#__PURE__*/Symbol.for(LoggerSymbolKey);
const loggerVariance = {
  /* c8 ignore next */
  _Message: _ => _,
  /* c8 ignore next */
  _Output: _ => _
};
/** @internal */
const makeLogger = log => ({
  [LoggerTypeId]: loggerVariance,
  log,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
});
/** @internal

## simple

Source: `my-backend/node_modules/effect/dist/cjs/internal/logger.js`

Signature: `simple(= simple;
const succeed = value => {
  return simple(()`

JSDoc:

@internal */
const mapInputOptions = exports.mapInputOptions = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeLogger(options => self.log(f(options))));
/** @internal */
const filterLogLevel = exports.filterLogLevel = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeLogger(options => f(options.logLevel) ? Option.some(self.log(options)) : Option.none()));
/** @internal */
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeLogger(options => f(self.log(options))));
/** @internal */
const none = exports.none = {
  [LoggerTypeId]: loggerVariance,
  log: _Function.constVoid,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
/** @internal */
const simple = log => ({
  [LoggerTypeId]: loggerVariance,
  log: ({
    message
  }) => log(message),
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
});
/** @internal

## succeed

Source: `my-backend/node_modules/effect/dist/cjs/internal/logger.js`

Signature: `succeed(= succeed;
const sync = evaluate => {
  return simple(evaluate)`

JSDoc:

@internal

## sync

Source: `my-backend/node_modules/effect/dist/cjs/internal/logger.js`

Signature: `sync(= sync;
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## structuredMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/logger.js`

Signature: `structuredMessage(= structuredMessage;
const jsonLogger = exports.jsonLogger = /*#__PURE__*/map(structuredLogger, Inspectable.stringifyCircular)`

JSDoc:

@internal */
const zipLeft = exports.zipLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => map(zip(self, that), tuple => tuple[0]));
/** @internal */
const zipRight = exports.zipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => map(zip(self, that), tuple => tuple[1]));
/**
Match strings that do not contain any whitespace characters, double quotes,
or equal signs.

@internal
/
const textOnly = /^[^\s"=]*$/;
/**
Used by both {@link stringLogger} and {@link logfmtLogger} to render a log
message.

@internal
/
const format = (quoteValue, whitespace) => ({
  annotations,
  cause,
  date,
  fiberId,
  logLevel,
  message,
  spans
}) => {
  const formatValue = value => value.match(textOnly) ? value : quoteValue(value);
  const format = (label, value) => `${logSpan_.formatLabel(label)}=${formatValue(value)}`;
  const append = (label, value) => " " + format(label, value);
  let out = format("timestamp", date.toISOString());
  out += append("level", logLevel.label);
  out += append("fiber", fiberId_.threadName(fiberId));
  const messages = Arr.ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append("message", Inspectable.toStringUnknown(messages[i], whitespace));
  }
  if (!Cause.isEmptyType(cause)) {
    out += append("cause", Cause.pretty(cause, {
      renderErrorCause: true
    }));
  }
  for (const span of spans) {
    out += " " + logSpan_.render(date.getTime())(span);
  }
  for (const [label, value] of annotations) {
    out += append(label, Inspectable.toStringUnknown(value, whitespace));
  }
  return out;
};
/** @internal */
const escapeDoubleQuotes = s => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
/** @internal */
const stringLogger = exports.stringLogger = /*#__PURE__*/makeLogger(/*#__PURE__*/format(escapeDoubleQuotes));
/** @internal */
const logfmtLogger = exports.logfmtLogger = /*#__PURE__*/makeLogger(/*#__PURE__*/format(JSON.stringify, 0));
/** @internal */
const structuredLogger = exports.structuredLogger = /*#__PURE__*/makeLogger(({
  annotations,
  cause,
  date,
  fiberId,
  logLevel,
  message,
  spans
}) => {
  const now = date.getTime();
  const annotationsObj = {};
  const spansObj = {};
  if (HashMap.size(annotations) > 0) {
    for (const [k, v] of annotations) {
      annotationsObj[k] = structuredMessage(v);
    }
  }
  if (List.isCons(spans)) {
    for (const span of spans) {
      spansObj[span.label] = now - span.startTime;
    }
  }
  const messageArr = Arr.ensure(message);
  return {
    message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
    logLevel: logLevel.label,
    timestamp: date.toISOString(),
    cause: Cause.isEmpty(cause) ? undefined : Cause.pretty(cause, {
      renderErrorCause: true
    }),
    annotations: annotationsObj,
    spans: spansObj,
    fiberId: fiberId_.threadName(fiberId)
  };
});
/** @internal */
const structuredMessage = u => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol":
      {
        return String(u);
      }
    default:
      {
        return Inspectable.toJSON(u);
      }
  }
};
/** @internal

## isMailbox

Source: `my-backend/node_modules/effect/dist/cjs/internal/mailbox.js`

Signature: `isMailbox(= isMailbox;
const isReadonlyMailbox = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/Mailbox");
/** @internal */
const ReadonlyTypeId = exports.ReadonlyTypeId = /*#__PURE__*/Symbol.for("effect/Mailbox/ReadonlyMailbox");
/** @internal */
const isMailbox = u => (0, _Predicate.hasProperty)(u, TypeId);
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/mailbox.js`

Signature: `make(= make;
const into = exports.into = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const make = capacity => core.withFiberRuntime(fiber => core.succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity === "number" ? capacity : capacity?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity === "number" ? "suspend" : capacity?.strategy ?? "suspend")));
/** @internal

## toChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/mailbox.js`

Signature: `toChannel(= toChannel;
const toStream = self => stream.fromChannel(toChannel(self)`

JSDoc:

@internal */
const toChannel = self => {
  const loop = coreChannel.flatMap(self.takeAll, ([messages, done]) => done ? messages.length === 0 ? coreChannel.void : coreChannel.write(messages) : channel.zipRight(coreChannel.write(messages), loop));
  return loop;
};
/** @internal

## toStream

Source: `my-backend/node_modules/effect/dist/cjs/internal/mailbox.js`

Signature: `toStream(= toStream;
const fromStream = exports.fromStream = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## type

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `type(= type;
const value = i => makeValueMatcher(i, Either.left(i)`

JSDoc:

@internal */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/matcher/Matcher");
const TypeMatcherProto = {
  [TypeId]: {
    _input: _Function.identity,
    _filters: _Function.identity,
    _remaining: _Function.identity,
    _result: _Function.identity,
    _return: _Function.identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
const ValueMatcherProto = {
  [TypeId]: {
    _input: _Function.identity,
    _filters: _Function.identity,
    _remaining: _Function.identity,
    _result: _Function.identity,
    _provided: _Function.identity,
    _return: _Function.identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, Either.right(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, Either.right(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
function makeValueMatcher(provided, value) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value;
  return matcher;
}
const makeWhen = (guard, evaluate) => ({
  _tag: "When",
  guard,
  evaluate
});
const makeNot = (guard, evaluate) => ({
  _tag: "Not",
  guard,
  evaluate
});
const makePredicate = pattern => {
  if (typeof pattern === "function") {
    return pattern;
  } else if (Array.isArray(pattern)) {
    const predicates = pattern.map(makePredicate);
    const len = predicates.length;
    return u => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern !== null && typeof pattern === "object") {
    const keysAndPredicates = Object.entries(pattern).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return u => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return u => u === pattern;
};
const makeOrPredicate = patterns => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
};
const makeAndPredicate = patterns => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return u => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
};
/** @internal */
const type = () => makeTypeMatcher([]);
/** @internal

## value

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `value(= value;
const valueTags = exports.valueTags = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## typeTags

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `typeTags(= typeTags;
const withReturnType = ()`

JSDoc:

@internal */
const typeTags = () => fields => {
  const match = tagsExhaustive(fields)(makeTypeMatcher([]));
  return input => match(input);
};
/** @internal

## withReturnType

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `withReturnType(= withReturnType;
const when = (pattern, f)`

JSDoc:

@internal

## when

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `when(= when;
const whenOr = (...args)`

JSDoc:

@internal

## whenOr

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `whenOr(= whenOr;
const whenAnd = (...args)`

JSDoc:

@internal

## whenAnd

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `whenAnd(= whenAnd;
const discriminator = field => (...pattern)`

JSDoc:

@internal

## discriminator

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `discriminator(= discriminator;
const discriminatorStartsWith = field => (pattern, f)`

JSDoc:

@internal

## discriminatorStartsWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `discriminatorStartsWith(= discriminatorStartsWith;
const discriminators = field => fields => {
  const predicate = makeWhen(arg => arg != null && arg[field] in fields, data => fields[data[field]](data)`

JSDoc:

@internal

## discriminators

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `discriminators(= discriminators;
const discriminatorsExhaustive = field => fields => {
  const addCases = discriminators(field)`

JSDoc:

@internal

## discriminatorsExhaustive

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `discriminatorsExhaustive(= discriminatorsExhaustive;
const tag = exports.tag = /*#__PURE__*/discriminator("_tag")`

JSDoc:

@internal

## not

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `not(= not;
const nonEmptyString = u => typeof u === "string" && u.length > 0;
/** @internal */
exports.nonEmptyString = nonEmptyString;
const is = (...literals)`

JSDoc:

@internal */
const tagStartsWith = exports.tagStartsWith = /*#__PURE__*/discriminatorStartsWith("_tag");
/** @internal */
const tags = exports.tags = /*#__PURE__*/discriminators("_tag");
/** @internal */
const tagsExhaustive = exports.tagsExhaustive = /*#__PURE__*/discriminatorsExhaustive("_tag");
/** @internal */
const not = (pattern, f) => self => self.add(makeNot(makePredicate(pattern), f));
/** @internal

## is

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `is(= is;
const any = ()`

JSDoc:

@internal

## any

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `any(= any;
const defined = u => u !== undefined && u !== null;
/** @internal */
exports.defined = defined;
const instanceOf = constructor => u => u instanceof constructor;
/** @internal */
exports.instanceOf = instanceOf;
const instanceOfUnsafe = exports.instanceOfUnsafe = instanceOf;
/** @internal */
const orElse = f => self => {
  const result = either(self)`

JSDoc:

@internal

## orElse

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `orElse(= orElse;
const orElseAbsurd = self => orElse(()`

JSDoc:

@internal

## orElseAbsurd

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `orElseAbsurd(= orElseAbsurd;
const either = self => {
  if (self._tag === "ValueMatcher")`

JSDoc:

@internal

## either

Source: `my-backend/node_modules/effect/dist/cjs/internal/matcher.js`

Signature: `either(= either;
const option = self => {
  const toEither = either(self)`

JSDoc:

@internal

## isMetricBoundaries

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/boundaries.js`

Signature: `isMetricBoundaries(= isMetricBoundaries;
const fromIterable = iterable => {
  const values = (0, _Function.pipe)`

JSDoc:

@internal */
const MetricBoundariesSymbolKey = "effect/MetricBoundaries";
/** @internal */
const MetricBoundariesTypeId = exports.MetricBoundariesTypeId = /*#__PURE__*/Symbol.for(MetricBoundariesSymbolKey);
/** @internal */
class MetricBoundariesImpl {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values) {
    this.values = values;
    this._hash = (0, _Function.pipe)(Hash.string(MetricBoundariesSymbolKey), Hash.combine(Hash.array(this.values)));
  }
  _hash;
  [Hash.symbol]() {
    return this._hash;
  }
  [Equal.symbol](u) {
    return isMetricBoundaries(u) && Equal.equals(this.values, u.values);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
const isMetricBoundaries = u => (0, _Predicate.hasProperty)(u, MetricBoundariesTypeId);
/** @internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/boundaries.js`

Signature: `fromIterable(= fromIterable;
const linear = options => (0, _Function.pipe)`

JSDoc:

@internal

## linear

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/boundaries.js`

Signature: `linear(= linear;
const exponential = options => (0, _Function.pipe)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/hook.js`

Signature: `make(= make;
const onModify = exports.onModify = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const MetricHookSymbolKey = "effect/MetricHook";
/** @internal */
const MetricHookTypeId = exports.MetricHookTypeId = /*#__PURE__*/Symbol.for(MetricHookSymbolKey);
const metricHookVariance = {
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
const make = options => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  ...options
});
/** @internal

## counter

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/hook.js`

Signature: `counter(= counter;
const frequency = key => {
  const values = new Map()`

JSDoc:

@internal */
const onUpdate = exports.onUpdate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  get: self.get,
  update: input => {
    self.update(input);
    return f(input);
  },
  modify: self.modify
}));
const bigint0 = /*#__PURE__*/BigInt(0);
/** @internal */
const counter = key => {
  let sum = key.keyType.bigint ? bigint0 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? value => value >= bigint0 : value => value >= 0 : _value => true;
  const update = value => {
    if (canUpdate(value)) {
      sum = sum + value;
    }
  };
  return make({
    get: () => metricState.counter(sum),
    update,
    modify: update
  });
};
/** @internal

## frequency

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/hook.js`

Signature: `frequency(= frequency;
const gauge = (_key, startAt)`

JSDoc:

@internal

## gauge

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/hook.js`

Signature: `gauge(= gauge;
const histogram = key => {
  const bounds = key.keyType.boundaries.values;
  const size = bounds.length;
  const values = new Uint32Array(size + 1)`

JSDoc:

@internal

## histogram

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/hook.js`

Signature: `histogram(= histogram;
const summary = key => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = (0, _Function.pipe)`

JSDoc:

@internal

## summary

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/hook.js`

Signature: `summary(= summary;
const calculateQuantiles = (error, sortedQuantiles, sortedSamples)`

JSDoc:

@internal

## isMetricKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/key.js`

Signature: `isMetricKey(= isMetricKey;
const counter = (name, options)`

JSDoc:

@internal */
const MetricKeySymbolKey = "effect/MetricKey";
/** @internal */
const MetricKeyTypeId = exports.MetricKeyTypeId = /*#__PURE__*/Symbol.for(MetricKeySymbolKey);
const metricKeyVariance = {
  /* c8 ignore next */
  _Type: _ => _
};
const arrayEquivilence = /*#__PURE__*/Arr.getEquivalence(Equal.equals);
/** @internal */
class MetricKeyImpl {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = (0, _Function.pipe)(Hash.string(this.name + this.description), Hash.combine(Hash.hash(this.keyType)), Hash.combine(Hash.array(this.tags)));
  }
  _hash;
  [Hash.symbol]() {
    return this._hash;
  }
  [Equal.symbol](u) {
    return isMetricKey(u) && this.name === u.name && Equal.equals(this.keyType, u.keyType) && Equal.equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
const isMetricKey = u => (0, _Predicate.hasProperty)(u, MetricKeyTypeId);
/** @internal

## counter

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/key.js`

Signature: `counter(= counter;
const frequency = (name, options)`

JSDoc:

@internal

## frequency

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/key.js`

Signature: `frequency(= frequency;
const gauge = (name, options)`

JSDoc:

@internal

## gauge

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/key.js`

Signature: `gauge(= gauge;
const histogram = (name, boundaries, description)`

JSDoc:

@internal

## histogram

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/key.js`

Signature: `histogram(= histogram;
const summary = options => new MetricKeyImpl(options.name, metricKeyType.summary(options)`

JSDoc:

@internal

## summary

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/key.js`

Signature: `summary(= summary;
const tagged = exports.tagged = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## HistogramKeyType

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `HistogramKeyType(= HistogramKeyType;
class SummaryKeyType {
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
  constructor(maxAge, maxSize, error, quantiles)`

JSDoc:

@internal */
const MetricKeyTypeSymbolKey = "effect/MetricKeyType";
/** @internal */
const MetricKeyTypeTypeId = exports.MetricKeyTypeTypeId = /*#__PURE__*/Symbol.for(MetricKeyTypeSymbolKey);
/** @internal */
const CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
/** @internal */
const CounterKeyTypeTypeId = exports.CounterKeyTypeTypeId = /*#__PURE__*/Symbol.for(CounterKeyTypeSymbolKey);
/** @internal */
const FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
/** @internal */
const FrequencyKeyTypeTypeId = exports.FrequencyKeyTypeTypeId = /*#__PURE__*/Symbol.for(FrequencyKeyTypeSymbolKey);
/** @internal */
const GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
/** @internal */
const GaugeKeyTypeTypeId = exports.GaugeKeyTypeTypeId = /*#__PURE__*/Symbol.for(GaugeKeyTypeSymbolKey);
/** @internal */
const HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
/** @internal */
const HistogramKeyTypeTypeId = exports.HistogramKeyTypeTypeId = /*#__PURE__*/Symbol.for(HistogramKeyTypeSymbolKey);
/** @internal */
const SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
/** @internal */
const SummaryKeyTypeTypeId = exports.SummaryKeyTypeTypeId = /*#__PURE__*/Symbol.for(SummaryKeyTypeSymbolKey);
const metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
class CounterKeyType {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = Hash.string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [Hash.symbol]() {
    return this._hash;
  }
  [Equal.symbol](that) {
    return isCounterKey(that);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
const FrequencyKeyTypeHash = /*#__PURE__*/Hash.string(FrequencyKeyTypeSymbolKey);
/** @internal */
class FrequencyKeyType {
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [Hash.symbol]() {
    return FrequencyKeyTypeHash;
  }
  [Equal.symbol](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
const GaugeKeyTypeHash = /*#__PURE__*/Hash.string(GaugeKeyTypeSymbolKey);
/** @internal */
class GaugeKeyType {
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint) {
    this.bigint = bigint;
  }
  [Hash.symbol]() {
    return GaugeKeyTypeHash;
  }
  [Equal.symbol](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
class HistogramKeyType {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = (0, _Function.pipe)(Hash.string(HistogramKeyTypeSymbolKey), Hash.combine(Hash.hash(this.boundaries)));
  }
  _hash;
  [Hash.symbol]() {
    return this._hash;
  }
  [Equal.symbol](that) {
    return isHistogramKey(that) && Equal.equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## counter

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `counter(= counter;
const frequency = options => new FrequencyKeyType(options?.preregisteredWords ?? [])`

JSDoc:

@internal */
const counter = options => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
/** @internal

## frequency

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `frequency(= frequency;
const gauge = options => new GaugeKeyType(options?.bigint ?? false)`

JSDoc:

@internal

## gauge

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `gauge(= gauge;
const histogram = boundaries => {
  return new HistogramKeyType(boundaries)`

JSDoc:

@internal

## histogram

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `histogram(= histogram;
const summary = options => {
  return new SummaryKeyType(Duration.decode(options.maxAge)`

JSDoc:

@internal

## summary

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `summary(= summary;
const isMetricKeyType = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isMetricKeyType

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `isMetricKeyType(= isMetricKeyType;
const isCounterKey = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isCounterKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `isCounterKey(= isCounterKey;
const isFrequencyKey = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isFrequencyKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `isFrequencyKey(= isFrequencyKey;
const isGaugeKey = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isGaugeKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `isGaugeKey(= isGaugeKey;
const isHistogramKey = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isHistogramKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/keyType.js`

Signature: `isHistogramKey(= isHistogramKey;
const isSummaryKey = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/label.js`

Signature: `make(= make;
const isMetricLabel = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const MetricLabelSymbolKey = "effect/MetricLabel";
/** @internal */
const MetricLabelTypeId = exports.MetricLabelTypeId = /*#__PURE__*/Symbol.for(MetricLabelSymbolKey);
/** @internal */
class MetricLabelImpl {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = Hash.string(MetricLabelSymbolKey + this.key + this.value);
  }
  [Hash.symbol]() {
    return this._hash;
  }
  [Equal.symbol](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
const make = (key, value) => {
  return new MetricLabelImpl(key, value);
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/pair.js`

Signature: `make(= make;
const unsafeMake = (metricKey, metricState)`

JSDoc:

@internal */
const MetricPairSymbolKey = "effect/MetricPair";
/** @internal */
const MetricPairTypeId = exports.MetricPairTypeId = /*#__PURE__*/Symbol.for(MetricPairSymbolKey);
const metricPairVariance = {
  /* c8 ignore next */
  _Type: _ => _
};
/** @internal */
const make = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return (0, _Pipeable.pipeArguments)(this, arguments);
    }
  };
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/polling.js`

Signature: `make(= make;
const collectAll = iterable => {
  const metrics = Array.from(iterable)`

JSDoc:

@internal */
const MetricPollingSymbolKey = "effect/MetricPolling";
/** @internal */
const MetricPollingTypeId = exports.MetricPollingTypeId = /*#__PURE__*/Symbol.for(MetricPollingSymbolKey);
/** @internal */
const make = (metric, poll) => {
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return (0, _Pipeable.pipeArguments)(this, arguments);
    },
    metric,
    poll
  };
};
/** @internal

## collectAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/polling.js`

Signature: `collectAll(= collectAll;
const launch = exports.launch = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## poll

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/polling.js`

Signature: `poll(= poll;
const pollAndUpdate = self => core.flatMap(self.poll, value => metric.update(self.metric, value)`

JSDoc:

@internal */
const poll = self => self.poll;
/** @internal

## pollAndUpdate

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/polling.js`

Signature: `pollAndUpdate(= pollAndUpdate;
const retry = exports.retry = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## HistogramState

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `HistogramState(= HistogramState;
class SummaryState {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min, max, sum)`

JSDoc:

@internal */
const MetricStateSymbolKey = "effect/MetricState";
/** @internal */
const MetricStateTypeId = exports.MetricStateTypeId = /*#__PURE__*/Symbol.for(MetricStateSymbolKey);
/** @internal */
const CounterStateSymbolKey = "effect/MetricState/Counter";
/** @internal */
const CounterStateTypeId = exports.CounterStateTypeId = /*#__PURE__*/Symbol.for(CounterStateSymbolKey);
/** @internal */
const FrequencyStateSymbolKey = "effect/MetricState/Frequency";
/** @internal */
const FrequencyStateTypeId = exports.FrequencyStateTypeId = /*#__PURE__*/Symbol.for(FrequencyStateSymbolKey);
/** @internal */
const GaugeStateSymbolKey = "effect/MetricState/Gauge";
/** @internal */
const GaugeStateTypeId = exports.GaugeStateTypeId = /*#__PURE__*/Symbol.for(GaugeStateSymbolKey);
/** @internal */
const HistogramStateSymbolKey = "effect/MetricState/Histogram";
/** @internal */
const HistogramStateTypeId = exports.HistogramStateTypeId = /*#__PURE__*/Symbol.for(HistogramStateSymbolKey);
/** @internal */
const SummaryStateSymbolKey = "effect/MetricState/Summary";
/** @internal */
const SummaryStateTypeId = exports.SummaryStateTypeId = /*#__PURE__*/Symbol.for(SummaryStateSymbolKey);
const metricStateVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class CounterState {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(CounterStateSymbolKey), Hash.combine(Hash.hash(this.count)), Hash.cached(this));
  }
  [Equal.symbol](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
const arrayEquals = /*#__PURE__*/Arr.getEquivalence(Equal.equals);
/** @internal */
class FrequencyState {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.string(FrequencyStateSymbolKey), Hash.combine(Hash.array(Arr.fromIterable(this.occurrences.entries()))), Hash.cached(this));
  }
  [Equal.symbol](that) {
    return isFrequencyState(that) && arrayEquals(Arr.fromIterable(this.occurrences.entries()), Arr.fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
class GaugeState {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(GaugeStateSymbolKey), Hash.combine(Hash.hash(this.value)), Hash.cached(this));
  }
  [Equal.symbol](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
class HistogramState {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min, max, sum) {
    this.buckets = buckets;
    this.count = count;
    this.min = min;
    this.max = max;
    this.sum = sum;
  }
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(HistogramStateSymbolKey), Hash.combine(Hash.hash(this.buckets)), Hash.combine(Hash.hash(this.count)), Hash.combine(Hash.hash(this.min)), Hash.combine(Hash.hash(this.max)), Hash.combine(Hash.hash(this.sum)), Hash.cached(this));
  }
  [Equal.symbol](that) {
    return isHistogramState(that) && Equal.equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## SummaryState

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `SummaryState(= SummaryState;
const counter = count => new CounterState(count)`

JSDoc:

@internal

## counter

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `counter(= counter;
const frequency = occurrences => {
  return new FrequencyState(occurrences)`

JSDoc:

@internal

## frequency

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `frequency(= frequency;
const gauge = count => new GaugeState(count)`

JSDoc:

@internal

## gauge

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `gauge(= gauge;
const histogram = options => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum)`

JSDoc:

@internal

## histogram

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `histogram(= histogram;
const summary = options => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum)`

JSDoc:

@internal

## summary

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `summary(= summary;
const isMetricState = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isMetricState

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `isMetricState(= isMetricState;
const isCounterState = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isCounterState

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `isCounterState(= isCounterState;
const isFrequencyState = u => (0, _Predicate.hasProperty)`

JSDoc:

@since 2.0.0
@category refinements

## isFrequencyState

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `isFrequencyState(= isFrequencyState;
const isGaugeState = u => (0, _Predicate.hasProperty)`

JSDoc:

@since 2.0.0
@category refinements

## isGaugeState

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `isGaugeState(= isGaugeState;
const isHistogramState = u => (0, _Predicate.hasProperty)`

JSDoc:

@since 2.0.0
@category refinements

## isHistogramState

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric/state.js`

Signature: `isHistogramState(= isHistogramState;
const isSummaryState = u => (0, _Predicate.hasProperty)`

JSDoc:

@since 2.0.0
@category refinements

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `make(= make;
const mapInput = exports.mapInput = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const MetricSymbolKey = "effect/Metric";
/** @internal */
const MetricTypeId = exports.MetricTypeId = /*#__PURE__*/Symbol.for(MetricSymbolKey);
const metricVariance = {
  /* c8 ignore next */
  _Type: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
const globalMetricRegistry = exports.globalMetricRegistry = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/Metric/globalMetricRegistry"), () => metricRegistry.make());
/** @internal */
const make = function (keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign(effect => core.tap(effect, a => update(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return (0, _Pipeable.pipeArguments)(this, arguments);
    }
  });
  return metric;
};
/** @internal

## counter

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `counter(= counter;
const frequency = (name, options)`

JSDoc:

@internal */
const counter = (name, options) => fromMetricKey(metricKey.counter(name, options));
/** @internal

## frequency

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `frequency(= frequency;
const withConstantInput = exports.withConstantInput = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fromMetricKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `fromMetricKey(= fromMetricKey;
const gauge = (name, options)`

JSDoc:

@internal */
const fromMetricKey = key => {
  let untaggedHook;
  const hookCache = new WeakMap();
  const hook = extraTags => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook = hookCache.get(extraTags);
    if (hook !== undefined) {
      return hook;
    }
    hook = globalMetricRegistry.get(metricKey.taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook);
    return hook;
  };
  return make(key.keyType, (input, extraTags) => hook(extraTags).update(input), extraTags => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
/** @internal

## gauge

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `gauge(= gauge;
const histogram = (name, boundaries, description)`

JSDoc:

@internal

## succeed

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `succeed(= succeed;
const sync = evaluate => make(void 0, _Function.constVoid, evaluate, _Function.constVoid)`

JSDoc:

@internal */
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => make(self.keyType, self.unsafeUpdate, extraTags => f(self.unsafeValue(extraTags)), self.unsafeModify));
/** @internal */
const mapType = exports.mapType = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => make(f(self.keyType), self.unsafeUpdate, self.unsafeValue, self.unsafeModify));
/** @internal */
const modify = exports.modify = /*#__PURE__*/(0, _Function.dual)(2, (self, input) => core.fiberRefGetWith(core.currentMetricLabels, tags => core.sync(() => self.unsafeModify(input, tags))));
/* @internal */
const set = exports.set = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => update(self, value));
/** @internal */
const succeed = out => make(void 0, _Function.constVoid, () => out, _Function.constVoid);
/** @internal

## sync

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `sync(= sync;
const summary = options => withNow(summaryTimestamp(options)`

JSDoc:

@internal

## summary

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `summary(= summary;
const summaryTimestamp = options => fromMetricKey(metricKey.summary(options)`

JSDoc:

@internal

## summaryTimestamp

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `summaryTimestamp(= summaryTimestamp;
const tagged = exports.tagged = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## timer

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `timer(= timer;
const timerWithBoundaries = (name, boundaries, description)`

JSDoc:

@internal */
const taggedWithLabelsInput = exports.taggedWithLabelsInput = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => map(make(self.keyType, (input, extraTags) => self.unsafeUpdate(input, Arr.union(f(input), extraTags)), self.unsafeValue, (input, extraTags) => self.unsafeModify(input, Arr.union(f(input), extraTags))), _Function.constVoid));
/** @internal */
const taggedWithLabels = exports.taggedWithLabels = /*#__PURE__*/(0, _Function.dual)(2, (self, extraTags) => {
  return make(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, Arr.union(extraTags, extraTags1)), extraTags1 => self.unsafeValue(Arr.union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, Arr.union(extraTags, extraTags1)));
});
/** @internal */
const timer = (name, description) => {
  const boundaries = metricBoundaries.exponential({
    start: 0.5,
    factor: 2,
    count: 35
  });
  const base = (0, _Function.pipe)(histogram(name, boundaries, description), tagged("time_unit", "milliseconds"));
  return mapInput(base, Duration.toMillis);
};
/** @internal

## value

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `value(= value;
const withNow = self => mapInput(self, input => [input, Date.now()`

JSDoc:

@internal

## withNow

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `withNow(= withNow;
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## unsafeSnapshot

Source: `my-backend/node_modules/effect/dist/cjs/internal/metric.js`

Signature: `unsafeSnapshot(= unsafeSnapshot;
const snapshot = exports.snapshot = /*#__PURE__*/core.sync(unsafeSnapshot)`

JSDoc:

@internal */
const unsafeSnapshot = () => globalMetricRegistry.snapshot();
/** @internal

## isOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/option.js`

Signature: `isOption(= isOption;
const isNone = fa => fa._tag === "None";
/** @internal */
exports.isNone = isNone;
const isSome = fa => fa._tag === "Some";
/** @internal */
exports.isSome = isSome;
const none = exports.none = /*#__PURE__*/Object.create(NoneProto)`

JSDoc:

@since 2.0.0
/

const TypeId = /*#__PURE__*/Symbol.for("effect/Option");
const CommonProto = {
  ..._effectable.EffectPrototype,
  [TypeId]: {
    _A: _ => _
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  }
};
const SomeProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [Equal.symbol](that) {
    return isOption(that) && isSome(that) && Equal.equals(this.value, that.value);
  },
  [Hash.symbol]() {
    return Hash.cached(this, Hash.combine(Hash.hash(this._tag))(Hash.hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: (0, _Inspectable.toJSON)(this.value)
    };
  }
});
const NoneHash = /*#__PURE__*/Hash.hash("None");
const NoneProto = /*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [Equal.symbol](that) {
    return isOption(that) && isNone(that);
  },
  [Hash.symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
/** @internal */
const isOption = input => (0, _Predicate.hasProperty)(input, TypeId);
/** @internal

## isPool

Source: `my-backend/node_modules/effect/dist/cjs/internal/pool.js`

Signature: `isPool(= isPool;
const makeWith = options => core.uninterruptibleMask(restore => core.flatMap(core.context()`

JSDoc:

@internal */
const PoolTypeId = exports.PoolTypeId = /*#__PURE__*/Symbol.for("effect/Pool");
const poolVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const isPool = u => (0, _Predicate.hasProperty)(u, PoolTypeId);
/** @internal

## makeWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/pool.js`

Signature: `makeWith(= makeWith;
const make = options => makeWith({
  ...options,
  min: options.size,
  max: options.size,
  strategy: strategyNoop()`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/pool.js`

Signature: `make(= make;
const makeWithTTL = options => core.flatMap(options.timeToLiveStrategy === "creation" ? strategyCreationTTL(options.timeToLive)`

JSDoc:

@internal

## makeWithTTL

Source: `my-backend/node_modules/effect/dist/cjs/internal/pool.js`

Signature: `makeWithTTL(= makeWithTTL;
const get = self => self.get;
/** @internal */
exports.get = get;
const invalidate = exports.invalidate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## bounded

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `bounded(= bounded;
const dropping = capacity => core.suspend(()`

JSDoc:

@internal */
const bounded = capacity => core.suspend(() => {
  const pubsub = makeBoundedPubSub(capacity);
  return makePubSub(pubsub, new BackPressureStrategy());
});
/** @internal

## dropping

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `dropping(= dropping;
const sliding = capacity => core.suspend(()`

JSDoc:

@internal

## sliding

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `sliding(= sliding;
const unbounded = options => core.suspend(()`

JSDoc:

@internal

## unbounded

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `unbounded(= unbounded;
const capacity = self => self.capacity()`

JSDoc:

@internal

## capacity

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `capacity(= capacity;
const size = self => self.size;
/** @internal */
exports.size = size;
const isFull = self => self.isFull;
/** @internal */
exports.isFull = isFull;
const isEmpty = self => self.isEmpty;
/** @internal */
exports.isEmpty = isEmpty;
const shutdown = self => self.shutdown;
/** @internal */
exports.shutdown = shutdown;
const isShutdown = self => self.isShutdown;
/** @internal */
exports.isShutdown = isShutdown;
const awaitShutdown = self => self.awaitShutdown;
/** @internal */
exports.awaitShutdown = awaitShutdown;
const publish = exports.publish = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## subscribe

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `subscribe(= subscribe;
const makeBoundedPubSub = capacity => {
  const options = typeof capacity === "number" ? {
    capacity
  } : capacity;
  ensureCapacity(options.capacity)`

JSDoc:

@internal */
const publishAll = exports.publishAll = /*#__PURE__*/(0, _Function.dual)(2, (self, elements) => self.publishAll(elements));
/** @internal */
const subscribe = self => self.subscribe;
/** @internal

## unsafeMakeSubscription

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `unsafeMakeSubscription(= unsafeMakeSubscription;
class BoundedPubSubArb {
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity, replayBuffer)`

JSDoc:

@internal */
const makeUnboundedPubSub = options => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : undefined);
/** @internal */
const makeSubscription = (pubsub, subscribers, strategy) => core.map(core.deferredMake(), deferred => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), MutableQueue.unbounded(), deferred, MutableRef.make(false), strategy));
/** @internal */
const unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());
/** @internal

## makePubSub

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `makePubSub(= makePubSub;
const unsafeMakePubSub = (pubsub, subscribers, scope, shutdownHook, shutdownFlag, strategy)`

JSDoc:

@internal */
class BoundedPubSubPow2 {
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity, replayBuffer) {
    this.capacity = capacity;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity
    });
    this.mask = capacity - 1;
    this.subscribers = Array.from({
      length: capacity
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return Chunk.empty();
    }
    const chunk = Chunk.fromIterable(elements);
    const n = chunk.length;
    const size = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = Chunk.unsafeGet(chunk, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return Chunk.drop(chunk, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
}
/** @internal */
class BoundedPubSubPow2Subscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return Chunk.empty();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size);
    if (toPoll <= 0) {
      return Chunk.empty();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return Chunk.fromIterable(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
}
/** @internal */
class BoundedPubSubSingle {
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return Chunk.empty();
    }
    const chunk = Chunk.fromIterable(elements);
    if (Chunk.isEmpty(chunk)) {
      return chunk;
    }
    if (this.publish(Chunk.unsafeHead(chunk))) {
      return Chunk.drop(chunk, 1);
    } else {
      return chunk;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
}
/** @internal */
class BoundedPubSubSingleSubscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return Chunk.empty();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return Chunk.of(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
}
/** @internal */
class UnboundedPubSub {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return Chunk.empty();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
}
/** @internal */
class UnboundedPubSubSubscription {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty = true;
    let loop = true;
    while (loop) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty = false;
          loop = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop = true;
    let polled = default_;
    while (loop) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return Chunk.fromIterable(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
}
/** @internal */
class SubscriptionImpl extends Effectable.Class {
  pubsub;
  subscribers;
  subscription;
  pollers;
  shutdownHook;
  shutdownFlag;
  strategy;
  replayWindow;
  [queue.DequeueTypeId] = queue.dequeueVariance;
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !MutableRef.get(this.shutdownFlag);
  }
  get size() {
    return core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt : core.succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (MutableRef.get(this.shutdownFlag)) {
      return Option.none();
    }
    return Option.some(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt : core.succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return core.map(this.size, size => size === 0);
  }
  get shutdown() {
    return core.uninterruptible(core.withFiberRuntime(state => {
      MutableRef.set(this.shutdownFlag, true);
      return (0, _Function.pipe)(fiberRuntime.forEachParUnbounded(unsafePollAllQueue(this.pollers), d => core.deferredInterruptWith(d, state.id()), false), core.zipRight(core.sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), core.whenEffect(core.deferredSucceed(this.shutdownHook, void 0)), core.asVoid);
    }));
  }
  get isShutdown() {
    return core.sync(() => MutableRef.get(this.shutdownFlag));
  }
  get awaitShutdown() {
    return core.deferredAwait(this.shutdownHook);
  }
  get take() {
    return core.withFiberRuntime(state => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      if (this.replayWindow.remaining > 0) {
        const message = this.replayWindow.take();
        return core.succeed(message);
      }
      const message = MutableQueue.isEmpty(this.pollers) ? this.subscription.poll(MutableQueue.EmptyMutableQueue) : MutableQueue.EmptyMutableQueue;
      if (message === MutableQueue.EmptyMutableQueue) {
        const deferred = core.deferredUnsafeMake(state.id());
        return (0, _Function.pipe)(core.suspend(() => {
          (0, _Function.pipe)(this.pollers, MutableQueue.offer(deferred));
          (0, _Function.pipe)(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return MutableRef.get(this.shutdownFlag) ? core.interrupt : core.deferredAwait(deferred);
        }), core.onInterrupt(() => core.sync(() => unsafeRemove(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return core.succeed(message);
      }
    });
  }
  get takeAll() {
    return core.suspend(() => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      const as = MutableQueue.isEmpty(this.pollers) ? unsafePollAllSubscription(this.subscription) : Chunk.empty();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return core.succeed(Chunk.appendAll(this.replayWindow.takeAll(), as));
      }
      return core.succeed(as);
    });
  }
  takeUpTo(max) {
    return core.suspend(() => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      let replay = undefined;
      if (this.replayWindow.remaining >= max) {
        const as = this.replayWindow.takeN(max);
        return core.succeed(as);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max = max - replay.length;
      }
      const as = MutableQueue.isEmpty(this.pollers) ? unsafePollN(this.subscription, max) : Chunk.empty();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? core.succeed(Chunk.appendAll(replay, as)) : core.succeed(as);
    });
  }
  takeBetween(min, max) {
    return core.suspend(() => takeRemainderLoop(this, min, max, Chunk.empty()));
  }
}
/** @internal */
const takeRemainderLoop = (self, min, max, acc) => {
  if (max < min) {
    return core.succeed(acc);
  }
  return (0, _Function.pipe)(self.takeUpTo(max), core.flatMap(bs => {
    const remaining = min - bs.length;
    if (remaining === 1) {
      return (0, _Function.pipe)(self.take, core.map(b => (0, _Function.pipe)(acc, Chunk.appendAll(bs), Chunk.append(b))));
    }
    if (remaining > 1) {
      return (0, _Function.pipe)(self.take, core.flatMap(b => takeRemainderLoop(self, remaining - 1, max - bs.length - 1, (0, _Function.pipe)(acc, Chunk.appendAll(bs), Chunk.append(b)))));
    }
    return core.succeed((0, _Function.pipe)(acc, Chunk.appendAll(bs)));
  }));
};
/** @internal */
class PubSubImpl {
  pubsub;
  subscribers;
  scope;
  shutdownHook;
  shutdownFlag;
  strategy;
  [queue.EnqueueTypeId] = queue.enqueueVariance;
  [queue.DequeueTypeId] = queue.dequeueVariance;
  constructor(pubsub, subscribers, scope, shutdownHook, shutdownFlag, strategy) {
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt : core.sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (MutableRef.get(this.shutdownFlag)) {
      return Option.none();
    }
    return Option.some(this.pubsub.size());
  }
  get isFull() {
    return core.map(this.size, size => size === this.capacity());
  }
  get isEmpty() {
    return core.map(this.size, size => size === 0);
  }
  get awaitShutdown() {
    return core.deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return core.sync(() => MutableRef.get(this.shutdownFlag));
  }
  get shutdown() {
    return core.uninterruptible(core.withFiberRuntime(state => {
      (0, _Function.pipe)(this.shutdownFlag, MutableRef.set(true));
      return (0, _Function.pipe)(this.scope.close(core.exitInterrupt(state.id())), core.zipRight(this.strategy.shutdown), core.whenEffect(core.deferredSucceed(this.shutdownHook, void 0)), core.asVoid);
    }));
  }
  publish(value) {
    return core.suspend(() => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      if (this.pubsub.publish(value)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return core.succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, Chunk.of(value), this.shutdownFlag);
    });
  }
  isActive() {
    return !MutableRef.get(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (MutableRef.get(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return core.suspend(() => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (Chunk.isEmpty(surplus)) {
        return core.succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire = core.tap(fiberRuntime.all([this.scope.fork(executionStrategy.sequential), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), tuple => tuple[0].addFinalizer(() => tuple[1].shutdown));
    return core.map(fiberRuntime.acquireRelease(acquire, (tuple, exit) => tuple[0].close(exit)), tuple => tuple[1]);
  }
  offer(value) {
    return this.publish(value);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
const makePubSub = (pubsub, strategy) => core.flatMap(fiberRuntime.scopeMake(), scope => core.map(core.deferredMake(), deferred => unsafeMakePubSub(pubsub, new Map(), scope, deferred, MutableRef.make(false), strategy)));
/** @internal

## unsafeMakePubSub

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `unsafeMakePubSub(= unsafeMakePubSub;
const ensureCapacity = capacity => {
  if (capacity <= 0)`

JSDoc:

@internal

## DroppingStrategy

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `DroppingStrategy(= DroppingStrategy;
class SlidingStrategy {
  get shutdown()`

JSDoc:

@internal */
const unsafeCompleteDeferred = (deferred, a) => {
  core.deferredUnsafeDone(deferred, core.succeed(a));
};
/** @internal */
const unsafeOfferAll = (queue, as) => {
  return (0, _Function.pipe)(queue, MutableQueue.offerAll(as));
};
/** @internal */
const unsafePollAllQueue = queue => {
  return (0, _Function.pipe)(queue, MutableQueue.pollUpTo(Number.POSITIVE_INFINITY));
};
/** @internal */
const unsafePollAllSubscription = subscription => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
/** @internal */
const unsafePollN = (subscription, max) => {
  return subscription.pollUpTo(max);
};
/** @internal */
const unsafePublishAll = (pubsub, as) => {
  return pubsub.publishAll(as);
};
/** @internal */
const unsafeRemove = (queue, value) => {
  unsafeOfferAll(queue, (0, _Function.pipe)(unsafePollAllQueue(queue), Chunk.filter(elem => elem !== value)));
};
/**
A strategy that applies back pressure to publishers when the `PubSub` is at
capacity. This guarantees that all subscribers will receive all messages
published to the `PubSub` while they are subscribed. However, it creates the
risk that a slow subscriber will slow down the rate at which messages
are published and received by other subscribers.

@internal
/
class BackPressureStrategy {
  publishers = /*#__PURE__*/MutableQueue.unbounded();
  get shutdown() {
    return core.flatMap(core.fiberId, fiberId => core.flatMap(core.sync(() => unsafePollAllQueue(this.publishers)), publishers => fiberRuntime.forEachConcurrentDiscard(publishers, ([_, deferred, last]) => last ? (0, _Function.pipe)(core.deferredInterruptWith(deferred, fiberId), core.asVoid) : core.void, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown) {
    return core.withFiberRuntime(state => {
      const deferred = core.deferredUnsafeMake(state.id());
      return (0, _Function.pipe)(core.suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return MutableRef.get(isShutdown) ? core.interrupt : core.deferredAwait(deferred);
      }), core.onInterrupt(() => core.sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = (0, _Function.pipe)(this.publishers, MutableQueue.poll(MutableQueue.EmptyMutableQueue));
      if (publisher === MutableQueue.EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll(this.publishers, (0, _Function.pipe)(unsafePollAllQueue(this.publishers), Chunk.prepend(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next = iterator.next();
    if (!next.done) {
      // eslint-disable-next-line no-constant-condition
      while (1) {
        const value = next.value;
        next = iterator.next();
        if (next.done) {
          (0, _Function.pipe)(this.publishers, MutableQueue.offer([value, deferred, true]));
          break;
        }
        (0, _Function.pipe)(this.publishers, MutableQueue.offer([value, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.publishers, (0, _Function.pipe)(unsafePollAllQueue(this.publishers), Chunk.filter(([_, a]) => a !== deferred)));
  }
}
/**
A strategy that drops new messages when the `PubSub` is at capacity. This
guarantees that a slow subscriber will not slow down the rate at which
messages are published. However, it creates the risk that a slow
subscriber will slow down the rate at which messages are received by
other subscribers and that subscribers may not receive all messages
published to the `PubSub` while they are subscribed.

@internal
/
class DroppingStrategy {
  get shutdown() {
    return core.void;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return core.succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
    //
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
}
/**
A strategy that adds new messages and drops old messages when the `PubSub` is
at capacity. This guarantees that a slow subscriber will not slow down
the rate at which messages are published and received by other
subscribers. However, it creates the risk that a slow subscriber will
not receive some messages published to the `PubSub` while it is subscribed.

@internal

## SlidingStrategy

Source: `my-backend/node_modules/effect/dist/cjs/internal/pubsub.js`

Signature: `SlidingStrategy(= SlidingStrategy;
const unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers)`

JSDoc:

@internal

## fromRequest

Source: `my-backend/node_modules/effect/dist/cjs/internal/query.js`

Signature: `fromRequest(= fromRequest;
const cacheRequest = (request, result)`

JSDoc:

@internal */
const currentCache = exports.currentCache = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentCache"), () => core.fiberRefUnsafeMake((0, _cache.unsafeMakeWith)(65536, () => core.map(core.deferredMake(), handle => ({
  listeners: new _request.Listeners(),
  handle
})), () => (0, _Duration.seconds)(60))));
/** @internal */
const currentCacheEnabled = exports.currentCacheEnabled = /*#__PURE__*/(0, _GlobalValue.globalValue)(/*#__PURE__*/Symbol.for("effect/FiberRef/currentCacheEnabled"), () => core.fiberRefUnsafeMake(false));
/** @internal */
const fromRequest = (request, dataSource) => core.flatMap(core.isEffect(dataSource) ? dataSource : core.succeed(dataSource), ds => core.fiberIdWith(id => {
  const proxy = new Proxy(request, {});
  return core.fiberRefGetWith(currentCacheEnabled, cacheEnabled => {
    if (cacheEnabled) {
      const cached = core.fiberRefGetWith(currentCache, cache => core.flatMap(cache.getEither(proxy), orNew => {
        switch (orNew._tag) {
          case "Left":
            {
              if (orNew.left.listeners.interrupted) {
                return core.flatMap(cache.invalidateWhen(proxy, entry => entry.handle === orNew.left.handle), () => cached);
              }
              orNew.left.listeners.increment();
              return core.uninterruptibleMask(restore => core.flatMap(core.exit(core.blocked(BlockedRequests.empty, restore(core.deferredAwait(orNew.left.handle)))), exit => {
                orNew.left.listeners.decrement();
                return exit;
              }));
            }
          case "Right":
            {
              orNew.right.listeners.increment();
              return core.uninterruptibleMask(restore => core.flatMap(core.exit(core.blocked(BlockedRequests.single(ds, BlockedRequests.makeEntry({
                request: proxy,
                result: orNew.right.handle,
                listeners: orNew.right.listeners,
                ownerId: id,
                state: {
                  completed: false
                }
              })), restore(core.deferredAwait(orNew.right.handle)))), () => {
                orNew.right.listeners.decrement();
                return core.deferredAwait(orNew.right.handle);
              }));
            }
        }
      }));
      return cached;
    }
    const listeners = new _request.Listeners();
    listeners.increment();
    return core.flatMap(core.deferredMake(), ref => (0, _fiberRuntime.ensuring)(core.blocked(BlockedRequests.single(ds, BlockedRequests.makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id,
      state: {
        completed: false
      }
    })), core.deferredAwait(ref)), core.sync(() => listeners.decrement())));
  });
}));
/** @internal

## cacheRequest

Source: `my-backend/node_modules/effect/dist/cjs/internal/query.js`

Signature: `cacheRequest(= cacheRequest;
const withRequestCaching = exports.withRequestCaching = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## isQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `isQueue(= isQueue;
const isEnqueue = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const EnqueueSymbolKey = "effect/QueueEnqueue";
/** @internal */
const EnqueueTypeId = exports.EnqueueTypeId = /*#__PURE__*/Symbol.for(EnqueueSymbolKey);
/** @internal */
const DequeueSymbolKey = "effect/QueueDequeue";
/** @internal */
const DequeueTypeId = exports.DequeueTypeId = /*#__PURE__*/Symbol.for(DequeueSymbolKey);
/** @internal */
const QueueStrategySymbolKey = "effect/QueueStrategy";
/** @internal */
const QueueStrategyTypeId = exports.QueueStrategyTypeId = /*#__PURE__*/Symbol.for(QueueStrategySymbolKey);
/** @internal */
const BackingQueueSymbolKey = "effect/BackingQueue";
/** @internal */
const BackingQueueTypeId = exports.BackingQueueTypeId = /*#__PURE__*/Symbol.for(BackingQueueSymbolKey);
const queueStrategyVariance = {
  /* c8 ignore next */
  _A: _ => _
};
const backingQueueVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const enqueueVariance = exports.enqueueVariance = {
  /* c8 ignore next */
  _In: _ => _
};
/** @internal */
const dequeueVariance = exports.dequeueVariance = {
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
class QueueImpl extends Effectable.Class {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(/** @internal */
  queue, /** @internal */
  takers, /** @internal */
  shutdownHook, /** @internal */
  shutdownFlag, /** @internal */
  strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return core.suspend(() => core.catchAll(this.unsafeSize(), () => core.interrupt));
  }
  unsafeSize() {
    if (MutableRef.get(this.shutdownFlag)) {
      return Option.none();
    }
    return Option.some(this.queue.length() - MutableQueue.length(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return core.map(this.size, size => size <= 0);
  }
  get isFull() {
    return core.map(this.size, size => size >= this.capacity());
  }
  get shutdown() {
    return core.uninterruptible(core.withFiberRuntime(state => {
      (0, _Function.pipe)(this.shutdownFlag, MutableRef.set(true));
      return (0, _Function.pipe)(fiberRuntime.forEachConcurrentDiscard(unsafePollAll(this.takers), d => core.deferredInterruptWith(d, state.id()), false, false), core.zipRight(this.strategy.shutdown), core.whenEffect(core.deferredSucceed(this.shutdownHook, void 0)), core.asVoid);
    }));
  }
  get isShutdown() {
    return core.sync(() => MutableRef.get(this.shutdownFlag));
  }
  get awaitShutdown() {
    return core.deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !MutableRef.get(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (MutableRef.get(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = (0, _Function.pipe)(this.takers, MutableQueue.poll(MutableQueue.EmptyMutableQueue));
      if (taker !== MutableQueue.EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    // Not enough takers, offer to the queue
    const succeeded = this.queue.offer(value);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value) {
    return core.suspend(() => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = (0, _Function.pipe)(this.takers, MutableQueue.poll(MutableQueue.EmptyMutableQueue));
        if (taker !== MutableQueue.EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return core.succeed(true);
      }
      // Not enough takers, offer to the queue
      const succeeded = this.queue.offer(value);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? core.succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return core.suspend(() => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      const values = Arr.fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? Arr.fromIterable(unsafePollN(this.takers, values.length)) : Arr.empty;
      const [forTakers, remaining] = (0, _Function.pipe)(values, Arr.splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return core.succeed(true);
      }
      // Not enough takers, offer to the queue
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return Chunk.isEmpty(surplus) ? core.succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return core.withFiberRuntime(state => {
      if (MutableRef.get(this.shutdownFlag)) {
        return core.interrupt;
      }
      const item = this.queue.poll(MutableQueue.EmptyMutableQueue);
      if (item !== MutableQueue.EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return core.succeed(item);
      } else {
        // Add the deferred to takers, then:
        // - Try to take again in case a value was added since
        // - Wait for the deferred to be completed
        // - Clean up resources in case of interruption
        const deferred = core.deferredUnsafeMake(state.id());
        return (0, _Function.pipe)(core.suspend(() => {
          (0, _Function.pipe)(this.takers, MutableQueue.offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return MutableRef.get(this.shutdownFlag) ? core.interrupt : core.deferredAwait(deferred);
        }), core.onInterrupt(() => {
          return core.sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return core.suspend(() => {
      return MutableRef.get(this.shutdownFlag) ? core.interrupt : core.sync(() => {
        const values = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return Chunk.fromIterable(values);
      });
    });
  }
  takeUpTo(max) {
    return core.suspend(() => MutableRef.get(this.shutdownFlag) ? core.interrupt : core.sync(() => {
      const values = this.queue.pollUpTo(max);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return Chunk.fromIterable(values);
    }));
  }
  takeBetween(min, max) {
    return core.suspend(() => takeRemainderLoop(this, min, max, Chunk.empty()));
  }
}
/** @internal */
const takeRemainderLoop = (self, min, max, acc) => {
  if (max < min) {
    return core.succeed(acc);
  }
  return (0, _Function.pipe)(takeUpTo(self, max), core.flatMap(bs => {
    const remaining = min - bs.length;
    if (remaining === 1) {
      return (0, _Function.pipe)(take(self), core.map(b => (0, _Function.pipe)(acc, Chunk.appendAll(bs), Chunk.append(b))));
    }
    if (remaining > 1) {
      return (0, _Function.pipe)(take(self), core.flatMap(b => takeRemainderLoop(self, remaining - 1, max - bs.length - 1, (0, _Function.pipe)(acc, Chunk.appendAll(bs), Chunk.append(b)))));
    }
    return core.succeed((0, _Function.pipe)(acc, Chunk.appendAll(bs)));
  }));
};
/** @internal */
const isQueue = u => isEnqueue(u) && isDequeue(u);
/** @internal

## isEnqueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `isEnqueue(= isEnqueue;
const isDequeue = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isDequeue

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `isDequeue(= isDequeue;
const bounded = requestedCapacity => (0, _Function.pipe)`

JSDoc:

@internal

## bounded

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `bounded(= bounded;
const dropping = requestedCapacity => (0, _Function.pipe)`

JSDoc:

@internal

## dropping

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `dropping(= dropping;
const sliding = requestedCapacity => (0, _Function.pipe)`

JSDoc:

@internal

## sliding

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `sliding(= sliding;
const unbounded = ()`

JSDoc:

@internal

## unbounded

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `unbounded(= unbounded;
const unsafeMake = (queue, takers, shutdownHook, shutdownFlag, strategy)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `make(= make;
class BackingQueueFromMutableQueue {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable)`

JSDoc:

@internal */
const make = (queue, strategy) => (0, _Function.pipe)(core.deferredMake(), core.map(deferred => unsafeMake(queue, MutableQueue.unbounded(), deferred, MutableRef.make(false), strategy)));
/** @internal

## BackingQueueFromMutableQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `BackingQueueFromMutableQueue(= BackingQueueFromMutableQueue;
const backingQueueFromMutableQueue = mutable => new BackingQueueFromMutableQueue(mutable)`

JSDoc:

@internal

## backingQueueFromMutableQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `backingQueueFromMutableQueue(= backingQueueFromMutableQueue;
const capacity = self => self.capacity()`

JSDoc:

@internal

## capacity

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `capacity(= capacity;
const size = self => self.size;
/** @internal */
exports.size = size;
const isFull = self => self.isFull;
/** @internal */
exports.isFull = isFull;
const isEmpty = self => self.isEmpty;
/** @internal */
exports.isEmpty = isEmpty;
const isShutdown = self => self.isShutdown;
/** @internal */
exports.isShutdown = isShutdown;
const awaitShutdown = self => self.awaitShutdown;
/** @internal */
exports.awaitShutdown = awaitShutdown;
const shutdown = self => self.shutdown;
/** @internal */
exports.shutdown = shutdown;
const offer = exports.offer = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## poll

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `poll(= poll;
const take = self => self.take;
/** @internal */
exports.take = take;
const takeAll = self => self.takeAll;
/** @internal */
exports.takeAll = takeAll;
const takeUpTo = exports.takeUpTo = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const unsafeOffer = exports.unsafeOffer = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => self.unsafeOffer(value));
/** @internal */
const offerAll = exports.offerAll = /*#__PURE__*/(0, _Function.dual)(2, (self, iterable) => self.offerAll(iterable));
/** @internal */
const poll = self => core.map(self.takeUpTo(1), Chunk.head);
/** @internal

## backPressureStrategy

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `backPressureStrategy(= backPressureStrategy;
const droppingStrategy = ()`

JSDoc:

@internal */
const takeBetween = exports.takeBetween = /*#__PURE__*/(0, _Function.dual)(3, (self, min, max) => self.takeBetween(min, max));
/** @internal */
const takeN = exports.takeN = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => self.takeBetween(n, n));
// -----------------------------------------------------------------------------
// Strategy
// -----------------------------------------------------------------------------
/** @internal */
const backPressureStrategy = () => new BackPressureStrategy();
/** @internal

## droppingStrategy

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `droppingStrategy(= droppingStrategy;
const slidingStrategy = ()`

JSDoc:

@internal

## slidingStrategy

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `slidingStrategy(= slidingStrategy;
class BackPressureStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /*#__PURE__*/MutableQueue.unbounded()`

JSDoc:

@internal

## unsafeRemove

Source: `my-backend/node_modules/effect/dist/cjs/internal/queue.js`

Signature: `unsafeRemove(= unsafeRemove;
const unsafeCompleteTakers = (strategy, queue, takers)`

JSDoc:

@internal */
class DroppingStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return core.void;
  }
  onCompleteTakersWithEmptyQueue() {}
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return core.succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
    //
  }
}
/** @internal */
class SlidingStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return core.void;
  }
  onCompleteTakersWithEmptyQueue() {}
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return core.sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
    //
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next;
    let offering = true;
    while (!(next = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      // Poll 1 and retry
      queue.poll(MutableQueue.EmptyMutableQueue);
      offering = queue.offer(next.value);
    }
  }
}
/** @internal */
const unsafeCompleteDeferred = (deferred, a) => {
  return core.deferredUnsafeDone(deferred, core.succeed(a));
};
/** @internal */
const unsafeOfferAll = (queue, as) => {
  return (0, _Function.pipe)(queue, MutableQueue.offerAll(as));
};
/** @internal */
const unsafePollAll = queue => {
  return (0, _Function.pipe)(queue, MutableQueue.pollUpTo(Number.POSITIVE_INFINITY));
};
/** @internal */
const unsafePollN = (queue, max) => {
  return (0, _Function.pipe)(queue, MutableQueue.pollUpTo(max));
};
/** @internal */
const unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, (0, _Function.pipe)(unsafePollAll(queue), Chunk.filter(b => a !== b)));
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/rcMap.js`

Signature: `make(= make;
const get = exports.get = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/RcMap");
const variance = {
  _K: _Function.identity,
  _A: _Function.identity,
  _E: _Function.identity
};
class RcMapImpl {
  lookup;
  context;
  scope;
  idleTimeToLive;
  capacity;
  [TypeId];
  state = {
    _tag: "Open",
    map: /*#__PURE__*/MutableHashMap.empty()
  };
  semaphore = /*#__PURE__*/circular.unsafeMakeSemaphore(1);
  constructor(lookup, context, scope, idleTimeToLive, capacity) {
    this.lookup = lookup;
    this.context = context;
    this.scope = scope;
    this.idleTimeToLive = idleTimeToLive;
    this.capacity = capacity;
    this[TypeId] = variance;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
const make = options => core.withFiberRuntime(fiber => {
  const context = fiber.getFiberRef(core.currentContext);
  const scope = Context.get(context, fiberRuntime.scopeTag);
  const self = new RcMapImpl(options.lookup, context, scope, options.idleTimeToLive ? Duration.decode(options.idleTimeToLive) : undefined, Math.max(options.capacity ?? Number.POSITIVE_INFINITY, 0));
  return core.as(scope.addFinalizer(() => core.suspend(() => {
    if (self.state._tag === "Closed") {
      return core.void;
    }
    const map = self.state.map;
    self.state = {
      _tag: "Closed"
    };
    return core.forEachSequentialDiscard(map, ([, entry]) => core.scopeClose(entry.scope, core.exitVoid)).pipe(core.tap(() => {
      MutableHashMap.clear(map);
    }), self.semaphore.withPermits(1));
  })), self);
});
/** @internal

## keys

Source: `my-backend/node_modules/effect/dist/cjs/internal/rcMap.js`

Signature: `keys(= keys;
const invalidate = exports.invalidate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const keys = self => {
  const impl = self;
  return core.suspend(() => impl.state._tag === "Closed" ? core.interrupt : core.succeed(MutableHashMap.keys(impl.state.map)));
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/rcRef.js`

Signature: `make(= make;
const get = self_ => {
  const self = self_;
  return core.uninterruptibleMask(restore => core.suspend(()`

JSDoc:

@internal */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("effect/RcRef");
const stateEmpty = {
  _tag: "Empty"
};
const stateClosed = {
  _tag: "Closed"
};
const variance = {
  _A: _Function.identity,
  _E: _Function.identity
};
class RcRefImpl extends Effectable.Class {
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId] = variance;
  [Readable.TypeId] = Readable.TypeId;
  state = stateEmpty;
  semaphore = /*#__PURE__*/circular.unsafeMakeSemaphore(1);
  constructor(acquire, context, scope, idleTimeToLive) {
    super();
    this.acquire = acquire;
    this.context = context;
    this.scope = scope;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get(this);
  }
  get;
  commit() {
    return this.get;
  }
}
/** @internal */
const make = options => core.withFiberRuntime(fiber => {
  const context = fiber.getFiberRef(core.currentContext);
  const scope = Context.get(context, fiberRuntime.scopeTag);
  const ref = new RcRefImpl(options.acquire, context, scope, options.idleTimeToLive ? Duration.decode(options.idleTimeToLive) : undefined);
  return core.as(scope.addFinalizer(() => ref.semaphore.withPermits(1)(core.suspend(() => {
    const close = ref.state._tag === "Acquired" ? core.scopeClose(ref.state.scope, core.exitVoid) : core.void;
    ref.state = stateClosed;
    return close;
  }))), ref);
});
/** @internal

## clone

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree/node.js`

Signature: `clone(= clone;
function swap(n, v)`

JSDoc:

@internal */
const Color = exports.Color = {
  Red: 0,
  Black: 1 << 0
};
/** @internal */
const clone = ({
  color,
  count,
  key,
  left,
  right,
  value
}) => ({
  color,
  key,
  value,
  left,
  right,
  count
});
/** @internal

## repaint

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree/node.js`

Signature: `repaint(= repaint;
const recount = node => {
  node.count = 1 + (node.left?.count ?? 0)`

JSDoc:

@internal */
const repaint = ({
  count,
  key,
  left,
  right,
  value
}, color) => ({
  color,
  key,
  value,
  left,
  right,
  count
});
/** @internal

## isRedBlackTree

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `isRedBlackTree(= isRedBlackTree;
const empty = ord => makeImpl(ord, undefined)`

JSDoc:

@internal */
const RedBlackTreeTypeId = exports.RedBlackTreeTypeId = /*#__PURE__*/Symbol.for(RedBlackTreeSymbolKey);
const redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: _ => _,
  /* c8 ignore next */
  _Value: _ => _
};
const RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [Hash.symbol]() {
    let hash = Hash.hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash ^= (0, _Function.pipe)(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])));
    }
    return Hash.cached(this, hash);
  },
  [Equal.symbol](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries[i];
        return Equal.equals(itemSelf[0], itemThat[0]) && Equal.equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new _iterator.RedBlackTreeIterator(this, stack, _iterator.Direction.Forward);
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const makeImpl = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
/** @internal */
const isRedBlackTree = u => (0, _Predicate.hasProperty)(u, RedBlackTreeTypeId);
/** @internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `empty(= empty;
const fromIterable = exports.fromIterable = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `make(= make;
const atBackwards = exports.atBackwards = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const make = ord => (...entries) => {
  return fromIterable(entries, ord);
};
/** @internal

## first

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `first(= first;
const getAt = exports.getAt = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const atForwards = exports.atForwards = /*#__PURE__*/(0, _Function.dual)(2, (self, index) => at(self, index, _iterator.Direction.Forward));
const at = (self, index, direction) => {
  return {
    [Symbol.iterator]: () => {
      if (index < 0) {
        return new _iterator.RedBlackTreeIterator(self, [], direction);
      }
      let node = self._root;
      const stack = [];
      while (node !== undefined) {
        stack.push(node);
        if (node.left !== undefined) {
          if (index < node.left.count) {
            node = node.left;
            continue;
          }
          index -= node.left.count;
        }
        if (!index) {
          return new _iterator.RedBlackTreeIterator(self, stack, direction);
        }
        index -= 1;
        if (node.right !== undefined) {
          if (index >= node.right.count) {
            break;
          }
          node = node.right;
        } else {
          break;
        }
      }
      return new _iterator.RedBlackTreeIterator(self, [], direction);
    }
  };
};
/** @internal */
const findAll = exports.findAll = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => {
  const stack = [];
  let node = self._root;
  let result = Chunk.empty();
  while (node !== undefined || stack.length > 0) {
    if (node) {
      stack.push(node);
      node = node.left;
    } else {
      const current = stack.pop();
      if (Equal.equals(key, current.key)) {
        result = Chunk.prepend(current.value)(result);
      }
      node = current.right;
    }
  }
  return result;
});
/** @internal */
const findFirst = exports.findFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== undefined) {
    const d = cmp(key, node.key);
    if (Equal.equals(key, node.key)) {
      return Option.some(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return Option.none();
});
/** @internal */
const first = self => {
  let node = self._root;
  let current = self._root;
  while (node !== undefined) {
    current = node;
    node = node.left;
  }
  return current ? Option.some([current.key, current.value]) : Option.none();
};
/** @internal

## getOrder

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `getOrder(= getOrder;
const has = exports.has = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const getOrder = tree => tree._ord;
/** @internal

## keysForward

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `keysForward(= keysForward;
const keysBackward = self => keys(self, _iterator.Direction.Backward)`

JSDoc:

@internal */
const insert = exports.insert = /*#__PURE__*/(0, _Function.dual)(3, (self, key, value) => {
  const cmp = self._ord;
  // Find point to insert new node at
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  // Rebuild path to leaf node
  n_stack.push({
    color: Node.Color.Red,
    key,
    value,
    left: undefined,
    right: undefined,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  // Rebalance tree using rotations
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Node.Color.Black || n3.color === Node.Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Node.Color.Red) {
          p.color = Node.Color.Black;
          pp.right = Node.repaint(y, Node.Color.Black);
          pp.color = Node.Color.Red;
          s -= 1;
        } else {
          pp.color = Node.Color.Red;
          pp.left = p.right;
          p.color = Node.Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          Node.recount(pp);
          Node.recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Node.Color.Red) {
          p.color = Node.Color.Black;
          pp.right = Node.repaint(y, Node.Color.Black);
          pp.color = Node.Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Node.Color.Red;
          pp.left = n3.right;
          n3.color = Node.Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          Node.recount(pp);
          Node.recount(p);
          Node.recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Node.Color.Red) {
          p.color = Node.Color.Black;
          pp.left = Node.repaint(y, Node.Color.Black);
          pp.color = Node.Color.Red;
          s -= 1;
        } else {
          pp.color = Node.Color.Red;
          pp.right = p.left;
          p.color = Node.Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          Node.recount(pp);
          Node.recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Node.Color.Red) {
          p.color = Node.Color.Black;
          pp.left = Node.repaint(y, Node.Color.Black);
          pp.color = Node.Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Node.Color.Red;
          pp.right = n3.left;
          n3.color = Node.Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          Node.recount(pp);
          Node.recount(p);
          Node.recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  // Return new tree
  n_stack[0].color = Node.Color.Black;
  return makeImpl(self._ord, n_stack[0]);
});
/** @internal */
const keysForward = self => keys(self, _iterator.Direction.Forward);
/** @internal

## last

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `last(= last;
const reversed = self => {
  return {
    [Symbol.iterator]: ()`

JSDoc:

@internal */
const last = self => {
  let node = self._root;
  let current = self._root;
  while (node !== undefined) {
    current = node;
    node = node.right;
  }
  return current ? Option.some([current.key, current.value]) : Option.none();
};
/** @internal

## reversed

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `reversed(= reversed;
const greaterThanBackwards = exports.greaterThanBackwards = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `size(= size;
const valuesForward = self => values(self, _iterator.Direction.Forward)`

JSDoc:

@internal */
const greaterThanForwards = exports.greaterThanForwards = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => greaterThan(self, key, _iterator.Direction.Forward));
const greaterThan = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== undefined) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d < 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new _iterator.RedBlackTreeIterator(self, stack, direction);
    }
  };
};
/** @internal */
const greaterThanEqualBackwards = exports.greaterThanEqualBackwards = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => greaterThanEqual(self, key, _iterator.Direction.Backward));
/** @internal */
const greaterThanEqualForwards = exports.greaterThanEqualForwards = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => greaterThanEqual(self, key, _iterator.Direction.Forward));
const greaterThanEqual = (self, key, direction = _iterator.Direction.Forward) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== undefined) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d <= 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new _iterator.RedBlackTreeIterator(self, stack, direction);
    }
  };
};
/** @internal */
const lessThanBackwards = exports.lessThanBackwards = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => lessThan(self, key, _iterator.Direction.Backward));
/** @internal */
const lessThanForwards = exports.lessThanForwards = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => lessThan(self, key, _iterator.Direction.Forward));
const lessThan = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== undefined) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d > 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new _iterator.RedBlackTreeIterator(self, stack, direction);
    }
  };
};
/** @internal */
const lessThanEqualBackwards = exports.lessThanEqualBackwards = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => lessThanEqual(self, key, _iterator.Direction.Backward));
/** @internal */
const lessThanEqualForwards = exports.lessThanEqualForwards = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => lessThanEqual(self, key, _iterator.Direction.Forward));
const lessThanEqual = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== undefined) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d >= 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new _iterator.RedBlackTreeIterator(self, stack, direction);
    }
  };
};
/** @internal */
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const root = self._root;
  if (root !== undefined) {
    visitFull(root, (key, value) => {
      f(key, value);
      return Option.none();
    });
  }
});
/** @internal */
const forEachGreaterThanEqual = exports.forEachGreaterThanEqual = /*#__PURE__*/(0, _Function.dual)(3, (self, min, f) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== undefined) {
    visitGreaterThanEqual(root, min, ord, (key, value) => {
      f(key, value);
      return Option.none();
    });
  }
});
/** @internal */
const forEachLessThan = exports.forEachLessThan = /*#__PURE__*/(0, _Function.dual)(3, (self, max, f) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== undefined) {
    visitLessThan(root, max, ord, (key, value) => {
      f(key, value);
      return Option.none();
    });
  }
});
/** @internal */
const forEachBetween = exports.forEachBetween = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  body,
  max,
  min
}) => {
  const root = self._root;
  const ord = self._ord;
  if (root) {
    visitBetween(root, min, max, ord, (key, value) => {
      body(key, value);
      return Option.none();
    });
  }
});
/** @internal */
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => {
  let accumulator = zero;
  for (const entry of self) {
    accumulator = f(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
/** @internal */
const removeFirst = exports.removeFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => {
  if (!has(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== undefined) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (Equal.equals(key, node.key)) {
      node = undefined;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  // Get node
  n = cstack[cstack.length - 1];
  // If not leaf, then swap with previous node
  if (n.left !== undefined && n.right !== undefined) {
    // First walk to previous leaf
    const split = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    // Copy path to leaf
    const v = cstack[split - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split - 1].key = n.key;
    cstack[split - 1].value = n.value;
    // Fix up stack
    for (let i = cstack.length - 2; i >= split; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split - 1].left = cstack[split];
  }
  // Remove leaf node
  n = cstack[cstack.length - 1];
  if (n.color === Node.Color.Red) {
    // Easy case: removing red leaf
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = undefined;
    } else if (p.right === n) {
      p.right = undefined;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl(ord, cstack[0]);
  } else {
    if (n.left !== undefined || n.right !== undefined) {
      // Second easy case:  Single child black parent
      if (n.left !== undefined) {
        Node.swap(n, n.left);
      } else if (n.right !== undefined) {
        Node.swap(n, n.right);
      }
      // Child must be red, so repaint it black to balance color
      n.color = Node.Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl(ord, cstack[0]);
    } else if (cstack.length === 1) {
      // Third easy case: root
      return makeImpl(ord, undefined);
    } else {
      // Hard case: Repaint n, and then do some nasty stuff
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      // Fix up links
      if (parent.left === n) {
        parent.left = undefined;
      } else {
        parent.right = undefined;
      }
    }
  }
  return makeImpl(ord, cstack[0]);
});
/** @internal */
const size = self => self._root?.count ?? 0;
/** @internal

## valuesForward

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `valuesForward(= valuesForward;
const valuesBackward = self => values(self, _iterator.Direction.Backward)`

JSDoc:

@internal

## valuesBackward

Source: `my-backend/node_modules/effect/dist/cjs/internal/redBlackTree.js`

Signature: `valuesBackward(= valuesBackward;
const values = (self, direction)`

JSDoc:

@internal

## isRedacted

Source: `my-backend/node_modules/effect/dist/cjs/internal/redacted.js`

Signature: `isRedacted(= isRedacted;
const make = value => {
  const redacted = Object.create(proto)`

JSDoc:

@internal */
const RedactedSymbolKey = "effect/Redacted";
/** @internal */
const redactedRegistry = exports.redactedRegistry = /*#__PURE__*/(0, _GlobalValue.globalValue)("effect/Redacted/redactedRegistry", () => new WeakMap());
/** @internal */
const RedactedTypeId = exports.RedactedTypeId = /*#__PURE__*/Symbol.for(RedactedSymbolKey);
/** @internal */
const proto = exports.proto = {
  [RedactedTypeId]: {
    _A: _ => _
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [_Inspectable.NodeInspectSymbol]() {
    return "<redacted>";
  },
  [Hash.symbol]() {
    return (0, _Function.pipe)(Hash.hash(RedactedSymbolKey), Hash.combine(Hash.hash(redactedRegistry.get(this))), Hash.cached(this));
  },
  [Equal.symbol](that) {
    return isRedacted(that) && Equal.equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
/** @internal */
const isRedacted = u => (0, _Predicate.hasProperty)(u, RedactedTypeId);
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/redacted.js`

Signature: `make(= make;
const value = self => {
  if (redactedRegistry.has(self)`

JSDoc:

@internal

## value

Source: `my-backend/node_modules/effect/dist/cjs/internal/redacted.js`

Signature: `value(= value;
const unsafeWipe = self => redactedRegistry.delete(self)`

JSDoc:

@internal

## unsafeMake

Source: `my-backend/node_modules/effect/dist/cjs/internal/ref.js`

Signature: `unsafeMake(= unsafeMake;
const make = value => core.sync(()`

JSDoc:

@internal */
const RefTypeId = exports.RefTypeId = /*#__PURE__*/Symbol.for("effect/Ref");
/** @internal */
const refVariance = exports.refVariance = {
  /* c8 ignore next */
  _A: _ => _
};
class RefImpl extends Effectable.Class {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [Readable.TypeId] = Readable.TypeId;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = core.sync(() => MutableRef.get(this.ref));
  }
  get;
  modify(f) {
    return core.sync(() => {
      const current = MutableRef.get(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        MutableRef.set(a)(this.ref);
      }
      return b;
    });
  }
}
/** @internal */
const unsafeMake = value => new RefImpl(MutableRef.make(value));
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/ref.js`

Signature: `make(= make;
const get = self => self.get;
/** @internal */
exports.get = get;
const set = exports.set = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## auto

Source: `my-backend/node_modules/effect/dist/cjs/internal/reloadable.js`

Signature: `auto(= auto;
const autoFromConfig = (tag, options)`

JSDoc:

@internal */
const ReloadableSymbolKey = "effect/Reloadable";
/** @internal */
const ReloadableTypeId = exports.ReloadableTypeId = /*#__PURE__*/Symbol.for(ReloadableSymbolKey);
const reloadableVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const auto = (tag, options) => layer_.scoped(reloadableTag(tag), (0, _Function.pipe)(layer_.build(manual(tag, {
  layer: options.layer
})), core.map(Context.unsafeGet(reloadableTag(tag))), core.tap(reloadable => fiberRuntime.acquireRelease((0, _Function.pipe)(reloadable.reload, effect.ignoreLogged, schedule_.schedule_Effect(options.schedule), fiberRuntime.forkDaemon), core.interruptFiber))));
/** @internal

## autoFromConfig

Source: `my-backend/node_modules/effect/dist/cjs/internal/reloadable.js`

Signature: `autoFromConfig(= autoFromConfig;
const get = tag => core.flatMap(reloadableTag(tag)`

JSDoc:

@internal

## get

Source: `my-backend/node_modules/effect/dist/cjs/internal/reloadable.js`

Signature: `get(= get;
const manual = (tag, options)`

JSDoc:

@internal

## manual

Source: `my-backend/node_modules/effect/dist/cjs/internal/reloadable.js`

Signature: `manual(= manual;
const reloadableTag = tag => {
  return Context.GenericTag(`effect/Reloadable<${tag.key}>`)`

JSDoc:

@internal

## reloadableTag

Source: `my-backend/node_modules/effect/dist/cjs/internal/reloadable.js`

Signature: `reloadableTag(= reloadableTag;
const reload = tag => core.flatMap(reloadableTag(tag)`

JSDoc:

@internal

## reload

Source: `my-backend/node_modules/effect/dist/cjs/internal/reloadable.js`

Signature: `reload(= reload;
const reloadFork = tag => core.flatMap(reloadableTag(tag)`

JSDoc:

@internal

## isRequest

Source: `my-backend/node_modules/effect/dist/cjs/internal/request.js`

Signature: `isRequest(= isRequest;
const of = ()`

JSDoc:

@internal */
const RequestSymbolKey = "effect/Request";
/** @internal */
const RequestTypeId = exports.RequestTypeId = /*#__PURE__*/Symbol.for(RequestSymbolKey);
const requestVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
const RequestPrototype = {
  ..._effectable.StructuralPrototype,
  [RequestTypeId]: requestVariance
};
/** @internal */
const isRequest = u => (0, _Predicate.hasProperty)(u, RequestTypeId);
/** @internal

## of

Source: `my-backend/node_modules/effect/dist/cjs/internal/request.js`

Signature: `of(= of;
const tagged = tag => args => {
  const request = Object.assign(Object.create(RequestPrototype)`

JSDoc:

@internal

## tagged

Source: `my-backend/node_modules/effect/dist/cjs/internal/request.js`

Signature: `tagged(= tagged;
const Class = exports.Class = /*#__PURE__*/function ()`

JSDoc:

@internal

## TaggedClass

Source: `my-backend/node_modules/effect/dist/cjs/internal/request.js`

Signature: `TaggedClass(= TaggedClass;
const complete = exports.complete = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const TaggedClass = tag => {
  return class TaggedClass extends Class {
    _tag = tag;
  };
};
/** @internal

## Listeners

Source: `my-backend/node_modules/effect/dist/cjs/internal/request.js`

Signature: `Listeners(= Listeners;
const filterOutCompleted = requests => core.fiberRefGetWith(completedRequestMap.currentRequestMap, map => core.succeed(requests.filter(request => !(map.get(request)`

JSDoc:

@internal */
const completeEffect = exports.completeEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => core.matchEffect(effect, {
  onFailure: error => complete(self, core.exitFail(error)),
  onSuccess: value => complete(self, core.exitSucceed(value))
}));
/** @internal */
const fail = exports.fail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => complete(self, core.exitFail(error)));
/** @internal */
const failCause = exports.failCause = /*#__PURE__*/(0, _Function.dual)(2, (self, cause) => complete(self, core.exitFailCause(cause)));
/** @internal */
const succeed = exports.succeed = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => complete(self, core.exitSucceed(value)));
/** @internal */
class Listeners {
  count = 0;
  observers = /*#__PURE__*/new Set();
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach(f => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach(f => f(this.count));
  }
}
/**
@internal

## auto

Source: `my-backend/node_modules/effect/dist/cjs/internal/resource.js`

Signature: `auto(= auto;
const manual = acquire => core.flatMap(core.context()`

JSDoc:

@internal */
const ResourceSymbolKey = "effect/Resource";
/** @internal */
const ResourceTypeId = exports.ResourceTypeId = /*#__PURE__*/Symbol.for(ResourceSymbolKey);
const resourceVariance = {
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal  */
const proto = {
  ...effectable.CommitPrototype,
  commit() {
    return get(this);
  },
  [ResourceTypeId]: resourceVariance
};
/** @internal */
const auto = (acquire, policy) => core.tap(manual(acquire), manual => fiberRuntime.acquireRelease((0, _Function.pipe)(refresh(manual), schedule_.schedule_Effect(policy), core.interruptible, fiberRuntime.forkDaemon), core.interruptFiber));
/** @internal

## manual

Source: `my-backend/node_modules/effect/dist/cjs/internal/resource.js`

Signature: `manual(= manual;
const get = self => core.flatMap(scopedRef.get(self.scopedRef)`

JSDoc:

@internal

## get

Source: `my-backend/node_modules/effect/dist/cjs/internal/resource.js`

Signature: `get(= get;
const refresh = self => scopedRef.set(self.scopedRef, core.map(self.acquire, core.exitSucceed)`

JSDoc:

@internal

## isAsyncFiberException

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtime.js`

Signature: `isAsyncFiberException(= isAsyncFiberException;
const FiberFailureId = exports.FiberFailureId = /*#__PURE__*/Symbol.for("effect/Runtime/FiberFailure")`

JSDoc:

@internal */
const unsafeFork = exports.unsafeFork = /*#__PURE__*/makeDual((runtime, self, options) => {
  const fiberId = FiberId.unsafeMake();
  const fiberRefUpdates = [[core.currentContext, [[fiberId, runtime.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([scheduler_.currentScheduler, [[fiberId, options.scheduler]]]);
  }
  let fiberRefs = FiberRefs.updateManyAs(runtime.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId
  });
  if (options?.updateRefs) {
    fiberRefs = options.updateRefs(fiberRefs, fiberId);
  }
  const fiberRuntime = new FiberRuntime.FiberRuntime(fiberId, fiberRefs, runtime.runtimeFlags);
  let effect = self;
  if (options?.scope) {
    effect = core.flatMap(scope_.fork(options.scope, executionStrategy.sequential), closeableScope => core.zipRight(core.scopeAddFinalizer(closeableScope, core.fiberIdWith(id => (0, _Equal.equals)(id, fiberRuntime.id()) ? core.void : core.interruptAsFiber(fiberRuntime, id))), core.onExit(self, exit => scope_.close(closeableScope, exit))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  // we can compare by reference here as _supervisor.none is wrapped with globalValue
  if (supervisor !== supervisor_.none) {
    supervisor.onStart(runtime.context, effect, Option.none(), fiberRuntime);
    fiberRuntime.addObserver(exit => supervisor.onEnd(exit, fiberRuntime));
  }
  fiberScope.globalScope.add(runtime.runtimeFlags, fiberRuntime);
  // Only an explicit false will prevent immediate execution
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
});
/** @internal */
const unsafeRunCallback = exports.unsafeRunCallback = /*#__PURE__*/makeDual((runtime, effect, options = {}) => {
  const fiberRuntime = unsafeFork(runtime, effect, options);
  if (options.onExit) {
    fiberRuntime.addObserver(exit => {
      options.onExit(exit);
    });
  }
  return (id, cancelOptions) => unsafeRunCallback(runtime)((0, _Function.pipe)(fiberRuntime, Fiber.interruptAs(id ?? FiberId.none)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? exit => cancelOptions.onExit(Exit.flatten(exit)) : undefined
  });
});
/** @internal */
const unsafeRunSync = exports.unsafeRunSync = /*#__PURE__*/makeDual((runtime, effect) => {
  const result = unsafeRunSyncExit(runtime)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
class AsyncFiberExceptionImpl extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
}
const asyncFiberException = fiber => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
};
/** @internal */
const isAsyncFiberException = u => Predicate.isTagged(u, "AsyncFiberException") && "fiber" in u;
/** @internal

## fiberFailure

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtime.js`

Signature: `fiberFailure(= fiberFailure;
const isFiberFailure = u => Predicate.hasProperty(u, FiberFailureId)`

JSDoc:

@internal */
const FiberFailureCauseId = exports.FiberFailureCauseId = /*#__PURE__*/Symbol.for("effect/Runtime/FiberFailure/Cause");
class FiberFailureImpl extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause) {
    const head = InternalCause.prettyErrors(cause)[0];
    super(head?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause;
    this.name = head ? `(FiberFailure) ${head.name}` : "FiberFailure";
    if (head?.stack) {
      this.stack = head.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + InternalCause.pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [Inspectable.NodeInspectSymbol]() {
    return this.toString();
  }
}
/** @internal */
const fiberFailure = cause => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause);
  Error.stackTraceLimit = limit;
  return error;
};
/** @internal

## RuntimeImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtime.js`

Signature: `RuntimeImpl(= RuntimeImpl;
const make = options => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs)`

JSDoc:

@internal */
const unsafeRunSyncExit = exports.unsafeRunSyncExit = /*#__PURE__*/makeDual((runtime, effect) => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new scheduler_.SyncScheduler();
  const fiberRuntime = unsafeFork(runtime)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return core.exitDie(core.capture(asyncFiberException(fiberRuntime), core.currentSpanFromFiber(fiberRuntime)));
});
/** @internal */
const unsafeRunPromise = exports.unsafeRunPromise = /*#__PURE__*/makeDual((runtime, effect, options) => unsafeRunPromiseExit(runtime, effect, options).then(result => {
  switch (result._tag) {
    case OpCodes.OP_SUCCESS:
      {
        return result.effect_instruction_i0;
      }
    case OpCodes.OP_FAILURE:
      {
        throw fiberFailure(result.effect_instruction_i0);
      }
  }
}));
/** @internal */
const unsafeRunPromiseExit = exports.unsafeRunPromiseExit = /*#__PURE__*/makeDual((runtime, effect, options) => new Promise(resolve => {
  const op = fastPath(effect);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork(runtime)(effect);
  fiber.addObserver(exit => {
    resolve(exit);
  });
  if (options?.signal !== undefined) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
/** @internal */
class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context, runtimeFlags, fiberRefs) {
    this.context = context;
    this.runtimeFlags = runtimeFlags;
    this.fiberRefs = fiberRefs;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtime.js`

Signature: `make(= make;
const runtime = ()`

JSDoc:

@internal

## runtime

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtime.js`

Signature: `runtime(= runtime;
const defaultRuntimeFlags = exports.defaultRuntimeFlags = /*#__PURE__*/runtimeFlags.make(runtimeFlags.Interruption, runtimeFlags.CooperativeYielding, runtimeFlags.RuntimeMetrics)`

JSDoc:

@internal

## cooperativeYielding

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `cooperativeYielding(= cooperativeYielding;
const disable = exports.disable = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const None = exports.None = 0;
/** @internal */
const Interruption = exports.Interruption = 1 << 0;
/** @internal */
const OpSupervision = exports.OpSupervision = 1 << 1;
/** @internal */
const RuntimeMetrics = exports.RuntimeMetrics = 1 << 2;
/** @internal */
const WindDown = exports.WindDown = 1 << 4;
/** @internal */
const CooperativeYielding = exports.CooperativeYielding = 1 << 5;
/** @internal */
const allFlags = exports.allFlags = [None, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];
const print = flag => {
  switch (flag) {
    case CooperativeYielding:
      {
        return "CooperativeYielding";
      }
    case WindDown:
      {
        return "WindDown";
      }
    case RuntimeMetrics:
      {
        return "RuntimeMetrics";
      }
    case OpSupervision:
      {
        return "OpSupervision";
      }
    case Interruption:
      {
        return "Interruption";
      }
    case None:
      {
        return "None";
      }
  }
};
/** @internal */
const cooperativeYielding = self => isEnabled(self, CooperativeYielding);
/** @internal

## interruptible

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `interruptible(= interruptible;
const interruption = self => isEnabled(self, Interruption)`

JSDoc:

@internal */
const disableAll = exports.disableAll = /*#__PURE__*/(0, _Function.dual)(2, (self, flags) => self & ~flags);
/** @internal */
const enable = exports.enable = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => self | flag);
/** @internal */
const enableAll = exports.enableAll = /*#__PURE__*/(0, _Function.dual)(2, (self, flags) => self | flags);
/** @internal */
const interruptible = self => interruption(self) && !windDown(self);
/** @internal

## interruption

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `interruption(= interruption;
const isDisabled = exports.isDisabled = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `make(= make;
const none = exports.none = /*#__PURE__*/make(None)`

JSDoc:

@internal */
const isEnabled = exports.isEnabled = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => (self & flag) !== 0);
/** @internal */
const make = (...flags) => flags.reduce((a, b) => a | b, 0);
/** @internal

## opSupervision

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `opSupervision(= opSupervision;
const render = self => {
  const active = [];
  allFlags.forEach(flag => {
    if (isEnabled(self, flag)`

JSDoc:

@internal */
const opSupervision = self => isEnabled(self, OpSupervision);
/** @internal

## render

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `render(= render;
const runtimeMetrics = self => isEnabled(self, RuntimeMetrics)`

JSDoc:

@internal

## runtimeMetrics

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `runtimeMetrics(= runtimeMetrics;
const toSet = self => new Set(allFlags.filter(flag => isEnabled(self, flag)`

JSDoc:

@internal

## windDown

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `windDown(= windDown;
const enabledSet = self => toSet(runtimeFlagsPatch.active(self)`

JSDoc:

@internal

## enabledSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `enabledSet(= enabledSet;
const disabledSet = self => toSet(runtimeFlagsPatch.active(self)`

JSDoc:

@internal

## disabledSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `disabledSet(= disabledSet;
const diff = exports.diff = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## renderPatch

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlags.js`

Signature: `renderPatch(= renderPatch;
const differ = exports.differ = /*#__PURE__*/internalDiffer.make({
  empty: runtimeFlagsPatch.empty,
  diff: (oldValue, newValue)`

JSDoc:

@internal */
const patch = exports.patch = /*#__PURE__*/(0, _Function.dual)(2, (self, patch) => self & (runtimeFlagsPatch.invert(runtimeFlagsPatch.active(patch)) | runtimeFlagsPatch.enabled(patch)) | runtimeFlagsPatch.active(patch) & runtimeFlagsPatch.enabled(patch));
/** @internal */
const renderPatch = self => {
  const enabled = Array.from(enabledSet(self)).map(flag => print(flag)).join(", ");
  const disabled = Array.from(disabledSet(self)).map(flag => print(flag)).join(", ");
  return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`;
};
/** @internal

## active

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlagsPatch.js`

Signature: `active(= active;
const enabled = patch => patch >> BIT_SHIFT & BIT_MASK;
/** @internal */
exports.enabled = enabled;
const make = (active, enabled)`

JSDoc:

@internal */
const BIT_MASK = 0xff;
/** @internal */
const BIT_SHIFT = 0x08;
/** @internal */
const active = patch => patch & BIT_MASK;
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlagsPatch.js`

Signature: `make(= make;
const empty = exports.empty = /*#__PURE__*/make(0, 0)`

JSDoc:

@internal

## enable

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlagsPatch.js`

Signature: `enable(= enable;
const disable = flag => make(flag, 0)`

JSDoc:

@internal */
const enable = flag => make(flag, flag);
/** @internal

## disable

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlagsPatch.js`

Signature: `disable(= disable;
const isEmpty = patch => patch === 0;
/** @internal */
exports.isEmpty = isEmpty;
const isActive = exports.isActive = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## inverse

Source: `my-backend/node_modules/effect/dist/cjs/internal/runtimeFlagsPatch.js`

Signature: `inverse(= inverse;
const invert = n => ~n >>> 0 & BIT_MASK;
exports.invert = invert;
//# sourceMappingURL=runtimeFlagsPatch.js.map)`

JSDoc:

@internal */
const isEnabled = exports.isEnabled = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => (enabled(self) & flag) !== 0);
/** @internal */
const isDisabled = exports.isDisabled = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
/** @internal */
const exclude = exports.exclude = /*#__PURE__*/(0, _Function.dual)(2, (self, flag) => make(active(self) & ~flag, enabled(self)));
/** @internal */
const both = exports.both = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(active(self) | active(that), enabled(self) & enabled(that)));
/** @internal */
const either = exports.either = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => make(active(self) | active(that), enabled(self) | enabled(that)));
/** @internal */
const andThen = exports.andThen = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => self | that);
/** @internal */
const inverse = patch => make(enabled(patch), invert(active(patch)));
/** @internal

## _continue

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/decision.js`

Signature: `_continue(= _continue;
const continueWith = interval => {
  return {
    _tag: OP_CONTINUE,
    intervals: Intervals.make(Chunk.of(interval)`

JSDoc:

@internal */
const OP_CONTINUE = exports.OP_CONTINUE = "Continue";
/** @internal */
const OP_DONE = exports.OP_DONE = "Done";
/** @internal */
const _continue = intervals => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
/** @internal

## continueWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/decision.js`

Signature: `continueWith(= continueWith;
const done = exports.done = {
  _tag: OP_DONE
};
/** @internal */
const isContinue = self => {
  return self._tag === OP_CONTINUE;
};
/** @internal */
exports.isContinue = isContinue;
const isDone = self => {
  return self._tag === OP_DONE;
};
exports.isDone = isDone;
//# sourceMappingURL=decision.js.map)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/interval.js`

Signature: `make(= make;
const lessThan = exports.lessThan = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const IntervalSymbolKey = "effect/ScheduleInterval";
/** @internal */
const IntervalTypeId = exports.IntervalTypeId = /*#__PURE__*/Symbol.for(IntervalSymbolKey);
/** @internal */
const empty = exports.empty = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
/** @internal */
const make = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
/** @internal

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/interval.js`

Signature: `isEmpty(= isEmpty;
const isNonEmpty = self => {
  return !isEmpty(self)`

JSDoc:

@internal */
const min = exports.min = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
/** @internal */
const max = exports.max = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => min(self, that) === self ? that : self);
/** @internal */
const isEmpty = self => {
  return self.startMillis >= self.endMillis;
};
/** @internal

## isNonEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/interval.js`

Signature: `isNonEmpty(= isNonEmpty;
const intersect = exports.intersect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/interval.js`

Signature: `size(= size;
const union = exports.union = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const size = self => {
  return Duration.millis(self.endMillis - self.startMillis);
};
/** @internal

## after

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/interval.js`

Signature: `after(= after;
const before = endMilliseconds => {
  return make(Number.NEGATIVE_INFINITY, endMilliseconds)`

JSDoc:

@internal */
const after = startMilliseconds => {
  return make(startMilliseconds, Number.POSITIVE_INFINITY);
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/intervals.js`

Signature: `make(= make;
const empty = exports.empty = /*#__PURE__*/make(/*#__PURE__*/Chunk.empty()`

JSDoc:

@internal */
const IntervalsSymbolKey = "effect/ScheduleIntervals";
/** @internal */
const IntervalsTypeId = exports.IntervalsTypeId = /*#__PURE__*/Symbol.for(IntervalsSymbolKey);
/** @internal */
const make = intervals => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
/** @internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/intervals.js`

Signature: `fromIterable(= fromIterable;
const union = exports.union = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const fromIterable = intervals => Array.from(intervals).reduce((intervals, interval) => (0, _Function.pipe)(intervals, union(make(Chunk.of(interval)))), empty);
/** @internal

## start

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/intervals.js`

Signature: `start(= start;
const end = self => {
  return (0, _Function.pipe)`

JSDoc:

@internal */
const unionLoop = (_self, _that, _interval, _acc) => {
  let self = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (Chunk.isNonEmpty(self) || Chunk.isNonEmpty(that)) {
    if (!Chunk.isNonEmpty(self) && Chunk.isNonEmpty(that)) {
      if (interval.endMillis < Chunk.headNonEmpty(that).startMillis) {
        acc = (0, _Function.pipe)(acc, Chunk.prepend(interval));
        interval = Chunk.headNonEmpty(that);
        that = Chunk.tailNonEmpty(that);
        self = Chunk.empty();
      } else {
        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(that).endMillis);
        that = Chunk.tailNonEmpty(that);
        self = Chunk.empty();
      }
    } else if (Chunk.isNonEmpty(self) && Chunk.isEmpty(that)) {
      if (interval.endMillis < Chunk.headNonEmpty(self).startMillis) {
        acc = (0, _Function.pipe)(acc, Chunk.prepend(interval));
        interval = Chunk.headNonEmpty(self);
        that = Chunk.empty();
        self = Chunk.tailNonEmpty(self);
      } else {
        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(self).endMillis);
        that = Chunk.empty();
        self = Chunk.tailNonEmpty(self);
      }
    } else if (Chunk.isNonEmpty(self) && Chunk.isNonEmpty(that)) {
      if (Chunk.headNonEmpty(self).startMillis < Chunk.headNonEmpty(that).startMillis) {
        if (interval.endMillis < Chunk.headNonEmpty(self).startMillis) {
          acc = (0, _Function.pipe)(acc, Chunk.prepend(interval));
          interval = Chunk.headNonEmpty(self);
          self = Chunk.tailNonEmpty(self);
        } else {
          interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(self).endMillis);
          self = Chunk.tailNonEmpty(self);
        }
      } else if (interval.endMillis < Chunk.headNonEmpty(that).startMillis) {
        acc = (0, _Function.pipe)(acc, Chunk.prepend(interval));
        interval = Chunk.headNonEmpty(that);
        that = Chunk.tailNonEmpty(that);
      } else {
        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(that).endMillis);
        that = Chunk.tailNonEmpty(that);
      }
    } else {
      throw new Error((0, _errors.getBugErrorMessage)("Intervals.unionLoop"));
    }
  }
  return make((0, _Function.pipe)(acc, Chunk.prepend(interval), Chunk.reverse));
};
/** @internal */
const intersect = exports.intersect = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => intersectLoop(self.intervals, that.intervals, Chunk.empty()));
/** @internal */
const intersectLoop = (_left, _right, _acc) => {
  let left = _left;
  let right = _right;
  let acc = _acc;
  while (Chunk.isNonEmpty(left) && Chunk.isNonEmpty(right)) {
    const interval = (0, _Function.pipe)(Chunk.headNonEmpty(left), Interval.intersect(Chunk.headNonEmpty(right)));
    const intervals = Interval.isEmpty(interval) ? acc : (0, _Function.pipe)(acc, Chunk.prepend(interval));
    if ((0, _Function.pipe)(Chunk.headNonEmpty(left), Interval.lessThan(Chunk.headNonEmpty(right)))) {
      left = Chunk.tailNonEmpty(left);
    } else {
      right = Chunk.tailNonEmpty(right);
    }
    acc = intervals;
  }
  return make(Chunk.reverse(acc));
};
/** @internal */
const start = self => {
  return (0, _Function.pipe)(self.intervals, Chunk.head, Option.getOrElse(() => Interval.empty)).startMillis;
};
/** @internal

## end

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/intervals.js`

Signature: `end(= end;
const lessThan = exports.lessThan = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## isNonEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule/intervals.js`

Signature: `isNonEmpty(= isNonEmpty;
const max = exports.max = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const isNonEmpty = self => {
  return Chunk.isNonEmpty(self.intervals);
};
/** @internal

## isSchedule

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `isSchedule(= isSchedule;
const ScheduleDriverSymbolKey = "effect/ScheduleDriver";
/** @internal */
const ScheduleDriverTypeId = exports.ScheduleDriverTypeId = /*#__PURE__*/Symbol.for(ScheduleDriverSymbolKey)`

JSDoc:

@internal */
const ScheduleSymbolKey = "effect/Schedule";
/** @internal */
const ScheduleTypeId = exports.ScheduleTypeId = /*#__PURE__*/Symbol.for(ScheduleSymbolKey);
/** @internal */
const isSchedule = u => (0, _Predicate.hasProperty)(u, ScheduleTypeId);
/** @internal

## makeWithState

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `makeWithState(= makeWithState;
const addDelay = exports.addDelay = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: undefined,
  elapsed: Duration.zero,
  elapsedSincePrevious: Duration.zero,
  recurrence: 0
};
/** @internal */
const CurrentIterationMetadata = exports.CurrentIterationMetadata = /*#__PURE__*/Context.Reference()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
const scheduleVariance = {
  /* c8 ignore next */
  _Out: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
const scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
/** @internal */
class ScheduleImpl {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step) {
    this.initial = initial;
    this.step = step;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
const updateInfo = (iterationMetaRef, now, input) => ref.update(iterationMetaRef, prev => prev.recurrence === 0 ? {
  now,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: Duration.zero,
  elapsedSincePrevious: Duration.zero,
  start: now
} : {
  now,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: Duration.millis(now - prev.start),
  elapsedSincePrevious: Duration.millis(now - prev.now),
  start: prev.start
});
/** @internal */
class ScheduleDriverImpl {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule, ref) {
    this.schedule = schedule;
    this.ref = ref;
  }
  get state() {
    return core.map(ref.get(this.ref), tuple => tuple[1]);
  }
  get last() {
    return core.flatMap(ref.get(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None":
          {
            return core.failSync(() => new core.NoSuchElementException());
          }
        case "Some":
          {
            return core.succeed(element.value);
          }
      }
    });
  }
  iterationMeta = /*#__PURE__*/ref.unsafeMake(defaultIterationMetadata);
  get reset() {
    return ref.set(this.ref, [Option.none(), this.schedule.initial]).pipe(core.zipLeft(ref.set(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return (0, _Function.pipe)(core.map(ref.get(this.ref), tuple => tuple[1]), core.flatMap(state => (0, _Function.pipe)(Clock.currentTimeMillis, core.flatMap(now => (0, _Function.pipe)(core.suspend(() => this.schedule.step(now, input, state)), core.flatMap(([state, out, decision]) => {
      const setState = ref.set(this.ref, [Option.some(out), state]);
      if (ScheduleDecision.isDone(decision)) {
        return setState.pipe(core.zipRight(core.fail(Option.none())));
      }
      const millis = Intervals.start(decision.intervals) - now;
      if (millis <= 0) {
        return setState.pipe(core.zipRight(updateInfo(this.iterationMeta, now, input)), core.as(out));
      }
      const duration = Duration.millis(millis);
      return (0, _Function.pipe)(setState, core.zipRight(updateInfo(this.iterationMeta, now, input)), core.zipRight(effect.sleep(duration)), core.as(out));
    }))))));
  }
}
/** @internal */
const makeWithState = (initial, step) => new ScheduleImpl(initial, step);
/** @internal

## asVoid

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `asVoid(= asVoid;
const bothInOut = exports.bothInOut = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const addDelayEffect = exports.addDelayEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => modifyDelayEffect(self, (out, duration) => core.map(f(out), delay => Duration.sum(duration, Duration.decode(delay)))));
/** @internal */
const andThen = exports.andThen = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => map(andThenEither(self, that), Either.merge));
/** @internal */
const andThenEither = exports.andThenEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => makeWithState([self.initial, that.initial, true], (now, input, state) => state[2] ? core.flatMap(self.step(now, input, state[0]), ([lState, out, decision]) => {
  if (ScheduleDecision.isDone(decision)) {
    return core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[lState, rState, false], Either.right(out), decision]);
  }
  return core.succeed([[lState, state[1], true], Either.left(out), decision]);
}) : core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], Either.right(out), decision])));
/** @internal */
const as = exports.as = /*#__PURE__*/(0, _Function.dual)(2, (self, out) => map(self, () => out));
/** @internal */
const asVoid = self => map(self, _Function.constVoid);
/** @internal

## collectAllInputs

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `collectAllInputs(= collectAllInputs;
const collectAllOutputs = self => reduce(self, Chunk.empty()`

JSDoc:

@internal */
const check = exports.check = /*#__PURE__*/(0, _Function.dual)(2, (self, test) => checkEffect(self, (input, out) => core.sync(() => test(input, out))));
/** @internal */
const checkEffect = exports.checkEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, test) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => {
  if (ScheduleDecision.isDone(decision)) {
    return core.succeed([state, out, ScheduleDecision.done]);
  }
  return core.map(test(input, out), cont => cont ? [state, out, decision] : [state, out, ScheduleDecision.done]);
})));
/** @internal */
const collectAllInputs = () => collectAllOutputs(identity());
/** @internal

## collectAllOutputs

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `collectAllOutputs(= collectAllOutputs;
const collectUntil = f => collectAllOutputs(recurUntil(f)`

JSDoc:

@internal

## collectUntil

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `collectUntil(= collectUntil;
const collectUntilEffect = f => collectAllOutputs(recurUntilEffect(f)`

JSDoc:

@internal

## collectUntilEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `collectUntilEffect(= collectUntilEffect;
const collectWhile = f => collectAllOutputs(recurWhile(f)`

JSDoc:

@internal

## collectWhile

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `collectWhile(= collectWhile;
const collectWhileEffect = f => collectAllOutputs(recurWhileEffect(f)`

JSDoc:

@internal

## collectWhileEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `collectWhileEffect(= collectWhileEffect;
const compose = exports.compose = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## cron

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `cron(= cron;
const dayOfMonth = day => {
  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state)`

JSDoc:

@internal */
const mapInput = exports.mapInput = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapInputEffect(self, input2 => core.sync(() => f(input2))));
/** @internal */
const mapInputContext = exports.mapInputContext = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.mapInputContext(self.step(now, input, state), f)));
/** @internal */
const mapInputEffect = exports.mapInputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeWithState(self.initial, (now, input2, state) => core.flatMap(f(input2), input => self.step(now, input, state))));
/** @internal */
const cron = (expression, tz) => {
  const parsed = Cron.isCron(expression) ? Either.right(expression) : Cron.parse(expression, tz);
  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now, _, [initial, previous]) => {
    if (now < previous[0]) {
      return core.succeed([[false, previous], [previous[1], previous[2]], ScheduleDecision.continueWith(Interval.make(previous[1], previous[2]))]);
    }
    if (Either.isLeft(parsed)) {
      return core.die(parsed.left);
    }
    const cron = parsed.right;
    const date = new Date(now);
    let next;
    if (initial && Cron.match(cron, date)) {
      next = now;
    }
    next = Cron.next(cron, date).getTime();
    const start = beginningOfSecond(next);
    const end = endOfSecond(next);
    return core.succeed([[false, [next, start, end]], [start, end], ScheduleDecision.continueWith(Interval.make(start, end))]);
  });
};
/** @internal

## dayOfMonth

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `dayOfMonth(= dayOfMonth;
const dayOfWeek = day => {
  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state)`

JSDoc:

@internal

## dayOfWeek

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `dayOfWeek(= dayOfWeek;
const delayed = exports.delayed = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## delayedSchedule

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `delayedSchedule(= delayedSchedule;
const delays = self => makeWithState(self.initial, (now, input, state)`

JSDoc:

@internal */
const delayedEffect = exports.delayedEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => modifyDelayEffect(self, (_, delay) => f(delay)));
/** @internal */
const delayedSchedule = schedule => addDelay(schedule, x => x);
/** @internal

## delays

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `delays(= delays;
const mapBoth = exports.mapBoth = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## driver

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `driver(= driver;
const duration = durationInput => {
  const duration = Duration.decode(durationInput)`

JSDoc:

@internal */
const mapBothEffect = exports.mapBothEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onInput,
  onOutput
}) => mapEffect(mapInputEffect(self, onInput), onOutput));
/** @internal */
const driver = self => (0, _Function.pipe)(ref.make([Option.none(), self.initial]), core.map(ref => new ScheduleDriverImpl(self, ref)));
/** @internal

## duration

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `duration(= duration;
const either = exports.either = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## exponential

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `exponential(= exponential;
const fibonacci = oneInput => {
  const one = Duration.decode(oneInput)`

JSDoc:

@internal */
const eitherWith = exports.eitherWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => unionWith(self, that, f));
/** @internal */
const ensuring = exports.ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.as(finalizer, [state, out, decision]) : core.succeed([state, out, decision]))));
/** @internal */
const exponential = (baseInput, factor = 2.0) => {
  const base = Duration.decode(baseInput);
  return delayedSchedule(map(forever, i => Duration.times(base, Math.pow(factor, i))));
};
/** @internal

## fibonacci

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `fibonacci(= fibonacci;
const fixed = intervalInput => {
  const interval = Duration.decode(intervalInput)`

JSDoc:

@internal

## fixed

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `fixed(= fixed;
const fromDelay = delay => duration(delay)`

JSDoc:

@internal

## fromDelay

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `fromDelay(= fromDelay;
const fromDelays = (delay, ...delays)`

JSDoc:

@internal

## fromDelays

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `fromDelays(= fromDelays;
const fromFunction = f => map(identity()`

JSDoc:

@internal

## fromFunction

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `fromFunction(= fromFunction;
const hourOfDay = hour => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state)`

JSDoc:

@internal

## hourOfDay

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `hourOfDay(= hourOfDay;
const identity = ()`

JSDoc:

@internal

## identity

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `identity(= identity;
const intersect = exports.intersect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## jittered

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `jittered(= jittered;
const jitteredWith = exports.jitteredWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const intersectWith = exports.intersectWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => (0, _Function.pipe)(core.zipWith(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), core.flatMap(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);
}))));
/** @internal */
const intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (Intervals.isNonEmpty(combined)) {
    return core.succeed([[lState, rState], [out, out2], ScheduleDecision.continue(combined)]);
  }
  if ((0, _Function.pipe)(lInterval, Intervals.lessThan(rInterval))) {
    return core.flatMap(self.step(Intervals.end(lInterval), input, lState), ([lState, out, decision]) => {
      if (ScheduleDecision.isDone(decision)) {
        return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);
      }
      return intersectWithLoop(self, that, input, lState, out, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return core.flatMap(that.step(Intervals.end(rInterval), input, rState), ([rState, out2, decision]) => {
    if (ScheduleDecision.isDone(decision)) {
      return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState, out2, decision.intervals, f);
  });
};
/** @internal */
const jittered = self => jitteredWith(self, {
  min: 0.8,
  max: 1.2
});
/** @internal

## linear

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `linear(= linear;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const linear = baseInput => {
  const base = Duration.decode(baseInput);
  return delayedSchedule(map(forever, i => Duration.times(base, i + 1)));
};
/** @internal

## minuteOfHour

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `minuteOfHour(= minuteOfHour;
const modifyDelay = exports.modifyDelay = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const mapEffect = exports.mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => core.map(f(out), out2 => [state, out2, decision]))));
/** @internal */
const minuteOfHour = minute => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {
  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
    return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const minute0 = nextMinute(now, minute, initial);
  const start = beginningOfMinute(minute0);
  const end = endOfMinute(minute0);
  const interval = Interval.make(start, end);
  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);
});
/** @internal

## passthrough

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `passthrough(= passthrough;
const provideContext = exports.provideContext = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const modifyDelayEffect = exports.modifyDelayEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => {
  if (ScheduleDecision.isDone(decision)) {
    return core.succeed([state, out, decision]);
  }
  const intervals = decision.intervals;
  const delay = Interval.size(Interval.make(now, Intervals.start(intervals)));
  return core.map(f(out, delay), durationInput => {
    const duration = Duration.decode(durationInput);
    const oldStart = Intervals.start(intervals);
    const newStart = now + Duration.toMillis(duration);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, Intervals.end(intervals) + delta);
    const newInterval = Interval.make(newStart, newEnd);
    return [state, out, ScheduleDecision.continueWith(newInterval)];
  });
})));
/** @internal */
const onDecision = exports.onDecision = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => core.as(f(out, decision), [state, out, decision]))));
/** @internal */
const passthrough = self => makeWithState(self.initial, (now, input, state) => (0, _Function.pipe)(self.step(now, input, state), core.map(([state, _, decision]) => [state, input, decision])));
/** @internal

## recurUntil

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `recurUntil(= recurUntil;
const recurUntilEffect = f => untilInputEffect(identity()`

JSDoc:

@internal */
const provideService = exports.provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, service) => makeWithState(self.initial, (now, input, state) => core.contextWithEffect(env => core.provideContext(
// @ts-expect-error
self.step(now, input, state), Context.add(env, tag, service)))));
/** @internal */
const recurUntil = f => untilInput(identity(), f);
/** @internal

## recurUntilEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `recurUntilEffect(= recurUntilEffect;
const recurUntilOption = pf => untilOutput(map(identity()`

JSDoc:

@internal

## recurUntilOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `recurUntilOption(= recurUntilOption;
const recurUpTo = durationInput => {
  const duration = Duration.decode(durationInput)`

JSDoc:

@internal

## recurUpTo

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `recurUpTo(= recurUpTo;
const recurWhile = f => whileInput(identity()`

JSDoc:

@internal

## recurWhile

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `recurWhile(= recurWhile;
const recurWhileEffect = f => whileInputEffect(identity()`

JSDoc:

@internal

## recurWhileEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `recurWhileEffect(= recurWhileEffect;
const recurs = n => whileOutput(forever, out => out < n)`

JSDoc:

@internal

## recurs

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `recurs(= recurs;
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## repeatForever

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `repeatForever(= repeatForever;
const repetitions = self => reduce(self, 0, (n, _)`

JSDoc:

@internal */
const reduceEffect = exports.reduceEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => makeWithState([self.initial, zero], (now, input, [s, z]) => core.flatMap(self.step(now, input, s), ([s, out, decision]) => ScheduleDecision.isDone(decision) ? core.succeed([[s, z], z, decision]) : core.map(f(z, out), z2 => [[s, z2], z, decision]))));
/** @internal */
const repeatForever = self => makeWithState(self.initial, (now, input, state) => {
  const step = (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? step(now, input, self.initial) : core.succeed([state, out, decision]));
  return step(now, input, state);
});
/** @internal

## repetitions

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `repetitions(= repetitions;
const resetAfter = exports.resetAfter = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## secondOfMinute

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `secondOfMinute(= secondOfMinute;
const spaced = duration => addDelay(forever, ()`

JSDoc:

@internal */
const resetWhen = exports.resetWhen = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(self.step(now, input, state), ([state, out, decision]) => f(out) ? self.step(now, input, self.initial) : core.succeed([state, out, decision]))));
/** @internal */
const run = exports.run = /*#__PURE__*/(0, _Function.dual)(3, (self, now, input) => (0, _Function.pipe)(runLoop(self, now, Chunk.fromIterable(input), self.initial, Chunk.empty()), core.map(list => Chunk.reverse(list))));
/** @internal */
const runLoop = (self, now, inputs, state, acc) => {
  if (!Chunk.isNonEmpty(inputs)) {
    return core.succeed(acc);
  }
  const input = Chunk.headNonEmpty(inputs);
  const nextInputs = Chunk.tailNonEmpty(inputs);
  return core.flatMap(self.step(now, input, state), ([state, out, decision]) => {
    if (ScheduleDecision.isDone(decision)) {
      return core.sync(() => (0, _Function.pipe)(acc, Chunk.prepend(out)));
    }
    return runLoop(self, Intervals.start(decision.intervals), nextInputs, state, Chunk.prepend(acc, out));
  });
};
/** @internal */
const secondOfMinute = second => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
  if (!Number.isInteger(second) || second < 0 || 59 < second) {
    return core.dieSync(() => new core.IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const second0 = nextSecond(now, second, initial);
  const start = beginningOfSecond(second0);
  const end = endOfSecond(second0);
  const interval = Interval.make(start, end);
  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);
});
/** @internal

## spaced

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `spaced(= spaced;
const succeed = value => map(forever, ()`

JSDoc:

@internal

## succeed

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `succeed(= succeed;
const sync = evaluate => map(forever, evaluate)`

JSDoc:

@internal

## sync

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `sync(= sync;
const tapInput = exports.tapInput = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## unfold

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `unfold(= unfold;
const union = exports.union = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const tapOutput = exports.tapOutput = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => makeWithState(self.initial, (now, input, state) => core.tap(self.step(now, input, state), ([, out]) => f(out))));
/** @internal */
const unfold = (initial, f) => makeWithState(initial, (now, _, state) => core.sync(() => [f(state), state, ScheduleDecision.continueWith(Interval.after(now))]));
/** @internal

## windowed

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `windowed(= windowed;
const zipLeft = exports.zipLeft = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const unionWith = exports.unionWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => core.zipWith(self.step(now, input, state[0]), that.step(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isDone(rDecision)) {
    return [[lState, rState], [l, r], ScheduleDecision.done];
  }
  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isContinue(rDecision)) {
    return [[lState, rState], [l, r], ScheduleDecision.continue(rDecision.intervals)];
  }
  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isDone(rDecision)) {
    return [[lState, rState], [l, r], ScheduleDecision.continue(lDecision.intervals)];
  }
  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {
    const combined = f(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l, r], ScheduleDecision.continue(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})));
/** @internal */
const untilInput = exports.untilInput = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => check(self, (input, _) => !f(input)));
/** @internal */
const untilInputEffect = exports.untilInputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => checkEffect(self, (input, _) => effect.negate(f(input))));
/** @internal */
const untilOutput = exports.untilOutput = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => check(self, (_, out) => !f(out)));
/** @internal */
const untilOutputEffect = exports.untilOutputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => checkEffect(self, (_, out) => effect.negate(f(out))));
/** @internal */
const upTo = exports.upTo = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => zipLeft(self, recurUpTo(duration)));
/** @internal */
const whileInput = exports.whileInput = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => check(self, (input, _) => f(input)));
/** @internal */
const whileInputEffect = exports.whileInputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => checkEffect(self, (input, _) => f(input)));
/** @internal */
const whileOutput = exports.whileOutput = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => check(self, (_, out) => f(out)));
/** @internal */
const whileOutputEffect = exports.whileOutputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => checkEffect(self, (_, out) => f(out)));
/** @internal */
const windowed = intervalInput => {
  const interval = Duration.decode(intervalInput);
  const millis = Duration.toMillis(interval);
  return makeWithState([Option.none(), 0], (now, _, [option, n]) => {
    switch (option._tag) {
      case "None":
        {
          return core.succeed([[Option.some(now), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + millis))]);
        }
      case "Some":
        {
          return core.succeed([[Option.some(option.value), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + (millis - (now - option.value) % millis)))]);
        }
    }
  });
};
/** @internal

## beginningOfSecond

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `beginningOfSecond(= beginningOfSecond;
const endOfSecond = now => {
  const date = new Date(beginningOfSecond(now)`

JSDoc:

@internal */
const zipRight = exports.zipRight = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => map(intersect(self, that), out => out[1]));
/** @internal */
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => map(intersect(self, that), ([out, out2]) => f(out, out2)));
// -----------------------------------------------------------------------------
// Seconds
// -----------------------------------------------------------------------------
/** @internal */
const beginningOfSecond = now => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0).getTime();
};
/** @internal

## endOfSecond

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `endOfSecond(= endOfSecond;
const nextSecond = (now, second, initial)`

JSDoc:

@internal

## nextSecond

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `nextSecond(= nextSecond;
const beginningOfMinute = now => {
  const date = new Date(now)`

JSDoc:

@internal

## beginningOfMinute

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `beginningOfMinute(= beginningOfMinute;
const endOfMinute = now => {
  const date = new Date(beginningOfMinute(now)`

JSDoc:

@internal

## endOfMinute

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `endOfMinute(= endOfMinute;
const nextMinute = (now, minute, initial)`

JSDoc:

@internal

## nextMinute

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `nextMinute(= nextMinute;
const beginningOfHour = now => {
  const date = new Date(now)`

JSDoc:

@internal

## beginningOfHour

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `beginningOfHour(= beginningOfHour;
const endOfHour = now => {
  const date = new Date(beginningOfHour(now)`

JSDoc:

@internal

## endOfHour

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `endOfHour(= endOfHour;
const nextHour = (now, hour, initial)`

JSDoc:

@internal

## nextHour

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `nextHour(= nextHour;
const beginningOfDay = now => {
  const date = new Date(now)`

JSDoc:

@internal

## beginningOfDay

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `beginningOfDay(= beginningOfDay;
const endOfDay = now => {
  const date = new Date(beginningOfDay(now)`

JSDoc:

@internal

## endOfDay

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `endOfDay(= endOfDay;
const nextDay = (now, dayOfWeek, initial)`

JSDoc:

@internal

## nextDay

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `nextDay(= nextDay;
const nextDayOfMonth = (now, day, initial)`

JSDoc:

@internal

## nextDayOfMonth

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `nextDayOfMonth(= nextDayOfMonth;
const findNextMonth = (now, day, months)`

JSDoc:

@internal

## scheduleDefectRefailCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `scheduleDefectRefailCause(= scheduleDefectRefailCause;
const scheduleDefectRefail = effect => core.catchAllCause(effect, cause => core.failCause(scheduleDefectRefailCause(cause)`

JSDoc:

@internal */
const scheduleDefectRefailCause = cause => Option.match(internalCause.find(cause, _ => internalCause.isDieType(_) && isScheduleDefect(_.defect) ? Option.some(_.defect) : Option.none()), {
  onNone: () => cause,
  onSome: error => internalCause.fail(error.error)
});
/** @internal

## scheduleDefectRefail

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `scheduleDefectRefail(= scheduleDefectRefail;
const repeat_Effect = exports.repeat_Effect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fromRetryOptions

Source: `my-backend/node_modules/effect/dist/cjs/internal/schedule.js`

Signature: `fromRetryOptions(= fromRetryOptions;
const retryOrElse_Effect = exports.retryOrElse_Effect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const repeat_combined = exports.repeat_combined = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough(forever);
  const withWhile = options.while ? whileInputEffect(base, a => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return core.succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, a => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return core.succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect(withUntil, recurs(options.times)).pipe(map(intersectionPair => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
/** @internal */
const repeatOrElse_Effect = exports.repeatOrElse_Effect = /*#__PURE__*/(0, _Function.dual)(3, (self, schedule, orElse) => core.flatMap(driver(schedule), driver => core.matchEffect(self, {
  onFailure: error => orElse(error, Option.none()),
  onSuccess: value => repeatOrElseEffectLoop(effect.provideServiceEffect(self, CurrentIterationMetadata, ref.get(driver.iterationMeta)), driver, (error, option) => effect.provideServiceEffect(orElse(error, option), CurrentIterationMetadata, ref.get(driver.iterationMeta)), value)
})));
/** @internal */
const repeatOrElseEffectLoop = (self, driver, orElse, value) => core.matchEffect(driver.next(value), {
  onFailure: () => core.orDie(driver.last),
  onSuccess: b => core.matchEffect(self, {
    onFailure: error => orElse(error, Option.some(b)),
    onSuccess: value => repeatOrElseEffectLoop(self, driver, orElse, value)
  })
});
/** @internal */
const retry_Effect = exports.retry_Effect = /*#__PURE__*/(0, _Function.dual)(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => core.fail(e)));
/** @internal */
const retry_combined = exports.retry_combined = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
/** @internal */
const fromRetryOptions = options => {
  const base = options.schedule ?? forever;
  const withWhile = options.while ? whileInputEffect(base, e => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return core.succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, e => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return core.succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect(withUntil, recurs(options.times)) : withUntil;
};
/** @internal

## getArbitraryUnsupportedErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getArbitraryUnsupportedErrorMessage(= getArbitraryUnsupportedErrorMessage;
const getArbitraryMissingAnnotationErrorMessage = (path, ast)`

JSDoc:

@internal */
const getInvalidArgumentErrorMessage = details => getErrorMessage("Invalid Argument", details);
exports.getInvalidArgumentErrorMessage = getInvalidArgumentErrorMessage;
const getUnsupportedSchemaErrorMessage = (details, path, ast) => getErrorMessage("Unsupported schema", details, path, ast);
const getMissingAnnotationErrorMessage = (details, path, ast) => getErrorMessage("Missing annotation", details, path, ast);
// ---------------------------------------------
// Arbitrary
// ---------------------------------------------
/** @internal */
const getArbitraryUnsupportedErrorMessage = (path, ast) => getUnsupportedSchemaErrorMessage("Cannot build an Arbitrary for this schema", path, ast);
/** @internal

## getArbitraryMissingAnnotationErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getArbitraryMissingAnnotationErrorMessage(= getArbitraryMissingAnnotationErrorMessage;
const getArbitraryEmptyEnumErrorMessage = path => getErrorMessage("Empty Enums schema", "Generating an Arbitrary for this schema requires at least one enum", path)`

JSDoc:

@internal

## getArbitraryEmptyEnumErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getArbitraryEmptyEnumErrorMessage(= getArbitraryEmptyEnumErrorMessage;
const getEquivalenceUnsupportedErrorMessage = (ast, path)`

JSDoc:

@internal

## getEquivalenceUnsupportedErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getEquivalenceUnsupportedErrorMessage(= getEquivalenceUnsupportedErrorMessage;
const getJSONSchemaMissingAnnotationErrorMessage = (path, ast)`

JSDoc:

@internal

## getJSONSchemaMissingAnnotationErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getJSONSchemaMissingAnnotationErrorMessage(= getJSONSchemaMissingAnnotationErrorMessage;
const getJSONSchemaMissingIdentifierAnnotationErrorMessage = (path, ast)`

JSDoc:

@internal

## getJSONSchemaMissingIdentifierAnnotationErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getJSONSchemaMissingIdentifierAnnotationErrorMessage(= getJSONSchemaMissingIdentifierAnnotationErrorMessage;
const getJSONSchemaUnsupportedPostRestElementsErrorMessage = path => getErrorMessage("Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request", undefined, path)`

JSDoc:

@internal

## getJSONSchemaUnsupportedPostRestElementsErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getJSONSchemaUnsupportedPostRestElementsErrorMessage(= getJSONSchemaUnsupportedPostRestElementsErrorMessage;
const getJSONSchemaUnsupportedKeyErrorMessage = (key, path)`

JSDoc:

@internal

## getJSONSchemaUnsupportedKeyErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getJSONSchemaUnsupportedKeyErrorMessage(= getJSONSchemaUnsupportedKeyErrorMessage;
const getPrettyMissingAnnotationErrorMessage = (path, ast)`

JSDoc:

@internal

## getPrettyMissingAnnotationErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getPrettyMissingAnnotationErrorMessage(= getPrettyMissingAnnotationErrorMessage;
const getPrettyNeverErrorMessage = exports.getPrettyNeverErrorMessage = "Cannot pretty print a `never` value";
/** @internal */
const getPrettyNoMatchingSchemaErrorMessage = (actual, path, ast)`

JSDoc:

@internal

## getPrettyNoMatchingSchemaErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getPrettyNoMatchingSchemaErrorMessage(= getPrettyNoMatchingSchemaErrorMessage;
const getSchemaExtendErrorMessage = (x, y, path)`

JSDoc:

@internal

## getSchemaExtendErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getSchemaExtendErrorMessage(= getSchemaExtendErrorMessage;
const getSchemaUnsupportedLiteralSpanErrorMessage = ast => getErrorMessage("Unsupported template literal span", undefined, undefined, ast)`

JSDoc:

@internal

## getSchemaUnsupportedLiteralSpanErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getSchemaUnsupportedLiteralSpanErrorMessage(= getSchemaUnsupportedLiteralSpanErrorMessage;
const getASTUnsupportedSchemaErrorMessage = ast => getUnsupportedSchemaErrorMessage(undefined, undefined, ast)`

JSDoc:

@internal

## getASTUnsupportedSchemaErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getASTUnsupportedSchemaErrorMessage(= getASTUnsupportedSchemaErrorMessage;
const getASTUnsupportedKeySchemaErrorMessage = ast => getErrorMessage("Unsupported key schema", undefined, undefined, ast)`

JSDoc:

@internal

## getASTUnsupportedKeySchemaErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getASTUnsupportedKeySchemaErrorMessage(= getASTUnsupportedKeySchemaErrorMessage;
const getASTUnsupportedLiteralErrorMessage = literal => getErrorMessage("Unsupported literal", `literal value: ${util_.formatUnknown(literal)`

JSDoc:

@internal

## getASTUnsupportedLiteralErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getASTUnsupportedLiteralErrorMessage(= getASTUnsupportedLiteralErrorMessage;
const getASTDuplicateIndexSignatureErrorMessage = type => getErrorMessage("Duplicate index signature", `${type} index signature`)`

JSDoc:

@internal

## getASTDuplicateIndexSignatureErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getASTDuplicateIndexSignatureErrorMessage(= getASTDuplicateIndexSignatureErrorMessage;
const getASTIndexSignatureParameterErrorMessage = exports.getASTIndexSignatureParameterErrorMessage = /*#__PURE__*/getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types")`

JSDoc:

@internal

## getASTDuplicatePropertySignatureTransformationErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getASTDuplicatePropertySignatureTransformationErrorMessage(= getASTDuplicatePropertySignatureTransformationErrorMessage;
const getASTUnsupportedRenameSchemaErrorMessage = ast => getUnsupportedSchemaErrorMessage(undefined, undefined, ast)`

JSDoc:

@internal */
const getASTRequiredElementFollowinAnOptionalElementErrorMessage = exports.getASTRequiredElementFollowinAnOptionalElementErrorMessage = /*#__PURE__*/getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
/** @internal */
const getASTDuplicatePropertySignatureTransformationErrorMessage = key => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${util_.formatUnknown(key)}`);
/** @internal

## getASTUnsupportedRenameSchemaErrorMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/errors.js`

Signature: `getASTUnsupportedRenameSchemaErrorMessage(= getASTUnsupportedRenameSchemaErrorMessage;
const getASTDuplicatePropertySignatureErrorMessage = key => getErrorMessage("Duplicate property signature", `Duplicate key ${util_.formatUnknown(key)`

JSDoc:

@internal

## getKeysForIndexSignature

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `getKeysForIndexSignature(= getKeysForIndexSignature;
const ownKeys = o => Object.keys(o)`

JSDoc:

@internal */
const getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
/**
JavaScript does not store the insertion order of properties in a way that
combines both string and symbol keys. The internal order groups string keys
and symbol keys separately. Hence concatenating the keys is fine.

@internal

## ownKeys

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `ownKeys(= ownKeys;
const memoizeThunk = f => {
  let done = false;
  let a;
  return ()`

JSDoc:

@internal

## memoizeThunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `memoizeThunk(= memoizeThunk;
const formatDate = date => {
  try {
    return date.toISOString()`

JSDoc:

@internal

## formatDate

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `formatDate(= formatDate;
const formatUnknown = (u, checkCircular = true)`

JSDoc:

@internal

## formatUnknown

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `formatUnknown(= formatUnknown;
const formatPropertyKey = name => typeof name === "string" ? JSON.stringify(name)`

JSDoc:

@internal

## formatPropertyKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `formatPropertyKey(= formatPropertyKey;
const isNonEmpty = x => Array.isArray(x)`

JSDoc:

@internal

## isNonEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `isNonEmpty(= isNonEmpty;
const isSingle = x => !Array.isArray(x)`

JSDoc:

@internal

## isSingle

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `isSingle(= isSingle;
const formatPathKey = key => `[${formatPropertyKey(key)`

JSDoc:

@internal

## formatPathKey

Source: `my-backend/node_modules/effect/dist/cjs/internal/schema/util.js`

Signature: `formatPathKey(= formatPathKey;
const formatPath = path => isNonEmpty(path)`

JSDoc:

@internal

## makeCacheState

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedCache.js`

Signature: `makeCacheState(= makeCacheState;
const initialCacheState = ()`

JSDoc:

@internal */
const makeCacheState = (map, keys, accesses, updating, hits, misses) => ({
  map,
  keys,
  accesses,
  updating,
  hits,
  misses
});
/**
Constructs an initial cache state.

@internal

## initialCacheState

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedCache.js`

Signature: `initialCacheState(= initialCacheState;
const complete = (key, exit, ownerCount, entryStats, timeToLive)`

JSDoc:

@internal

## complete

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedCache.js`

Signature: `complete(= complete;
const pending = (key, scoped)`

JSDoc:

@internal

## pending

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedCache.js`

Signature: `pending(= pending;
const refreshing = (scoped, complete)`

JSDoc:

@internal

## refreshing

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedCache.js`

Signature: `refreshing(= refreshing;
const toScoped = self => Exit.matchEffect(self.exit, {
  onFailure: cause => core.failCause(cause)`

JSDoc:

@internal

## toScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedCache.js`

Signature: `toScoped(= toScoped;
const releaseOwner = self => Exit.matchEffect(self.exit, {
  onFailure: ()`

JSDoc:

@internal

## releaseOwner

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedCache.js`

Signature: `releaseOwner(= releaseOwner;
const ScopedCacheSymbolKey = "effect/ScopedCache";
/** @internal */
const ScopedCacheTypeId = exports.ScopedCacheTypeId = /*#__PURE__*/Symbol.for(ScopedCacheSymbolKey)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedCache.js`

Signature: `make(= make;
const makeWith = options => core.flatMap(effect.clock, clock => buildWith(options.capacity, options.lookup, clock, exit => Duration.decode(options.timeToLive(exit)`

JSDoc:

@internal */
const make = options => {
  const timeToLive = Duration.decode(options.timeToLive);
  return makeWith({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
/** @internal

## fromAcquire

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedRef.js`

Signature: `fromAcquire(= fromAcquire;
const get = self => core.map(ref.get(self.ref)`

JSDoc:

@internal */
const ScopedRefSymbolKey = "effect/ScopedRef";
/** @internal */
const ScopedRefTypeId = exports.ScopedRefTypeId = /*#__PURE__*/Symbol.for(ScopedRefSymbolKey);
/** @internal */
const scopedRefVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal  */
const proto = {
  ...effectable.CommitPrototype,
  commit() {
    return get(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
};
/** @internal  */
const close = self => core.flatMap(ref.get(self.ref), tuple => tuple[0].close(core.exitVoid));
/** @internal */
const fromAcquire = acquire => core.uninterruptible(fiberRuntime.scopeMake().pipe(core.flatMap(newScope => acquire.pipe(core.mapInputContext(Context.add(fiberRuntime.scopeTag, newScope)), core.onError(cause => newScope.close(core.exitFail(cause))), core.flatMap(value => circular.makeSynchronized([newScope, value]).pipe(core.flatMap(ref => {
  const scopedRef = Object.create(proto);
  scopedRef.ref = ref;
  return (0, _Function.pipe)(fiberRuntime.addFinalizer(() => close(scopedRef)), core.as(scopedRef));
})))))));
/** @internal

## get

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedRef.js`

Signature: `get(= get;
const make = evaluate => fromAcquire(core.sync(evaluate)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/scopedRef.js`

Signature: `make(= make;
const set = exports.set = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/secret.js`

Signature: `make(= make;
const fromIterable = iterable => make(Arr.fromIterable(iterable)`

JSDoc:

@internal
@deprecated
/
const SecretSymbolKey = "effect/Secret";
/**
@internal
@deprecated
/
const SecretTypeId = exports.SecretTypeId = /*#__PURE__*/Symbol.for(SecretSymbolKey);
/**
@internal
@deprecated
/
const isSecret = u => (0, _Predicate.hasProperty)(u, SecretTypeId);
exports.isSecret = isSecret;
const SecretProto = {
  ...redacted_.proto,
  [SecretTypeId]: SecretTypeId
};
/**
@internal
@deprecated
/
const make = bytes => {
  const secret = Object.create(SecretProto);
  Object.defineProperty(secret, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret, "raw", {
    enumerable: false,
    value: bytes
  });
  redacted_.redactedRegistry.set(secret, bytes.map(byte => String.fromCharCode(byte)).join(""));
  return secret;
};
/**
@internal
@deprecated

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/secret.js`

Signature: `fromIterable(= fromIterable;
const fromString = text => {
  return make(text.split("")`

JSDoc:

@internal
@deprecated

## fromString

Source: `my-backend/node_modules/effect/dist/cjs/internal/secret.js`

Signature: `fromString(= fromString;
const value = self => {
  return self.raw.map(byte => String.fromCharCode(byte)`

JSDoc:

@internal
@deprecated

## value

Source: `my-backend/node_modules/effect/dist/cjs/internal/secret.js`

Signature: `value(= value;
const unsafeWipe = self => {
  for (let i = 0; i < self.raw.length; i++)`

JSDoc:

@internal
@deprecated

## SinkImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `SinkImpl(= SinkImpl;
const isSink = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const SinkTypeId = exports.SinkTypeId = /*#__PURE__*/Symbol.for("effect/Sink");
const sinkVariance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _In: _ => _,
  /* c8 ignore next */
  _L: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _R: _ => _
};
/** @internal */
class SinkImpl {
  channel;
  [SinkTypeId] = sinkVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## isSink

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `isSink(= isSink;
const suspend = evaluate => new SinkImpl(core.suspend(()`

JSDoc:

@internal

## suspend

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `suspend(= suspend;
const as = exports.as = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## collectAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAll(= collectAll;
const collectAllLoop = acc => core.readWithCause({
  onInput: chunk => collectAllLoop((0, _Function.pipe)`

JSDoc:

@internal */
const collectAll = () => new SinkImpl(collectAllLoop(Chunk.empty()));
/** @internal

## collectAllN

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllN(= collectAllN;
const collectAllNLoop = (n, acc)`

JSDoc:

@internal */
const collectAllN = n => suspend(() => fromChannel(collectAllNLoop(n, Chunk.empty())));
/** @internal

## collectAllFrom

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllFrom(= collectAllFrom;
const collectAllToMap = (key, merge)`

JSDoc:

@internal */
const collectAllFrom = self => collectAllWhileWith(self, {
  initial: Chunk.empty(),
  while: _Function.constTrue,
  body: (chunk, a) => (0, _Function.pipe)(chunk, Chunk.append(a))
});
/** @internal

## collectAllToMap

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllToMap(= collectAllToMap;
const collectAllToMapN = (n, key, merge)`

JSDoc:

@internal

## collectAllToMapN

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllToMapN(= collectAllToMapN;
const collectAllToSet = ()`

JSDoc:

@internal

## collectAllToSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllToSet(= collectAllToSet;
const collectAllToSetN = n => foldWeighted({
  initial: HashSet.empty()`

JSDoc:

@internal

## collectAllToSetN

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllToSetN(= collectAllToSetN;
const collectAllUntil = p => {
  return (0, _Function.pipe)`

JSDoc:

@internal

## collectAllUntil

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllUntil(= collectAllUntil;
const collectAllUntilEffect = p => {
  return (0, _Function.pipe)`

JSDoc:

@internal

## collectAllUntilEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllUntilEffect(= collectAllUntilEffect;
const collectAllWhile = predicate => fromChannel(collectAllWhileReader(predicate, Chunk.empty()`

JSDoc:

@internal

## collectAllWhile

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllWhile(= collectAllWhile;
const collectAllWhileReader = (predicate, done)`

JSDoc:

@internal

## collectAllWhileEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectAllWhileEffect(= collectAllWhileEffect;
const collectAllWhileEffectReader = (predicate, done)`

JSDoc:

@internal */
const collectAllWhileEffect = predicate => fromChannel(collectAllWhileEffectReader(predicate, Chunk.empty()));
/** @internal

## collectLeftover

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `collectLeftover(= collectLeftover;
const mapInput = exports.mapInput = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const collectAllWhileWith = exports.collectAllWhileWith = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const refs = (0, _Function.pipe)(Ref.make(Chunk.empty()), Effect.zip(Ref.make(false)));
  const newChannel = (0, _Function.pipe)(core.fromEffect(refs), core.flatMap(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = core.readWith({
      onInput: input => (0, _Function.pipe)(core.write(input), core.flatMap(() => upstreamMarker)),
      onFailure: core.fail,
      onDone: done => (0, _Function.pipe)(core.fromEffect(Ref.set(upstreamDoneRef, true)), channel.as(done))
    });
    return (0, _Function.pipe)(upstreamMarker, core.pipeTo(channel.bufferChunk(leftoversRef)), core.pipeTo(collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body)));
  }));
  return new SinkImpl(newChannel);
});
const collectAllWhileWithLoop = (self, leftoversRef, upstreamDoneRef, currentResult, p, f) => {
  return (0, _Function.pipe)(toChannel(self), channel.doneCollect, channel.foldChannel({
    onFailure: core.fail,
    onSuccess: ([leftovers, doneValue]) => p(doneValue) ? (0, _Function.pipe)(core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers))), core.flatMap(() => (0, _Function.pipe)(core.fromEffect(Ref.get(upstreamDoneRef)), core.flatMap(upstreamDone => {
      const accumulatedResult = f(currentResult, doneValue);
      return upstreamDone ? (0, _Function.pipe)(core.write(Chunk.flatten(leftovers)), channel.as(accumulatedResult)) : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f);
    })))) : (0, _Function.pipe)(core.write(Chunk.flatten(leftovers)), channel.as(currentResult))
  }));
};
/** @internal */
const collectLeftover = self => new SinkImpl((0, _Function.pipe)(core.collectElements(toChannel(self)), channel.map(([chunks, z]) => [z, Chunk.flatten(chunks)])));
/** @internal

## die

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `die(= die;
const dieMessage = message => failCause(Cause.die(new Cause.RuntimeException(message)`

JSDoc:

@internal */
const mapInputEffect = exports.mapInputEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapInputChunksEffect(self, chunk => Effect.map(Effect.forEach(chunk, v => f(v)), Chunk.unsafeFromArray)));
/** @internal */
const mapInputChunks = exports.mapInputChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = core.readWith({
    onInput: chunk => (0, _Function.pipe)(core.write(f(chunk)), core.flatMap(() => loop)),
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new SinkImpl((0, _Function.pipe)(loop, core.pipeTo(toChannel(self))));
});
/** @internal */
const mapInputChunksEffect = exports.mapInputChunksEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = core.readWith({
    onInput: chunk => (0, _Function.pipe)(core.fromEffect(f(chunk)), core.flatMap(core.write), core.flatMap(() => loop)),
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new SinkImpl((0, _Function.pipe)(loop, channel.pipeToOrFail(toChannel(self))));
});
/** @internal */
const die = defect => failCause(Cause.die(defect));
/** @internal

## dieMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `dieMessage(= dieMessage;
const dieSync = evaluate => failCauseSync(()`

JSDoc:

@internal

## dieSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `dieSync(= dieSync;
const dimap = exports.dimap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## drop

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `drop(= drop;
const dropLoop = n => core.readWith({
  onInput: input => {
    const dropped = (0, _Function.pipe)`

JSDoc:

@internal */
const dimapEffect = exports.dimapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => mapEffect(mapInputEffect(self, options.onInput), options.onDone));
/** @internal */
const dimapChunks = exports.dimapChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => map(mapInputChunks(self, options.onInput), options.onDone));
/** @internal */
const dimapChunksEffect = exports.dimapChunksEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => mapEffect(mapInputChunksEffect(self, options.onInput), options.onDone));
/** @internal */
const drain = exports.drain = /*#__PURE__*/new SinkImpl(/*#__PURE__*/channel.drain(/*#__PURE__*/channel.identityChannel()));
/** @internal */
const drop = n => suspend(() => new SinkImpl(dropLoop(n)));
/** @internal

## dropUntil

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `dropUntil(= dropUntil;
const dropUntilEffect = predicate => suspend(()`

JSDoc:

@internal */
const dropUntil = predicate => new SinkImpl((0, _Function.pipe)(toChannel(dropWhile(input => !predicate(input))), channel.pipeToOrFail(toChannel(drop(1)))));
/** @internal

## dropUntilEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `dropUntilEffect(= dropUntilEffect;
const dropUntilEffectReader = predicate => core.readWith({
  onInput: input => (0, _Function.pipe)`

JSDoc:

@internal

## dropWhile

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `dropWhile(= dropWhile;
const dropWhileReader = predicate => core.readWith({
  onInput: input => {
    const out = (0, _Function.pipe)`

JSDoc:

@internal */
const dropWhile = predicate => new SinkImpl(dropWhileReader(predicate));
/** @internal

## dropWhileEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `dropWhileEffect(= dropWhileEffect;
const dropWhileEffectReader = predicate => core.readWith({
  onInput: input => (0, _Function.pipe)`

JSDoc:

@internal */
const dropWhileEffect = predicate => suspend(() => new SinkImpl(dropWhileEffectReader(predicate)));
/** @internal

## context

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `context(= context;
const contextWith = f => (0, _Function.pipe)`

JSDoc:

@internal */
const ensuring = exports.ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new SinkImpl((0, _Function.pipe)(self, toChannel, channel.ensuring(finalizer))));
/** @internal */
const ensuringWith = exports.ensuringWith = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new SinkImpl((0, _Function.pipe)(self, toChannel, core.ensuringWith(finalizer))));
/** @internal */
const context = () => fromEffect(Effect.context());
/** @internal

## contextWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `contextWith(= contextWith;
const contextWithEffect = f => (0, _Function.pipe)`

JSDoc:

@internal

## contextWithEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `contextWithEffect(= contextWithEffect;
const contextWithSink = f => new SinkImpl(channel.unwrap((0, _Function.pipe)`

JSDoc:

@internal

## contextWithSink

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `contextWithSink(= contextWithSink;
const every = predicate => fold(true, _Function.identity, (acc, input)`

JSDoc:

@internal

## every

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `every(= every;
const fail = e => new SinkImpl(core.fail(e)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `fail(= fail;
const failSync = evaluate => new SinkImpl(core.failSync(evaluate)`

JSDoc:

@internal

## failSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `failSync(= failSync;
const failCause = cause => new SinkImpl(core.failCause(cause)`

JSDoc:

@internal

## failCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `failCause(= failCause;
const failCauseSync = evaluate => new SinkImpl(core.failCauseSync(evaluate)`

JSDoc:

@internal

## failCauseSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `failCauseSync(= failCauseSync;
const filterInput = f => {
  return self => (0, _Function.pipe)`

JSDoc:

@internal

## filterInput

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `filterInput(= filterInput;
const filterInputEffect = exports.filterInputEffect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fold

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `fold(= fold;
const foldReader = (s, contFn, f)`

JSDoc:

@internal */
const findEffect = exports.findEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const newChannel = (0, _Function.pipe)(core.fromEffect((0, _Function.pipe)(Ref.make(Chunk.empty()), Effect.zip(Ref.make(false)))), core.flatMap(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = core.readWith({
      onInput: input => (0, _Function.pipe)(core.write(input), core.flatMap(() => upstreamMarker)),
      onFailure: core.fail,
      onDone: done => (0, _Function.pipe)(core.fromEffect(Ref.set(upstreamDoneRef, true)), channel.as(done))
    });
    const loop = channel.foldChannel(core.collectElements(toChannel(self)), {
      onFailure: core.fail,
      onSuccess: ([leftovers, doneValue]) => (0, _Function.pipe)(core.fromEffect(f(doneValue)), core.flatMap(satisfied => (0, _Function.pipe)(core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers))), channel.zipRight((0, _Function.pipe)(core.fromEffect(Ref.get(upstreamDoneRef)), core.flatMap(upstreamDone => {
        if (satisfied) {
          return (0, _Function.pipe)(core.write(Chunk.flatten(leftovers)), channel.as(Option.some(doneValue)));
        }
        if (upstreamDone) {
          return (0, _Function.pipe)(core.write(Chunk.flatten(leftovers)), channel.as(Option.none()));
        }
        return loop;
      }))))))
    });
    return (0, _Function.pipe)(upstreamMarker, core.pipeTo(channel.bufferChunk(leftoversRef)), core.pipeTo(loop));
  }));
  return new SinkImpl(newChannel);
});
/** @internal */
const fold = (s, contFn, f) => suspend(() => new SinkImpl(foldReader(s, contFn, f)));
/** @internal

## foldChunks

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldChunks(= foldChunks;
const foldChunksReader = (s, contFn, f)`

JSDoc:

@internal */
const foldChunkSplit = (s, chunk, contFn, f, index, length) => {
  if (index === length) {
    return [s, Chunk.empty()];
  }
  const s1 = f(s, (0, _Function.pipe)(chunk, Chunk.unsafeGet(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk, contFn, f, index + 1, length);
  }
  return [s1, (0, _Function.pipe)(chunk, Chunk.drop(index + 1))];
};
/** @internal */
const foldSink = exports.foldSink = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const newChannel = (0, _Function.pipe)(toChannel(self), core.collectElements, channel.foldChannel({
    onFailure: error => toChannel(options.onFailure(error)),
    onSuccess: ([leftovers, z]) => core.suspend(() => {
      const leftoversRef = {
        ref: (0, _Function.pipe)(leftovers, Chunk.filter(Chunk.isNonEmpty))
      };
      const refReader = (0, _Function.pipe)(core.sync(() => {
        const ref = leftoversRef.ref;
        leftoversRef.ref = Chunk.empty();
        return ref;
      }),
      // This cast is safe because of the L1 >: L <: In1 bound. It follows that
      // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
      core.flatMap(chunk => channel.writeChunk(chunk)));
      const passthrough = channel.identityChannel();
      const continuationSink = (0, _Function.pipe)(refReader, channel.zipRight(passthrough), core.pipeTo(toChannel(options.onSuccess(z))));
      return core.flatMap(core.collectElements(continuationSink), ([newLeftovers, z1]) => (0, _Function.pipe)(core.succeed(leftoversRef.ref), core.flatMap(channel.writeChunk), channel.zipRight(channel.writeChunk(newLeftovers)), channel.as(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
/** @internal */
const foldChunks = (s, contFn, f) => suspend(() => new SinkImpl(foldChunksReader(s, contFn, f)));
/** @internal

## foldChunksEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldChunksEffect(= foldChunksEffect;
const foldChunksEffectReader = (s, contFn, f)`

JSDoc:

@internal */
const foldChunksEffect = (s, contFn, f) => suspend(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)));
/** @internal

## foldEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldEffect(= foldEffect;
const foldEffectReader = (s, contFn, f)`

JSDoc:

@internal */
const foldEffect = (s, contFn, f) => suspend(() => new SinkImpl(foldEffectReader(s, contFn, f)));
/** @internal

## foldLeft

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldLeft(= foldLeft;
const foldLeftChunks = (s, f)`

JSDoc:

@internal */
const foldChunkSplitEffect = (s, chunk, contFn, f) => foldChunkSplitEffectInternal(s, chunk, 0, chunk.length, contFn, f);
/** @internal */
const foldChunkSplitEffectInternal = (s, chunk, index, length, contFn, f) => {
  if (index === length) {
    return Effect.succeed([s, Option.none()]);
  }
  return (0, _Function.pipe)(f(s, (0, _Function.pipe)(chunk, Chunk.unsafeGet(index))), Effect.flatMap(s1 => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk, index + 1, length, contFn, f) : Effect.succeed([s1, Option.some((0, _Function.pipe)(chunk, Chunk.drop(index + 1)))])));
};
/** @internal */
const foldLeft = (s, f) => ignoreLeftover(fold(s, _Function.constTrue, f));
/** @internal

## foldLeftChunks

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldLeftChunks(= foldLeftChunks;
const foldLeftChunksEffect = (s, f)`

JSDoc:

@internal

## foldLeftChunksEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldLeftChunksEffect(= foldLeftChunksEffect;
const foldLeftEffect = (s, f)`

JSDoc:

@internal

## foldLeftEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldLeftEffect(= foldLeftEffect;
const foldUntil = (s, max, f)`

JSDoc:

@internal

## foldUntil

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldUntil(= foldUntil;
const foldUntilEffect = (s, max, f)`

JSDoc:

@internal

## foldUntilEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldUntilEffect(= foldUntilEffect;
const foldWeighted = options => foldWeightedDecompose({
  ...options,
  decompose: Chunk.of
})`

JSDoc:

@internal

## foldWeighted

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldWeighted(= foldWeighted;
const foldWeightedDecompose = options => suspend(()`

JSDoc:

@internal

## foldWeightedDecompose

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldWeightedDecompose(= foldWeightedDecompose;
const foldWeightedDecomposeLoop = (s, cost, dirty, max, costFn, decompose, f)`

JSDoc:

@internal

## foldWeightedDecomposeEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `foldWeightedDecomposeEffect(= foldWeightedDecomposeEffect;
const foldWeightedEffect = options => foldWeightedDecomposeEffect({
  ...options,
  decompose: input => Effect.succeed(Chunk.of(input)`

JSDoc:

@internal */
const foldWeightedDecomposeFold = (input, index, s, cost, dirty, max, costFn, decompose, f) => {
  if (index === input.length) {
    return [s, cost, dirty, Chunk.empty()];
  }
  const elem = (0, _Function.pipe)(input, Chunk.unsafeGet(index));
  const total = cost + costFn(s, elem);
  if (total <= max) {
    return foldWeightedDecomposeFold(input, index + 1, f(s, elem), total, true, max, costFn, decompose, f);
  }
  const decomposed = decompose(elem);
  if (decomposed.length <= 1 && !dirty) {
    // If `elem` cannot be decomposed, we need to cross the `max` threshold. To
    // minimize "injury", we only allow this when we haven't added anything else
    // to the aggregate (dirty = false).
    return [f(s, elem), total, true, (0, _Function.pipe)(input, Chunk.drop(index + 1))];
  }
  if (decomposed.length <= 1 && dirty) {
    // If the state is dirty and `elem` cannot be decomposed, we stop folding
    // and include `elem` in the leftovers.
    return [s, cost, dirty, (0, _Function.pipe)(input, Chunk.drop(index))];
  }
  // `elem` got decomposed, so we will recurse with the decomposed elements pushed
  // into the chunk we're processing and see if we can aggregate further.
  const next = (0, _Function.pipe)(decomposed, Chunk.appendAll((0, _Function.pipe)(input, Chunk.drop(index + 1))));
  return foldWeightedDecomposeFold(next, 0, s, cost, dirty, max, costFn, decompose, f);
};
/** @internal */
const foldWeightedDecomposeEffect = options => suspend(() => new SinkImpl(foldWeightedDecomposeEffectLoop(options.initial, options.maxCost, options.cost, options.decompose, options.body, 0, false)));
/** @internal

## forEach

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `forEach(= forEach;
const forEachChunk = f => {
  const process = core.readWithCause({
    onInput: input => (0, _Function.pipe)`

JSDoc:

@internal */
const foldWeightedDecomposeEffectFold = (s, max, costFn, decompose, f, input, dirty, cost, index) => {
  if (index === input.length) {
    return Effect.succeed([s, cost, dirty, Chunk.empty()]);
  }
  const elem = (0, _Function.pipe)(input, Chunk.unsafeGet(index));
  return (0, _Function.pipe)(costFn(s, elem), Effect.map(newCost => cost + newCost), Effect.flatMap(total => {
    if (total <= max) {
      return (0, _Function.pipe)(f(s, elem), Effect.flatMap(s => foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, true, total, index + 1)));
    }
    return (0, _Function.pipe)(decompose(elem), Effect.flatMap(decomposed => {
      if (decomposed.length <= 1 && !dirty) {
        // If `elem` cannot be decomposed, we need to cross the `max` threshold. To
        // minimize "injury", we only allow this when we haven't added anything else
        // to the aggregate (dirty = false).
        return (0, _Function.pipe)(f(s, elem), Effect.map(s => [s, total, true, (0, _Function.pipe)(input, Chunk.drop(index + 1))]));
      }
      if (decomposed.length <= 1 && dirty) {
        // If the state is dirty and `elem` cannot be decomposed, we stop folding
        // and include `elem` in th leftovers.
        return Effect.succeed([s, cost, dirty, (0, _Function.pipe)(input, Chunk.drop(index))]);
      }
      // `elem` got decomposed, so we will recurse with the decomposed elements pushed
      // into the chunk we're processing and see if we can aggregate further.
      const next = (0, _Function.pipe)(decomposed, Chunk.appendAll((0, _Function.pipe)(input, Chunk.drop(index + 1))));
      return foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, next, dirty, cost, 0);
    }));
  }));
};
/** @internal */
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => foldSink(self, {
  onFailure: fail,
  onSuccess: f
}));
/** @internal */
const forEach = f => {
  const process = core.readWithCause({
    onInput: input => (0, _Function.pipe)(core.fromEffect(Effect.forEach(input, v => f(v), {
      discard: true
    })), core.flatMap(() => process)),
    onFailure: core.failCause,
    onDone: () => core.void
  });
  return new SinkImpl(process);
};
/** @internal

## forEachChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `forEachChunk(= forEachChunk;
const forEachWhile = f => {
  const process = core.readWithCause({
    onInput: input => forEachWhileReader(f, input, 0, input.length, process)`

JSDoc:

@internal

## forEachWhile

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `forEachWhile(= forEachWhile;
const forEachWhileReader = (f, input, index, length, cont)`

JSDoc:

@internal

## forEachChunkWhile

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `forEachChunkWhile(= forEachChunkWhile;
const fromChannel = channel => new SinkImpl(channel)`

JSDoc:

@internal */
const forEachChunkWhile = f => {
  const reader = core.readWith({
    onInput: input => (0, _Function.pipe)(core.fromEffect(f(input)), core.flatMap(cont => cont ? reader : core.void)),
    onFailure: core.fail,
    onDone: () => core.void
  });
  return new SinkImpl(reader);
};
/** @internal

## fromChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `fromChannel(= fromChannel;
const fromEffect = effect => new SinkImpl(core.fromEffect(effect)`

JSDoc:

@internal

## fromEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `fromEffect(= fromEffect;
const fromPubSub = (pubsub, options)`

JSDoc:

@internal

## fromPubSub

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `fromPubSub(= fromPubSub;
const fromPush = push => new SinkImpl(channel.unwrapScoped((0, _Function.pipe)`

JSDoc:

@internal

## fromQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `fromQueue(= fromQueue;
const head = ()`

JSDoc:

@internal */
const fromQueue = (queue, options) => options?.shutdown ? unwrapScoped(Effect.map(Effect.acquireRelease(Effect.succeed(queue), Queue.shutdown), fromQueue)) : forEachChunk(input => (0, _Function.pipe)(Queue.offerAll(queue, input)));
/** @internal

## head

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `head(= head;
const ignoreLeftover = self => new SinkImpl(channel.drain(toChannel(self)`

JSDoc:

@internal

## ignoreLeftover

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `ignoreLeftover(= ignoreLeftover;
const last = ()`

JSDoc:

@internal

## last

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `last(= last;
const leftover = chunk => new SinkImpl(core.suspend(()`

JSDoc:

@internal

## leftover

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `leftover(= leftover;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## service

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `service(= service;
const serviceWith = (tag, f)`

JSDoc:

@internal */
const mapEffect = exports.mapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl((0, _Function.pipe)(toChannel(self), channel.mapEffect(f))));
/** @internal */
const mapError = exports.mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl((0, _Function.pipe)(toChannel(self), channel.mapError(f))));
/** @internal */
const mapLeftover = exports.mapLeftover = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new SinkImpl((0, _Function.pipe)(toChannel(self), channel.mapOut(Chunk.map(f)))));
/** @internal */
const never = exports.never = /*#__PURE__*/fromEffect(Effect.never);
/** @internal */
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new SinkImpl((0, _Function.pipe)(toChannel(self), channel.orElse(() => toChannel(that())))));
/** @internal */
const provideContext = exports.provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => new SinkImpl((0, _Function.pipe)(toChannel(self), core.provideContext(context))));
/** @internal */
const race = exports.race = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => (0, _Function.pipe)(self, raceBoth(that), map(Either.merge)));
/** @internal */
const raceBoth = exports.raceBoth = /*#__PURE__*/(0, _Function.dual)(args => isSink(args[1]), (self, that, options) => raceWith(self, {
  other: that,
  onSelfDone: selfDone => mergeDecision.Done(Effect.map(selfDone, Either.left)),
  onOtherDone: thatDone => mergeDecision.Done(Effect.map(thatDone, Either.right)),
  capacity: options?.capacity ?? 16
}));
/** @internal */
const raceWith = exports.raceWith = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  function race(scope) {
    return Effect.gen(function* () {
      const pubsub = yield* PubSub.bounded(options?.capacity ?? 16);
      const subscription1 = yield* Scope.extend(PubSub.subscribe(pubsub), scope);
      const subscription2 = yield* Scope.extend(PubSub.subscribe(pubsub), scope);
      const reader = channel.toPubSub(pubsub);
      const writer = channel.fromQueue(subscription1).pipe(core.pipeTo(toChannel(self)), channel.zipLeft(core.fromEffect(Queue.shutdown(subscription1))), channel.mergeWith({
        other: channel.fromQueue(subscription2).pipe(core.pipeTo(toChannel(options.other)), channel.zipLeft(core.fromEffect(Queue.shutdown(subscription2)))),
        onSelfDone: options.onSelfDone,
        onOtherDone: options.onOtherDone
      }));
      const racedChannel = channel.mergeWith(reader, {
        other: writer,
        onSelfDone: () => mergeDecision.Await(_Function.identity),
        onOtherDone: exit => mergeDecision.Done(exit)
      });
      return new SinkImpl(racedChannel);
    });
  }
  return unwrapScopedWith(race);
});
/** @internal */
const refineOrDie = exports.refineOrDie = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => (0, _Function.pipe)(self, refineOrDieWith(pf, _Function.identity)));
/** @internal */
const refineOrDieWith = exports.refineOrDieWith = /*#__PURE__*/(0, _Function.dual)(3, (self, pf, f) => {
  const newChannel = (0, _Function.pipe)(self, toChannel, channel.catchAll(error => Option.match(pf(error), {
    onNone: () => core.failCauseSync(() => Cause.die(f(error))),
    onSome: core.fail
  })));
  return new SinkImpl(newChannel);
});
/** @internal */
const service = tag => serviceWith(tag, _Function.identity);
/** @internal

## serviceWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `serviceWith(= serviceWith;
const serviceWithEffect = (tag, f)`

JSDoc:

@internal

## serviceWithEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `serviceWithEffect(= serviceWithEffect;
const serviceWithSink = (tag, f)`

JSDoc:

@internal

## serviceWithSink

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `serviceWithSink(= serviceWithSink;
const some = predicate => fold(false, bool => !bool, (acc, input)`

JSDoc:

@internal

## some

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `some(= some;
const splitWhere = exports.splitWhere = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## succeed

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `succeed(= succeed;
const sum = exports.sum = /*#__PURE__*/foldLeftChunks(0, (acc, chunk)`

JSDoc:

@internal */
const splitWhereSplitter = (written, leftovers, f) => core.readWithCause({
  onInput: input => {
    if (Chunk.isEmpty(input)) {
      return splitWhereSplitter(written, leftovers, f);
    }
    if (written) {
      const index = indexWhere(input, f);
      if (index === -1) {
        return channel.zipRight(core.write(input), splitWhereSplitter(true, leftovers, f));
      }
      const [left, right] = Chunk.splitAt(input, index);
      return channel.zipRight(core.write(left), core.fromEffect(Ref.set(leftovers, right)));
    }
    const index = indexWhere(input, f, 1);
    if (index === -1) {
      return channel.zipRight(core.write(input), splitWhereSplitter(true, leftovers, f));
    }
    const [left, right] = (0, _Function.pipe)(input, Chunk.splitAt(Math.max(index, 1)));
    return channel.zipRight(core.write(left), core.fromEffect(Ref.set(leftovers, right)));
  },
  onFailure: core.failCause,
  onDone: core.succeed
});
/** @internal */
const indexWhere = (self, predicate, from = 0) => {
  const iterator = self[Symbol.iterator]();
  let index = 0;
  let result = -1;
  let next;
  while (result < 0 && (next = iterator.next()) && !next.done) {
    const a = next.value;
    if (index >= from && predicate(a)) {
      result = index;
    }
    index = index + 1;
  }
  return result;
};
/** @internal */
const succeed = a => new SinkImpl(core.succeed(a));
/** @internal

## sync

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `sync(= sync;
const take = n => (0, _Function.pipe)`

JSDoc:

@internal */
const summarized = exports.summarized = /*#__PURE__*/(0, _Function.dual)(3, (self, summary, f) => {
  const newChannel = (0, _Function.pipe)(core.fromEffect(summary), core.flatMap(start => (0, _Function.pipe)(self, toChannel, core.flatMap(done => (0, _Function.pipe)(core.fromEffect(summary), channel.map(end => [done, f(start, end)]))))));
  return new SinkImpl(newChannel);
});
/** @internal */
const sync = evaluate => new SinkImpl(core.sync(evaluate));
/** @internal

## take

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `take(= take;
const toChannel = self => Effect.isEffect(self)`

JSDoc:

@internal

## toChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `toChannel(= toChannel;
const unwrap = effect => new SinkImpl(channel.unwrap((0, _Function.pipe)`

JSDoc:

@internal

## unwrap

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `unwrap(= unwrap;
const unwrapScoped = effect => new SinkImpl(channel.unwrapScoped(effect.pipe(Effect.map(sink => toChannel(sink)`

JSDoc:

@internal

## unwrapScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `unwrapScoped(= unwrapScoped;
const unwrapScopedWith = f => new SinkImpl(channel.unwrapScopedWith(scope => f(scope)`

JSDoc:

@internal

## unwrapScopedWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `unwrapScopedWith(= unwrapScopedWith;
const withDuration = self => (0, _Function.pipe)`

JSDoc:

@internal

## withDuration

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `withDuration(= withDuration;
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## channelToSink

Source: `my-backend/node_modules/effect/dist/cjs/internal/sink.js`

Signature: `channelToSink(= channelToSink;
const count = exports.count = /*#__PURE__*/foldLeftChunks(0, (acc, chunk)`

JSDoc:

@internal */
const zipLeft = exports.zipLeft = /*#__PURE__*/(0, _Function.dual)(args => isSink(args[1]), (self, that, options) => zipWith(self, that, (z, _) => z, options));
/** @internal */
const zipRight = exports.zipRight = /*#__PURE__*/(0, _Function.dual)(args => isSink(args[1]), (self, that, options) => zipWith(self, that, (_, z2) => z2, options));
/** @internal */
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)(args => isSink(args[1]), (self, that, f, options) => options?.concurrent ? raceWith(self, {
  other: that,
  onSelfDone: Exit.match({
    onFailure: cause => mergeDecision.Done(Effect.failCause(cause)),
    onSuccess: leftZ => mergeDecision.Await(Exit.match({
      onFailure: Effect.failCause,
      onSuccess: rightZ => Effect.succeed(f(leftZ, rightZ))
    }))
  }),
  onOtherDone: Exit.match({
    onFailure: cause => mergeDecision.Done(Effect.failCause(cause)),
    onSuccess: rightZ => mergeDecision.Await(Exit.match({
      onFailure: Effect.failCause,
      onSuccess: leftZ => Effect.succeed(f(leftZ, rightZ))
    }))
  })
}) : flatMap(self, z => map(that, z2 => f(z, z2))));
// Circular with Channel
/** @internal */
const channelToSink = self => new SinkImpl(self);
// Constants
/** @internal

## isSTM

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `isSTM(= isSTM;
const commit = self => unsafeAtomically(self, _Function.constVoid, _Function.constVoid)`

JSDoc:

@internal */
const STMSymbolKey = "effect/STM";
/** @internal */
const STMTypeId = exports.STMTypeId = /*#__PURE__*/Symbol.for(STMSymbolKey);
const stmVariance = {
  /* c8 ignore next */
  _R: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class STMPrimitive {
  effect_instruction_i0;
  _op = _effect.OP_COMMIT;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  [Effect.EffectTypeId];
  [_effectable.StreamTypeId];
  [_sink.SinkTypeId];
  [_coreStream.ChannelTypeId];
  get [STMTypeId]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[Effect.EffectTypeId] = _effectable.effectVariance;
    this[_effectable.StreamTypeId] = stmVariance;
    this[_sink.SinkTypeId] = stmVariance;
    this[_coreStream.ChannelTypeId] = stmVariance;
  }
  [Equal.symbol](that) {
    return this === that;
  }
  [Hash.symbol]() {
    return Hash.cached(this, Hash.random(this));
  }
  [Symbol.iterator]() {
    return new _singleShotGen.SingleShotGen(new _Utils.YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, _Function.constVoid, _Function.constVoid);
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal */
const isSTM = u => (0, _Predicate.hasProperty)(u, STMTypeId);
/** @internal

## commit

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `commit(= commit;
const unsafeAtomically = (self, onDone, onInterrupt)`

JSDoc:

@internal

## unsafeAtomically

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `unsafeAtomically(= unsafeAtomically;
const tryCommit = (fiberId, stm, state, env, scheduler, priority)`

JSDoc:

@internal

## context

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `context(= context;
const contextWith = f => map(context()`

JSDoc:

@internal */
const tryCommitSync = (fiberId, stm, env, scheduler, priority) => {
  const journal = new Map();
  const tExit = new STMDriver(stm, journal, fiberId, env).run();
  const analysis = Journal.analyzeJournal(journal);
  if (analysis === Journal.JournalAnalysisReadWrite && TExit.isSuccess(tExit)) {
    Journal.commitJournal(journal);
  } else if (analysis === Journal.JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case TExitOpCodes.OP_SUCCEED:
      {
        return completeTodos(Exit.succeed(tExit.value), journal, scheduler, priority);
      }
    case TExitOpCodes.OP_FAIL:
      {
        const cause = Cause.fail(tExit.error);
        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);
      }
    case TExitOpCodes.OP_DIE:
      {
        const cause = Cause.die(tExit.defect);
        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);
      }
    case TExitOpCodes.OP_INTERRUPT:
      {
        const cause = Cause.interrupt(fiberId);
        return completeTodos(Exit.failCause(cause), journal, scheduler, priority);
      }
    case TExitOpCodes.OP_RETRY:
      {
        return TryCommit.suspend(journal);
      }
  }
};
/** @internal */
const tryCommitAsync = (fiberId, self, txnId, state, context, scheduler, priority, k) => {
  if (STMState.isRunning(state.value)) {
    const result = tryCommit(fiberId, self, state, context, scheduler, priority);
    switch (result._tag) {
      case TryCommitOpCodes.OP_DONE:
        {
          completeTryCommit(result.exit, k);
          break;
        }
      case TryCommitOpCodes.OP_SUSPEND:
        {
          Journal.addTodo(txnId, result.journal, () => tryCommitAsync(fiberId, self, txnId, state, context, scheduler, priority, k));
          break;
        }
    }
  }
};
/** @internal */
const completeTodos = (exit, journal, scheduler, priority) => {
  const todos = Journal.collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => Journal.execTodos(todos), priority);
  }
  return TryCommit.done(exit);
};
/** @internal */
const completeTryCommit = (exit, k) => {
  k(exit);
};
/** @internal */
const context = () => effect((_, __, env) => env);
/** @internal

## contextWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `contextWith(= contextWith;
const contextWithSTM = f => flatMap(context()`

JSDoc:

@internal

## contextWithSTM

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `contextWithSTM(= contextWithSTM;
class STMDriver {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self, journal, fiberId, r0)`

JSDoc:

@internal

## STMDriver

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `STMDriver(= STMDriver;
const catchAll = exports.catchAll = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## die

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `die(= die;
const dieMessage = message => dieSync(()`

JSDoc:

@internal */
const mapInputContext = exports.mapInputContext = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const stm = new STMPrimitive(OpCodes.OP_PROVIDE);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
/** @internal */
const die = defect => dieSync(() => defect);
/** @internal

## dieMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `dieMessage(= dieMessage;
const dieSync = evaluate => {
  const stm = new STMPrimitive(OpCodes.OP_DIE)`

JSDoc:

@internal

## dieSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `dieSync(= dieSync;
const effect = f => withSTMRuntime(_ => succeed(f(_.journal, _.fiberId, _.getEnv()`

JSDoc:

@internal

## effect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `effect(= effect;
const ensuring = exports.ensuring = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `fail(= fail;
const failSync = evaluate => {
  const stm = new STMPrimitive(OpCodes.OP_FAIL)`

JSDoc:

@internal */
const fail = error => failSync(() => error);
/** @internal

## failSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `failSync(= failSync;
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## withSTMRuntime

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `withSTMRuntime(= withSTMRuntime;
const interrupt = exports.interrupt = /*#__PURE__*/withSTMRuntime(_ => {
  const stm = new STMPrimitive(OpCodes.OP_INTERRUPT)`

JSDoc:

@internal */
const matchSTM = exports.matchSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => (0, _Function.pipe)(self, map(Either.right), catchAll(e => (0, _Function.pipe)(onFailure(e), map(Either.left))), flatMap(either => {
  switch (either._tag) {
    case "Left":
      {
        return succeed(either.left);
      }
    case "Right":
      {
        return onSuccess(either.right);
      }
  }
})));
/** @internal */
const withSTMRuntime = f => {
  const stm = new STMPrimitive(OpCodes.OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
/** @internal

## interruptAs

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `interruptAs(= interruptAs;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const interruptAs = fiberId => {
  const stm = new STMPrimitive(OpCodes.OP_INTERRUPT);
  stm.effect_instruction_i1 = fiberId;
  return stm;
};
/** @internal

## succeed

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `succeed(= succeed;
const sync = evaluate => {
  const stm = new STMPrimitive(OpCodes.OP_SYNC)`

JSDoc:

@internal */
const orTry = exports.orTry = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => {
  const stm = new STMPrimitive(OpCodes.OP_ON_RETRY);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = that;
  return stm;
});
/** @internal */
const retry = exports.retry = /*#__PURE__*/new STMPrimitive(OpCodes.OP_RETRY);
/** @internal */
const succeed = value => {
  const stm = new STMPrimitive(OpCodes.OP_SUCCEED);
  stm.effect_instruction_i1 = value;
  return stm;
};
/** @internal

## sync

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/core.js`

Signature: `sync(= sync;
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## unsafeGet

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/entry.js`

Signature: `unsafeGet(= unsafeGet;
const unsafeSet = (self, value)`

JSDoc:

@internal */
const make = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
exports.make = make;
const unsafeGet = self => {
  return self.newValue;
};
/** @internal

## unsafeSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/entry.js`

Signature: `unsafeSet(= unsafeSet;
const commit = self => {
  self.ref.versioned = new Versioned.Versioned(self.newValue)`

JSDoc:

@internal

## commit

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/entry.js`

Signature: `commit(= commit;
const copy = self => ({
  ref: self.ref,
  isNew: self.isNew,
  isChanged: self.isChanged,
  expected: self.expected,
  newValue: self.newValue
})`

JSDoc:

@internal

## copy

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/entry.js`

Signature: `copy(= copy;
const isValid = self => {
  return self.ref.versioned === self.expected;
};
/** @internal */
exports.isValid = isValid;
const isInvalid = self => {
  return self.ref.versioned !== self.expected;
};
/** @internal */
exports.isInvalid = isInvalid;
const isChanged = self => {
  return self.isChanged;
};
exports.isChanged = isChanged;
//# sourceMappingURL=entry.js.map)`

JSDoc:

@internal

## commitJournal

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/journal.js`

Signature: `commitJournal(= commitJournal;
const analyzeJournal = journal => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal)`

JSDoc:

@internal */
const JournalAnalysisInvalid = exports.JournalAnalysisInvalid = "Invalid";
/** @internal */
const JournalAnalysisReadWrite = exports.JournalAnalysisReadWrite = "ReadWrite";
/** @internal */
const JournalAnalysisReadOnly = exports.JournalAnalysisReadOnly = "ReadOnly";
/** @internal */
const commitJournal = journal => {
  for (const entry of journal) {
    Entry.commit(entry[1]);
  }
};
/**
Analyzes the journal, determining whether it is valid and whether it is
read only in a single pass. Note that information on whether the
journal is read only will only be accurate if the journal is valid, due
to short-circuiting that occurs on an invalid journal.

@internal

## analyzeJournal

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/journal.js`

Signature: `analyzeJournal(= analyzeJournal;
const prepareResetJournal = journal => {
  const saved = new Map()`

JSDoc:

@internal

## prepareResetJournal

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/journal.js`

Signature: `prepareResetJournal(= prepareResetJournal;
const collectTodos = journal => {
  const allTodos = new Map()`

JSDoc:

@internal

## collectTodos

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/journal.js`

Signature: `collectTodos(= collectTodos;
const execTodos = todos => {
  const todosSorted = Array.from(todos.entries()`

JSDoc:

@internal

## execTodos

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/journal.js`

Signature: `execTodos(= execTodos;
const addTodo = (txnId, journal, todoEffect)`

JSDoc:

@internal

## addTodo

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/journal.js`

Signature: `addTodo(= addTodo;
const isValid = journal => {
  let valid = true;
  for (const [, entry] of journal)`

JSDoc:

@internal

## isValid

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/journal.js`

Signature: `isValid(= isValid;
const isInvalid = journal => {
  return !isValid(journal)`

JSDoc:

@internal

## asSome

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `asSome(= asSome;
const asSomeError = self => (0, _Function.pipe)`

JSDoc:

@internal */
const acquireUseRelease = exports.acquireUseRelease = /*#__PURE__*/(0, _Function.dual)(3, (acquire, use, release) => Effect.uninterruptibleMask(restore => {
  let state = STMState.running;
  return (0, _Function.pipe)(restore(core.unsafeAtomically(acquire, exit => {
    state = STMState.done(exit);
  }, () => {
    state = STMState.interrupted;
  })), Effect.matchCauseEffect({
    onFailure: cause => {
      if (STMState.isDone(state) && Exit.isSuccess(state.exit)) {
        return (0, _Function.pipe)(release(state.exit.value), Effect.matchCauseEffect({
          onFailure: cause2 => Effect.failCause(Cause.parallel(cause, cause2)),
          onSuccess: () => Effect.failCause(cause)
        }));
      }
      return Effect.failCause(cause);
    },
    onSuccess: a => (0, _Function.pipe)(restore(use(a)), Effect.matchCauseEffect({
      onFailure: cause => (0, _Function.pipe)(release(a), Effect.matchCauseEffect({
        onFailure: cause2 => Effect.failCause(Cause.parallel(cause, cause2)),
        onSuccess: () => Effect.failCause(cause)
      })),
      onSuccess: a2 => (0, _Function.pipe)(release(a), Effect.as(a2))
    }))
  }));
}));
/** @internal */
const as = exports.as = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => (0, _Function.pipe)(self, core.map(() => value)));
/** @internal */
const asSome = self => (0, _Function.pipe)(self, core.map(Option.some));
/** @internal

## asSomeError

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `asSomeError(= asSomeError;
const asVoid = self => (0, _Function.pipe)`

JSDoc:

@internal

## asVoid

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `asVoid(= asVoid;
const attempt = evaluate => suspend(()`

JSDoc:

@internal

## check

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `check(= check;
const collect = exports.collect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const catchSome = exports.catchSome = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.catchAll(self, e => Option.getOrElse(pf(e), () => core.fail(e))));
/** @internal */
const catchTag = exports.catchTag = /*#__PURE__*/(0, _Function.dual)(3, (self, k, f) => core.catchAll(self, e => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return core.fail(e);
}));
/** @internal */
const catchTags = exports.catchTags = /*#__PURE__*/(0, _Function.dual)(2, (self, cases) => core.catchAll(self, e => {
  const keys = Object.keys(cases);
  if ("_tag" in e && keys.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return core.fail(e);
}));
/** @internal */
const check = predicate => suspend(() => predicate() ? void_ : core.retry);
/** @internal

## commitEither

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `commitEither(= commitEither;
const cond = (predicate, error, result)`

JSDoc:

@internal */
const collectSTM = exports.collectSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.matchSTM(self, {
  onFailure: core.fail,
  onSuccess: a => {
    const option = pf(a);
    return Option.isSome(option) ? option.value : core.retry;
  }
}));
/** @internal */
const commitEither = self => Effect.flatten(core.commit(either(self)));
/** @internal

## cond

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `cond(= cond;
const either = self => match(self, {
  onFailure: Either.left,
  onSuccess: Either.right
})`

JSDoc:

@internal

## either

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `either(= either;
const eventually = self => core.matchSTM(self, {
  onFailure: ()`

JSDoc:

@internal

## eventually

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `eventually(= eventually;
const every = exports.every = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## flatten

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `flatten(= flatten;
const flip = self => core.matchSTM(self, {
  onFailure: core.succeed,
  onSuccess: core.fail
})`

JSDoc:

@internal */
const exists = exports.exists = /*#__PURE__*/(0, _Function.dual)(2, (iterable, predicate) => core.flatMap(core.sync(() => iterable[Symbol.iterator]()), iterator => {
  const loop = suspend(() => {
    const next = iterator.next();
    if (next.done) {
      return core.succeed(false);
    }
    return core.flatMap(predicate(next.value), bool => bool ? core.succeed(bool) : loop);
  });
  return loop;
}));
/** @internal */
const fiberId = exports.fiberId = /*#__PURE__*/core.effect((_, fiberId) => fiberId);
/** @internal */
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)(2, (iterable, predicate) => Array.from(iterable).reduce((acc, curr) => (0, _Function.pipe)(acc, core.zipWith(predicate(curr), (as, p) => {
  if (p) {
    as.push(curr);
    return as;
  }
  return as;
})), core.succeed([])));
/** @internal */
const filterNot = exports.filterNot = /*#__PURE__*/(0, _Function.dual)(2, (iterable, predicate) => filter(iterable, a => negate(predicate(a))));
/** @internal */
const filterOrDie = exports.filterOrDie = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, defect) => filterOrElse(self, predicate, () => core.dieSync(defect)));
/** @internal */
const filterOrDieMessage = exports.filterOrDieMessage = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, message) => filterOrElse(self, predicate, () => core.dieMessage(message)));
/** @internal */
const filterOrElse = exports.filterOrElse = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, orElse) => core.flatMap(self, a => predicate(a) ? core.succeed(a) : orElse(a)));
/** @internal */
const filterOrFail = exports.filterOrFail = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, orFailWith) => filterOrElse(self, predicate, a => core.failSync(() => orFailWith(a))));
/** @internal */
const flatten = self => core.flatMap(self, _Function.identity);
/** @internal

## flip

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `flip(= flip;
const flipWith = exports.flipWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## fromEither

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `fromEither(= fromEither;
const fromOption = option => Option.match(option, {
  onNone: ()`

JSDoc:

@internal */
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => core.matchSTM(self, {
  onFailure: e => core.succeed(onFailure(e)),
  onSuccess: a => core.succeed(onSuccess(a))
}));
/** @internal */
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)(args => predicate.isIterable(args[0]), (iterable, f, options) => {
  if (options?.discard) {
    return (0, _Function.pipe)(core.sync(() => iterable[Symbol.iterator]()), core.flatMap(iterator => {
      const loop = suspend(() => {
        const next = iterator.next();
        if (next.done) {
          return void_;
        }
        return (0, _Function.pipe)(f(next.value), core.flatMap(() => loop));
      });
      return loop;
    }));
  }
  return suspend(() => RA.fromIterable(iterable).reduce((acc, curr) => core.zipWith(acc, f(curr), (array, elem) => {
    array.push(elem);
    return array;
  }), core.succeed([])));
});
/** @internal */
const fromEither = either => {
  switch (either._tag) {
    case "Left":
      {
        return core.fail(either.left);
      }
    case "Right":
      {
        return core.succeed(either.right);
      }
  }
};
/** @internal

## fromOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `fromOption(= fromOption;
const gen = (...args)`

JSDoc:

Inspired by https://github.com/tusharmath/qio/pull/22 (revised)
@internal

## gen

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `gen(= gen;
const head = self => (0, _Function.pipe)`

JSDoc:

@internal

## head

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `head(= head;
const if_ = exports.if_ = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## ignore

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `ignore(= ignore;
const isFailure = self => match(self, {
  onFailure: _Function.constTrue,
  onSuccess: _Function.constFalse
})`

JSDoc:

@internal */
const ignore = self => match(self, {
  onFailure: () => void_,
  onSuccess: () => void_
});
/** @internal

## isFailure

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `isFailure(= isFailure;
const isSuccess = self => match(self, {
  onFailure: _Function.constFalse,
  onSuccess: _Function.constTrue
})`

JSDoc:

@internal

## isSuccess

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `isSuccess(= isSuccess;
const iterate = (initial, options)`

JSDoc:

@internal

## merge

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `merge(= merge;
const mergeAll = exports.mergeAll = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const loop = (initial, options) => options.discard ? loopDiscardLoop(initial, options.while, options.step, options.body) : core.map(loopLoop(initial, options.while, options.step, options.body), a => Array.from(a));
exports.loop = loop;
const loopLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return (0, _Function.pipe)(body(initial), core.flatMap(a => (0, _Function.pipe)(loopLoop(inc(initial), cont, inc, body), core.map(Chunk.append(a)))));
  }
  return core.succeed(Chunk.empty());
};
const loopDiscardLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return (0, _Function.pipe)(body(initial), core.flatMap(() => loopDiscardLoop(inc(initial), cont, inc, body)));
  }
  return void_;
};
/** @internal */
const mapAttempt = exports.mapAttempt = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.matchSTM(self, {
  onFailure: e => core.fail(e),
  onSuccess: a => attempt(() => f(a))
}));
/** @internal */
const mapBoth = exports.mapBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => core.matchSTM(self, {
  onFailure: e => core.fail(onFailure(e)),
  onSuccess: a => core.succeed(onSuccess(a))
}));
/** @internal */
const mapError = exports.mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.matchSTM(self, {
  onFailure: e => core.fail(f(e)),
  onSuccess: core.succeed
}));
/** @internal */
const merge = self => core.matchSTM(self, {
  onFailure: e => core.succeed(e),
  onSuccess: core.succeed
});
/** @internal

## negate

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `negate(= negate;
const none = self => core.matchSTM(self, {
  onFailure: e => core.fail(Option.some(e)`

JSDoc:

@internal */
const negate = self => (0, _Function.pipe)(self, core.map(b => !b));
/** @internal

## none

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `none(= none;
const option = self => match(self, {
  onFailure: ()`

JSDoc:

@internal

## option

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `option(= option;
const orDie = self => (0, _Function.pipe)`

JSDoc:

@internal

## orDie

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `orDie(= orDie;
const orDieWith = exports.orDieWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## some

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `some(= some;
const all = (input, options)`

JSDoc:

@internal */
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => core.flatMap(core.effect(journal => Journal.prepareResetJournal(journal)), reset => (0, _Function.pipe)(core.orTry(self, () => core.flatMap(core.sync(reset), that)), core.catchAll(() => core.flatMap(core.sync(reset), that)))));
/** @internal */
const orElseEither = exports.orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => orElse(core.map(self, Either.left), () => core.map(that(), Either.right)));
/** @internal */
const orElseFail = exports.orElseFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => orElse(self, () => core.failSync(error)));
/** @internal */
const orElseOptional = exports.orElseOptional = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => core.catchAll(self, Option.match({
  onNone: that,
  onSome: e => core.fail(Option.some(e))
})));
/** @internal */
const orElseSucceed = exports.orElseSucceed = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => orElse(self, () => core.sync(value)));
/** @internal */
const provideContext = exports.provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, env) => core.mapInputContext(self, _ => env));
/** @internal */
const provideSomeContext = exports.provideSomeContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => core.mapInputContext(self, parent => Context.merge(parent, context)));
/** @internal */
const provideService = exports.provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, resource) => provideServiceSTM(self, tag, core.succeed(resource)));
/** @internal */
const provideServiceSTM = exports.provideServiceSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, stm) => core.contextWithSTM(env => core.flatMap(stm, service => provideContext(self, Context.add(env, tag, service)))));
/** @internal */
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)(3, (iterable, zero, f) => suspend(() => Array.from(iterable).reduce((acc, curr) => (0, _Function.pipe)(acc, core.flatMap(s => f(s, curr))), core.succeed(zero))));
/** @internal */
const reduceAll = exports.reduceAll = /*#__PURE__*/(0, _Function.dual)(3, (iterable, initial, f) => suspend(() => Array.from(iterable).reduce((acc, curr) => (0, _Function.pipe)(acc, core.zipWith(curr, f)), initial)));
/** @internal */
const reduceRight = exports.reduceRight = /*#__PURE__*/(0, _Function.dual)(3, (iterable, zero, f) => suspend(() => Array.from(iterable).reduceRight((acc, curr) => (0, _Function.pipe)(acc, core.flatMap(s => f(s, curr))), core.succeed(zero))));
/** @internal */
const refineOrDie = exports.refineOrDie = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => refineOrDieWith(self, pf, _Function.identity));
/** @internal */
const refineOrDieWith = exports.refineOrDieWith = /*#__PURE__*/(0, _Function.dual)(3, (self, pf, f) => core.catchAll(self, e => Option.match(pf(e), {
  onNone: () => core.die(f(e)),
  onSome: core.fail
})));
/** @internal */
const reject = exports.reject = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => rejectSTM(self, a => Option.map(pf(a), core.fail)));
/** @internal */
const rejectSTM = exports.rejectSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.flatMap(self, a => Option.match(pf(a), {
  onNone: () => core.succeed(a),
  onSome: core.flatMap(core.fail)
})));
/** @internal */
const repeatUntil = exports.repeatUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => repeatUntilLoop(self, predicate));
const repeatUntilLoop = (self, predicate) => core.flatMap(self, a => predicate(a) ? core.succeed(a) : repeatUntilLoop(self, predicate));
/** @internal */
const repeatWhile = exports.repeatWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => repeatWhileLoop(self, predicate));
const repeatWhileLoop = (self, predicate) => (0, _Function.pipe)(core.flatMap(self, a => predicate(a) ? repeatWhileLoop(self, predicate) : core.succeed(a)));
/** @internal */
const replicate = exports.replicate = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => Array.from({
  length: n
}, () => self));
/** @internal */
const replicateSTM = exports.replicateSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => all(replicate(self, n)));
/** @internal */
const replicateSTMDiscard = exports.replicateSTMDiscard = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => all(replicate(self, n), {
  discard: true
}));
/** @internal */
const retryUntil = exports.retryUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.matchSTM(self, {
  onFailure: core.fail,
  onSuccess: a => predicate(a) ? core.succeed(a) : core.retry
}));
/** @internal */
const retryWhile = exports.retryWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.matchSTM(self, {
  onFailure: core.fail,
  onSuccess: a => !predicate(a) ? core.succeed(a) : core.retry
}));
/** @internal */
const partition = exports.partition = /*#__PURE__*/(0, _Function.dual)(2, (elements, f) => (0, _Function.pipe)(forEach(elements, a => either(f(a))), core.map(as => effectCore.partitionMap(as, _Function.identity))));
/** @internal */
const some = self => core.matchSTM(self, {
  onFailure: e => core.fail(Option.some(e)),
  onSuccess: Option.match({
    onNone: () => core.fail(Option.none()),
    onSome: core.succeed
  })
});
/* @internal

## all

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `all(= all;
const succeedNone = exports.succeedNone = /*#__PURE__*/core.succeed(/*#__PURE__*/Option.none()`

JSDoc:

@internal

## succeedSome

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `succeedSome(= succeedSome;
const summarized = exports.summarized = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const succeedSome = value => core.succeed(Option.some(value));
/** @internal

## suspend

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `suspend(= suspend;
const tap = exports.tap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const suspend = evaluate => flatten(core.sync(evaluate));
/** @internal

## try_

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `try_(= try_;
const void_ = exports.void = /*#__PURE__*/core.succeed(void 0)`

JSDoc:

@internal */
const tapBoth = exports.tapBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onFailure,
  onSuccess
}) => core.matchSTM(self, {
  onFailure: e => (0, _Function.pipe)(onFailure(e), core.zipRight(core.fail(e))),
  onSuccess: a => (0, _Function.pipe)(onSuccess(a), as(a))
}));
/** @internal */
const tapError = exports.tapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.matchSTM(self, {
  onFailure: e => core.zipRight(f(e), core.fail(e)),
  onSuccess: core.succeed
}));
/** @internal */
const try_ = arg => {
  const evaluate = typeof arg === "function" ? arg : arg.try;
  return suspend(() => {
    try {
      return core.succeed(evaluate());
    } catch (error) {
      return core.fail("catch" in arg ? arg.catch(error) : error);
    }
  });
};
/** @internal

## unsome

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stm.js`

Signature: `unsome(= unsome;
const validateAll = exports.validateAll = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const unless = exports.unless = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => suspend(() => predicate() ? succeedNone : asSome(self)));
/** @internal */
const unlessSTM = exports.unlessSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.flatMap(predicate, bool => bool ? succeedNone : asSome(self)));
/** @internal */
const unsome = self => core.matchSTM(self, {
  onFailure: Option.match({
    onNone: () => core.succeed(Option.none()),
    onSome: core.fail
  }),
  onSuccess: a => core.succeed(Option.some(a))
});
/** @internal

## isSTMState

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/stmState.js`

Signature: `isSTMState(= isSTMState;
const isRunning = self => {
  return self._tag === OpCodes.OP_RUNNING;
};
/** @internal */
exports.isRunning = isRunning;
const isDone = self => {
  return self._tag === OpCodes.OP_DONE;
};
/** @internal */
exports.isDone = isDone;
const isInterrupted = self => {
  return self._tag === OpCodes.OP_INTERRUPTED;
};
/** @internal */
exports.isInterrupted = isInterrupted;
const done = exit => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OpCodes.OP_DONE,
    exit,
    [Hash.symbol]()`

JSDoc:

@internal */
const STMStateSymbolKey = "effect/STM/State";
/** @internal */
const STMStateTypeId = exports.STMStateTypeId = /*#__PURE__*/Symbol.for(STMStateSymbolKey);
/** @internal */
const isSTMState = u => (0, _Predicate.hasProperty)(u, STMStateTypeId);
/** @internal

## TArrayImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tArray.js`

Signature: `TArrayImpl(= TArrayImpl;
const collectFirst = exports.collectFirst = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const TArraySymbolKey = "effect/TArray";
/** @internal */
const TArrayTypeId = exports.TArrayTypeId = /*#__PURE__*/Symbol.for(TArraySymbolKey);
const tArrayVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class TArrayImpl {
  chunk;
  [TArrayTypeId] = tArrayVariance;
  constructor(chunk) {
    this.chunk = chunk;
  }
}
/** @internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tArray.js`

Signature: `empty(= empty;
const every = exports.every = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const collectFirstSTM = exports.collectFirstSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.withSTMRuntime(runtime => {
  let index = 0;
  let result = Option.none();
  while (Option.isNone(result) && index < self.chunk.length) {
    const element = (0, _Function.pipe)(self.chunk[index], tRef.unsafeGet(runtime.journal));
    const option = pf(element);
    if (Option.isSome(option)) {
      result = option;
    }
    index = index + 1;
  }
  return (0, _Function.pipe)(result, Option.match({
    onNone: () => stm.succeedNone,
    onSome: core.map(Option.some)
  }));
}));
/** @internal */
const contains = exports.contains = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => some(self, a => Equal.equals(a)(value)));
/** @internal */
const count = exports.count = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => reduce(self, 0, (n, a) => predicate(a) ? n + 1 : n));
/** @internal */
const countSTM = exports.countSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => reduceSTM(self, 0, (n, a) => core.map(predicate(a), bool => bool ? n + 1 : n)));
/** @internal */
const empty = () => fromIterable([]);
/** @internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tArray.js`

Signature: `fromIterable(= fromIterable;
const get = exports.get = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const everySTM = exports.everySTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.map(countSTM(self, predicate), count => count === self.chunk.length));
/** @internal */
const findFirst = exports.findFirst = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => collectFirst(self, a => predicate(a) ? Option.some(a) : Option.none()));
/** @internal */
const findFirstIndex = exports.findFirstIndex = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => findFirstIndexFrom(self, value, 0));
/** @internal */
const findFirstIndexFrom = exports.findFirstIndexFrom = /*#__PURE__*/(0, _Function.dual)(3, (self, value, from) => findFirstIndexWhereFrom(self, a => Equal.equals(a)(value), from));
/** @internal */
const findFirstIndexWhere = exports.findFirstIndexWhere = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0));
/** @internal */
const findFirstIndexWhereFrom = exports.findFirstIndexWhereFrom = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, from) => {
  if (from < 0) {
    return stm.succeedNone;
  }
  return core.effect(journal => {
    let index = from;
    let found = false;
    while (!found && index < self.chunk.length) {
      const element = tRef.unsafeGet(self.chunk[index], journal);
      found = predicate(element);
      index = index + 1;
    }
    if (found) {
      return Option.some(index - 1);
    }
    return Option.none();
  });
});
/** @internal */
const findFirstIndexWhereSTM = exports.findFirstIndexWhereSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0));
/** @internal */
const findFirstIndexWhereFromSTM = exports.findFirstIndexWhereFromSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, predicate, from) => {
  const forIndex = index => index < self.chunk.length ? (0, _Function.pipe)(tRef.get(self.chunk[index]), core.flatMap(predicate), core.flatMap(bool => bool ? core.succeed(Option.some(index)) : forIndex(index + 1))) : stm.succeedNone;
  return from < 0 ? stm.succeedNone : forIndex(from);
});
/** @internal */
const findFirstSTM = exports.findFirstSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const init = [Option.none(), 0];
  const cont = state => Option.isNone(state[0]) && state[1] < self.chunk.length - 1;
  return core.map(stm.iterate(init, {
    while: cont,
    body: state => {
      const index = state[1];
      return (0, _Function.pipe)(tRef.get(self.chunk[index]), core.flatMap(value => core.map(predicate(value), bool => [bool ? Option.some(value) : Option.none(), index + 1])));
    }
  }), state => state[0]);
});
/** @internal */
const findLast = exports.findLast = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.effect(journal => {
  let index = self.chunk.length - 1;
  let result = Option.none();
  while (Option.isNone(result) && index >= 0) {
    const element = tRef.unsafeGet(self.chunk[index], journal);
    if (predicate(element)) {
      result = Option.some(element);
    }
    index = index - 1;
  }
  return result;
}));
/** @internal */
const findLastIndex = exports.findLastIndex = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => findLastIndexFrom(self, value, self.chunk.length - 1));
/** @internal */
const findLastIndexFrom = exports.findLastIndexFrom = /*#__PURE__*/(0, _Function.dual)(3, (self, value, end) => {
  if (end >= self.chunk.length) {
    return stm.succeedNone;
  }
  return core.effect(journal => {
    let index = end;
    let found = false;
    while (!found && index >= 0) {
      const element = tRef.unsafeGet(self.chunk[index], journal);
      found = Equal.equals(element)(value);
      index = index - 1;
    }
    if (found) {
      return Option.some(index + 1);
    }
    return Option.none();
  });
});
/** @internal */
const findLastSTM = exports.findLastSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const init = [Option.none(), self.chunk.length - 1];
  const cont = state => Option.isNone(state[0]) && state[1] >= 0;
  return core.map(stm.iterate(init, {
    while: cont,
    body: state => {
      const index = state[1];
      return (0, _Function.pipe)(tRef.get(self.chunk[index]), core.flatMap(value => core.map(predicate(value), bool => [bool ? Option.some(value) : Option.none(), index - 1])));
    }
  }), state => state[0]);
});
/** @internal */
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduceSTM(self, void 0, (_, a) => f(a)));
/** @internal */
const fromIterable = iterable => core.map(stm.forEach(iterable, tRef.make), chunk => new TArrayImpl(chunk));
/** @internal

## headOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tArray.js`

Signature: `headOption(= headOption;
const lastOption = self => self.chunk.length === 0 ? stm.succeedNone : core.map(tRef.get(self.chunk[self.chunk.length - 1])`

JSDoc:

@internal */
const headOption = self => self.chunk.length === 0 ? core.succeed(Option.none()) : core.map(tRef.get(self.chunk[0]), Option.some);
/** @internal

## lastOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tArray.js`

Signature: `lastOption(= lastOption;
const make = (...elements)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tArray.js`

Signature: `make(= make;
const maxOption = exports.maxOption = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tArray.js`

Signature: `size(= size;
const some = exports.some = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const minOption = exports.minOption = /*#__PURE__*/(0, _Function.dual)(2, (self, order) => {
  const lessThan = Order.lessThan(order);
  return reduceOption(self, (acc, curr) => lessThan(acc)(curr) ? curr : acc);
});
/** @internal */
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => core.effect(journal => {
  let index = 0;
  let result = zero;
  while (index < self.chunk.length) {
    const element = tRef.unsafeGet(self.chunk[index], journal);
    result = f(result, element);
    index = index + 1;
  }
  return result;
}));
/** @internal */
const reduceOption = exports.reduceOption = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => core.effect(journal => {
  let index = 0;
  let result = undefined;
  while (index < self.chunk.length) {
    const element = tRef.unsafeGet(self.chunk[index], journal);
    result = result === undefined ? element : f(result, element);
    index = index + 1;
  }
  return Option.fromNullable(result);
}));
/** @internal */
const reduceOptionSTM = exports.reduceOptionSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduceSTM(self, Option.none(), (acc, curr) => Option.isSome(acc) ? core.map(f(acc.value, curr), Option.some) : stm.succeedSome(curr)));
/** @internal */
const reduceSTM = exports.reduceSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => core.flatMap(toArray(self), stm.reduce(zero, f)));
/** @internal */
const size = self => self.chunk.length;
/** @internal

## toArray

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tArray.js`

Signature: `toArray(= toArray;
const transform = exports.transform = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const someSTM = exports.someSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => core.map(countSTM(self, predicate), n => n > 0));
/** @internal */
const toArray = self => stm.forEach(self.chunk, tRef.get);
/** @internal

## _await

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tDeferred.js`

Signature: `_await(= _await;
const done = exports.done = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const TDeferredSymbolKey = "effect/TDeferred";
/** @internal */
const TDeferredTypeId = exports.TDeferredTypeId = /*#__PURE__*/Symbol.for(TDeferredSymbolKey);
/** @internal */
const tDeferredVariance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _E: _ => _
};
/** @internal */
class TDeferredImpl {
  ref;
  [TDeferredTypeId] = tDeferredVariance;
  constructor(ref) {
    this.ref = ref;
  }
}
/** @internal */
const _await = self => stm.flatten(stm.collect(tRef.get(self.ref), option => Option.isSome(option) ? Option.some(stm.fromEither(option.value)) : Option.none()));
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tDeferred.js`

Signature: `make(= make;
const poll = self => tRef.get(self.ref)`

JSDoc:

@internal */
const fail = exports.fail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => done(self, Either.left(error)));
/** @internal */
const make = () => core.map(tRef.make(Option.none()), ref => new TDeferredImpl(ref));
/** @internal

## poll

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tDeferred.js`

Signature: `poll(= poll;
const succeed = exports.succeed = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## isExit

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tExit.js`

Signature: `isExit(= isExit;
const isFail = self => {
  return self._tag === OpCodes.OP_FAIL;
};
/** @internal */
exports.isFail = isFail;
const isDie = self => {
  return self._tag === OpCodes.OP_DIE;
};
/** @internal */
exports.isDie = isDie;
const isInterrupt = self => {
  return self._tag === OpCodes.OP_INTERRUPT;
};
/** @internal */
exports.isInterrupt = isInterrupt;
const isSuccess = self => {
  return self._tag === OpCodes.OP_SUCCEED;
};
/** @internal */
exports.isSuccess = isSuccess;
const isRetry = self => {
  return self._tag === OpCodes.OP_RETRY;
};
/** @internal */
exports.isRetry = isRetry;
const fail = error => ({
  [TExitTypeId]: variance,
  _tag: OpCodes.OP_FAIL,
  error,
  [Hash.symbol]()`

JSDoc:

@internal */
const TExitSymbolKey = "effect/TExit";
/** @internal */
const TExitTypeId = exports.TExitTypeId = /*#__PURE__*/Symbol.for(TExitSymbolKey);
const variance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _E: _ => _
};
/** @internal */
const isExit = u => (0, _Predicate.hasProperty)(u, TExitTypeId);
/** @internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tExit.js`

Signature: `fail(= fail;
const die = defect => ({
  [TExitTypeId]: variance,
  _tag: OpCodes.OP_DIE,
  defect,
  [Hash.symbol]()`

JSDoc:

@internal

## die

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tExit.js`

Signature: `die(= die;
const interrupt = fiberId => ({
  [TExitTypeId]: variance,
  _tag: OpCodes.OP_INTERRUPT,
  fiberId,
  [Hash.symbol]()`

JSDoc:

@internal

## interrupt

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tExit.js`

Signature: `interrupt(= interrupt;
const succeed = value => ({
  [TExitTypeId]: variance,
  _tag: OpCodes.OP_SUCCEED,
  value,
  [Hash.symbol]()`

JSDoc:

@internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `empty(= empty;
const find = exports.find = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const TMapSymbolKey = "effect/TMap";
/** @internal */
const TMapTypeId = exports.TMapTypeId = /*#__PURE__*/Symbol.for(TMapSymbolKey);
const tMapVariance = {
  /* c8 ignore next */
  _K: _ => _,
  /* c8 ignore next */
  _V: _ => _
};
/** @internal */
class TMapImpl {
  tBuckets;
  tSize;
  [TMapTypeId] = tMapVariance;
  constructor(tBuckets, tSize) {
    this.tBuckets = tBuckets;
    this.tSize = tSize;
  }
}
const isTMap = u => (0, _Predicate.hasProperty)(u, TMapTypeId);
/** @internal */
const InitialCapacity = 16;
const LoadFactor = 0.75;
/** @internal */
const nextPowerOfTwo = size => {
  const n = -1 >>> Math.clz32(size - 1);
  return n < 0 ? 1 : n + 1;
};
/** @internal */
const hash = key => {
  const h = Hash.hash(key);
  return h ^ h >>> 16;
};
/** @internal */
const indexOf = (k, capacity) => hash(k) & capacity - 1;
/** @internal */
const allocate = (capacity, data) => {
  const buckets = Array.from({
    length: capacity
  }, () => Chunk.empty());
  const distinct = new Map(data);
  let size = 0;
  for (const entry of distinct) {
    const index = indexOf(entry[0], capacity);
    buckets[index] = (0, _Function.pipe)(buckets[index], Chunk.prepend(entry));
    size = size + 1;
  }
  return (0, _Function.pipe)(tArray.fromIterable(buckets), core.flatMap(buckets => (0, _Function.pipe)(tRef.make(buckets), core.flatMap(tBuckets => (0, _Function.pipe)(tRef.make(size), core.map(tSize => new TMapImpl(tBuckets, tSize)))))));
};
/** @internal */
const empty = () => fromIterable([]);
/** @internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `fromIterable(= fromIterable;
const get = exports.get = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const findSTM = exports.findSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduceSTM(self, Option.none(), (acc, value, key) => Option.isNone(acc) ? core.matchSTM(f(key, value), {
  onFailure: Option.match({
    onNone: () => stm.succeedNone,
    onSome: core.fail
  }),
  onSuccess: stm.succeedSome
}) : STM.succeed(acc)));
/** @internal */
const findAll = exports.findAll = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => findAllSTM(self, (key, value) => {
  const option = pf(key, value);
  if (Option.isSome(option)) {
    return core.succeed(option.value);
  }
  return core.fail(Option.none());
}));
/** @internal */
const findAllSTM = exports.findAllSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => core.map(reduceSTM(self, Chunk.empty(), (acc, value, key) => core.matchSTM(pf(key, value), {
  onFailure: Option.match({
    onNone: () => core.succeed(acc),
    onSome: core.fail
  }),
  onSuccess: a => core.succeed(Chunk.append(acc, a))
})), a => Array.from(a)));
/** @internal */
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduceSTM(self, void 0, (_, value, key) => stm.asVoid(f(key, value))));
/** @internal */
const fromIterable = iterable => stm.suspend(() => {
  const data = Chunk.fromIterable(iterable);
  const capacity = data.length < InitialCapacity ? InitialCapacity : nextPowerOfTwo(data.length);
  return allocate(capacity, data);
});
/** @internal

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `isEmpty(= isEmpty;
const keys = self => core.map(toReadonlyArray(self)`

JSDoc:

@internal */
const getOrElse = exports.getOrElse = /*#__PURE__*/(0, _Function.dual)(3, (self, key, fallback) => core.map(get(self, key), Option.getOrElse(fallback)));
/** @internal */
const has = exports.has = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => core.map(get(self, key), Option.isSome));
/** @internal */
const isEmpty = self => core.map(tRef.get(self.tSize), size => size === 0);
/** @internal

## keys

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `keys(= keys;
const make = (...entries)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `make(= make;
const merge = exports.merge = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `size(= size;
const takeFirst = exports.takeFirst = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => core.effect(journal => {
  const buckets = tRef.unsafeGet(self.tBuckets, journal);
  let result = zero;
  let index = 0;
  while (index < buckets.chunk.length) {
    const bucket = buckets.chunk[index];
    const items = tRef.unsafeGet(bucket, journal);
    result = Chunk.reduce(items, result, (acc, entry) => f(acc, entry[1], entry[0]));
    index = index + 1;
  }
  return result;
}));
/** @internal */
const reduceSTM = exports.reduceSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => core.flatMap(toReadonlyArray(self), stm.reduce(zero, (acc, entry) => f(acc, entry[1], entry[0]))));
/** @internal */
const remove = exports.remove = /*#__PURE__*/(0, _Function.dual)(2, (self, key) => core.effect(journal => {
  const buckets = tRef.unsafeGet(self.tBuckets, journal);
  const index = indexOf(key, buckets.chunk.length);
  const bucket = tRef.unsafeGet(buckets.chunk[index], journal);
  const [toRemove, toRetain] = Chunk.partition(bucket, entry => Equal.equals(entry[1], key));
  if (Chunk.isNonEmpty(toRemove)) {
    const currentSize = tRef.unsafeGet(self.tSize, journal);
    tRef.unsafeSet(buckets.chunk[index], toRetain, journal);
    tRef.unsafeSet(self.tSize, currentSize - 1, journal);
  }
}));
/** @internal */
const removeAll = exports.removeAll = /*#__PURE__*/(0, _Function.dual)(2, (self, keys) => core.effect(journal => {
  const iterator = keys[Symbol.iterator]();
  let next;
  while ((next = iterator.next()) && !next.done) {
    const buckets = tRef.unsafeGet(self.tBuckets, journal);
    const index = indexOf(next.value, buckets.chunk.length);
    const bucket = tRef.unsafeGet(buckets.chunk[index], journal);
    const [toRemove, toRetain] = Chunk.partition(bucket, entry => Equal.equals(next.value)(entry[0]));
    if (Chunk.isNonEmpty(toRemove)) {
      const currentSize = tRef.unsafeGet(self.tSize, journal);
      tRef.unsafeSet(buckets.chunk[index], toRetain, journal);
      tRef.unsafeSet(self.tSize, currentSize - 1, journal);
    }
  }
}));
/** @internal */
const removeIf = exports.removeIf = /*#__PURE__*/(0, _Function.dual)(args => isTMap(args[0]), (self, predicate, options) => core.effect(journal => {
  const discard = options?.discard === true;
  const buckets = tRef.unsafeGet(self.tBuckets, journal);
  const capacity = buckets.chunk.length;
  const removed = [];
  let index = 0;
  let newSize = 0;
  while (index < capacity) {
    const bucket = tRef.unsafeGet(buckets.chunk[index], journal);
    const iterator = bucket[Symbol.iterator]();
    let next;
    let newBucket = Chunk.empty();
    while ((next = iterator.next()) && !next.done) {
      const [k, v] = next.value;
      if (!predicate(k, v)) {
        newBucket = Chunk.prepend(newBucket, next.value);
        newSize = newSize + 1;
      } else {
        if (!discard) {
          removed.push([k, v]);
        }
      }
    }
    tRef.unsafeSet(buckets.chunk[index], newBucket, journal);
    index = index + 1;
  }
  tRef.unsafeSet(self.tSize, newSize, journal);
  if (!discard) {
    return removed;
  }
}));
/** @internal */
const retainIf = exports.retainIf = /*#__PURE__*/(0, _Function.dual)(args => isTMap(args[0]), (self, predicate, options) => removeIf(self, (key, value) => !predicate(key, value), options));
/** @internal */
const set = exports.set = /*#__PURE__*/(0, _Function.dual)(3, (self, key, value) => {
  const resize = (journal, buckets) => {
    const capacity = buckets.chunk.length;
    const newCapacity = capacity << 1;
    const newBuckets = Array.from({
      length: newCapacity
    }, () => Chunk.empty());
    let index = 0;
    while (index < capacity) {
      const pairs = tRef.unsafeGet(buckets.chunk[index], journal);
      const iterator = pairs[Symbol.iterator]();
      let next;
      while ((next = iterator.next()) && !next.done) {
        const newIndex = indexOf(next.value[0], newCapacity);
        newBuckets[newIndex] = Chunk.prepend(newBuckets[newIndex], next.value);
      }
      index = index + 1;
    }
    // insert new pair
    const newIndex = indexOf(key, newCapacity);
    newBuckets[newIndex] = Chunk.prepend(newBuckets[newIndex], [key, value]);
    const newArray = [];
    index = 0;
    while (index < newCapacity) {
      newArray[index] = new tRef.TRefImpl(newBuckets[index]);
      index = index + 1;
    }
    const newTArray = new tArray.TArrayImpl(newArray);
    tRef.unsafeSet(self.tBuckets, newTArray, journal);
  };
  return core.effect(journal => {
    const buckets = tRef.unsafeGet(self.tBuckets, journal);
    const capacity = buckets.chunk.length;
    const index = indexOf(key, capacity);
    const bucket = tRef.unsafeGet(buckets.chunk[index], journal);
    const shouldUpdate = Chunk.some(bucket, entry => Equal.equals(key)(entry[0]));
    if (shouldUpdate) {
      const newBucket = Chunk.map(bucket, entry => Equal.equals(key)(entry[0]) ? [key, value] : entry);
      tRef.unsafeSet(buckets.chunk[index], newBucket, journal);
    } else {
      const newSize = tRef.unsafeGet(self.tSize, journal) + 1;
      tRef.unsafeSet(self.tSize, newSize, journal);
      if (capacity * LoadFactor < newSize) {
        resize(journal, buckets);
      } else {
        const newBucket = Chunk.prepend(bucket, [key, value]);
        tRef.unsafeSet(buckets.chunk[index], newBucket, journal);
      }
    }
  });
});
/** @internal */
const setIfAbsent = exports.setIfAbsent = /*#__PURE__*/(0, _Function.dual)(3, (self, key, value) => core.flatMap(get(self, key), Option.match({
  onNone: () => set(self, key, value),
  onSome: () => stm.void
})));
/** @internal */
const size = self => tRef.get(self.tSize);
/** @internal

## toChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `toChunk(= toChunk;
const toHashMap = self => reduce(self, HashMap.empty()`

JSDoc:

@internal */
const takeFirstSTM = exports.takeFirstSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => (0, _Function.pipe)(findSTM(self, (key, value) => core.map(pf(key, value), a => [key, a])), stm.collect(option => Option.isSome(option) ? Option.some(option.value) : Option.none()), core.flatMap(entry => stm.as(remove(self, entry[0]), entry[1]))));
/** @internal */
const takeSome = exports.takeSome = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => (0, _Function.pipe)(core.effect(journal => {
  const buckets = tRef.unsafeGet(self.tBuckets, journal);
  const capacity = buckets.chunk.length;
  const builder = [];
  let newSize = 0;
  let index = 0;
  while (index < capacity) {
    const bucket = tRef.unsafeGet(buckets.chunk[index], journal);
    const recreate = Chunk.some(bucket, entry => Option.isSome(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = Chunk.empty();
      let next;
      while ((next = iterator.next()) && !next.done) {
        const option = pf(next.value[0], next.value[1]);
        if (Option.isSome(option)) {
          builder.push(option.value);
        } else {
          newBucket = Chunk.prepend(newBucket, next.value);
          newSize = newSize + 1;
        }
      }
      tRef.unsafeSet(buckets.chunk[index], newBucket, journal);
    } else {
      newSize = newSize + bucket.length;
    }
    index = index + 1;
  }
  tRef.unsafeSet(self.tSize, newSize, journal);
  if (builder.length > 0) {
    return Option.some(builder);
  }
  return Option.none();
}), stm.collect(option => Option.isSome(option) ? Option.some(option.value) : Option.none())));
/** @internal */
const takeSomeSTM = exports.takeSomeSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => (0, _Function.pipe)(findAllSTM(self, (key, value) => core.map(pf(key, value), a => [key, a])), core.map(chunk => RA.isNonEmptyArray(chunk) ? Option.some(chunk) : Option.none()), stm.collect(option => Option.isSome(option) ? Option.some(option.value) : Option.none()), core.flatMap(entries => stm.as(removeAll(self, entries.map(entry => entry[0])), RA.map(entries, entry => entry[1])))));
const toReadonlyArray = self => core.effect(journal => {
  const buckets = tRef.unsafeGet(self.tBuckets, journal);
  const capacity = buckets.chunk.length;
  const builder = [];
  let index = 0;
  while (index < capacity) {
    const bucket = buckets.chunk[index];
    for (const entry of tRef.unsafeGet(bucket, journal)) {
      builder.push(entry);
    }
    index = index + 1;
  }
  return builder;
});
/** @internal */
const toChunk = self => reduce(self, Chunk.empty(), (acc, value, key) => Chunk.append(acc, [key, value]));
/** @internal

## toHashMap

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `toHashMap(= toHashMap;
const toArray = self => reduce(self, [], (acc, value, key)`

JSDoc:

@internal

## toArray

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `toArray(= toArray;
const toMap = self => reduce(self, new Map()`

JSDoc:

@internal

## toMap

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tMap.js`

Signature: `toMap(= toMap;
const transform = exports.transform = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## TPriorityQueueImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `TPriorityQueueImpl(= TPriorityQueueImpl;
const empty = order => (0, _Function.pipe)`

JSDoc:

@internal */
const TPriorityQueueSymbolKey = "effect/TPriorityQueue";
/** @internal */
const TPriorityQueueTypeId = exports.TPriorityQueueTypeId = /*#__PURE__*/Symbol.for(TPriorityQueueSymbolKey);
const tPriorityQueueVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class TPriorityQueueImpl {
  ref;
  [TPriorityQueueTypeId] = tPriorityQueueVariance;
  constructor(ref) {
    this.ref = ref;
  }
}
/** @internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `empty(= empty;
const fromIterable = order => iterable => (0, _Function.pipe)`

JSDoc:

@internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `fromIterable(= fromIterable;
const isEmpty = self => core.map(tRef.get(self.ref)`

JSDoc:

@internal

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `isEmpty(= isEmpty;
const isNonEmpty = self => core.map(tRef.get(self.ref)`

JSDoc:

@internal

## isNonEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `isNonEmpty(= isNonEmpty;
const make = order => (...elements)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `make(= make;
const offer = exports.offer = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## peek

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `peek(= peek;
const peekOption = self => tRef.modify(self.ref, map => [Option.map(SortedMap.headOption(map)`

JSDoc:

@internal */
const offerAll = exports.offerAll = /*#__PURE__*/(0, _Function.dual)(2, (self, values) => tRef.update(self.ref, map => Arr.fromIterable(values).reduce((map, value) => SortedMap.set(map, value, Option.match(SortedMap.get(map, value), {
  onNone: () => Arr.of(value),
  onSome: Arr.prepend(value)
})), map)));
/** @internal */
const peek = self => core.withSTMRuntime(runtime => {
  const map = tRef.unsafeGet(self.ref, runtime.journal);
  return Option.match(SortedMap.headOption(map), {
    onNone: () => core.retry,
    onSome: elements => core.succeed(elements[0])
  });
});
/** @internal

## peekOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `peekOption(= peekOption;
const removeIf = exports.removeIf = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `size(= size;
const take = self => core.withSTMRuntime(runtime => {
  const map = tRef.unsafeGet(self.ref, runtime.journal)`

JSDoc:

@internal */
const retainIf = exports.retainIf = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => tRef.update(self.ref, map => SortedMap.reduce(map, SortedMap.empty(SortedMap.getOrder(map)), (map, value, key) => {
  const filtered = Arr.filter(value, predicate);
  return filtered.length > 0 ? SortedMap.set(map, key, filtered) : SortedMap.remove(map, key);
})));
/** @internal */
const size = self => tRef.modify(self.ref, map => [SortedMap.reduce(map, 0, (n, as) => n + as.length), map]);
/** @internal

## take

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `take(= take;
const takeAll = self => tRef.modify(self.ref, map => {
  const builder = [];
  for (const entry of map)`

JSDoc:

@internal

## takeAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `takeAll(= takeAll;
const takeOption = self => core.effect(journal => {
  const map = (0, _Function.pipe)`

JSDoc:

@internal

## takeOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `takeOption(= takeOption;
const takeUpTo = exports.takeUpTo = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## toChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPriorityQueue.js`

Signature: `toChunk(= toChunk;
const toArray = self => tRef.modify(self.ref, map => {
  const builder = [];
  for (const entry of map)`

JSDoc:

@internal */
const toChunk = self => tRef.modify(self.ref, map => {
  const builder = [];
  for (const entry of map) {
    for (const value of entry[1]) {
      builder.push(value);
    }
  }
  return [Chunk.unsafeFromArray(builder), map];
});
/** @internal

## makeNode

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `makeNode(= makeNode;
class TPubSubImpl {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: _ => _
  };
  [tQueue.TEnqueueTypeId] = tQueue.tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers)`

JSDoc:

@internal */
const TPubSubSymbolKey = "effect/TPubSub";
/** @internal */
const TPubSubTypeId = exports.TPubSubTypeId = /*#__PURE__*/Symbol.for(TPubSubSymbolKey);
const AbsentValue = /*#__PURE__*/Symbol.for("effect/TPubSub/AbsentValue");
/** @internal */
const makeNode = (head, subscribers, tail) => ({
  head,
  subscribers,
  tail
});
/** @internal

## awaitShutdown

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `awaitShutdown(= awaitShutdown;
const bounded = requestedCapacity => makeTPubSub(requestedCapacity, tQueue.BackPressure)`

JSDoc:

@internal */
class TPubSubSubscriptionImpl {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [tQueue.TDequeueTypeId] = tQueue.tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /*#__PURE__*/core.effect(journal => {
    const currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, journal);
    return currentSubscriberHead === undefined;
  });
  awaitShutdown = /*#__PURE__*/core.flatMap(this.isShutdown, isShutdown => isShutdown ? stm.void : core.retry);
  capacity() {
    return this.requestedCapacity;
  }
  size = /*#__PURE__*/core.withSTMRuntime(runtime => {
    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
    if (currentSubscriberHead === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    let loop = true;
    let size = 0;
    while (loop) {
      const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
      if (node === undefined) {
        loop = false;
      } else {
        const head = node.head;
        const tail = node.tail;
        if (head !== AbsentValue) {
          size = size + 1;
          if (size >= Number.MAX_SAFE_INTEGER) {
            loop = false;
          }
        }
        currentSubscriberHead = tail;
      }
    }
    return core.succeed(size);
  });
  isEmpty = /*#__PURE__*/core.map(this.size, size => size === 0);
  isFull = /*#__PURE__*/core.map(this.size, size => size === this.capacity());
  peek = /*#__PURE__*/core.withSTMRuntime(runtime => {
    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
    if (currentSubscriberHead === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    let value = AbsentValue;
    let loop = true;
    while (loop) {
      const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
      if (node === undefined) {
        return core.retry;
      }
      const head = node.head;
      const tail = node.tail;
      if (head !== AbsentValue) {
        value = head;
        loop = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return core.succeed(value);
  });
  peekOption = /*#__PURE__*/core.withSTMRuntime(runtime => {
    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
    if (currentSubscriberHead === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    let value = Option.none();
    let loop = true;
    while (loop) {
      const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
      if (node === undefined) {
        value = Option.none();
        loop = false;
      } else {
        const head = node.head;
        const tail = node.tail;
        if (head !== AbsentValue) {
          value = Option.some(head);
          loop = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
    }
    return core.succeed(value);
  });
  shutdown = /*#__PURE__*/core.effect(journal => {
    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, journal);
    if (currentSubscriberHead !== undefined) {
      tRef.unsafeSet(this.subscriberHead, void 0, journal);
      let loop = true;
      while (loop) {
        const node = tRef.unsafeGet(currentSubscriberHead, journal);
        if (node === undefined) {
          loop = false;
        } else {
          const head = node.head;
          const tail = node.tail;
          if (head !== AbsentValue) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size = tRef.unsafeGet(this.pubsubSize, journal);
              const updatedNode = makeNode(AbsentValue, 0, tail);
              tRef.unsafeSet(currentSubscriberHead, updatedNode, journal);
              tRef.unsafeSet(this.publisherHead, tail, journal);
              tRef.unsafeSet(this.pubsubSize, size - 1, journal);
            } else {
              const updatedNode = makeNode(head, subscribers - 1, tail);
              tRef.unsafeSet(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail;
        }
      }
      const currentSubscriberCount = tRef.unsafeGet(this.subscriberCount, journal);
      tRef.unsafeSet(this.subscriberCount, currentSubscriberCount - 1, journal);
      tRef.unsafeSet(this.subscribers, HashSet.remove(tRef.unsafeGet(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /*#__PURE__*/core.withSTMRuntime(runtime => {
    let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
    if (currentSubscriberHead === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    let value = AbsentValue;
    let loop = true;
    while (loop) {
      const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
      if (node === undefined) {
        return core.retry;
      }
      const head = node.head;
      const tail = node.tail;
      if (head !== AbsentValue) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size = tRef.unsafeGet(this.pubsubSize, runtime.journal);
          const updatedNode = makeNode(AbsentValue, 0, tail);
          tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);
          tRef.unsafeSet(this.publisherHead, tail, runtime.journal);
          tRef.unsafeSet(this.pubsubSize, size - 1, runtime.journal);
        } else {
          const updatedNode = makeNode(head, subscribers - 1, tail);
          tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);
        }
        tRef.unsafeSet(this.subscriberHead, tail, runtime.journal);
        value = head;
        loop = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return core.succeed(value);
  });
  takeAll = /*#__PURE__*/this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max) {
    return core.withSTMRuntime(runtime => {
      let currentSubscriberHead = tRef.unsafeGet(this.subscriberHead, runtime.journal);
      if (currentSubscriberHead === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max) {
        const node = tRef.unsafeGet(currentSubscriberHead, runtime.journal);
        if (node === undefined) {
          n = max;
        } else {
          const head = node.head;
          const tail = node.tail;
          if (head !== AbsentValue) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size = tRef.unsafeGet(this.pubsubSize, runtime.journal);
              const updatedNode = makeNode(AbsentValue, 0, tail);
              tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);
              tRef.unsafeSet(this.publisherHead, tail, runtime.journal);
              tRef.unsafeSet(this.pubsubSize, size - 1, runtime.journal);
            } else {
              const updatedNode = makeNode(head, subscribers - 1, tail);
              tRef.unsafeSet(currentSubscriberHead, updatedNode, runtime.journal);
            }
            builder.push(head);
            n = n + 1;
          }
          currentSubscriberHead = tail;
        }
      }
      tRef.unsafeSet(this.subscriberHead, currentSubscriberHead, runtime.journal);
      return core.succeed(builder);
    });
  }
}
/** @internal */
const makeTPubSub = (requestedCapacity, strategy) => (0, _Function.pipe)(stm.all([tRef.make(void 0), tRef.make(0)]), core.flatMap(([empty, pubsubSize]) => (0, _Function.pipe)(stm.all([tRef.make(empty), tRef.make(empty), tRef.make(0), tRef.make(HashSet.empty())]), core.map(([publisherHead, publisherTail, subscriberCount, subscribers]) => new TPubSubImpl(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers)))));
const makeSubscription = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => (0, _Function.pipe)(tRef.get(publisherTail), core.flatMap(currentPublisherTail => (0, _Function.pipe)(stm.all([tRef.make(currentPublisherTail), tRef.get(subscriberCount), tRef.get(subscribers)]), stm.tap(([_, currentSubscriberCount]) => (0, _Function.pipe)(subscriberCount, tRef.set(currentSubscriberCount + 1))), stm.tap(([subscriberHead, _, currentSubscribers]) => (0, _Function.pipe)(subscribers, tRef.set((0, _Function.pipe)(currentSubscribers, HashSet.add(subscriberHead))))), core.map(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
/** @internal */
const awaitShutdown = self => self.awaitShutdown;
/** @internal

## bounded

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `bounded(= bounded;
const capacity = self => self.capacity()`

JSDoc:

@internal

## capacity

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `capacity(= capacity;
const dropping = requestedCapacity => makeTPubSub(requestedCapacity, tQueue.Dropping)`

JSDoc:

@internal

## dropping

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `dropping(= dropping;
const isEmpty = self => self.isEmpty;
/** @internal */
exports.isEmpty = isEmpty;
const isFull = self => self.isFull;
/** @internal */
exports.isFull = isFull;
const isShutdown = self => self.isShutdown;
/** @internal */
exports.isShutdown = isShutdown;
const publish = exports.publish = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `size(= size;
const shutdown = self => self.shutdown;
/** @internal */
exports.shutdown = shutdown;
const sliding = requestedCapacity => makeTPubSub(requestedCapacity, tQueue.Sliding)`

JSDoc:

@internal */
const publishAll = exports.publishAll = /*#__PURE__*/(0, _Function.dual)(2, (self, iterable) => self.offerAll(iterable));
/** @internal */
const size = self => self.size;
/** @internal

## sliding

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `sliding(= sliding;
const subscribe = self => makeSubscription(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers)`

JSDoc:

@internal

## subscribe

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `subscribe(= subscribe;
const subscribeScoped = self => Effect.acquireRelease(subscribe(self)`

JSDoc:

@internal

## subscribeScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tPubSub.js`

Signature: `subscribeScoped(= subscribeScoped;
const unbounded = ()`

JSDoc:

@internal

## isTQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `isTQueue(= isTQueue;
const isTEnqueue = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const TEnqueueTypeId = exports.TEnqueueTypeId = /*#__PURE__*/Symbol.for(TEnqueueSymbolKey);
const TDequeueSymbolKey = "effect/TQueue/TDequeue";
/** @internal */
const TDequeueTypeId = exports.TDequeueTypeId = /*#__PURE__*/Symbol.for(TDequeueSymbolKey);
/** @internal */
const BackPressure = exports.BackPressure = {
  _tag: OpCodes.OP_BACKPRESSURE_STRATEGY
};
/** @internal */
const Dropping = exports.Dropping = {
  _tag: OpCodes.OP_DROPPING_STRATEGY
};
/** @internal */
const Sliding = exports.Sliding = {
  _tag: OpCodes.OP_SLIDING_STRATEGY
};
/** @internal */
const tDequeueVariance = exports.tDequeueVariance = {
  /* c8 ignore next */
  _Out: _ => _
};
/** @internal */
const tEnqueueVariance = exports.tEnqueueVariance = {
  /* c8 ignore next */
  _In: _ => _
};
class TQueueImpl {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = /*#__PURE__*/core.withSTMRuntime(runtime => {
    const queue = tRef.unsafeGet(this.ref, runtime.journal);
    if (queue === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    return core.succeed(queue.length);
  });
  isFull = /*#__PURE__*/core.map(this.size, size => size === this.requestedCapacity);
  isEmpty = /*#__PURE__*/core.map(this.size, size => size === 0);
  shutdown = /*#__PURE__*/core.withSTMRuntime(runtime => {
    tRef.unsafeSet(this.ref, void 0, runtime.journal);
    return stm.void;
  });
  isShutdown = /*#__PURE__*/core.effect(journal => {
    const queue = tRef.unsafeGet(this.ref, journal);
    return queue === undefined;
  });
  awaitShutdown = /*#__PURE__*/core.flatMap(this.isShutdown, isShutdown => isShutdown ? stm.void : core.retry);
  offer(value) {
    return core.withSTMRuntime(runtime => {
      const queue = (0, _Function.pipe)(this.ref, tRef.unsafeGet(runtime.journal));
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value);
        tRef.unsafeSet(this.ref, queue, runtime.journal);
        return core.succeed(true);
      }
      switch (this.strategy._tag) {
        case OpCodes.OP_BACKPRESSURE_STRATEGY:
          {
            return core.retry;
          }
        case OpCodes.OP_DROPPING_STRATEGY:
          {
            return core.succeed(false);
          }
        case OpCodes.OP_SLIDING_STRATEGY:
          {
            if (queue.length === 0) {
              return core.succeed(true);
            }
            queue.shift();
            queue.push(value);
            tRef.unsafeSet(this.ref, queue, runtime.journal);
            return core.succeed(true);
          }
      }
    });
  }
  offerAll(iterable) {
    return core.withSTMRuntime(runtime => {
      const as = Array.from(iterable);
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      if (queue.length + as.length <= this.requestedCapacity) {
        tRef.unsafeSet(this.ref, [...queue, ...as], runtime.journal);
        return core.succeed(true);
      }
      switch (this.strategy._tag) {
        case OpCodes.OP_BACKPRESSURE_STRATEGY:
          {
            return core.retry;
          }
        case OpCodes.OP_DROPPING_STRATEGY:
          {
            const forQueue = as.slice(0, this.requestedCapacity - queue.length);
            tRef.unsafeSet(this.ref, [...queue, ...forQueue], runtime.journal);
            return core.succeed(false);
          }
        case OpCodes.OP_SLIDING_STRATEGY:
          {
            const forQueue = as.slice(0, this.requestedCapacity - queue.length);
            const toDrop = queue.length + forQueue.length - this.requestedCapacity;
            const newQueue = queue.slice(toDrop);
            tRef.unsafeSet(this.ref, [...newQueue, ...forQueue], runtime.journal);
            return core.succeed(true);
          }
      }
    });
  }
  peek = /*#__PURE__*/core.withSTMRuntime(runtime => {
    const queue = tRef.unsafeGet(this.ref, runtime.journal);
    if (queue === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    if (queue.length === 0) {
      return core.retry;
    }
    return core.succeed(queue[0]);
  });
  peekOption = /*#__PURE__*/core.withSTMRuntime(runtime => {
    const queue = tRef.unsafeGet(this.ref, runtime.journal);
    if (queue === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    return core.succeed(Option.fromNullable(queue[0]));
  });
  take = /*#__PURE__*/core.withSTMRuntime(runtime => {
    const queue = tRef.unsafeGet(this.ref, runtime.journal);
    if (queue === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    if (queue.length === 0) {
      return core.retry;
    }
    const dequeued = queue.shift();
    tRef.unsafeSet(this.ref, queue, runtime.journal);
    return core.succeed(dequeued);
  });
  takeAll = /*#__PURE__*/core.withSTMRuntime(runtime => {
    const queue = tRef.unsafeGet(this.ref, runtime.journal);
    if (queue === undefined) {
      return core.interruptAs(runtime.fiberId);
    }
    tRef.unsafeSet(this.ref, [], runtime.journal);
    return core.succeed(queue);
  });
  takeUpTo(max) {
    return core.withSTMRuntime(runtime => {
      const queue = tRef.unsafeGet(this.ref, runtime.journal);
      if (queue === undefined) {
        return core.interruptAs(runtime.fiberId);
      }
      const [toTake, remaining] = Chunk.splitAt(Chunk.unsafeFromArray(queue), max);
      tRef.unsafeSet(this.ref, Array.from(remaining), runtime.journal);
      return core.succeed(Array.from(toTake));
    });
  }
}
/** @internal */
const isTQueue = u => {
  return isTEnqueue(u) && isTDequeue(u);
};
/** @internal

## isTEnqueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `isTEnqueue(= isTEnqueue;
const isTDequeue = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isTDequeue

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `isTDequeue(= isTDequeue;
const awaitShutdown = self => self.awaitShutdown;
/** @internal */
exports.awaitShutdown = awaitShutdown;
const bounded = requestedCapacity => makeQueue(requestedCapacity, BackPressure)`

JSDoc:

@internal

## bounded

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `bounded(= bounded;
const capacity = self => {
  return self.capacity()`

JSDoc:

@internal

## capacity

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `capacity(= capacity;
const dropping = requestedCapacity => makeQueue(requestedCapacity, Dropping)`

JSDoc:

@internal

## dropping

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `dropping(= dropping;
const isEmpty = self => self.isEmpty;
/** @internal */
exports.isEmpty = isEmpty;
const isFull = self => self.isFull;
/** @internal */
exports.isFull = isFull;
const isShutdown = self => self.isShutdown;
/** @internal */
exports.isShutdown = isShutdown;
const offer = exports.offer = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## peek

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `peek(= peek;
const peekOption = self => self.peekOption;
/** @internal */
exports.peekOption = peekOption;
const poll = self => (0, _Function.pipe)`

JSDoc:

@internal */
const offerAll = exports.offerAll = /*#__PURE__*/(0, _Function.dual)(2, (self, iterable) => self.offerAll(iterable));
/** @internal */
const peek = self => self.peek;
/** @internal

## poll

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `poll(= poll;
const seek = exports.seek = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## shutdown

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `shutdown(= shutdown;
const size = self => self.size;
/** @internal */
exports.size = size;
const sliding = requestedCapacity => makeQueue(requestedCapacity, Sliding)`

JSDoc:

@internal */
const shutdown = self => self.shutdown;
/** @internal

## sliding

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tQueue.js`

Signature: `sliding(= sliding;
const take = self => self.take;
/** @internal */
exports.take = take;
const takeAll = self => self.takeAll;
/** @internal */
exports.takeAll = takeAll;
const takeBetween = exports.takeBetween = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## nextIntBetween

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tRandom.js`

Signature: `nextIntBetween(= nextIntBetween;
const nextRange = (min, max)`

JSDoc:

@internal */
const TRandomTypeId = exports.TRandomTypeId = /*#__PURE__*/Symbol.for(TRandomSymbolKey);
const randomInteger = state => {
  const prng = new Random.PCGRandom();
  prng.setState(state);
  return [prng.integer(0), prng.getState()];
};
const randomIntegerBetween = (low, high) => {
  return state => {
    const prng = new Random.PCGRandom();
    prng.setState(state);
    return [prng.integer(high - low) + low, prng.getState()];
  };
};
const randomNumber = state => {
  const prng = new Random.PCGRandom();
  prng.setState(state);
  return [prng.number(), prng.getState()];
};
const withState = (state, f) => {
  return (0, _Function.pipe)(state, tRef.modify(f));
};
const shuffleWith = (iterable, nextIntBounded) => {
  const swap = (buffer, index1, index2) => (0, _Function.pipe)(buffer, tArray.get(index1), core.flatMap(tmp => (0, _Function.pipe)(buffer, tArray.updateSTM(index1, () => (0, _Function.pipe)(buffer, tArray.get(index2))), core.zipRight((0, _Function.pipe)(buffer, tArray.update(index2, () => tmp))))));
  return (0, _Function.pipe)(tArray.fromIterable(iterable), core.flatMap(buffer => {
    const array = [];
    for (let i = array.length; i >= 2; i = i - 1) {
      array.push(i);
    }
    return (0, _Function.pipe)(array, stm.forEach(n => (0, _Function.pipe)(nextIntBounded(n), core.flatMap(k => swap(buffer, n - 1, k))), {
      discard: true
    }), core.zipRight(tArray.toArray(buffer)));
  }));
};
/** @internal */
const Tag = exports.Tag = /*#__PURE__*/Context.GenericTag("effect/TRandom");
class TRandomImpl {
  state;
  [TRandomTypeId] = TRandomTypeId;
  constructor(state) {
    this.state = state;
    this.next = withState(this.state, randomNumber);
    this.nextBoolean = core.flatMap(this.next, n => core.succeed(n > 0.5));
    this.nextInt = withState(this.state, randomInteger);
  }
  next;
  nextBoolean;
  nextInt;
  nextRange(min, max) {
    return core.flatMap(this.next, n => core.succeed((max - min) * n + min));
  }
  nextIntBetween(low, high) {
    return withState(this.state, randomIntegerBetween(low, high));
  }
  shuffle(elements) {
    return shuffleWith(elements, n => this.nextIntBetween(0, n));
  }
}
/** @internal */
const live = exports.live = /*#__PURE__*/Layer.effect(Tag, /*#__PURE__*/(0, _Function.pipe)(/*#__PURE__*/tRef.make(/*#__PURE__*/new Random.PCGRandom(Math.random() * 4294967296 >>> 0).getState()), /*#__PURE__*/core.map(seed => new TRandomImpl(seed)), core.commit));
/** @internal */
const next = exports.next = /*#__PURE__*/core.flatMap(Tag, random => random.next);
/** @internal */
const nextBoolean = exports.nextBoolean = /*#__PURE__*/core.flatMap(Tag, random => random.nextBoolean);
/** @internal */
const nextInt = exports.nextInt = /*#__PURE__*/core.flatMap(Tag, random => random.nextInt);
/** @internal */
const nextIntBetween = (low, high) => core.flatMap(Tag, random => random.nextIntBetween(low, high));
/** @internal

## nextRange

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tRandom.js`

Signature: `nextRange(= nextRange;
const shuffle = elements => core.flatMap(Tag, random => random.shuffle(elements)`

JSDoc:

@internal

## ReadLock

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `ReadLock(= ReadLock;
class WriteLock {
  readLocks;
  writeLocks;
  fiberId;
  [WriteLockTypeId] = WriteLockTypeId;
  constructor(readLocks, writeLocks, fiberId)`

JSDoc:

@internal */
const TReentrantLockTypeId = exports.TReentrantLockTypeId = /*#__PURE__*/Symbol.for(TReentrantLockSymbolKey);
const WriteLockTypeId = /*#__PURE__*/Symbol.for("effect/TReentrantLock/WriteLock");
const ReadLockTypeId = /*#__PURE__*/Symbol.for("effect/TReentrantLock/ReadLock");
class TReentranLockImpl {
  state;
  [TReentrantLockTypeId] = TReentrantLockTypeId;
  constructor(state) {
    this.state = state;
  }
}
/**
This data structure describes the state of the lock when multiple fibers
have acquired read locks. The state is tracked as a map from fiber identity
to number of read locks acquired by the fiber. This level of detail permits
upgrading a read lock to a write lock.

@internal
/
class ReadLock {
  readers;
  [ReadLockTypeId] = ReadLockTypeId;
  constructor(readers) {
    this.readers = readers;
  }
  get readLocks() {
    return Array.from(this.readers).reduce((acc, curr) => acc + curr[1], 0);
  }
  get writeLocks() {
    return 0;
  }
  readLocksHeld(fiberId) {
    return Option.getOrElse(HashMap.get(this.readers, fiberId), () => 0);
  }
  writeLocksHeld(_fiberId) {
    return 0;
  }
}
/**
This data structure describes the state of the lock when a single fiber has
a write lock. The fiber has an identity, and may also have acquired a
certain number of read locks.

@internal

## acquireRead

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `acquireRead(= acquireRead;
const acquireWrite = self => core.withSTMRuntime(runtime => {
  const lock = tRef.unsafeGet(self.state, runtime.journal)`

JSDoc:

An empty read lock state, in which no fiber holds any read locks.
/
const emptyReadLock = /*#__PURE__*/new ReadLock(/*#__PURE__*/HashMap.empty());
/**
Creates a new read lock where the specified fiber holds the specified
number of read locks.
/
const makeReadLock = (fiberId, count) => {
  if (count <= 0) {
    return emptyReadLock;
  }
  return new ReadLock(HashMap.make([fiberId, count]));
};
/**
Determines if there is no other holder of read locks aside from the
specified fiber id. If there are no other holders of read locks aside
from the specified fiber id, then it is safe to upgrade the read lock
into a write lock.
/
const noOtherHolder = (readLock, fiberId) => {
  return HashMap.isEmpty(readLock.readers) || HashMap.size(readLock.readers) === 1 && HashMap.has(readLock.readers, fiberId);
};
/**
Adjusts the number of read locks held by the specified fiber id.
/
const adjustReadLock = (readLock, fiberId, adjustment) => {
  const total = readLock.readLocksHeld(fiberId);
  const newTotal = total + adjustment;
  if (newTotal < 0) {
    throw new Error("BUG - TReentrantLock.ReadLock.adjust - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  if (newTotal === 0) {
    return new ReadLock(HashMap.remove(readLock.readers, fiberId));
  }
  return new ReadLock(HashMap.set(readLock.readers, fiberId, newTotal));
};
const adjustRead = (self, delta) => core.withSTMRuntime(runtime => {
  const lock = tRef.unsafeGet(self.state, runtime.journal);
  if (isReadLock(lock)) {
    const result = adjustReadLock(lock, runtime.fiberId, delta);
    tRef.unsafeSet(self.state, result, runtime.journal);
    return core.succeed(result.readLocksHeld(runtime.fiberId));
  }
  if (isWriteLock(lock) && Equal.equals(runtime.fiberId)(lock.fiberId)) {
    const newTotal = lock.readLocks + delta;
    if (newTotal < 0) {
      throw new Error(`Defect: Fiber ${FiberId.threadName(runtime.fiberId)} releasing read locks it does not hold, newTotal: ${newTotal}`);
    }
    tRef.unsafeSet(self.state, new WriteLock(newTotal, lock.writeLocks, runtime.fiberId), runtime.journal);
    return core.succeed(newTotal);
  }
  return core.retry;
});
/** @internal */
const acquireRead = self => adjustRead(self, 1);
/** @internal

## acquireWrite

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `acquireWrite(= acquireWrite;
const fiberReadLocks = self => core.effect((journal, fiberId)`

JSDoc:

@internal

## fiberReadLocks

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `fiberReadLocks(= fiberReadLocks;
const fiberWriteLocks = self => core.effect((journal, fiberId)`

JSDoc:

@internal

## fiberWriteLocks

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `fiberWriteLocks(= fiberWriteLocks;
const lock = self => writeLock(self)`

JSDoc:

@internal

## lock

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `lock(= lock;
const locked = self => core.zipWith(readLocked(self)`

JSDoc:

@internal

## locked

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `locked(= locked;
const make = exports.make = /*#__PURE__*/core.map(/*#__PURE__*/tRef.make(emptyReadLock)`

JSDoc:

@internal

## readLock

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `readLock(= readLock;
const readLocks = self => core.map(tRef.get(self.state)`

JSDoc:

@internal */
const readLock = self => Effect.acquireRelease(core.commit(acquireRead(self)), () => core.commit(releaseRead(self)));
/** @internal

## readLocks

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `readLocks(= readLocks;
const readLocked = self => core.map(tRef.get(self.state)`

JSDoc:

@internal

## readLocked

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `readLocked(= readLocked;
const releaseRead = self => adjustRead(self, -1)`

JSDoc:

@internal

## releaseRead

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `releaseRead(= releaseRead;
const releaseWrite = self => core.withSTMRuntime(runtime => {
  const lock = tRef.unsafeGet(self.state, runtime.journal)`

JSDoc:

@internal

## releaseWrite

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `releaseWrite(= releaseWrite;
const withLock = exports.withLock = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## writeLock

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `writeLock(= writeLock;
const writeLocked = self => core.map(tRef.get(self.state)`

JSDoc:

@internal */
const withReadLock = exports.withReadLock = /*#__PURE__*/(0, _Function.dual)(2, (effect, self) => Effect.uninterruptibleMask(restore => Effect.zipRight(restore(core.commit(acquireRead(self))), Effect.ensuring(effect, core.commit(releaseRead(self))))));
/** @internal */
const withWriteLock = exports.withWriteLock = /*#__PURE__*/(0, _Function.dual)(2, (effect, self) => Effect.uninterruptibleMask(restore => Effect.zipRight(restore(core.commit(acquireWrite(self))), Effect.ensuring(effect, core.commit(releaseWrite(self))))));
/** @internal */
const writeLock = self => Effect.acquireRelease(core.commit(acquireWrite(self)), () => core.commit(releaseWrite(self)));
/** @internal

## writeLocked

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tReentrantLock.js`

Signature: `writeLocked(= writeLocked;
const writeLocks = self => core.map(tRef.get(self.state)`

JSDoc:

@internal

## TRefImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tRef.js`

Signature: `TRefImpl(= TRefImpl;
const make = value => core.effect(journal => {
  const ref = new TRefImpl(value)`

JSDoc:

@internal */
const TRefSymbolKey = "effect/TRef";
/** @internal */
const TRefTypeId = exports.TRefTypeId = /*#__PURE__*/Symbol.for(TRefSymbolKey);
const tRefVariance = exports.tRefVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class TRefImpl {
  [TRefTypeId] = tRefVariance;
  /** @internal */
  todos;
  /** @internal */
  versioned;
  constructor(value) {
    this.versioned = new Versioned.Versioned(value);
    this.todos = new Map();
  }
  modify(f) {
    return core.effect(journal => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(Entry.unsafeGet(entry));
      Entry.unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tRef.js`

Signature: `make(= make;
const get = self => self.modify(a => [a, a])`

JSDoc:

@internal

## get

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tRef.js`

Signature: `get(= get;
const set = exports.set = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSemaphore.js`

Signature: `make(= make;
const acquire = self => acquireN(self, 1)`

JSDoc:

@internal */
const TSemaphoreSymbolKey = "effect/TSemaphore";
/** @internal */
const TSemaphoreTypeId = exports.TSemaphoreTypeId = /*#__PURE__*/Symbol.for(TSemaphoreSymbolKey);
/** @internal */
class TSemaphoreImpl {
  permits;
  [TSemaphoreTypeId] = TSemaphoreTypeId;
  constructor(permits) {
    this.permits = permits;
  }
}
/** @internal */
const make = permits => STM.map(tRef.make(permits), permits => new TSemaphoreImpl(permits));
/** @internal

## acquire

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSemaphore.js`

Signature: `acquire(= acquire;
const acquireN = exports.acquireN = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## available

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSemaphore.js`

Signature: `available(= available;
const release = self => releaseN(self, 1)`

JSDoc:

@internal */
const available = self => tRef.get(self.permits);
/** @internal

## release

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSemaphore.js`

Signature: `release(= release;
const releaseN = exports.releaseN = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## withPermitScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSemaphore.js`

Signature: `withPermitScoped(= withPermitScoped;
const withPermitsScoped = exports.withPermitsScoped = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const withPermit = exports.withPermit = /*#__PURE__*/(0, _Function.dual)(2, (self, semaphore) => withPermits(self, semaphore, 1));
/** @internal */
const withPermits = exports.withPermits = /*#__PURE__*/(0, _Function.dual)(3, (self, semaphore, permits) => Effect.uninterruptibleMask(restore => Effect.zipRight(restore(core.commit(acquireN(permits)(semaphore))), Effect.ensuring(self, core.commit(releaseN(permits)(semaphore))))));
/** @internal */
const withPermitScoped = self => withPermitsScoped(self, 1);
/** @internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `empty(= empty;
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const TSetSymbolKey = "effect/TSet";
/** @internal */
const TSetTypeId = exports.TSetTypeId = /*#__PURE__*/Symbol.for(TSetSymbolKey);
const tSetVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class TSetImpl {
  tMap;
  [TSetTypeId] = tSetVariance;
  constructor(tMap) {
    this.tMap = tMap;
  }
}
const isTSet = u => (0, _Predicate.hasProperty)(u, TSetTypeId);
/** @internal */
const add = exports.add = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => tMap.set(self.tMap, value, void 0));
/** @internal */
const difference = exports.difference = /*#__PURE__*/(0, _Function.dual)(2, (self, other) => core.flatMap(toHashSet(other), values => removeIf(self, value => HashSet.has(values, value), {
  discard: true
})));
/** @internal */
const empty = () => fromIterable([]);
/** @internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `fromIterable(= fromIterable;
const has = exports.has = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const fromIterable = iterable => core.map(tMap.fromIterable(Array.from(iterable).map(a => [a, void 0])), tMap => new TSetImpl(tMap));
/** @internal

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `isEmpty(= isEmpty;
const make = (...elements)`

JSDoc:

@internal */
const intersection = exports.intersection = /*#__PURE__*/(0, _Function.dual)(2, (self, other) => core.flatMap(toHashSet(other), values => (0, _Function.pipe)(self, retainIf(value => (0, _Function.pipe)(values, HashSet.has(value)), {
  discard: true
}))));
/** @internal */
const isEmpty = self => tMap.isEmpty(self.tMap);
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `make(= make;
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `size(= size;
const takeFirst = exports.takeFirst = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const reduceSTM = exports.reduceSTM = /*#__PURE__*/(0, _Function.dual)(3, (self, zero, f) => tMap.reduceSTM(self.tMap, zero, (acc, _, key) => f(acc, key)));
/** @internal */
const remove = exports.remove = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => tMap.remove(self.tMap, value));
/** @internal */
const removeAll = exports.removeAll = /*#__PURE__*/(0, _Function.dual)(2, (self, iterable) => tMap.removeAll(self.tMap, iterable));
/** @internal */
const removeIf = exports.removeIf = /*#__PURE__*/(0, _Function.dual)(args => isTSet(args[0]), (self, predicate, options) => options?.discard === true ? tMap.removeIf(self.tMap, key => predicate(key), {
  discard: true
}) : (0, _Function.pipe)(tMap.removeIf(self.tMap, key => predicate(key)), core.map(RA.map(entry => entry[0]))));
/** @internal */
const retainIf = exports.retainIf = /*#__PURE__*/(0, _Function.dual)(args => isTSet(args[0]), (self, predicate, options) => options?.discard === true ? tMap.retainIf(self.tMap, key => predicate(key), {
  discard: true
}) : (0, _Function.pipe)(tMap.retainIf(self.tMap, key => predicate(key)), core.map(RA.map(entry => entry[0]))));
/** @internal */
const size = self => core.map(toChunk(self), chunk => chunk.length);
/** @internal

## toChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `toChunk(= toChunk;
const toHashSet = self => reduce(self, HashSet.empty()`

JSDoc:

@internal */
const takeFirstSTM = exports.takeFirstSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => tMap.takeFirstSTM(self.tMap, key => pf(key)));
/** @internal */
const takeSome = exports.takeSome = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => tMap.takeSome(self.tMap, key => pf(key)));
/** @internal */
const takeSomeSTM = exports.takeSomeSTM = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => tMap.takeSomeSTM(self.tMap, key => pf(key)));
/** @internal */
const toChunk = self => tMap.keys(self.tMap).pipe(STM.map(Chunk.unsafeFromArray));
/** @internal

## toHashSet

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `toHashSet(= toHashSet;
const toArray = self => reduce(self, [], (acc, value)`

JSDoc:

@internal

## toArray

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `toArray(= toArray;
const toReadonlySet = self => core.map(toArray(self)`

JSDoc:

@internal

## toReadonlySet

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSet.js`

Signature: `toReadonlySet(= toReadonlySet;
const transform = exports.transform = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSubscriptionRef.js`

Signature: `make(= make;
const get = self => TRef.get(self.ref)`

JSDoc:

@internal */
const TSubscriptionRefSymbolKey = "effect/TSubscriptionRef";
/** @internal */
const TSubscriptionRefTypeId = exports.TSubscriptionRefTypeId = /*#__PURE__*/Symbol.for(TSubscriptionRefSymbolKey);
const TSubscriptionRefVariance = {
  /* c8 ignore next */
  _A: _ => _
};
class TDequeueMerge {
  first;
  second;
  [TQueue.TDequeueTypeId] = _tQueue.tDequeueVariance;
  constructor(first, second) {
    this.first = first;
    this.second = second;
  }
  peek = /*#__PURE__*/STM.gen(this, function* () {
    const first = yield* this.peekOption;
    if (first._tag === "Some") {
      return first.value;
    }
    return yield* STM.retry;
  });
  peekOption = /*#__PURE__*/STM.gen(this, function* () {
    const first = yield* this.first.peekOption;
    if (first._tag === "Some") {
      return first;
    }
    const second = yield* this.second.peekOption;
    if (second._tag === "Some") {
      return second;
    }
    return Option.none();
  });
  take = /*#__PURE__*/STM.gen(this, function* () {
    if (!(yield* this.first.isEmpty)) {
      return yield* this.first.take;
    }
    if (!(yield* this.second.isEmpty)) {
      return yield* this.second.take;
    }
    return yield* STM.retry;
  });
  takeAll = /*#__PURE__*/STM.gen(this, function* () {
    return [...(yield* this.first.takeAll), ...(yield* this.second.takeAll)];
  });
  takeUpTo(max) {
    return STM.gen(this, function* () {
      const first = yield* this.first.takeUpTo(max);
      if (first.length >= max) {
        return first;
      }
      return [...first, ...(yield* this.second.takeUpTo(max - first.length))];
    });
  }
  capacity() {
    return this.first.capacity() + this.second.capacity();
  }
  size = /*#__PURE__*/STM.gen(this, function* () {
    return (yield* this.first.size) + (yield* this.second.size);
  });
  isFull = /*#__PURE__*/STM.gen(this, function* () {
    return (yield* this.first.isFull) && (yield* this.second.isFull);
  });
  isEmpty = /*#__PURE__*/STM.gen(this, function* () {
    return (yield* this.first.isEmpty) && (yield* this.second.isEmpty);
  });
  shutdown = /*#__PURE__*/STM.gen(this, function* () {
    yield* this.first.shutdown;
    yield* this.second.shutdown;
  });
  isShutdown = /*#__PURE__*/STM.gen(this, function* () {
    return (yield* this.first.isShutdown) && (yield* this.second.isShutdown);
  });
  awaitShutdown = /*#__PURE__*/STM.gen(this, function* () {
    yield* this.first.awaitShutdown;
    yield* this.second.awaitShutdown;
  });
}
/** @internal */
class TSubscriptionRefImpl {
  ref;
  pubsub;
  [TSubscriptionRefTypeId] = TSubscriptionRefVariance;
  [TRef.TRefTypeId] = _tRef.tRefVariance;
  constructor(ref, pubsub) {
    this.ref = ref;
    this.pubsub = pubsub;
  }
  get todos() {
    return this.ref.todos;
  }
  get versioned() {
    return this.ref.versioned;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
  get changes() {
    return STM.gen(this, function* () {
      const first = yield* TQueue.unbounded();
      yield* TQueue.offer(first, yield* TRef.get(this.ref));
      return new TDequeueMerge(first, yield* TPubSub.subscribe(this.pubsub));
    });
  }
  modify(f) {
    return (0, _Function.pipe)(TRef.get(this.ref), STM.map(f), STM.flatMap(([b, a]) => (0, _Function.pipe)(TRef.set(this.ref, a), STM.as(b), STM.zipLeft(TPubSub.publish(this.pubsub, a)))));
  }
}
/** @internal */
const make = value => (0, _Function.pipe)(STM.all([TPubSub.unbounded(), TRef.make(value)]), STM.map(([pubsub, ref]) => new TSubscriptionRefImpl(ref, pubsub)));
/** @internal

## get

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSubscriptionRef.js`

Signature: `get(= get;
const set = exports.set = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## changesScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tSubscriptionRef.js`

Signature: `changesScoped(= changesScoped;
const changesStream = self => stream.unwrap(Effect.map(self.changes, stream.fromTQueue)`

JSDoc:

@internal */
const getAndSet = exports.getAndSet = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => self.modify(a => [a, value]));
/** @internal */
const getAndUpdate = exports.getAndUpdate = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.modify(a => [a, f(a)]));
/** @internal */
const getAndUpdateSome = exports.getAndUpdateSome = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.modify(a => Option.match(f(a), {
  onNone: () => [a, a],
  onSome: b => [a, b]
})));
/** @internal */
const setAndGet = exports.setAndGet = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => self.modify(() => [value, value]));
/** @internal */
const modify = exports.modify = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.modify(f));
/** @internal */
const modifySome = exports.modifySome = /*#__PURE__*/(0, _Function.dual)(3, (self, fallback, f) => self.modify(a => Option.match(f(a), {
  onNone: () => [fallback, a],
  onSome: b => b
})));
/** @internal */
const update = exports.update = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.modify(a => [void 0, f(a)]));
/** @internal */
const updateAndGet = exports.updateAndGet = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.modify(a => {
  const b = f(a);
  return [b, b];
}));
/** @internal */
const updateSome = exports.updateSome = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.modify(a => [void 0, Option.match(f(a), {
  onNone: () => a,
  onSome: b => b
})]));
/** @internal */
const updateSomeAndGet = exports.updateSomeAndGet = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => self.modify(a => Option.match(f(a), {
  onNone: () => [a, a],
  onSome: b => [b, b]
})));
/** @internal */
const changesScoped = self => Effect.acquireRelease(self.changes, TQueue.shutdown);
/** @internal

## done

Source: `my-backend/node_modules/effect/dist/cjs/internal/stm/tryCommit.js`

Signature: `done(= done;
const suspend = journal => {
  return {
    _tag: OpCodes.OP_SUSPEND,
    journal
  };
};
exports.suspend = suspend;
//# sourceMappingURL=tryCommit.js.map)`

JSDoc:

@internal */
const done = exit => {
  return {
    _tag: OpCodes.OP_DONE,
    exit
  };
};
/** @internal

## previous

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/debounceState.js`

Signature: `previous(= previous;
const current = fiber => ({
  _tag: OP_CURRENT,
  fiber
})`

JSDoc:

@internal */
const OP_NOT_STARTED = exports.OP_NOT_STARTED = "NotStarted";
/** @internal */
const OP_PREVIOUS = exports.OP_PREVIOUS = "Previous";
/** @internal */
const OP_CURRENT = exports.OP_CURRENT = "Current";
/** @internal */
const notStarted = exports.notStarted = {
  _tag: OP_NOT_STARTED
};
/** @internal */
const previous = fiber => ({
  _tag: OP_PREVIOUS,
  fiber
});
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/emit.js`

Signature: `make(= make;
const makePush = (queue, scheduler)`

JSDoc:

@internal */
const make = emit => {
  const ops = {
    chunk(as) {
      return this(Effect.succeed(as));
    },
    die(defect) {
      return this(Effect.die(defect));
    },
    dieMessage(message) {
      return this(Effect.dieMessage(message));
    },
    done(exit) {
      return this(Effect.suspend(() => Exit.mapBoth(exit, {
        onFailure: Option.some,
        onSuccess: Chunk.of
      })));
    },
    end() {
      return this(Effect.fail(Option.none()));
    },
    fail(e) {
      return this(Effect.fail(Option.some(e)));
    },
    fromEffect(effect) {
      return this(Effect.mapBoth(effect, {
        onFailure: Option.some,
        onSuccess: Chunk.of
      }));
    },
    fromEffectChunk(effect) {
      return this((0, _Function.pipe)(effect, Effect.mapError(Option.some)));
    },
    halt(cause) {
      return this(Effect.failCause((0, _Function.pipe)(cause, Cause.map(Option.some))));
    },
    single(value) {
      return this(Effect.succeed(Chunk.of(value)));
    }
  };
  return Object.assign(emit, ops);
};
/** @internal

## fromInput

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/haltStrategy.js`

Signature: `fromInput(= fromInput;
const isLeft = self => self._tag === OpCodes.OP_LEFT;
/** @internal */
exports.isLeft = isLeft;
const isRight = self => self._tag === OpCodes.OP_RIGHT;
/** @internal */
exports.isRight = isRight;
const isBoth = self => self._tag === OpCodes.OP_BOTH;
/** @internal */
exports.isBoth = isBoth;
const isEither = self => self._tag === OpCodes.OP_EITHER;
/** @internal */
exports.isEither = isEither;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const Left = exports.Left = {
  _tag: OpCodes.OP_LEFT
};
/** @internal */
const Right = exports.Right = {
  _tag: OpCodes.OP_RIGHT
};
/** @internal */
const Both = exports.Both = {
  _tag: OpCodes.OP_BOTH
};
/** @internal */
const Either = exports.Either = {
  _tag: OpCodes.OP_EITHER
};
/** @internal */
const fromInput = input => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/handoff.js`

Signature: `make(= make;
const offer = exports.offer = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const HandoffTypeId = exports.HandoffTypeId = /*#__PURE__*/Symbol.for("effect/Stream/Handoff");
/** @internal */
const OP_HANDOFF_STATE_EMPTY = exports.OP_HANDOFF_STATE_EMPTY = "Empty";
/** @internal */
const OP_HANDOFF_STATE_FULL = exports.OP_HANDOFF_STATE_FULL = "Full";
/** @internal */
const handoffStateEmpty = notifyConsumer => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
/** @internal */
const handoffStateFull = (value, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value,
  notifyProducer
});
/** @internal */
const handoffStateMatch = (onEmpty, onFull) => {
  return self => {
    switch (self._tag) {
      case OP_HANDOFF_STATE_EMPTY:
        {
          return onEmpty(self.notifyConsumer);
        }
      case OP_HANDOFF_STATE_FULL:
        {
          return onFull(self.value, self.notifyProducer);
        }
    }
  };
};
const handoffVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
const make = () => (0, _Function.pipe)(Deferred.make(), Effect.flatMap(deferred => Ref.make(handoffStateEmpty(deferred))), Effect.map(ref => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
/** @internal

## take

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/handoff.js`

Signature: `take(= take;
const poll = self => Effect.flatMap(Deferred.make()`

JSDoc:

@internal */
const take = self => Effect.flatMap(Deferred.make(), deferred => Effect.flatten(Ref.modify(self.ref, state => (0, _Function.pipe)(state, handoffStateMatch(notifyConsumer => [Effect.flatMap(Deferred.await(notifyConsumer), () => take(self)), state], (value, notifyProducer) => [Effect.as(Deferred.succeed(notifyProducer, void 0), value), handoffStateEmpty(deferred)])))));
/** @internal

## emit

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/handoffSignal.js`

Signature: `emit(= emit;
const halt = cause => ({
  _tag: OP_HALT,
  cause
})`

JSDoc:

@internal */
const OP_EMIT = exports.OP_EMIT = "Emit";
/** @internal */
const OP_HALT = exports.OP_HALT = "Halt";
/** @internal */
const OP_END = exports.OP_END = "End";
/** @internal */
const emit = elements => ({
  _tag: OP_EMIT,
  elements
});
/** @internal

## halt

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/handoffSignal.js`

Signature: `halt(= halt;
const end = reason => ({
  _tag: OP_END,
  reason
})`

JSDoc:

@internal

## emit

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/pull.js`

Signature: `emit(= emit;
const emitChunk = chunk => Effect.succeed(chunk)`

JSDoc:

@internal */
const emit = value => Effect.succeed(Chunk.of(value));
/** @internal

## emitChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/pull.js`

Signature: `emitChunk(= emitChunk;
const empty = ()`

JSDoc:

@internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/pull.js`

Signature: `empty(= empty;
const end = ()`

JSDoc:

@internal

## end

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/pull.js`

Signature: `end(= end;
const fail = error => Effect.fail(Option.some(error)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/pull.js`

Signature: `fail(= fail;
const failCause = cause => Effect.mapError(Effect.failCause(cause)`

JSDoc:

@internal

## failCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/pull.js`

Signature: `failCause(= failCause;
const fromDequeue = dequeue => Effect.flatMap(Queue.take(dequeue)`

JSDoc:

@internal

## PullLeft

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/zipAllState.js`

Signature: `PullLeft(= PullLeft;
const PullRight = leftChunk => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
})`

JSDoc:

@internal */
const OP_DRAIN_LEFT = exports.OP_DRAIN_LEFT = "DrainLeft";
/** @internal */
const OP_DRAIN_RIGHT = exports.OP_DRAIN_RIGHT = "DrainRight";
/** @internal */
const OP_PULL_BOTH = exports.OP_PULL_BOTH = "PullBoth";
/** @internal */
const OP_PULL_LEFT = exports.OP_PULL_LEFT = "PullLeft";
/** @internal */
const OP_PULL_RIGHT = exports.OP_PULL_RIGHT = "PullRight";
/** @internal */
const DrainLeft = exports.DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
/** @internal */
const DrainRight = exports.DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
/** @internal */
const PullBoth = exports.PullBoth = {
  _tag: OP_PULL_BOTH
};
/** @internal */
const PullLeft = rightChunk => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
/** @internal

## PullLeft

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream/zipChunksState.js`

Signature: `PullLeft(= PullLeft;
const PullRight = leftChunk => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
})`

JSDoc:

@internal */
const OP_PULL_BOTH = exports.OP_PULL_BOTH = "PullBoth";
/** @internal */
const OP_PULL_LEFT = exports.OP_PULL_LEFT = "PullLet";
/** @internal */
const OP_PULL_RIGHT = exports.OP_PULL_RIGHT = "PullRight";
/** @internal */
const PullBoth = exports.PullBoth = {
  _tag: OP_PULL_BOTH
};
/** @internal */
const PullLeft = rightChunk => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
/** @internal

## StreamImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `StreamImpl(= StreamImpl;
const isStream = u => (0, _Predicate.hasProperty)`

JSDoc:

@internal */
const StreamSymbolKey = "effect/Stream";
/** @internal */
const StreamTypeId = exports.StreamTypeId = /*#__PURE__*/Symbol.for(StreamSymbolKey);
/** @internal */
const streamVariance = {
  _R: _ => _,
  _E: _ => _,
  _A: _ => _
};
/** @internal */
class StreamImpl {
  channel;
  [StreamTypeId] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## isStream

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `isStream(= isStream;
const DefaultChunkSize = exports.DefaultChunkSize = 4096;
/** @internal */
const accumulate = self => chunks(accumulateChunks(self)`

JSDoc:

@internal

## accumulate

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `accumulate(= accumulate;
const accumulateChunks = self => {
  const accumulator = s => core.readWith({
    onInput: input => {
      const next = Chunk.appendAll(s, input)`

JSDoc:

@internal

## accumulateChunks

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `accumulateChunks(= accumulateChunks;
const acquireRelease = (acquire, release)`

JSDoc:

@internal

## acquireRelease

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `acquireRelease(= acquireRelease;
const aggregate = exports.aggregate = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## _async

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `_async(= _async;
const asyncEffect = (register, bufferSize)`

JSDoc:

@internal */
const aggregateWithin = exports.aggregateWithin = /*#__PURE__*/(0, _Function.dual)(3, (self, sink, schedule) => filterMap(aggregateWithinEither(self, sink, schedule), _ => Either.match(_, {
  onLeft: Option.none,
  onRight: Option.some
})));
/** @internal */
const aggregateWithinEither = exports.aggregateWithinEither = /*#__PURE__*/(0, _Function.dual)(3, (self, sink, schedule) => {
  const layer = Effect.all([Handoff.make(), Ref.make(SinkEndReason.ScheduleEnd), Ref.make(Chunk.empty()), Schedule.driver(schedule), Ref.make(false), Ref.make(false)]);
  return fromEffect(layer).pipe(flatMap(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = core.readWithCause({
      onInput: input => core.flatMap(core.fromEffect((0, _Function.pipe)(handoff, Handoff.offer(HandoffSignal.emit(input)), Effect.when(() => Chunk.isNonEmpty(input)))), () => handoffProducer),
      onFailure: cause => core.fromEffect(Handoff.offer(handoff, HandoffSignal.halt(cause))),
      onDone: () => core.fromEffect(Handoff.offer(handoff, HandoffSignal.end(SinkEndReason.UpstreamEnd)))
    });
    const handoffConsumer = (0, _Function.pipe)(Ref.getAndSet(sinkLeftovers, Chunk.empty()), Effect.flatMap(leftovers => {
      if (Chunk.isNonEmpty(leftovers)) {
        return (0, _Function.pipe)(Ref.set(consumed, true), Effect.zipRight(Effect.succeed((0, _Function.pipe)(core.write(leftovers), core.flatMap(() => handoffConsumer)))));
      }
      return (0, _Function.pipe)(Handoff.take(handoff), Effect.map(signal => {
        switch (signal._tag) {
          case HandoffSignal.OP_EMIT:
            {
              return (0, _Function.pipe)(core.fromEffect(Ref.set(consumed, true)), channel.zipRight(core.write(signal.elements)), channel.zipRight(core.fromEffect(Ref.get(endAfterEmit))), core.flatMap(bool => bool ? core.void : handoffConsumer));
            }
          case HandoffSignal.OP_HALT:
            {
              return core.failCause(signal.cause);
            }
          case HandoffSignal.OP_END:
            {
              if (signal.reason._tag === SinkEndReason.OP_SCHEDULE_END) {
                return (0, _Function.pipe)(Ref.get(consumed), Effect.map(bool => bool ? core.fromEffect((0, _Function.pipe)(Ref.set(sinkEndReason, SinkEndReason.ScheduleEnd), Effect.zipRight(Ref.set(endAfterEmit, true)))) : (0, _Function.pipe)(core.fromEffect((0, _Function.pipe)(Ref.set(sinkEndReason, SinkEndReason.ScheduleEnd), Effect.zipRight(Ref.set(endAfterEmit, true)))), core.flatMap(() => handoffConsumer))), channel.unwrap);
              }
              return (0, _Function.pipe)(Ref.set(sinkEndReason, signal.reason), Effect.zipRight(Ref.set(endAfterEmit, true)), core.fromEffect);
            }
        }
      }));
    }), channel.unwrap);
    const timeout = lastB => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope) => {
      const forkSink = (0, _Function.pipe)(Ref.set(consumed, false), Effect.zipRight(Ref.set(endAfterEmit, false)), Effect.zipRight((0, _Function.pipe)(handoffConsumer, channel.pipeToOrFail(sink_.toChannel(sink)), core.collectElements, channel.run, Effect.forkIn(scope))));
      const handleSide = (leftovers, b, c) => (0, _Function.pipe)(Ref.set(sinkLeftovers, Chunk.flatten(leftovers)), Effect.zipRight(Effect.map(Ref.get(sinkEndReason), reason => {
        switch (reason._tag) {
          case SinkEndReason.OP_SCHEDULE_END:
            {
              return (0, _Function.pipe)(Effect.all([Ref.get(consumed), forkSink, (0, _Function.pipe)(timeout(Option.some(b)), Effect.forkIn(scope))]), Effect.map(([wasConsumed, sinkFiber, scheduleFiber]) => {
                const toWrite = (0, _Function.pipe)(c, Option.match({
                  onNone: () => Chunk.of(Either.right(b)),
                  onSome: c => Chunk.make(Either.right(b), Either.left(c))
                }));
                if (wasConsumed) {
                  return (0, _Function.pipe)(core.write(toWrite), core.flatMap(() => scheduledAggregator(sinkFiber, scheduleFiber, scope)));
                }
                return scheduledAggregator(sinkFiber, scheduleFiber, scope);
              }), channel.unwrap);
            }
          case SinkEndReason.OP_UPSTREAM_END:
            {
              return (0, _Function.pipe)(Ref.get(consumed), Effect.map(wasConsumed => wasConsumed ? core.write(Chunk.of(Either.right(b))) : core.void), channel.unwrap);
            }
        }
      })), channel.unwrap);
      return channel.unwrap(Effect.raceWith(Fiber.join(sinkFiber), Fiber.join(scheduleFiber), {
        onSelfDone: (sinkExit, _) => (0, _Function.pipe)(Fiber.interrupt(scheduleFiber), Effect.zipRight((0, _Function.pipe)(Effect.suspend(() => sinkExit), Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))))),
        onOtherDone: (scheduleExit, _) => Effect.matchCauseEffect(Effect.suspend(() => scheduleExit), {
          onFailure: cause => Either.match(Cause.failureOrCause(cause), {
            onLeft: () => (0, _Function.pipe)(handoff, Handoff.offer(HandoffSignal.end(SinkEndReason.ScheduleEnd)), Effect.forkDaemon, Effect.zipRight((0, _Function.pipe)(Fiber.join(sinkFiber), Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))))),
            onRight: cause => (0, _Function.pipe)(handoff, Handoff.offer(HandoffSignal.halt(cause)), Effect.forkDaemon, Effect.zipRight((0, _Function.pipe)(Fiber.join(sinkFiber), Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none())))))
          }),
          onSuccess: c => (0, _Function.pipe)(handoff, Handoff.offer(HandoffSignal.end(SinkEndReason.ScheduleEnd)), Effect.forkDaemon, Effect.zipRight((0, _Function.pipe)(Fiber.join(sinkFiber), Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.some(c))))))
        })
      }));
    };
    return unwrapScopedWith(scope => core.pipeTo(toChannel(self), handoffProducer).pipe(channel.run, Effect.forkIn(scope), Effect.zipRight(channel.pipeToOrFail(handoffConsumer, sink_.toChannel(sink)).pipe(core.collectElements, channel.run, Effect.forkIn(scope), Effect.flatMap(sinkFiber => timeout(Option.none()).pipe(Effect.forkIn(scope), Effect.map(scheduleFiber => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope)))))))));
  }));
});
/** @internal */
const as = exports.as = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => map(self, () => value));
const queueFromBufferOptions = bufferSize => {
  if (bufferSize === "unbounded") {
    return Queue.unbounded();
  } else if (typeof bufferSize === "number" || bufferSize === undefined) {
    return Queue.bounded(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return Queue.dropping(bufferSize.bufferSize ?? 16);
    case "sliding":
      return Queue.sliding(bufferSize.bufferSize ?? 16);
    default:
      return Queue.bounded(bufferSize.bufferSize ?? 16);
  }
};
/** @internal */
const _async = (register, bufferSize) => Effect.acquireRelease(queueFromBufferOptions(bufferSize), queue => Queue.shutdown(queue)).pipe(Effect.flatMap(output => Effect.runtime().pipe(Effect.flatMap(runtime => Effect.sync(() => {
  const runPromiseExit = Runtime.runPromiseExit(runtime);
  const canceler = register(emit.make(resume => InternalTake.fromPull(resume).pipe(Effect.flatMap(take => Queue.offer(output, take)), Effect.asVoid, runPromiseExit).then(exit => {
    if (Exit.isFailure(exit)) {
      if (!Cause.isInterrupted(exit.cause)) {
        throw Cause.squash(exit.cause);
      }
    }
  })));
  return canceler;
})), Effect.map(value => {
  const loop = Queue.take(output).pipe(Effect.flatMap(take => InternalTake.done(take)), Effect.match({
    onFailure: maybeError => core.fromEffect(Queue.shutdown(output)).pipe(channel.zipRight(Option.match(maybeError, {
      onNone: () => core.void,
      onSome: error => core.fail(error)
    }))),
    onSuccess: chunk => core.write(chunk).pipe(core.flatMap(() => loop))
  }), channel.unwrap);
  return fromChannel(loop).pipe(ensuring(value ?? Effect.void));
}))), unwrapScoped);
/** @internal

## asyncPush

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `asyncPush(= asyncPush;
const asyncScoped = (register, bufferSize)`

JSDoc:

@internal */
const asyncPush = (register, options) => Effect.acquireRelease(queueFromBufferOptionsPush(options), Queue.shutdown).pipe(Effect.tap(queue => FiberRef.getWith(FiberRef.currentScheduler, scheduler => register(emit.makePush(queue, scheduler)))), Effect.map(queue => {
  const loop = core.flatMap(Queue.take(queue), item => Exit.isExit(item) ? Exit.isSuccess(item) ? core.void : core.failCause(item.cause) : channel.zipRight(core.write(Chunk.unsafeFromArray(item)), loop));
  return loop;
}), channel.unwrapScoped, fromChannel);
/** @internal

## asyncScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `asyncScoped(= asyncScoped;
const branchAfter = exports.branchAfter = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## changes

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `changes(= changes;
const changesWith = exports.changesWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const broadcast = exports.broadcast = /*#__PURE__*/(0, _Function.dual)(3, (self, n, maximumLag) => (0, _Function.pipe)(self, broadcastedQueues(n, maximumLag), Effect.map(tuple => tuple.map(queue => flattenTake(fromQueue(queue, {
  shutdown: true
}))))));
/** @internal */
const broadcastDynamic = exports.broadcastDynamic = /*#__PURE__*/(0, _Function.dual)(2, (self, maximumLag) => Effect.map(toPubSub(self, maximumLag), pubsub => flattenTake(fromPubSub(pubsub))));
const share = exports.share = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => Effect.map(RcRef.make({
  acquire: broadcastDynamic(self, options),
  idleTimeToLive: options.idleTimeToLive
}), rcRef => unwrapScoped(RcRef.get(rcRef))));
/** @internal */
const broadcastedQueues = exports.broadcastedQueues = /*#__PURE__*/(0, _Function.dual)(3, (self, n, maximumLag) => Effect.flatMap(pubsubFromOptions(maximumLag), pubsub => (0, _Function.pipe)(Effect.all(Array.from({
  length: n
}, () => PubSub.subscribe(pubsub))), Effect.tap(() => Effect.forkScoped(runIntoPubSubScoped(self, pubsub))))));
/** @internal */
const broadcastedQueuesDynamic = exports.broadcastedQueuesDynamic = /*#__PURE__*/(0, _Function.dual)(2, (self, maximumLag) => Effect.map(toPubSub(self, maximumLag), PubSub.subscribe));
/** @internal */
const buffer = exports.buffer = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self, options.capacity);
  }
  const queue = toQueueOfElements(self, options);
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {
    const process = (0, _Function.pipe)(core.fromEffect(Queue.take(queue)), core.flatMap(Exit.match({
      onFailure: cause => (0, _Function.pipe)(Cause.flipCauseOption(cause), Option.match({
        onNone: () => core.void,
        onSome: core.failCause
      })),
      onSuccess: value => core.flatMap(core.write(Chunk.of(value)), () => process)
    })));
    return process;
  })));
});
/** @internal */
const bufferChunks = exports.bufferChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self, options.capacity);
  }
  const queue = toQueue(self, options);
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {
    const process = (0, _Function.pipe)(core.fromEffect(Queue.take(queue)), core.flatMap(InternalTake.match({
      onEnd: () => core.void,
      onFailure: core.failCause,
      onSuccess: value => (0, _Function.pipe)(core.write(value), core.flatMap(() => process))
    })));
    return process;
  })));
});
const bufferChunksDropping = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(self)));
});
const bufferChunksSliding = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(self)));
});
const bufferDropping = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.dropping(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel(rechunk(1)(self))));
});
const bufferSliding = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => {
  const queue = Effect.acquireRelease(Queue.sliding(capacity), queue => Queue.shutdown(queue));
  return new StreamImpl(bufferSignal(queue, toChannel((0, _Function.pipe)(self, rechunk(1)))));
});
const bufferUnbounded = self => {
  const queue = toQueue(self, {
    strategy: "unbounded"
  });
  return new StreamImpl(channel.unwrapScoped(Effect.map(queue, queue => {
    const process = (0, _Function.pipe)(core.fromEffect(Queue.take(queue)), core.flatMap(InternalTake.match({
      onEnd: () => core.void,
      onFailure: core.failCause,
      onSuccess: value => core.flatMap(core.write(value), () => process)
    })));
    return process;
  })));
};
const bufferSignal = (scoped, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = take => (0, _Function.pipe)(Ref.get(ref), Effect.tap(Deferred.await), Effect.zipRight(Deferred.make()), Effect.flatMap(deferred => (0, _Function.pipe)(Queue.offer(queue, [take, deferred]), Effect.zipRight(Ref.set(ref, deferred)), Effect.zipRight(Deferred.await(deferred)))), Effect.asVoid, core.fromEffect);
    return core.readWithCause({
      onInput: input => (0, _Function.pipe)(Deferred.make(), Effect.flatMap(deferred => (0, _Function.pipe)(Queue.offer(queue, [InternalTake.chunk(input), deferred]), Effect.flatMap(added => (0, _Function.pipe)(Ref.set(ref, deferred), Effect.when(() => added))))), Effect.asVoid, core.fromEffect, core.flatMap(() => producer(queue, ref))),
      onFailure: error => terminate(InternalTake.failCause(error)),
      onDone: () => terminate(InternalTake.end)
    });
  };
  const consumer = queue => {
    const process = (0, _Function.pipe)(core.fromEffect(Queue.take(queue)), core.flatMap(([take, deferred]) => channel.zipRight(core.fromEffect(Deferred.succeed(deferred, void 0)), InternalTake.match(take, {
      onEnd: () => core.void,
      onFailure: core.failCause,
      onSuccess: value => (0, _Function.pipe)(core.write(value), core.flatMap(() => process))
    }))));
    return process;
  };
  return channel.unwrapScoped((0, _Function.pipe)(scoped, Effect.flatMap(queue => (0, _Function.pipe)(Deferred.make(), Effect.tap(start => Deferred.succeed(start, void 0)), Effect.flatMap(start => (0, _Function.pipe)(Ref.make(start), Effect.flatMap(ref => (0, _Function.pipe)(bufferChannel, core.pipeTo(producer(queue, ref)), channel.runScoped, Effect.forkScoped)), Effect.as(consumer(queue))))))));
};
/** @internal */
const catchAll = exports.catchAll = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAllCause(self, cause => Either.match(Cause.failureOrCause(cause), {
  onLeft: f,
  onRight: failCause
})));
/** @internal */
const catchAllCause = exports.catchAllCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl((0, _Function.pipe)(toChannel(self), core.catchAllCause(cause => toChannel(f(cause))))));
/** @internal */
const catchSome = exports.catchSome = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => (0, _Function.pipe)(self, catchAll(error => (0, _Function.pipe)(pf(error), Option.getOrElse(() => fail(error))))));
/** @internal */
const catchSomeCause = exports.catchSomeCause = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => (0, _Function.pipe)(self, catchAllCause(cause => (0, _Function.pipe)(pf(cause), Option.getOrElse(() => failCause(cause))))));
/* @internal */
const catchTag = exports.catchTag = /*#__PURE__*/(0, _Function.dual)(3, (self, k, f) => catchAll(self, e => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail(e);
}));
/** @internal */
const catchTags = exports.catchTags = /*#__PURE__*/(0, _Function.dual)(2, (self, cases) => catchAll(self, e => {
  const keys = Object.keys(cases);
  if ("_tag" in e && keys.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail(e);
}));
/** @internal */
const changes = self => (0, _Function.pipe)(self, changesWith((x, y) => Equal.equals(y)(x)));
/** @internal

## chunks

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `chunks(= chunks;
const chunksWith = exports.chunksWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const changesWithEffect = exports.changesWithEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const writer = last => core.readWithCause({
    onInput: input => (0, _Function.pipe)(input, Effect.reduce([last, Chunk.empty()], ([option, outputs], output) => {
      if (Option.isSome(option)) {
        return (0, _Function.pipe)(f(option.value, output), Effect.map(bool => bool ? [Option.some(output), outputs] : [Option.some(output), (0, _Function.pipe)(outputs, Chunk.append(output))]));
      }
      return Effect.succeed([Option.some(output), (0, _Function.pipe)(outputs, Chunk.append(output))]);
    }), core.fromEffect, core.flatMap(([newLast, newChunk]) => (0, _Function.pipe)(core.write(newChunk), core.flatMap(() => writer(newLast))))),
    onFailure: core.failCause,
    onDone: () => core.void
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(writer(Option.none()))));
});
/** @internal */
const chunks = self => (0, _Function.pipe)(self, mapChunks(Chunk.of));
/** @internal

## concatAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `concatAll(= concatAll;
const cross = exports.cross = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const combine = exports.combine = /*#__PURE__*/(0, _Function.dual)(4, (self, that, s, f) => {
  function producer(handoff, latch) {
    return core.fromEffect(Handoff.take(latch)).pipe(channel.zipRight(core.readWithCause({
      onInput: input => core.flatMap(core.fromEffect(Handoff.offer(handoff, Exit.succeed(input))), () => producer(handoff, latch)),
      onFailure: cause => core.fromEffect(Handoff.offer(handoff, Exit.failCause((0, _Function.pipe)(cause, Cause.map(Option.some))))),
      onDone: () => core.flatMap(core.fromEffect(Handoff.offer(handoff, Exit.fail(Option.none()))), () => producer(handoff, latch))
    })));
  }
  return new StreamImpl(channel.unwrapScopedWith(scope => Effect.all([Handoff.make(), Handoff.make(), Handoff.make(), Handoff.make()]).pipe(Effect.tap(([left, _, latchL]) => toChannel(self).pipe(channel.concatMap(channel.writeChunk), core.pipeTo(producer(left, latchL)), channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.tap(([, right, _, rightL]) => toChannel(that).pipe(channel.concatMap(channel.writeChunk), core.pipeTo(producer(right, rightL)), channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.map(([left, right, latchL, latchR]) => {
    const pullLeft = Handoff.offer(latchL, void 0).pipe(Effect.zipRight(Handoff.take(left).pipe(Effect.flatMap(_Function.identity))));
    const pullRight = Handoff.offer(latchR, void 0).pipe(Effect.zipRight(Handoff.take(right).pipe(Effect.flatMap(_Function.identity))));
    return toChannel(unfoldEffect(s, s => Effect.flatMap(f(s, pullLeft, pullRight), unsome)));
  }))));
});
/** @internal */
const combineChunks = exports.combineChunks = /*#__PURE__*/(0, _Function.dual)(4, (self, that, s, f) => {
  const producer = (handoff, latch) => channel.zipRight(core.fromEffect(Handoff.take(latch)), core.readWithCause({
    onInput: input => core.flatMap(core.fromEffect((0, _Function.pipe)(handoff, Handoff.offer(InternalTake.chunk(input)))), () => producer(handoff, latch)),
    onFailure: cause => core.fromEffect(Handoff.offer(handoff, InternalTake.failCause(cause))),
    onDone: () => core.fromEffect(Handoff.offer(handoff, InternalTake.end))
  }));
  return new StreamImpl(channel.unwrapScopedWith(scope => Effect.all([Handoff.make(), Handoff.make(), Handoff.make(), Handoff.make()]).pipe(Effect.tap(([left, _, latchL]) => core.pipeTo(toChannel(self), producer(left, latchL)).pipe(channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.tap(([_, right, __, latchR]) => core.pipeTo(toChannel(that), producer(right, latchR)).pipe(channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.map(([left, right, latchL, latchR]) => {
    const pullLeft = Handoff.offer(latchL, void 0).pipe(Effect.zipRight(Handoff.take(left).pipe(Effect.flatMap(InternalTake.done))));
    const pullRight = Handoff.offer(latchR, void 0).pipe(Effect.zipRight(Handoff.take(right).pipe(Effect.flatMap(InternalTake.done))));
    return toChannel(unfoldChunkEffect(s, s => Effect.flatMap(f(s, pullLeft, pullRight), unsome)));
  }))));
});
/** @internal */
const concat = exports.concat = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.zipRight(toChannel(that)))));
/** @internal */
const concatAll = streams => suspend(() => (0, _Function.pipe)(streams, Chunk.reduce(empty, (x, y) => concat(y)(x))));
/** @internal

## die

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `die(= die;
const dieSync = evaluate => fromEffect(Effect.dieSync(evaluate)`

JSDoc:

@internal */
const crossLeft = exports.crossLeft = /*#__PURE__*/(0, _Function.dual)(2, (left, right) => (0, _Function.pipe)(left, crossWith(right, (a, _) => a)));
/** @internal */
const crossRight = exports.crossRight = /*#__PURE__*/(0, _Function.dual)(2, (left, right) => flatMap(left, () => right));
/** @internal */
const crossWith = exports.crossWith = /*#__PURE__*/(0, _Function.dual)(3, (left, right, f) => (0, _Function.pipe)(left, flatMap(a => (0, _Function.pipe)(right, map(b => f(a, b))))));
/** @internal */
const debounce = exports.debounce = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => unwrapScopedWith(scope => Effect.gen(function* () {
  const handoff = yield* Handoff.make();
  function enqueue(last) {
    return Clock.sleep(duration).pipe(Effect.as(last), Effect.forkIn(scope), Effect.map(fiber => consumer(DebounceState.previous(fiber))));
  }
  const producer = core.readWithCause({
    onInput: input => Option.match(Chunk.last(input), {
      onNone: () => producer,
      onSome: elem => core.fromEffect(Handoff.offer(handoff, HandoffSignal.emit(Chunk.of(elem)))).pipe(core.flatMap(() => producer))
    }),
    onFailure: cause => core.fromEffect(Handoff.offer(handoff, HandoffSignal.halt(cause))),
    onDone: () => core.fromEffect(Handoff.offer(handoff, HandoffSignal.end(SinkEndReason.UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case DebounceState.OP_NOT_STARTED:
        {
          return channel.unwrap(Handoff.take(handoff).pipe(Effect.map(signal => {
            switch (signal._tag) {
              case HandoffSignal.OP_EMIT:
                {
                  return channel.unwrap(enqueue(signal.elements));
                }
              case HandoffSignal.OP_HALT:
                {
                  return core.failCause(signal.cause);
                }
              case HandoffSignal.OP_END:
                {
                  return core.void;
                }
            }
          })));
        }
      case DebounceState.OP_PREVIOUS:
        {
          return channel.unwrap(Handoff.take(handoff).pipe(Effect.forkIn(scope), Effect.flatMap(handoffFiber => Effect.raceWith(Fiber.join(state.fiber), Fiber.join(handoffFiber), {
            onSelfDone: (leftExit, current) => Exit.match(leftExit, {
              onFailure: cause => Fiber.interrupt(current).pipe(Effect.as(core.failCause(cause))),
              onSuccess: chunk => Fiber.interrupt(current).pipe(Effect.zipRight(Effect.succeed(core.write(chunk).pipe(core.flatMap(() => consumer(DebounceState.current(handoffFiber)))))))
            }),
            onOtherDone: (rightExit, previous) => Exit.match(rightExit, {
              onFailure: cause => Fiber.interrupt(previous).pipe(Effect.as(core.failCause(cause))),
              onSuccess: signal => {
                switch (signal._tag) {
                  case HandoffSignal.OP_EMIT:
                    {
                      return Fiber.interrupt(previous).pipe(Effect.zipRight(enqueue(signal.elements)));
                    }
                  case HandoffSignal.OP_HALT:
                    {
                      return Fiber.interrupt(previous).pipe(Effect.as(core.failCause(signal.cause)));
                    }
                  case HandoffSignal.OP_END:
                    {
                      return Fiber.join(previous).pipe(Effect.map(chunk => core.write(chunk).pipe(channel.zipRight(core.void))));
                    }
                }
              }
            })
          }))));
        }
      case DebounceState.OP_CURRENT:
        {
          return channel.unwrap(Fiber.join(state.fiber).pipe(Effect.map(signal => {
            switch (signal._tag) {
              case HandoffSignal.OP_EMIT:
                {
                  return channel.unwrap(enqueue(signal.elements));
                }
              case HandoffSignal.OP_HALT:
                {
                  return core.failCause(signal.cause);
                }
              case HandoffSignal.OP_END:
                {
                  return core.void;
                }
            }
          })));
        }
    }
  }
  return scopedWith(scope => core.pipeTo(toChannel(self), producer).pipe(channelExecutor.runIn(scope), Effect.forkIn(scope))).pipe(crossRight(new StreamImpl(consumer(DebounceState.notStarted))));
})));
/** @internal */
const die = defect => fromEffect(Effect.die(defect));
/** @internal

## dieSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `dieSync(= dieSync;
const dieMessage = message => fromEffect(Effect.dieMessage(message)`

JSDoc:

@internal

## dieMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `dieMessage(= dieMessage;
const distributedWith = exports.distributedWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## drain

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `drain(= drain;
const drainFork = exports.drainFork = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const distributedWithDynamicId = {
  ref: 0
};
const newDistributedWithDynamicId = () => {
  const current = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current + 1;
  return current;
};
/** @internal */
const distributedWithDynamic = exports.distributedWithDynamic = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => Effect.void));
/** @internal */
const distributedWithDynamicCallback = exports.distributedWithDynamicCallback = /*#__PURE__*/(0, _Function.dual)(4, (self, maximumLag, decide, done) => (0, _Function.pipe)(Effect.acquireRelease(Ref.make(new Map()), (ref, _) => (0, _Function.pipe)(Ref.get(ref), Effect.flatMap(queues => (0, _Function.pipe)(queues.values(), Effect.forEach(Queue.shutdown))))), Effect.flatMap(queuesRef => Effect.gen(function* () {
  const offer = a => (0, _Function.pipe)(decide(a), Effect.flatMap(shouldProcess => (0, _Function.pipe)(Ref.get(queuesRef), Effect.flatMap(queues => (0, _Function.pipe)(queues.entries(), Effect.reduce(Chunk.empty(), (acc, [id, queue]) => {
    if (shouldProcess(id)) {
      return (0, _Function.pipe)(Queue.offer(queue, Exit.succeed(a)), Effect.matchCauseEffect({
        onFailure: cause =>
        // Ignore all downstream queues that were shut
        // down and remove them later
        Cause.isInterrupted(cause) ? Effect.succeed((0, _Function.pipe)(acc, Chunk.prepend(id))) : Effect.failCause(cause),
        onSuccess: () => Effect.succeed(acc)
      }));
    }
    return Effect.succeed(acc);
  }), Effect.flatMap(ids => {
    if (Chunk.isNonEmpty(ids)) {
      return (0, _Function.pipe)(Ref.update(queuesRef, map => {
        for (const id of ids) {
          map.delete(id);
        }
        return map;
      }));
    }
    return Effect.void;
  }))))), Effect.asVoid);
  const queuesLock = yield* Effect.makeSemaphore(1);
  const newQueue = yield* Ref.make((0, _Function.pipe)(Queue.bounded(maximumLag), Effect.flatMap(queue => {
    const id = newDistributedWithDynamicId();
    return (0, _Function.pipe)(Ref.update(queuesRef, map => map.set(id, queue)), Effect.as([id, queue]));
  })));
  const finalize = endTake =>
  // Make sure that no queues are currently being added
  queuesLock.withPermits(1)((0, _Function.pipe)(Ref.set(newQueue, (0, _Function.pipe)(
  // All newly created queues should end immediately
  Queue.bounded(1), Effect.tap(queue => Queue.offer(queue, endTake)), Effect.flatMap(queue => {
    const id = newDistributedWithDynamicId();
    return (0, _Function.pipe)(Ref.update(queuesRef, map => map.set(id, queue)), Effect.as(Tuple.make(id, queue)));
  }))), Effect.zipRight((0, _Function.pipe)(Ref.get(queuesRef), Effect.flatMap(map => (0, _Function.pipe)(Chunk.fromIterable(map.values()), Effect.forEach(queue => (0, _Function.pipe)(Queue.offer(queue, endTake), Effect.catchSomeCause(cause => Cause.isInterrupted(cause) ? Option.some(Effect.void) : Option.none()))))))), Effect.zipRight(done(endTake)), Effect.asVoid));
  yield* (0, _Function.pipe)(self, runForEachScoped(offer), Effect.matchCauseEffect({
    onFailure: cause => finalize(Exit.failCause((0, _Function.pipe)(cause, Cause.map(Option.some)))),
    onSuccess: () => finalize(Exit.fail(Option.none()))
  }), Effect.forkScoped);
  return queuesLock.withPermits(1)(Effect.flatten(Ref.get(newQueue)));
}))));
/** @internal */
const drain = self => new StreamImpl(channel.drain(toChannel(self)));
/** @internal

## either

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `either(= either;
const empty = exports.empty = /*#__PURE__*/new StreamImpl(core.void)`

JSDoc:

@internal */
const drop = exports.drop = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  const loop = r => core.readWith({
    onInput: input => {
      const dropped = (0, _Function.pipe)(input, Chunk.drop(r));
      const leftover = Math.max(0, r - input.length);
      const more = Chunk.isEmpty(input) || leftover > 0;
      if (more) {
        return loop(leftover);
      }
      return (0, _Function.pipe)(core.write(dropped), channel.zipRight(channel.identityChannel()));
    },
    onFailure: core.fail,
    onDone: () => core.void
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(loop(n))));
});
/** @internal */
const dropRight = exports.dropRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend(() => {
    const queue = new _ringBuffer.RingBuffer(n);
    const reader = core.readWith({
      onInput: input => {
        const outputs = (0, _Function.pipe)(input, Chunk.filterMap(elem => {
          const head = queue.head();
          queue.put(elem);
          return head;
        }));
        return (0, _Function.pipe)(core.write(outputs), core.flatMap(() => reader));
      },
      onFailure: core.fail,
      onDone: () => core.void
    });
    return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(reader)));
  });
});
/** @internal */
const dropUntil = exports.dropUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => drop(dropWhile(self, a => !predicate(a)), 1));
/** @internal */
const dropUntilEffect = exports.dropUntilEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => (0, _Function.pipe)(Effect.dropUntil(input, predicate), Effect.map(Chunk.unsafeFromArray), Effect.map(leftover => {
      const more = Chunk.isEmpty(leftover);
      if (more) {
        return core.suspend(() => loop);
      }
      return (0, _Function.pipe)(core.write(leftover), channel.zipRight(channel.identityChannel()));
    }), channel.unwrap),
    onFailure: core.fail,
    onDone: () => core.void
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(loop)));
});
/** @internal */
const dropWhile = exports.dropWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => {
      const output = Chunk.dropWhile(input, predicate);
      if (Chunk.isEmpty(output)) {
        return core.suspend(() => loop);
      }
      return channel.zipRight(core.write(output), channel.identityChannel());
    },
    onFailure: core.fail,
    onDone: core.succeedNow
  });
  return new StreamImpl(channel.pipeToOrFail(toChannel(self), loop));
});
/** @internal */
const dropWhileEffect = exports.dropWhileEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => (0, _Function.pipe)(Effect.dropWhile(input, predicate), Effect.map(Chunk.unsafeFromArray), Effect.map(leftover => {
      const more = Chunk.isEmpty(leftover);
      if (more) {
        return core.suspend(() => loop);
      }
      return channel.zipRight(core.write(leftover), channel.identityChannel());
    }), channel.unwrap),
    onFailure: core.fail,
    onDone: () => core.void
  });
  return new StreamImpl(channel.pipeToOrFail(toChannel(self), loop));
});
/** @internal */
const either = self => (0, _Function.pipe)(self, map(Either.right), catchAll(error => make(Either.left(error))));
/** @internal

## context

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `context(= context;
const contextWith = f => (0, _Function.pipe)`

JSDoc:

@internal */
const ensuring = exports.ensuring = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.ensuring(finalizer))));
/** @internal */
const ensuringWith = exports.ensuringWith = /*#__PURE__*/(0, _Function.dual)(2, (self, finalizer) => new StreamImpl(core.ensuringWith(toChannel(self), finalizer)));
/** @internal */
const context = () => fromEffect(Effect.context());
/** @internal

## contextWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `contextWith(= contextWith;
const contextWithEffect = f => (0, _Function.pipe)`

JSDoc:

@internal

## contextWithEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `contextWithEffect(= contextWithEffect;
const contextWithStream = f => (0, _Function.pipe)`

JSDoc:

@internal

## contextWithStream

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `contextWithStream(= contextWithStream;
const execute = effect => drain(fromEffect(effect)`

JSDoc:

@internal

## execute

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `execute(= execute;
const fail = error => fromEffectOption(Effect.fail(Option.some(error)`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fail(= fail;
const failSync = evaluate => fromEffectOption(Effect.failSync(()`

JSDoc:

@internal

## failSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `failSync(= failSync;
const failCause = cause => fromEffect(Effect.failCause(cause)`

JSDoc:

@internal

## failCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `failCause(= failCause;
const failCauseSync = evaluate => fromEffect(Effect.failCauseSync(evaluate)`

JSDoc:

@internal

## failCauseSync

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `failCauseSync(= failCauseSync;
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## finalizer

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `finalizer(= finalizer;
const find = exports.find = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const filterEffect = exports.filterEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: input => loop(input[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    } else {
      return (0, _Function.pipe)(f(next.value), Effect.map(bool => bool ? (0, _Function.pipe)(core.write(Chunk.of(next.value)), core.flatMap(() => loop(iterator))) : loop(iterator)), channel.unwrap);
    }
  };
  return new StreamImpl(core.suspend(() => (0, _Function.pipe)(toChannel(self), core.pipeTo(loop(Chunk.empty()[Symbol.iterator]())))));
});
/** @internal */
const filterMap = exports.filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => mapChunks(self, Chunk.filterMap(pf)));
/** @internal */
const filterMapEffect = exports.filterMapEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => suspend(() => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: input => loop(input[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    } else {
      return (0, _Function.pipe)(pf(next.value), Option.match({
        onNone: () => Effect.sync(() => loop(iterator)),
        onSome: Effect.map(a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator)))
      }), channel.unwrap);
    }
  };
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))));
}));
/** @internal */
const filterMapWhile = exports.filterMapWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => {
  const loop = core.readWith({
    onInput: input => {
      const mapped = Chunk.filterMapWhile(input, pf);
      if (mapped.length === input.length) {
        return (0, _Function.pipe)(core.write(mapped), core.flatMap(() => loop));
      }
      return core.write(mapped);
    },
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(loop)));
});
/** @internal */
const filterMapWhileEffect = exports.filterMapWhileEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => suspend(() => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: input => loop(input[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    } else {
      return channel.unwrap(Option.match(pf(next.value), {
        onNone: () => Effect.succeed(core.void),
        onSome: Effect.map(a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator)))
      }));
    }
  };
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(loop(Chunk.empty()[Symbol.iterator]()))));
}));
/** @internal */
const finalizer = finalizer => acquireRelease(Effect.void, () => finalizer);
/** @internal

## flattenChunks

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `flattenChunks(= flattenChunks;
const flattenEffect = exports.flattenEffect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const findEffect = exports.findEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => (0, _Function.pipe)(Effect.findFirst(input, predicate), Effect.map(Option.match({
      onNone: () => loop,
      onSome: n => core.write(Chunk.of(n))
    })), channel.unwrap),
    onFailure: core.fail,
    onDone: () => core.void
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(loop)));
});
/** @internal */
const flatMap = exports.flatMap = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[0]), (self, f, options) => {
  const bufferSize = options?.bufferSize ?? 16;
  if (options?.switch) {
    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), n => flatMapParSwitchBuffer(self, n, bufferSize, f));
  }
  return matchConcurrency(options?.concurrency, () => new StreamImpl(channel.concatMap(toChannel(self), as => (0, _Function.pipe)(as, Chunk.map(a => toChannel(f(a))), Chunk.reduce(core.void, (left, right) => (0, _Function.pipe)(left, channel.zipRight(right)))))), _ => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.concatMap(channel.writeChunk), channel.mergeMap(out => toChannel(f(out)), options))));
});
/** @internal */
const matchConcurrency = (concurrency, sequential, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential();
    case "unbounded":
      return bounded(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential();
  }
};
exports.matchConcurrency = matchConcurrency;
const flatMapParSwitchBuffer = /*#__PURE__*/(0, _Function.dual)(4, (self, n, bufferSize, f) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.concatMap(channel.writeChunk), channel.mergeMap(out => toChannel(f(out)), {
  concurrency: n,
  mergeStrategy: MergeStrategy.BufferSliding(),
  bufferSize
}))));
/** @internal */
const flatten = exports.flatten = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[0]), (self, options) => flatMap(self, _Function.identity, options));
/** @internal */
const flattenChunks = self => {
  const flatten = core.readWithCause({
    onInput: chunks => core.flatMap(channel.writeChunk(chunks), () => flatten),
    onFailure: core.failCause,
    onDone: () => core.void
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(flatten)));
};
/** @internal

## flattenExitOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `flattenExitOption(= flattenExitOption;
const flattenIterables = self => (0, _Function.pipe)`

JSDoc:

@internal */
const flattenExitOption = self => {
  const processChunk = (chunk, cont) => {
    const [toEmit, rest] = (0, _Function.pipe)(chunk, Chunk.splitWhere(exit => !Exit.isSuccess(exit)));
    const next = (0, _Function.pipe)(Chunk.head(rest), Option.match({
      onNone: () => cont,
      onSome: Exit.match({
        onFailure: cause => Option.match(Cause.flipCauseOption(cause), {
          onNone: () => core.void,
          onSome: core.failCause
        }),
        onSuccess: () => core.void
      })
    }));
    return (0, _Function.pipe)(core.write((0, _Function.pipe)(toEmit, Chunk.filterMap(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none()))), core.flatMap(() => next));
  };
  const process = core.readWithCause({
    onInput: chunk => processChunk(chunk, process),
    onFailure: cause => core.failCause(cause),
    onDone: () => core.void
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(process)));
};
/** @internal

## flattenIterables

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `flattenIterables(= flattenIterables;
const flattenTake = self => flattenChunks(flattenExitOption((0, _Function.pipe)`

JSDoc:

@internal

## flattenTake

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `flattenTake(= flattenTake;
const forever = self => new StreamImpl(channel.repeated(toChannel(self)`

JSDoc:

@internal

## forever

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `forever(= forever;
const fromAsyncIterable = (iterable, onError)`

JSDoc:

@internal

## fromAsyncIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromAsyncIterable(= fromAsyncIterable;
const fromChannel = channel => new StreamImpl(channel)`

JSDoc:

@internal

## fromChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromChannel(= fromChannel;
const toChannel = stream => {
  if ("channel" in stream)`

JSDoc:

@internal

## toChannel

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `toChannel(= toChannel;
const fromChunk = chunk => new StreamImpl(Chunk.isEmpty(chunk)`

JSDoc:

@internal

## fromChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromChunk(= fromChunk;
const fromChunkPubSub = (pubsub, options)`

JSDoc:

@internal

## fromChunkPubSub

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromChunkPubSub(= fromChunkPubSub;
const fromChunkQueue = (queue, options)`

JSDoc:

@internal

## fromChunkQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromChunkQueue(= fromChunkQueue;
const fromChunks = (...chunks)`

JSDoc:

@internal

## fromChunks

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromChunks(= fromChunks;
const fromEffect = effect => (0, _Function.pipe)`

JSDoc:

@internal

## fromEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromEffect(= fromEffect;
const fromEffectOption = effect => new StreamImpl(channel.unwrap(Effect.match(effect, {
  onFailure: Option.match({
    onNone: ()`

JSDoc:

@internal

## fromEffectOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromEffectOption(= fromEffectOption;
const fromPubSub = (pubsub, options)`

JSDoc:

@internal

## fromPubSub

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromPubSub(= fromPubSub;
const fromTPubSub = pubsub => {
  return unwrapScoped(Effect.map(TPubSub.subscribeScoped(pubsub)`

JSDoc:

@internal

## fromTPubSub

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromTPubSub(= fromTPubSub;
const fromIterable = iterable => suspend(()`

JSDoc:

@internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromIterable(= fromIterable;
const fromIterableEffect = effect => (0, _Function.pipe)`

JSDoc:

@internal

## fromIterableEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromIterableEffect(= fromIterableEffect;
const fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize)`

JSDoc:

@internal

## fromIteratorSucceed

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromIteratorSucceed(= fromIteratorSucceed;
const fromPull = effect => (0, _Function.pipe)`

JSDoc:

@internal

## fromPull

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromPull(= fromPull;
const fromQueue = (queue, options)`

JSDoc:

@internal

## fromQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromQueue(= fromQueue;
const fromTQueue = queue => (0, _Function.pipe)`

JSDoc:

@internal

## fromTQueue

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromTQueue(= fromTQueue;
const fromSchedule = schedule => (0, _Function.pipe)`

JSDoc:

@internal

## fromSchedule

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromSchedule(= fromSchedule;
const fromReadableStream = (...args)`

JSDoc:

@internal

## fromReadableStream

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `fromReadableStream(= fromReadableStream;
const fromReadableStreamByob = (...args)`

JSDoc:

@internal

## identityStream

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `identityStream(= identityStream;
const interleave = exports.interleave = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const groupAdjacentBy = exports.groupAdjacentBy = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const groupAdjacentByChunk = (state, chunk) => {
    if (Chunk.isEmpty(chunk)) {
      return [state, Chunk.empty()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = undefined;
    let previousChunk = Chunk.empty();
    switch (state._tag) {
      case "Some":
        {
          const tuple = state.value;
          key = tuple[0];
          let loop = true;
          while (loop && until < chunk.length) {
            const input = Chunk.unsafeGet(chunk, until);
            const updatedKey = f(input);
            if (!Equal.equals(key, updatedKey)) {
              const previousChunk = tuple[1];
              const additionalChunk = Chunk.unsafeFromArray(Array.from(chunk).slice(from, until));
              const group = Chunk.appendAll(previousChunk, additionalChunk);
              builder.push([key, group]);
              key = updatedKey;
              from = until;
              loop = false;
            }
            until = until + 1;
          }
          if (loop) {
            previousChunk = tuple[1];
          }
          break;
        }
      case "None":
        {
          key = f(Chunk.unsafeGet(chunk, until));
          until = until + 1;
          break;
        }
    }
    while (until < chunk.length) {
      const input = Chunk.unsafeGet(chunk, until);
      const updatedKey = f(input);
      if (!Equal.equals(key, updatedKey)) {
        builder.push([key, Chunk.unsafeFromArray(Array.from(chunk).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = Chunk.appendAll(previousChunk, Chunk.unsafeFromArray(Array.from(chunk).slice(from, until)));
    const output = Chunk.unsafeFromArray(builder);
    return [Option.some([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = state => core.readWithCause({
    onInput: input => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return Chunk.isEmpty(output) ? groupAdjacent(updatedState) : core.flatMap(core.write(output), () => groupAdjacent(updatedState));
    },
    onFailure: cause => Option.match(state, {
      onNone: () => core.failCause(cause),
      onSome: output => core.flatMap(core.write(Chunk.of(output)), () => core.failCause(cause))
    }),
    onDone: done => Option.match(state, {
      onNone: () => core.succeedNow(done),
      onSome: output => core.flatMap(core.write(Chunk.of(output)), () => core.succeedNow(done))
    })
  });
  return new StreamImpl(channel.pipeToOrFail(toChannel(self), groupAdjacent(Option.none())));
});
/** @internal */
const grouped = exports.grouped = /*#__PURE__*/(0, _Function.dual)(2, (self, chunkSize) => (0, _Function.pipe)(self, rechunk(chunkSize), chunks));
/** @internal */
const groupedWithin = exports.groupedWithin = /*#__PURE__*/(0, _Function.dual)(3, (self, chunkSize, duration) => aggregateWithin(self, sink_.collectAllN(chunkSize), Schedule.spaced(duration)));
/** @internal */
const haltWhen = exports.haltWhen = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => {
  const writer = fiber => (0, _Function.pipe)(Fiber.poll(fiber), Effect.map(Option.match({
    onNone: () => core.readWith({
      onInput: input => core.flatMap(core.write(input), () => writer(fiber)),
      onFailure: core.fail,
      onDone: () => core.void
    }),
    onSome: Exit.match({
      onFailure: core.failCause,
      onSuccess: () => core.void
    })
  })), channel.unwrap);
  return new StreamImpl(channel.unwrapScopedWith(scope => effect.pipe(Effect.forkIn(scope), Effect.map(fiber => toChannel(self).pipe(core.pipeTo(writer(fiber)))))));
});
/** @internal */
const haltAfter = exports.haltAfter = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => (0, _Function.pipe)(self, haltWhen(Clock.sleep(duration))));
/** @internal */
const haltWhenDeferred = exports.haltWhenDeferred = /*#__PURE__*/(0, _Function.dual)(2, (self, deferred) => {
  const writer = (0, _Function.pipe)(Deferred.poll(deferred), Effect.map(Option.match({
    onNone: () => core.readWith({
      onInput: input => (0, _Function.pipe)(core.write(input), core.flatMap(() => writer)),
      onFailure: core.fail,
      onDone: () => core.void
    }),
    onSome: effect => channel.unwrap(Effect.match(effect, {
      onFailure: core.fail,
      onSuccess: () => core.void
    }))
  })), channel.unwrap);
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(writer)));
});
/** @internal */
const identityStream = () => new StreamImpl(channel.identityChannel());
/** @internal

## iterate

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `iterate(= iterate;
const make = (...as)`

JSDoc:

@internal */
const interleaveWith = exports.interleaveWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, decider) => {
  const producer = handoff => core.readWithCause({
    onInput: value => core.flatMap(core.fromEffect(Handoff.offer(handoff, InternalTake.of(value))), () => producer(handoff)),
    onFailure: cause => core.fromEffect(Handoff.offer(handoff, InternalTake.failCause(cause))),
    onDone: () => core.fromEffect(Handoff.offer(handoff, InternalTake.end))
  });
  return new StreamImpl(channel.unwrapScopedWith(scope => (0, _Function.pipe)(Handoff.make(), Effect.zip(Handoff.make()), Effect.tap(([left]) => toChannel(self).pipe(channel.concatMap(channel.writeChunk), core.pipeTo(producer(left)), channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.tap(([_, right]) => toChannel(that).pipe(channel.concatMap(channel.writeChunk), core.pipeTo(producer(right)), channelExecutor.runIn(scope), Effect.forkIn(scope))), Effect.map(([left, right]) => {
    const process = (leftDone, rightDone) => core.readWithCause({
      onInput: bool => {
        if (bool && !leftDone) {
          return (0, _Function.pipe)(core.fromEffect(Handoff.take(left)), core.flatMap(InternalTake.match({
            onEnd: () => rightDone ? core.void : process(true, rightDone),
            onFailure: core.failCause,
            onSuccess: chunk => (0, _Function.pipe)(core.write(chunk), core.flatMap(() => process(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return (0, _Function.pipe)(core.fromEffect(Handoff.take(right)), core.flatMap(InternalTake.match({
            onEnd: () => leftDone ? core.void : process(leftDone, true),
            onFailure: core.failCause,
            onSuccess: chunk => (0, _Function.pipe)(core.write(chunk), core.flatMap(() => process(leftDone, rightDone)))
          })));
        }
        return process(leftDone, rightDone);
      },
      onFailure: core.failCause,
      onDone: () => core.void
    });
    return (0, _Function.pipe)(toChannel(decider), channel.concatMap(channel.writeChunk), core.pipeTo(process(false, false)));
  }))));
});
/** @internal */
const intersperse = exports.intersperse = /*#__PURE__*/(0, _Function.dual)(2, (self, element) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(core.suspend(() => {
  const writer = isFirst => core.readWithCause({
    onInput: chunk => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element);
          builder.push(output);
        }
      }
      return (0, _Function.pipe)(core.write(Chunk.unsafeFromArray(builder)), core.flatMap(() => writer(flagResult)));
    },
    onFailure: core.failCause,
    onDone: () => core.void
  });
  return writer(true);
})))));
/** @internal */
const intersperseAffixes = exports.intersperseAffixes = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  end,
  middle,
  start
}) => (0, _Function.pipe)(make(start), concat((0, _Function.pipe)(self, intersperse(middle))), concat(make(end))));
/** @internal */
const interruptAfter = exports.interruptAfter = /*#__PURE__*/(0, _Function.dual)(2, (self, duration) => (0, _Function.pipe)(self, interruptWhen(Clock.sleep(duration))));
/** @internal */
const interruptWhen = exports.interruptWhen = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.interruptWhen(effect))));
/** @internal */
const interruptWhenDeferred = exports.interruptWhenDeferred = /*#__PURE__*/(0, _Function.dual)(2, (self, deferred) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.interruptWhenDeferred(deferred))));
/** @internal */
const iterate = (value, next) => unfold(value, a => Option.some([a, next(a)]));
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `make(= make;
const map = exports.map = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## mkString

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `mkString(= mkString;
const never = exports.never = /*#__PURE__*/fromEffect(Effect.never)`

JSDoc:

@internal */
const mapAccum = exports.mapAccum = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => {
  const accumulator = s => core.readWith({
    onInput: input => {
      const [nextS, chunk] = Chunk.mapAccum(input, s, f);
      return core.flatMap(core.write(chunk), () => accumulator(nextS));
    },
    onFailure: core.fail,
    onDone: () => core.void
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(accumulator(s))));
});
/** @internal */
const mapAccumEffect = exports.mapAccumEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => suspend(() => {
  const accumulator = s => core.readWith({
    onInput: input => (0, _Function.pipe)(Effect.suspend(() => {
      const outputs = [];
      const emit = output => Effect.sync(() => {
        outputs.push(output);
      });
      return (0, _Function.pipe)(input, Effect.reduce(s, (s, a) => (0, _Function.pipe)(f(s, a), Effect.flatMap(([s, a]) => (0, _Function.pipe)(emit(a), Effect.as(s))))), Effect.match({
        onFailure: error => {
          if (outputs.length !== 0) {
            return channel.zipRight(core.write(Chunk.unsafeFromArray(outputs)), core.fail(error));
          }
          return core.fail(error);
        },
        onSuccess: s => core.flatMap(core.write(Chunk.unsafeFromArray(outputs)), () => accumulator(s))
      }));
    }), channel.unwrap),
    onFailure: core.fail,
    onDone: () => core.void
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(accumulator(s))));
}));
/** @internal */
const mapBoth = exports.mapBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => (0, _Function.pipe)(self, mapError(options.onFailure), map(options.onSuccess)));
/** @internal */
const mapChunks = exports.mapChunks = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.mapOut(f))));
/** @internal */
const mapChunksEffect = exports.mapChunksEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.mapOutEffect(f))));
/** @internal */
const mapConcat = exports.mapConcat = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, mapConcatChunk(a => Chunk.fromIterable(f(a)))));
/** @internal */
const mapConcatChunk = exports.mapConcatChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, mapChunks(Chunk.flatMap(f))));
/** @internal */
const mapConcatChunkEffect = exports.mapConcatChunkEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, mapEffectSequential(f), mapConcatChunk(_Function.identity)));
/** @internal */
const mapConcatEffect = exports.mapConcatEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, mapEffectSequential(a => (0, _Function.pipe)(f(a), Effect.map(Chunk.fromIterable))), mapConcatChunk(_Function.identity)));
/** @internal */
const mapEffectSequential = exports.mapEffectSequential = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: elem => loop(elem[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    } else {
      const value = next.value;
      return channel.unwrap(Effect.map(f(value), a2 => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator))));
    }
  };
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(core.suspend(() => loop(Chunk.empty()[Symbol.iterator]())))));
});
/** @internal */
const mapEffectPar = exports.mapEffectPar = /*#__PURE__*/(0, _Function.dual)(3, (self, n, f) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.concatMap(channel.writeChunk), channel.mapOutEffectPar(f, n), channel.mapOut(Chunk.of))));
/** @internal */
const mapError = exports.mapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.mapError(f))));
/** @internal */
const mapErrorCause = exports.mapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.mapErrorCause(f))));
/** @internal */
const merge = exports.merge = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[1]), (self, that, options) => mergeWith(self, that, {
  onSelf: _Function.identity,
  onOther: _Function.identity,
  haltStrategy: options?.haltStrategy
}));
/** @internal */
const mergeAll = exports.mergeAll = /*#__PURE__*/(0, _Function.dual)(args => Symbol.iterator in args[0], (streams, options) => flatten(fromIterable(streams), options));
/** @internal */
const mergeWithTag = exports.mergeWithTag = /*#__PURE__*/(0, _Function.dual)(2, (streams, options) => {
  const keys = Object.keys(streams);
  const values = keys.map(key => streams[key].pipe(map(value => ({
    _tag: key,
    value
  }))));
  return mergeAll(values, options);
});
/** @internal */
const mergeEither = exports.mergeEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => mergeWith(self, that, {
  onSelf: Either.left,
  onOther: Either.right
}));
/** @internal */
const mergeLeft = exports.mergeLeft = /*#__PURE__*/(0, _Function.dual)(2, (left, right) => (0, _Function.pipe)(left, merge(drain(right))));
/** @internal */
const mergeRight = exports.mergeRight = /*#__PURE__*/(0, _Function.dual)(2, (left, right) => (0, _Function.pipe)(drain(left), merge(right)));
/** @internal */
const mergeWith = exports.mergeWith = /*#__PURE__*/(0, _Function.dual)(3, (self, other, options) => {
  const strategy = options.haltStrategy ? haltStrategy.fromInput(options.haltStrategy) : HaltStrategy.Both;
  const handler = terminate => exit => terminate || !Exit.isSuccess(exit) ?
  // TODO: remove
  MergeDecision.Done(Effect.suspend(() => exit)) : MergeDecision.Await(exit => Effect.suspend(() => exit));
  return new StreamImpl(channel.mergeWith(toChannel(map(self, options.onSelf)), {
    other: toChannel(map(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
/** @internal */
const mkString = self => run(self, sink_.mkString);
/** @internal

## orDie

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `orDie(= orDie;
const orDieWith = exports.orDieWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const onEnd = exports.onEnd = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => concat(self, drain(fromEffect(effect))));
/** @internal */
const onError = exports.onError = /*#__PURE__*/(0, _Function.dual)(2, (self, cleanup) => (0, _Function.pipe)(self, catchAllCause(cause => fromEffect((0, _Function.pipe)(cleanup(cause), Effect.zipRight(Effect.failCause(cause)))))));
/** @internal */
const onDone = exports.onDone = /*#__PURE__*/(0, _Function.dual)(2, (self, cleanup) => new StreamImpl((0, _Function.pipe)(toChannel(self), core.ensuringWith(exit => Exit.isSuccess(exit) ? cleanup() : Effect.void))));
/** @internal */
const onStart = exports.onStart = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => unwrap(Effect.as(effect, self)));
/** @internal */
const orDie = self => (0, _Function.pipe)(self, orDieWith(_Function.identity));
/** @internal

## paginate

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `paginate(= paginate;
const paginateChunk = (s, f)`

JSDoc:

@internal */
const orElse = exports.orElse = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.orElse(() => toChannel(that())))));
/** @internal */
const orElseEither = exports.orElseEither = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => (0, _Function.pipe)(self, map(Either.left), orElse(() => (0, _Function.pipe)(that(), map(Either.right)))));
/** @internal */
const orElseFail = exports.orElseFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => (0, _Function.pipe)(self, orElse(() => failSync(error))));
/** @internal */
const orElseIfEmpty = exports.orElseIfEmpty = /*#__PURE__*/(0, _Function.dual)(2, (self, element) => (0, _Function.pipe)(self, orElseIfEmptyChunk(() => Chunk.of(element()))));
/** @internal */
const orElseIfEmptyChunk = exports.orElseIfEmptyChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, chunk) => (0, _Function.pipe)(self, orElseIfEmptyStream(() => new StreamImpl(core.write(chunk())))));
/** @internal */
const orElseIfEmptyStream = exports.orElseIfEmptyStream = /*#__PURE__*/(0, _Function.dual)(2, (self, stream) => {
  const writer = core.readWith({
    onInput: input => {
      if (Chunk.isEmpty(input)) {
        return core.suspend(() => writer);
      }
      return (0, _Function.pipe)(core.write(input), channel.zipRight(channel.identityChannel()));
    },
    onFailure: core.fail,
    onDone: () => core.suspend(() => toChannel(stream()))
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(writer)));
});
/** @internal */
const orElseSucceed = exports.orElseSucceed = /*#__PURE__*/(0, _Function.dual)(2, (self, value) => (0, _Function.pipe)(self, orElse(() => sync(value))));
/** @internal */
const paginate = (s, f) => paginateChunk(s, s => {
  const page = f(s);
  return [Chunk.of(page[0]), page[1]];
});
/** @internal

## paginateChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `paginateChunk(= paginateChunk;
const paginateChunkEffect = (s, f)`

JSDoc:

@internal

## paginateChunkEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `paginateChunkEffect(= paginateChunkEffect;
const paginateEffect = (s, f)`

JSDoc:

@internal

## paginateEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `paginateEffect(= paginateEffect;
const peel = exports.peel = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## range

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `range(= range;
const race = exports.race = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const partition = exports.partition = /*#__PURE__*/(0, _Function.dual)(args => typeof args[1] === "function", (self, predicate, options) => partitionEither(self, a => Effect.succeed(predicate(a) ? Either.right(a) : Either.left(a)), options));
/** @internal */
const partitionEither = exports.partitionEither = /*#__PURE__*/(0, _Function.dual)(args => typeof args[1] === "function", (self, predicate, options) => (0, _Function.pipe)(mapEffectSequential(self, predicate), distributedWith({
  size: 2,
  maximumLag: options?.bufferSize ?? 16,
  decide: Either.match({
    onLeft: () => Effect.succeed(n => n === 0),
    onRight: () => Effect.succeed(n => n === 1)
  })
}), Effect.flatMap(([queue1, queue2]) => Effect.succeed([filterMap(flattenExitOption(fromQueue(queue1, {
  shutdown: true
})), _ => Either.match(_, {
  onLeft: Option.some,
  onRight: Option.none
})), filterMap(flattenExitOption(fromQueue(queue2, {
  shutdown: true
})), _ => Either.match(_, {
  onLeft: Option.none,
  onRight: Option.some
}))]))));
/** @internal */
const pipeThrough = exports.pipeThrough = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(sink_.toChannel(sink)))));
/** @internal */
const pipeThroughChannel = exports.pipeThroughChannel = /*#__PURE__*/(0, _Function.dual)(2, (self, channel) => new StreamImpl(core.pipeTo(toChannel(self), channel)));
/** @internal */
const pipeThroughChannelOrFail = exports.pipeThroughChannelOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, chan) => new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(chan))));
/** @internal */
const prepend = exports.prepend = /*#__PURE__*/(0, _Function.dual)(2, (self, values) => new StreamImpl(channel.zipRight(core.write(values), toChannel(self))));
/** @internal */
const provideContext = exports.provideContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => new StreamImpl((0, _Function.pipe)(toChannel(self), core.provideContext(context))));
/** @internal */
const provideSomeContext = exports.provideSomeContext = /*#__PURE__*/(0, _Function.dual)(2, (self, context) => mapInputContext(self, Context.merge(context)));
/** @internal */
const provideLayer = exports.provideLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) => new StreamImpl(channel.unwrapScopedWith(scope => Layer.buildWithScope(layer, scope).pipe(Effect.map(env => (0, _Function.pipe)(toChannel(self), core.provideContext(env)))))));
/** @internal */
const provideService = exports.provideService = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, resource) => provideServiceEffect(self, tag, Effect.succeed(resource)));
/** @internal */
const provideServiceEffect = exports.provideServiceEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, effect) => provideServiceStream(self, tag, fromEffect(effect)));
/** @internal */
const provideServiceStream = exports.provideServiceStream = /*#__PURE__*/(0, _Function.dual)(3, (self, tag, stream) => contextWithStream(env => flatMap(stream, service => (0, _Function.pipe)(self, provideContext(Context.add(env, tag, service))))));
/** @internal */
const mapInputContext = exports.mapInputContext = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => contextWithStream(env => (0, _Function.pipe)(self, provideContext(f(env)))));
/** @internal */
const provideSomeLayer = exports.provideSomeLayer = /*#__PURE__*/(0, _Function.dual)(2, (self, layer) =>
// @ts-expect-error
// @effect-diagnostics-next-line missingEffectContext:off
(0, _Function.pipe)(self, provideLayer((0, _Function.pipe)(Layer.context(), Layer.merge(layer)))));
/** @internal */
const range = (min, max, chunkSize = DefaultChunkSize) => suspend(() => {
  if (min > max) {
    return empty;
  }
  const go = (min, max, chunkSize) => {
    const remaining = max - min + 1;
    if (remaining > chunkSize) {
      return (0, _Function.pipe)(core.write(Chunk.range(min, min + chunkSize - 1)), core.flatMap(() => go(min + chunkSize, max, chunkSize)));
    }
    return core.write(Chunk.range(min, min + remaining - 1));
  };
  return new StreamImpl(go(min, max, chunkSize));
});
/** @internal

## raceAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `raceAll(= raceAll;
const rechunk = exports.rechunk = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const raceAll = (...streams) => Deferred.make().pipe(Effect.map(halt => {
  let winner = null;
  return mergeAll(streams.map((stream, index) => stream.pipe(takeWhile(() => {
    if (winner === null) {
      winner = index;
      Deferred.unsafeDone(halt, Exit.void);
      return true;
    }
    return winner === index;
  }), interruptWhen(Deferred.await(halt).pipe(Effect.flatMap(() => winner === index ? Effect.never : Effect.void))))), {
    concurrency: streams.length
  });
}), unwrap);
/** @internal

## repeatEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `repeatEffect(= repeatEffect;
const repeatEffectChunk = effect => repeatEffectChunkOption((0, _Function.pipe)`

JSDoc:

@internal */
const rechunkProcess = (rechunker, target) => core.readWithCause({
  onInput: chunk => {
    if (chunk.length === target && rechunker.isEmpty()) {
      return core.flatMap(core.write(chunk), () => rechunkProcess(rechunker, target));
    }
    if (chunk.length > 0) {
      const chunks = [];
      let result = undefined;
      let index = 0;
      while (index < chunk.length) {
        while (index < chunk.length && result === undefined) {
          result = rechunker.write((0, _Function.pipe)(chunk, Chunk.unsafeGet(index)));
          index = index + 1;
        }
        if (result !== undefined) {
          chunks.push(result);
          result = undefined;
        }
      }
      return core.flatMap(channel.writeAll(...chunks), () => rechunkProcess(rechunker, target));
    }
    return core.suspend(() => rechunkProcess(rechunker, target));
  },
  onFailure: cause => channel.zipRight(rechunker.emitIfNotEmpty(), core.failCause(cause)),
  onDone: () => rechunker.emitIfNotEmpty()
});
class StreamRechunker {
  n;
  builder = [];
  pos = 0;
  constructor(n) {
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = Chunk.unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return undefined;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return core.write(Chunk.unsafeFromArray(this.builder));
    }
    return core.void;
  }
}
/** @internal */
const refineOrDie = exports.refineOrDie = /*#__PURE__*/(0, _Function.dual)(2, (self, pf) => (0, _Function.pipe)(self, refineOrDieWith(pf, _Function.identity)));
/** @internal */
const refineOrDieWith = exports.refineOrDieWith = /*#__PURE__*/(0, _Function.dual)(3, (self, pf, f) => new StreamImpl(channel.catchAll(toChannel(self), error => Option.match(pf(error), {
  onNone: () => core.failCause(Cause.die(f(error))),
  onSome: core.fail
}))));
/** @internal */
const repeat = exports.repeat = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => filterMap(repeatEither(self, schedule), _ => Either.match(_, {
  onLeft: Option.none,
  onRight: Option.some
})));
/** @internal */
const repeatEffect = effect => repeatEffectOption((0, _Function.pipe)(effect, Effect.mapError(Option.some)));
/** @internal

## repeatEffectChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `repeatEffectChunk(= repeatEffectChunk;
const repeatEffectChunkOption = effect => unfoldChunkEffect(effect, effect => (0, _Function.pipe)`

JSDoc:

@internal

## repeatEffectChunkOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `repeatEffectChunkOption(= repeatEffectChunkOption;
const repeatEffectOption = effect => repeatEffectChunkOption((0, _Function.pipe)`

JSDoc:

@internal

## repeatEffectOption

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `repeatEffectOption(= repeatEffectOption;
const repeatEither = exports.repeatEither = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## repeatValue

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `repeatValue(= repeatValue;
const repeatWith = exports.repeatWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const repeatElements = exports.repeatElements = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => filterMap(repeatElementsWith(self, schedule, {
  onElement: a => Option.some(a),
  onSchedule: Option.none
}), _Function.identity));
/** @internal */
const repeatElementsWith = exports.repeatElementsWith = /*#__PURE__*/(0, _Function.dual)(3, (self, schedule, options) => {
  const driver = (0, _Function.pipe)(Schedule.driver(schedule), Effect.map(driver => {
    const feed = input => Option.match(Chunk.head(input), {
      onNone: () => loop,
      onSome: a => channel.zipRight(core.write(Chunk.of(options.onElement(a))), step((0, _Function.pipe)(input, Chunk.drop(1)), a))
    });
    const step = (input, a) => {
      const advance = (0, _Function.pipe)(driver.next(a), Effect.as((0, _Function.pipe)(core.write(Chunk.of(options.onElement(a))), core.flatMap(() => step(input, a)))));
      const reset = (0, _Function.pipe)(driver.last, Effect.orDie, Effect.flatMap(b => (0, _Function.pipe)(driver.reset, Effect.map(() => (0, _Function.pipe)(core.write(Chunk.of(options.onSchedule(b))), channel.zipRight(feed(input)))))));
      return (0, _Function.pipe)(advance, Effect.orElse(() => reset), channel.unwrap);
    };
    const loop = core.readWith({
      onInput: feed,
      onFailure: core.fail,
      onDone: () => core.void
    });
    return loop;
  }), channel.unwrap);
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(driver)));
});
/** @internal */
const repeatValue = value => new StreamImpl(channel.repeated(core.write(Chunk.of(value))));
/** @internal

## repeatEffectWithSchedule

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `repeatEffectWithSchedule(= repeatEffectWithSchedule;
const retry = exports.retry = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const repeatEffectWithSchedule = (effect, schedule) => flatMap(fromEffect(Effect.zip(effect, Schedule.driver(schedule))), ([a, driver]) => {
  const provideLastIterationInfo = Effect.provideServiceEffect(Schedule.CurrentIterationMetadata, Ref.get(driver.iterationMeta));
  return concat(succeed(a), unfoldEffect(a, s => Effect.matchEffect(driver.next(s), {
    onFailure: Effect.succeed,
    onSuccess: () => Effect.map(provideLastIterationInfo(effect), nextA => Option.some([nextA, nextA]))
  })));
});
/** @internal

## runCollect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `runCollect(= runCollect;
const runCount = self => run(self, sink_.count)`

JSDoc:

@internal */
const withExecutionPlan = exports.withExecutionPlan = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[0]), (self, policy, options) => suspend(() => {
  const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
  let i = 0;
  let lastError = Option.none();
  const loop = suspend(() => {
    const step = policy.steps[i++];
    if (!step) {
      return fail(Option.getOrThrow(lastError));
    }
    let nextStream = Context.isContext(step.provide) ? provideSomeContext(self, step.provide) : provideSomeLayer(self, step.provide);
    let receivedElements = false;
    if (Option.isSome(lastError)) {
      const error = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      // ensure the schedule is applied at least once
      nextStream = suspend(() => {
        if (attempted) return wrapped;
        attempted = true;
        return fail(error);
      });
      nextStream = scheduleDefectRefail(retry(nextStream, internalExecutionPlan.scheduleFromStep(step, false)));
    } else {
      const schedule = internalExecutionPlan.scheduleFromStep(step, true);
      nextStream = schedule ? scheduleDefectRefail(retry(nextStream, schedule)) : nextStream;
    }
    return catchAll(preventFallbackOnPartialStream ? mapChunks(nextStream, chunk => {
      receivedElements = true;
      return chunk;
    }) : nextStream, error => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail(error);
      }
      lastError = Option.some(error);
      return loop;
    });
  });
  return loop;
}));
const scheduleDefectRefail = self => catchAllCause(self, cause => failCause(InternalSchedule.scheduleDefectRefailCause(cause)));
/** @internal */
const run = exports.run = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => toChannel(self).pipe(channel.pipeToOrFail(sink_.toChannel(sink)), channel.runDrain));
/** @internal */
const runCollect = self => run(self, sink_.collectAll());
/** @internal

## runCount

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `runCount(= runCount;
const runDrain = self => run(self, sink_.drain)`

JSDoc:

@internal

## runDrain

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `runDrain(= runDrain;
const runFold = exports.runFold = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## runHead

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `runHead(= runHead;
const runIntoPubSub = exports.runIntoPubSub = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const runFoldEffect = exports.runFoldEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => runFoldWhileEffect(self, s, _Function.constTrue, f));
/** @internal */
const runFoldScoped = exports.runFoldScoped = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => (0, _Function.pipe)(self, runFoldWhileScoped(s, _Function.constTrue, f)));
/** @internal */
const runFoldScopedEffect = exports.runFoldScopedEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => (0, _Function.pipe)(self, runFoldWhileScopedEffect(s, _Function.constTrue, f)));
/** @internal */
const runFoldWhile = exports.runFoldWhile = /*#__PURE__*/(0, _Function.dual)(4, (self, s, cont, f) => run(self, sink_.fold(s, cont, f)));
/** @internal */
const runFoldWhileEffect = exports.runFoldWhileEffect = /*#__PURE__*/(0, _Function.dual)(4, (self, s, cont, f) => run(self, sink_.foldEffect(s, cont, f)));
/** @internal */
const runFoldWhileScoped = exports.runFoldWhileScoped = /*#__PURE__*/(0, _Function.dual)(4, (self, s, cont, f) => (0, _Function.pipe)(self, runScoped(sink_.fold(s, cont, f))));
/** @internal */
const runFoldWhileScopedEffect = exports.runFoldWhileScopedEffect = /*#__PURE__*/(0, _Function.dual)(4, (self, s, cont, f) => (0, _Function.pipe)(self, runScoped(sink_.foldEffect(s, cont, f))));
/** @internal */
const runForEach = exports.runForEach = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => run(self, sink_.forEach(f)));
/** @internal */
const runForEachChunk = exports.runForEachChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => run(self, sink_.forEachChunk(f)));
/** @internal */
const runForEachChunkScoped = exports.runForEachChunkScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, runScoped(sink_.forEachChunk(f))));
/** @internal */
const runForEachScoped = exports.runForEachScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, runScoped(sink_.forEach(f))));
/** @internal */
const runForEachWhile = exports.runForEachWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => run(self, sink_.forEachWhile(f)));
/** @internal */
const runForEachWhileScoped = exports.runForEachWhileScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, runScoped(sink_.forEachWhile(f))));
/** @internal */
const runHead = self => run(self, sink_.head());
/** @internal

## runLast

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `runLast(= runLast;
const runScoped = exports.runScoped = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const runIntoPubSubScoped = exports.runIntoPubSubScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, pubsub) => (0, _Function.pipe)(self, runIntoQueueScoped(pubsub)));
/** @internal */
const runIntoQueue = exports.runIntoQueue = /*#__PURE__*/(0, _Function.dual)(2, (self, queue) => (0, _Function.pipe)(self, runIntoQueueScoped(queue), Effect.scoped));
/** @internal */
const runIntoQueueElementsScoped = exports.runIntoQueueElementsScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, queue) => {
  const writer = core.readWithCause({
    onInput: input => core.flatMap(core.fromEffect(Queue.offerAll(queue, Chunk.map(input, Exit.succeed))), () => writer),
    onFailure: cause => core.fromEffect(Queue.offer(queue, Exit.failCause(Cause.map(cause, Option.some)))),
    onDone: () => core.fromEffect(Queue.offer(queue, Exit.fail(Option.none())))
  });
  return (0, _Function.pipe)(core.pipeTo(toChannel(self), writer), channel.drain, channel.runScoped, Effect.asVoid);
});
/** @internal */
const runIntoQueueScoped = exports.runIntoQueueScoped = /*#__PURE__*/(0, _Function.dual)(2, (self, queue) => {
  const writer = core.readWithCause({
    onInput: input => core.flatMap(core.write(InternalTake.chunk(input)), () => writer),
    onFailure: cause => core.write(InternalTake.failCause(cause)),
    onDone: () => core.write(InternalTake.end)
  });
  return (0, _Function.pipe)(core.pipeTo(toChannel(self), writer), channel.mapOutEffect(take => Queue.offer(queue, take)), channel.drain, channel.runScoped, Effect.asVoid);
});
/** @internal */
const runLast = self => run(self, sink_.last());
/** @internal

## runSum

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `runSum(= runSum;
const scan = exports.scan = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const runSum = self => run(self, sink_.sum);
/** @internal

## scoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `scoped(= scoped;
const scopedWith = f => new StreamImpl(channel.scopedWith(scope => f(scope)`

JSDoc:

@internal */
const scanReduce = exports.scanReduce = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, scanReduceEffect((a2, a) => Effect.succeed(f(a2, a)))));
/** @internal */
const scanReduceEffect = exports.scanReduceEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => (0, _Function.pipe)(self, mapAccumEffect(Option.none(), (option, a) => {
  switch (option._tag) {
    case "None":
      {
        return Effect.succeed([Option.some(a), a]);
      }
    case "Some":
      {
        return (0, _Function.pipe)(f(option.value, a), Effect.map(b => [Option.some(b), b]));
      }
  }
})));
/** @internal */
const schedule = exports.schedule = /*#__PURE__*/(0, _Function.dual)(2, (self, schedule) => filterMap(scheduleWith(self, schedule, {
  onElement: Option.some,
  onSchedule: Option.none
}), _Function.identity));
/** @internal */
const scheduleWith = exports.scheduleWith = /*#__PURE__*/(0, _Function.dual)(3, (self, schedule, options) => {
  const loop = (driver, iterator) => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: chunk => loop(driver, chunk[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeedNow
      });
    }
    return channel.unwrap(Effect.matchEffect(driver.next(next.value), {
      onFailure: () => (0, _Function.pipe)(driver.last, Effect.orDie, Effect.map(b => (0, _Function.pipe)(core.write(Chunk.make(options.onElement(next.value), options.onSchedule(b))), core.flatMap(() => loop(driver, iterator)))), Effect.zipLeft(driver.reset)),
      onSuccess: () => Effect.succeed((0, _Function.pipe)(core.write(Chunk.of(options.onElement(next.value))), core.flatMap(() => loop(driver, iterator))))
    }));
  };
  return new StreamImpl((0, _Function.pipe)(core.fromEffect(Schedule.driver(schedule)), core.flatMap(driver => (0, _Function.pipe)(toChannel(self), core.pipeTo(loop(driver, Chunk.empty()[Symbol.iterator]()))))));
});
/** @internal */
const scanEffect = exports.scanEffect = /*#__PURE__*/(0, _Function.dual)(3, (self, s, f) => new StreamImpl((0, _Function.pipe)(core.write(Chunk.of(s)), core.flatMap(() => toChannel((0, _Function.pipe)(self, mapAccumEffect(s, (s, a) => (0, _Function.pipe)(f(s, a), Effect.map(s => [s, s])))))))));
/** @internal */
const scoped = effect => new StreamImpl(channel.ensuring(channel.scoped((0, _Function.pipe)(effect, Effect.map(Chunk.of))), Effect.void));
/** @internal

## scopedWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `scopedWith(= scopedWith;
const some = self => (0, _Function.pipe)`

JSDoc:

@internal

## some

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `some(= some;
const someOrElse = exports.someOrElse = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## splitLines

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `splitLines(= splitLines;
const succeed = value => fromChunk(Chunk.of(value)`

JSDoc:

@internal */
const someOrFail = exports.someOrFail = /*#__PURE__*/(0, _Function.dual)(2, (self, error) => mapEffectSequential(self, Option.match({
  onNone: () => Effect.failSync(error),
  onSome: Effect.succeed
})));
/** @internal */
const sliding = exports.sliding = /*#__PURE__*/(0, _Function.dual)(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
/** @internal */
const slidingSize = exports.slidingSize = /*#__PURE__*/(0, _Function.dual)(3, (self, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die(new Cause.IllegalArgumentException("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(core.suspend(() => {
    const queue = new _ringBuffer.RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result = Chunk.isEmpty(items) ? Chunk.empty() : Chunk.of(items);
        return (0, _Function.pipe)(core.write(result), core.flatMap(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = (0, _Function.pipe)(queue.toChunk(), Chunk.takeRight(leftovers));
      const result = Chunk.isEmpty(lastItems) ? Chunk.empty() : Chunk.of(lastItems);
      return (0, _Function.pipe)(core.write(result), core.flatMap(() => channelEnd));
    };
    const reader = queueSize => core.readWithCause({
      onInput: input => core.flatMap(core.write(Chunk.filterMap(input, (element, index) => {
        queue.put(element);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return Option.none();
        }
        return Option.some(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: cause => emitOnStreamEnd(queueSize, core.failCause(cause)),
      onDone: () => emitOnStreamEnd(queueSize, core.void)
    });
    return (0, _Function.pipe)(toChannel(self), core.pipeTo(reader(0)));
  }));
});
/** @internal */
const split = exports.split = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const split = (leftovers, input) => {
    const [chunk, remaining] = (0, _Function.pipe)(leftovers, Chunk.appendAll(input), Chunk.splitWhere(predicate));
    if (Chunk.isEmpty(chunk) || Chunk.isEmpty(remaining)) {
      return loop((0, _Function.pipe)(chunk, Chunk.appendAll((0, _Function.pipe)(remaining, Chunk.drop(1)))));
    }
    return (0, _Function.pipe)(core.write(Chunk.of(chunk)), core.flatMap(() => split(Chunk.empty(), (0, _Function.pipe)(remaining, Chunk.drop(1)))));
  };
  const loop = leftovers => core.readWith({
    onInput: input => split(leftovers, input),
    onFailure: core.fail,
    onDone: () => {
      if (Chunk.isEmpty(leftovers)) {
        return core.void;
      }
      if (Option.isNone((0, _Function.pipe)(leftovers, Chunk.findFirst(predicate)))) {
        return channel.zipRight(core.write(Chunk.of(leftovers)), core.void);
      }
      return channel.zipRight(split(Chunk.empty(), leftovers), core.void);
    }
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(loop(Chunk.empty()))));
});
/** @internal */
const splitOnChunk = exports.splitOnChunk = /*#__PURE__*/(0, _Function.dual)(2, (self, delimiter) => {
  const next = (leftover, delimiterIndex) => core.readWithCause({
    onInput: inputChunk => {
      let buffer;
      const [carry, delimiterCursor] = (0, _Function.pipe)(inputChunk, Chunk.reduce([(0, _Function.pipe)(leftover, Option.getOrElse(() => Chunk.empty())), delimiterIndex], ([carry, delimiterCursor], a) => {
        const concatenated = (0, _Function.pipe)(carry, Chunk.append(a));
        if (delimiterCursor < delimiter.length && Equal.equals(a, (0, _Function.pipe)(delimiter, Chunk.unsafeGet(delimiterCursor)))) {
          if (delimiterCursor + 1 === delimiter.length) {
            if (buffer === undefined) {
              buffer = [];
            }
            buffer.push((0, _Function.pipe)(concatenated, Chunk.take(concatenated.length - delimiter.length)));
            return [Chunk.empty(), 0];
          }
          return [concatenated, delimiterCursor + 1];
        }
        return [concatenated, Equal.equals(a, (0, _Function.pipe)(delimiter, Chunk.unsafeGet(0))) ? 1 : 0];
      }));
      const output = buffer === undefined ? Chunk.empty() : Chunk.unsafeFromArray(buffer);
      return core.flatMap(core.write(output), () => next(Chunk.isNonEmpty(carry) ? Option.some(carry) : Option.none(), delimiterCursor));
    },
    onFailure: cause => Option.match(leftover, {
      onNone: () => core.failCause(cause),
      onSome: chunk => channel.zipRight(core.write(Chunk.of(chunk)), core.failCause(cause))
    }),
    onDone: done => Option.match(leftover, {
      onNone: () => core.succeed(done),
      onSome: chunk => channel.zipRight(core.write(Chunk.of(chunk)), core.succeed(done))
    })
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(next(Option.none(), 0))));
});
/** @internal */
const splitLines = self => pipeThroughChannel(self, channel.splitLines());
/** @internal

## succeed

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `succeed(= succeed;
const sync = evaluate => suspend(()`

JSDoc:

@internal

## sync

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `sync(= sync;
const suspend = stream => new StreamImpl(core.suspend(()`

JSDoc:

@internal

## suspend

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `suspend(= suspend;
const take = exports.take = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## tick

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `tick(= tick;
const timeout = exports.timeout = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const takeRight = exports.takeRight = /*#__PURE__*/(0, _Function.dual)(2, (self, n) => {
  if (n <= 0) {
    return empty;
  }
  return new StreamImpl((0, _Function.pipe)(Effect.succeed(new _ringBuffer.RingBuffer(n)), Effect.map(queue => {
    const reader = core.readWith({
      onInput: input => {
        for (const element of input) {
          queue.put(element);
        }
        return reader;
      },
      onFailure: core.fail,
      onDone: () => (0, _Function.pipe)(core.write(queue.toChunk()), channel.zipRight(core.void))
    });
    return (0, _Function.pipe)(toChannel(self), core.pipeTo(reader));
  }), channel.unwrap));
});
/** @internal */
const takeUntil = exports.takeUntil = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => {
      const taken = (0, _Function.pipe)(input, Chunk.takeWhile(a => !predicate(a)));
      const last = (0, _Function.pipe)(input, Chunk.drop(taken.length), Chunk.take(1));
      if (Chunk.isEmpty(last)) {
        return (0, _Function.pipe)(core.write(taken), core.flatMap(() => loop));
      }
      return core.write((0, _Function.pipe)(taken, Chunk.appendAll(last)));
    },
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(loop)));
});
/** @internal */
const takeUntilEffect = exports.takeUntilEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = iterator => {
    const next = iterator.next();
    if (next.done) {
      return core.readWithCause({
        onInput: elem => loop(elem[Symbol.iterator]()),
        onFailure: core.failCause,
        onDone: core.succeed
      });
    }
    return (0, _Function.pipe)(predicate(next.value), Effect.map(bool => bool ? core.write(Chunk.of(next.value)) : (0, _Function.pipe)(core.write(Chunk.of(next.value)), core.flatMap(() => loop(iterator)))), channel.unwrap);
  };
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(loop(Chunk.empty()[Symbol.iterator]()))));
});
/** @internal */
const takeWhile = exports.takeWhile = /*#__PURE__*/(0, _Function.dual)(2, (self, predicate) => {
  const loop = core.readWith({
    onInput: input => {
      const taken = (0, _Function.pipe)(input, Chunk.takeWhile(predicate));
      const more = taken.length === input.length;
      if (more) {
        return (0, _Function.pipe)(core.write(taken), core.flatMap(() => loop));
      }
      return core.write(taken);
    },
    onFailure: core.fail,
    onDone: core.succeed
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(loop)));
});
/** @internal */
const tap = exports.tap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => mapEffectSequential(self, a => Effect.as(f(a), a)));
/** @internal */
const tapBoth = exports.tapBoth = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => (0, _Function.pipe)(self, tapError(options.onFailure), tap(options.onSuccess)));
/** @internal */
const tapError = exports.tapError = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => catchAll(self, error => fromEffect(Effect.zipRight(f(error), Effect.fail(error)))));
/** @internal */
const tapErrorCause = exports.tapErrorCause = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => {
  const loop = core.readWithCause({
    onInput: chunk => core.flatMap(core.write(chunk), () => loop),
    onFailure: cause => core.fromEffect(Effect.zipRight(f(cause), Effect.failCause(cause))),
    onDone: core.succeedNow
  });
  return new StreamImpl((0, _Function.pipe)(toChannel(self), core.pipeTo(loop)));
});
/** @internal */
const tapSink = exports.tapSink = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => (0, _Function.pipe)(fromEffect(Effect.all([Queue.bounded(1), Deferred.make()])), flatMap(([queue, deferred]) => {
  const right = flattenTake(fromQueue(queue, {
    maxChunkSize: 1
  }));
  const loop = core.readWithCause({
    onInput: chunk => (0, _Function.pipe)(core.fromEffect(Queue.offer(queue, InternalTake.chunk(chunk))), core.foldCauseChannel({
      onFailure: () => core.flatMap(core.write(chunk), () => channel.identityChannel()),
      onSuccess: () => core.flatMap(core.write(chunk), () => loop)
    })),
    onFailure: cause => (0, _Function.pipe)(core.fromEffect(Queue.offer(queue, InternalTake.failCause(cause))), core.foldCauseChannel({
      onFailure: () => core.failCause(cause),
      onSuccess: () => core.failCause(cause)
    })),
    onDone: () => (0, _Function.pipe)(core.fromEffect(Queue.offer(queue, InternalTake.end)), core.foldCauseChannel({
      onFailure: () => core.void,
      onSuccess: () => core.void
    }))
  });
  return (0, _Function.pipe)(new StreamImpl((0, _Function.pipe)(core.pipeTo(toChannel(self), loop), channel.ensuring(Effect.zipRight(Effect.forkDaemon(Queue.offer(queue, InternalTake.end)), Deferred.await(deferred))))), merge(execute((0, _Function.pipe)(run(right, sink), Effect.ensuring(Effect.zipRight(Queue.shutdown(queue), Deferred.succeed(deferred, void 0)))))));
})));
/** @internal */
const throttle = exports.throttle = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => throttleEffect(self, {
  ...options,
  cost: chunk => Effect.succeed(options.cost(chunk))
}));
/** @internal */
const throttleEffect = exports.throttleEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
});
const throttleEnforceEffect = (self, cost, units, duration, burst) => {
  const loop = (tokens, timestampMillis) => core.readWithCause({
    onInput: input => (0, _Function.pipe)(cost(input), Effect.zip(Clock.currentTimeMillis), Effect.map(([weight, currentTimeMillis]) => {
      const elapsed = currentTimeMillis - timestampMillis;
      const cycles = elapsed / Duration.toMillis(duration);
      const sum = tokens + cycles * units;
      const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum < 0 ? max : Math.min(sum, max);
      if (weight <= available) {
        return (0, _Function.pipe)(core.write(input), core.flatMap(() => loop(available - weight, currentTimeMillis)));
      }
      return loop(tokens, timestampMillis);
    }), channel.unwrap),
    onFailure: core.failCause,
    onDone: () => core.void
  });
  const throttled = (0, _Function.pipe)(Clock.currentTimeMillis, Effect.map(currentTimeMillis => loop(units, currentTimeMillis)), channel.unwrap);
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(throttled)));
};
const throttleShapeEffect = (self, costFn, units, duration, burst) => {
  const loop = (tokens, timestampMillis) => core.readWithCause({
    onInput: input => (0, _Function.pipe)(costFn(input), Effect.zip(Clock.currentTimeMillis), Effect.map(([weight, currentTimeMillis]) => {
      const elapsed = currentTimeMillis - timestampMillis;
      const cycles = elapsed / Duration.toMillis(duration);
      const sum = tokens + cycles * units;
      const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum < 0 ? max : Math.min(sum, max);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay = Duration.millis(Math.max(0, waitCycles * Duration.toMillis(duration)));
      if (Duration.greaterThan(delay, Duration.zero)) {
        return (0, _Function.pipe)(core.fromEffect(Clock.sleep(delay)), channel.zipRight(core.write(input)), core.flatMap(() => loop(remaining, currentTimeMillis)));
      }
      return core.flatMap(core.write(input), () => loop(remaining, currentTimeMillis));
    }), channel.unwrap),
    onFailure: core.failCause,
    onDone: () => core.void
  });
  const throttled = (0, _Function.pipe)(Clock.currentTimeMillis, Effect.map(currentTimeMillis => loop(units, currentTimeMillis)), channel.unwrap);
  return new StreamImpl((0, _Function.pipe)(toChannel(self), channel.pipeToOrFail(throttled)));
};
/** @internal */
const tick = interval => repeatWithSchedule(void 0, Schedule.spaced(interval));
/** @internal

## toPull

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `toPull(= toPull;
const toQueue = exports.toQueue = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const timeoutFail = exports.timeoutFail = /*#__PURE__*/(0, _Function.dual)(3, (self, error, duration) => (0, _Function.pipe)(self, timeoutTo(duration, failSync(error))));
/** @internal */
const timeoutFailCause = exports.timeoutFailCause = /*#__PURE__*/(0, _Function.dual)(3, (self, cause, duration) => (0, _Function.pipe)(toPull(self), Effect.map(Effect.timeoutFailCause({
  onTimeout: () => Cause.map(cause(), Option.some),
  duration
})), fromPull));
/** @internal */
const timeoutTo = exports.timeoutTo = /*#__PURE__*/(0, _Function.dual)(3, (self, duration, that) => {
  const StreamTimeout = new Cause.RuntimeException("Stream Timeout");
  return (0, _Function.pipe)(self, timeoutFailCause(() => Cause.die(StreamTimeout), duration), catchSomeCause(cause => Cause.isDieType(cause) && Cause.isRuntimeException(cause.defect) && cause.defect.message !== undefined && cause.defect.message === "Stream Timeout" ? Option.some(that) : Option.none()));
});
const pubsubFromOptions = options => {
  if (typeof options === "number") {
    return PubSub.bounded(options);
  } else if (options.capacity === "unbounded") {
    return PubSub.unbounded({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return PubSub.dropping(options);
    case "sliding":
      return PubSub.sliding(options);
    default:
      return PubSub.bounded(options);
  }
};
/** @internal */
const toPubSub = exports.toPubSub = /*#__PURE__*/(0, _Function.dual)(2, (self, capacity) => (0, _Function.pipe)(Effect.acquireRelease(pubsubFromOptions(capacity), pubsub => PubSub.shutdown(pubsub)), Effect.tap(pubsub => (0, _Function.pipe)(self, runIntoPubSubScoped(pubsub), Effect.forkScoped))));
/** @internal */
const toPull = self => Effect.map(channel.toPull(toChannel(self)), pull => (0, _Function.pipe)(pull, Effect.mapError(Option.some), Effect.flatMap(Either.match({
  onLeft: () => Effect.fail(Option.none()),
  onRight: Effect.succeed
}))));
/** @internal

## toAsyncIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `toAsyncIterable(= toAsyncIterable;
const toAsyncIterableEffect = self => Effect.map(Effect.runtime()`

JSDoc:

@internal */
const toQueueOfElements = exports.toQueueOfElements = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[0]), (self, options) => Effect.tap(Effect.acquireRelease(Queue.bounded(options?.capacity ?? 2), queue => Queue.shutdown(queue)), queue => Effect.forkScoped(runIntoQueueElementsScoped(self, queue))));
/** @internal */
const toReadableStream = exports.toReadableStream = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[0]), (self, options) => toReadableStreamRuntime(self, Runtime.defaultRuntime, options));
/** @internal */
const toReadableStreamEffect = exports.toReadableStreamEffect = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[0]), (self, options) => Effect.map(Effect.runtime(), runtime => toReadableStreamRuntime(self, runtime, options)));
/** @internal */
const toReadableStreamRuntime = exports.toReadableStreamRuntime = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[0]), (self, runtime, options) => {
  const runFork = Runtime.runFork(runtime);
  let currentResolve = undefined;
  let fiber = undefined;
  const latch = Effect.unsafeMakeLatch(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork(runForEachChunk(self, chunk => {
        if (chunk.length === 0) return Effect.void;
        return latch.whenOpen(Effect.sync(() => {
          latch.unsafeClose();
          for (const item of chunk) {
            controller.enqueue(item);
          }
          currentResolve();
          currentResolve = undefined;
        }));
      }));
      fiber.addObserver(exit => {
        try {
          if (exit._tag === "Failure") {
            controller.error(Cause.squash(exit.cause));
          } else {
            controller.close();
          }
        } catch {
          // ignore
        }
      });
    },
    pull() {
      return new Promise(resolve => {
        currentResolve = resolve;
        Effect.runSync(latch.open);
      });
    },
    cancel() {
      if (!fiber) return;
      return Effect.runPromise(Effect.asVoid(Fiber.interrupt(fiber)));
    }
  }, options?.strategy);
});
/** @internal */
const transduce = exports.transduce = /*#__PURE__*/(0, _Function.dual)(2, (self, sink) => {
  const newChannel = core.suspend(() => {
    const leftovers = {
      ref: Chunk.empty()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer = core.suspend(() => {
      const leftover = leftovers.ref;
      if (Chunk.isEmpty(leftover)) {
        return core.readWith({
          onInput: input => (0, _Function.pipe)(core.write(input), core.flatMap(() => buffer)),
          onFailure: core.fail,
          onDone: core.succeedNow
        });
      }
      leftovers.ref = Chunk.empty();
      return (0, _Function.pipe)(channel.writeChunk(leftover), core.flatMap(() => buffer));
    });
    const concatAndGet = chunk => {
      const leftover = leftovers.ref;
      const concatenated = Chunk.appendAll(leftover, Chunk.filter(chunk, chunk => chunk.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = core.readWith({
      onInput: input => core.flatMap(core.write(input), () => upstreamMarker),
      onFailure: core.fail,
      onDone: done => channel.zipRight(core.sync(() => {
        upstreamDone.ref = true;
      }), core.succeedNow(done))
    });
    const transducer = (0, _Function.pipe)(sink, sink_.toChannel, core.collectElements, core.flatMap(([leftover, z]) => (0, _Function.pipe)(core.succeed([upstreamDone.ref, concatAndGet(leftover)]), core.flatMap(([done, newLeftovers]) => {
      const nextChannel = done && Chunk.isEmpty(newLeftovers) ? core.void : transducer;
      return (0, _Function.pipe)(core.write(Chunk.of(z)), core.flatMap(() => nextChannel));
    }))));
    return (0, _Function.pipe)(toChannel(self), core.pipeTo(upstreamMarker), core.pipeTo(buffer), channel.pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
/** @internal */
const toAsyncIterableRuntime = exports.toAsyncIterableRuntime = /*#__PURE__*/(0, _Function.dual)(args => isStream(args[0]), (self, runtime) => {
  const runFork = Runtime.runFork(runtime);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = undefined;
      let currentReject = undefined;
      let fiber = undefined;
      const latch = Effect.unsafeMakeLatch(false);
      return {
        next() {
          if (!fiber) {
            fiber = runFork(runForEach(self, value => latch.whenOpen(Effect.sync(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value
              });
              currentResolve = currentReject = undefined;
            }))));
            fiber.addObserver(exit => {
              fiber = Effect.runFork(latch.whenOpen(Effect.sync(() => {
                if (exit._tag === "Failure") {
                  currentReject(Cause.squash(exit.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: void 0
                  });
                }
                currentResolve = currentReject = undefined;
              })));
            });
          }
          return new Promise((resolve, reject) => {
            currentResolve = resolve;
            currentReject = reject;
            latch.unsafeOpen();
          });
        },
        return() {
          if (!fiber) return Promise.resolve({
            done: true,
            value: void 0
          });
          return Effect.runPromise(Effect.as(Fiber.interrupt(fiber), {
            done: true,
            value: void 0
          }));
        }
      };
    }
  };
});
/** @internal */
const toAsyncIterable = self => toAsyncIterableRuntime(self, Runtime.defaultRuntime);
/** @internal

## toAsyncIterableEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `toAsyncIterableEffect(= toAsyncIterableEffect;
const unfold = (s, f)`

JSDoc:

@internal

## unfold

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `unfold(= unfold;
const unfoldChunk = (s, f)`

JSDoc:

@internal

## unfoldChunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `unfoldChunk(= unfoldChunk;
const unfoldChunkEffect = (s, f)`

JSDoc:

@internal

## unfoldChunkEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `unfoldChunkEffect(= unfoldChunkEffect;
const unfoldEffect = (s, f)`

JSDoc:

@internal

## unwrap

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `unwrap(= unwrap;
const unwrapScoped = effect => flatten(scoped(effect)`

JSDoc:

@internal */
const unwrap = effect => flatten(fromEffect(effect));
/** @internal

## unwrapScoped

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `unwrapScoped(= unwrapScoped;
const unwrapScopedWith = f => flatten(scopedWith(scope => f(scope)`

JSDoc:

@internal

## unwrapScopedWith

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `unwrapScopedWith(= unwrapScopedWith;
const updateService = exports.updateService = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## whenCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `whenCase(= whenCase;
const whenCaseEffect = exports.whenCaseEffect = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const when = exports.when = /*#__PURE__*/(0, _Function.dual)(2, (self, test) => (0, _Function.pipe)(self, whenEffect(Effect.sync(test))));
/** @internal */
const whenCase = (evaluate, pf) => whenCaseEffect(pf)(Effect.sync(evaluate));
/** @internal

## withSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `withSpan(= withSpan;
const zip = exports.zip = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const whenEffect = exports.whenEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, effect) => (0, _Function.pipe)(fromEffect(effect), flatMap(bool => bool ? self : empty)));
/** @internal */
const withSpan = function () {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = InternalTracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return new StreamImpl(channel.withSpan(toChannel(self), name, options));
  }
  return self => new StreamImpl(channel.withSpan(toChannel(self), name, options));
};
/** @internal

## zipLatestAll

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `zipLatestAll(= zipLatestAll;
const zipLatestWith = exports.zipLatestWith = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const zipFlatten = exports.zipFlatten = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => (0, _Function.pipe)(self, zipWith(that, (a, a2) => [...a, a2])));
/** @internal */
const zipAll = exports.zipAll = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => zipAllWith(self, {
  other: options.other,
  onSelf: a => [a, options.defaultOther],
  onOther: a2 => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
/** @internal */
const zipAllLeft = exports.zipAllLeft = /*#__PURE__*/(0, _Function.dual)(3, (self, other, defaultSelf) => zipAllWith(self, {
  other,
  onSelf: _Function.identity,
  onOther: () => defaultSelf,
  onBoth: a => a
}));
/** @internal */
const zipAllRight = exports.zipAllRight = /*#__PURE__*/(0, _Function.dual)(3, (self, other, defaultRight) => zipAllWith(self, {
  other,
  onSelf: () => defaultRight,
  onOther: _Function.identity,
  onBoth: (_, a2) => a2
}));
/** @internal */
const zipAllSortedByKey = exports.zipAllSortedByKey = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: a => [a, options.defaultOther],
  onOther: a2 => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
/** @internal */
const zipAllSortedByKeyLeft = exports.zipAllSortedByKeyLeft = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: _Function.identity,
  onOther: () => options.defaultSelf,
  onBoth: a => a,
  order: options.order
}));
/** @internal */
const zipAllSortedByKeyRight = exports.zipAllSortedByKeyRight = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: _Function.identity,
  onBoth: (_, a2) => a2,
  order: options.order
}));
/** @internal */
const zipAllSortedByKeyWith = exports.zipAllSortedByKeyWith = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipAllState.OP_DRAIN_LEFT:
        {
          return (0, _Function.pipe)(pullLeft, Effect.match({
            onFailure: Exit.fail,
            onSuccess: leftChunk => Exit.succeed([Chunk.map(leftChunk, ([k, a]) => [k, options.onSelf(a)]), ZipAllState.DrainLeft])
          }));
        }
      case ZipAllState.OP_DRAIN_RIGHT:
        {
          return (0, _Function.pipe)(pullRight, Effect.match({
            onFailure: Exit.fail,
            onSuccess: rightChunk => Exit.succeed([Chunk.map(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), ZipAllState.DrainRight])
          }));
        }
      case ZipAllState.OP_PULL_BOTH:
        {
          return (0, _Function.pipe)(unsome(pullLeft), Effect.zip(unsome(pullRight), {
            concurrent: true
          }), Effect.matchEffect({
            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.PullBoth, pullLeft, pullRight);
                }
                if (Chunk.isEmpty(leftOption.value)) {
                  return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed(merge(leftOption.value, rightOption.value)));
              }
              if (Option.isSome(leftOption) && Option.isNone(rightOption)) {
                if (Chunk.isEmpty(leftOption.value)) {
                  return pull(ZipAllState.DrainLeft, pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed([(0, _Function.pipe)(leftOption.value, Chunk.map(([k, a]) => [k, options.onSelf(a)])), ZipAllState.DrainLeft]));
              }
              if (Option.isNone(leftOption) && Option.isSome(rightOption)) {
                if (Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.DrainRight, pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed([(0, _Function.pipe)(rightOption.value, Chunk.map(([k, a2]) => [k, options.onOther(a2)])), ZipAllState.DrainRight]));
              }
              return Effect.succeed(Exit.fail(Option.none()));
            }
          }));
        }
      case ZipAllState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(pullLeft, {
            onFailure: Option.match({
              onNone: () => Effect.succeed(Exit.succeed([(0, _Function.pipe)(state.rightChunk, Chunk.map(([k, a2]) => [k, options.onOther(a2)])), ZipAllState.DrainRight])),
              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))
            }),
            onSuccess: leftChunk => Chunk.isEmpty(leftChunk) ? pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(leftChunk, state.rightChunk)))
          });
        }
      case ZipAllState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(pullRight, {
            onFailure: Option.match({
              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), ZipAllState.DrainLeft])),
              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))
            }),
            onSuccess: rightChunk => Chunk.isEmpty(rightChunk) ? pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight) : Effect.succeed(Exit.succeed(merge(state.leftChunk, rightChunk)))
          });
        }
    }
  };
  const merge = (leftChunk, rightChunk) => {
    const hasNext = (chunk, index) => index < chunk.length - 1;
    const builder = [];
    let state = undefined;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = (0, _Function.pipe)(leftChunk, Chunk.unsafeGet(leftIndex));
    let rightTuple = (0, _Function.pipe)(rightChunk, Chunk.unsafeGet(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop = true;
    while (loop) {
      const compare = options.order(k1, k2);
      if (compare === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = (0, _Function.pipe)(leftChunk, Chunk.unsafeGet(leftIndex));
          rightTuple = (0, _Function.pipe)(rightChunk, Chunk.unsafeGet(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = ZipAllState.PullRight((0, _Function.pipe)(leftChunk, Chunk.drop(leftIndex + 1)));
          loop = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = ZipAllState.PullLeft((0, _Function.pipe)(rightChunk, Chunk.drop(rightIndex + 1)));
          loop = false;
        } else {
          state = ZipAllState.PullBoth;
          loop = false;
        }
      } else if (compare < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = (0, _Function.pipe)(leftChunk, Chunk.unsafeGet(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = (0, _Function.pipe)(rightChunk, Chunk.unsafeGet(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = ZipAllState.PullLeft(Chunk.unsafeFromArray(rightBuilder));
          loop = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = (0, _Function.pipe)(rightChunk, Chunk.unsafeGet(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = (0, _Function.pipe)(leftChunk, Chunk.unsafeGet(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = ZipAllState.PullRight(Chunk.unsafeFromArray(leftBuilder));
          loop = false;
        }
      }
    }
    return [Chunk.unsafeFromArray(builder), state];
  };
  return combineChunks(self, options.other, ZipAllState.PullBoth, pull);
});
/** @internal */
const zipAllWith = exports.zipAllWith = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipAllState.OP_DRAIN_LEFT:
        {
          return Effect.matchEffect(pullLeft, {
            onFailure: error => Effect.succeed(Exit.fail(error)),
            onSuccess: leftChunk => Effect.succeed(Exit.succeed([Chunk.map(leftChunk, options.onSelf), ZipAllState.DrainLeft]))
          });
        }
      case ZipAllState.OP_DRAIN_RIGHT:
        {
          return Effect.matchEffect(pullRight, {
            onFailure: error => Effect.succeed(Exit.fail(error)),
            onSuccess: rightChunk => Effect.succeed(Exit.succeed([Chunk.map(rightChunk, options.onOther), ZipAllState.DrainRight]))
          });
        }
      case ZipAllState.OP_PULL_BOTH:
        {
          return (0, _Function.pipe)(unsome(pullLeft), Effect.zip(unsome(pullRight), {
            concurrent: true
          }), Effect.matchEffect({
            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.PullBoth, pullLeft, pullRight);
                }
                if (Chunk.isEmpty(leftOption.value)) {
                  return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value, options.onBoth)));
              }
              if (Option.isSome(leftOption) && Option.isNone(rightOption)) {
                return Effect.succeed(Exit.succeed([Chunk.map(leftOption.value, options.onSelf), ZipAllState.DrainLeft]));
              }
              if (Option.isNone(leftOption) && Option.isSome(rightOption)) {
                return Effect.succeed(Exit.succeed([Chunk.map(rightOption.value, options.onOther), ZipAllState.DrainRight]));
              }
              return Effect.succeed(Exit.fail(Option.none()));
            }
          }));
        }
      case ZipAllState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(pullLeft, {
            onFailure: Option.match({
              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.rightChunk, options.onOther), ZipAllState.DrainRight])),
              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))
            }),
            onSuccess: leftChunk => {
              if (Chunk.isEmpty(leftChunk)) {
                return pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(state.rightChunk)) {
                return pull(ZipAllState.PullRight(leftChunk), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk, options.onBoth)));
            }
          });
        }
      case ZipAllState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(pullRight, {
            onFailure: Option.match({
              onNone: () => Effect.succeed(Exit.succeed([Chunk.map(state.leftChunk, options.onSelf), ZipAllState.DrainLeft])),
              onSome: error => Effect.succeed(Exit.fail(Option.some(error)))
            }),
            onSuccess: rightChunk => {
              if (Chunk.isEmpty(rightChunk)) {
                return pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(state.leftChunk)) {
                return pull(ZipAllState.PullLeft(rightChunk), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk, options.onBoth)));
            }
          });
        }
    }
  };
  const zip = (leftChunk, rightChunk, f) => {
    const [output, either] = zipChunks(leftChunk, rightChunk, f);
    switch (either._tag) {
      case "Left":
        {
          if (Chunk.isEmpty(either.left)) {
            return [output, ZipAllState.PullBoth];
          }
          return [output, ZipAllState.PullRight(either.left)];
        }
      case "Right":
        {
          if (Chunk.isEmpty(either.right)) {
            return [output, ZipAllState.PullBoth];
          }
          return [output, ZipAllState.PullLeft(either.right)];
        }
    }
  };
  return combineChunks(self, options.other, ZipAllState.PullBoth, pull);
});
/** @internal */
const zipLatest = exports.zipLatest = /*#__PURE__*/(0, _Function.dual)(2, (left, right) => (0, _Function.pipe)(left, zipLatestWith(right, (a, a2) => [a, a2])));
const zipLatestAll = (...streams) => {
  if (streams.length === 0) {
    return empty;
  } else if (streams.length === 1) {
    return map(streams[0], x => [x]);
  }
  const [head, ...tail] = streams;
  return zipLatestWith(head, zipLatestAll(...tail), (first, second) => [first, ...second]);
};
/** @internal

## zipWithIndex

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `zipWithIndex(= zipWithIndex;
const zipWithNext = self => {
  const process = last => core.readWithCause({
    onInput: input => {
      const [newLast, chunk] = Chunk.mapAccum(input, last, (prev, curr)`

JSDoc:

@internal */
const zipLeft = exports.zipLeft = /*#__PURE__*/(0, _Function.dual)(2, (left, right) => (0, _Function.pipe)(left, zipWithChunks(right, (left, right) => {
  if (left.length > right.length) {
    return [(0, _Function.pipe)(left, Chunk.take(right.length)), Either.left((0, _Function.pipe)(left, Chunk.take(right.length)))];
  }
  return [left, Either.right((0, _Function.pipe)(right, Chunk.drop(left.length)))];
})));
/** @internal */
const zipRight = exports.zipRight = /*#__PURE__*/(0, _Function.dual)(2, (left, right) => (0, _Function.pipe)(left, zipWithChunks(right, (left, right) => {
  if (left.length > right.length) {
    return [right, Either.left((0, _Function.pipe)(left, Chunk.take(right.length)))];
  }
  return [(0, _Function.pipe)(right, Chunk.take(left.length)), Either.right((0, _Function.pipe)(right, Chunk.drop(left.length)))];
})));
/** @internal */
const zipWith = exports.zipWith = /*#__PURE__*/(0, _Function.dual)(3, (left, right, f) => (0, _Function.pipe)(left, zipWithChunks(right, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
/** @internal */
const zipWithChunks = exports.zipWithChunks = /*#__PURE__*/(0, _Function.dual)(3, (self, that, f) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case ZipChunksState.OP_PULL_BOTH:
        {
          return (0, _Function.pipe)(unsome(pullLeft), Effect.zip(unsome(pullRight), {
            concurrent: true
          }), Effect.matchEffect({
            onFailure: error => Effect.succeed(Exit.fail(Option.some(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {
                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipChunksState.PullBoth, pullLeft, pullRight);
                }
                if (Chunk.isEmpty(leftOption.value)) {
                  return pull(ZipChunksState.PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (Chunk.isEmpty(rightOption.value)) {
                  return pull(ZipChunksState.PullRight(leftOption.value), pullLeft, pullRight);
                }
                return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value)));
              }
              return Effect.succeed(Exit.fail(Option.none()));
            }
          }));
        }
      case ZipChunksState.OP_PULL_LEFT:
        {
          return Effect.matchEffect(pullLeft, {
            onFailure: error => Effect.succeed(Exit.fail(error)),
            onSuccess: leftChunk => {
              if (Chunk.isEmpty(leftChunk)) {
                return pull(ZipChunksState.PullLeft(state.rightChunk), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(state.rightChunk)) {
                return pull(ZipChunksState.PullRight(leftChunk), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk)));
            }
          });
        }
      case ZipChunksState.OP_PULL_RIGHT:
        {
          return Effect.matchEffect(pullRight, {
            onFailure: error => Effect.succeed(Exit.fail(error)),
            onSuccess: rightChunk => {
              if (Chunk.isEmpty(rightChunk)) {
                return pull(ZipChunksState.PullRight(state.leftChunk), pullLeft, pullRight);
              }
              if (Chunk.isEmpty(state.leftChunk)) {
                return pull(ZipChunksState.PullLeft(rightChunk), pullLeft, pullRight);
              }
              return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk)));
            }
          });
        }
    }
  };
  const zip = (leftChunk, rightChunk) => {
    const [output, either] = f(leftChunk, rightChunk);
    switch (either._tag) {
      case "Left":
        {
          if (Chunk.isEmpty(either.left)) {
            return [output, ZipChunksState.PullBoth];
          }
          return [output, ZipChunksState.PullRight(either.left)];
        }
      case "Right":
        {
          if (Chunk.isEmpty(either.right)) {
            return [output, ZipChunksState.PullBoth];
          }
          return [output, ZipChunksState.PullLeft(either.right)];
        }
    }
  };
  return (0, _Function.pipe)(self, combineChunks(that, ZipChunksState.PullBoth, pull));
});
/** @internal */
const zipWithIndex = self => (0, _Function.pipe)(self, mapAccum(0, (index, a) => [index + 1, [a, index]]));
/** @internal

## zipWithNext

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `zipWithNext(= zipWithNext;
const zipWithPrevious = self => (0, _Function.pipe)`

JSDoc:

@internal

## zipWithPrevious

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `zipWithPrevious(= zipWithPrevious;
const zipWithPreviousAndNext = self => (0, _Function.pipe)`

JSDoc:

@internal

## zipWithPreviousAndNext

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `zipWithPreviousAndNext(= zipWithPreviousAndNext;
const zipChunks = (left, right, f)`

JSDoc:

@internal

## channelToStream

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `channelToStream(= channelToStream;
const decodeText = exports.decodeText = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const Do = exports.Do = /*#__PURE__*/succeed({});
/** @internal */
const bind = exports.bind = /*#__PURE__*/(0, _Function.dual)(args => typeof args[0] !== "string", (self, tag, f, options) => flatMap(self, k => map(f(k), a => ({
  ...k,
  [tag]: a
})), options));
/* @internal */
const bindTo = exports.bindTo = /*#__PURE__*/doNotation.bindTo(map);
/* @internal */
const let_ = exports.let_ = /*#__PURE__*/doNotation.let_(map);
// Circular with Channel
/** @internal */
const channelToStream = self => {
  return new StreamImpl(self);
};
// =============================================================================
// encoding
// =============================================================================
/** @internal

## encodeText

Source: `my-backend/node_modules/effect/dist/cjs/internal/stream.js`

Signature: `encodeText(= encodeText;
const fromEventListener = (target, type, options)`

JSDoc:

@internal */
const encodeText = self => suspend(() => {
  const encoder = new TextEncoder();
  return map(self, s => encoder.encode(s));
});
/** @internal

## lowerCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/string-utils.js`

Signature: `lowerCase(= lowerCase;
const upperCase = str => str.toUpperCase()`

JSDoc:

Adapted from the `change-case` library.

Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)
/
/** @internal */
const lowerCase = str => str.toLowerCase();
/** @internal

## upperCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/string-utils.js`

Signature: `upperCase(= upperCase;
const replace = (input, re, value)`

JSDoc:

Replace `re` in the input string with the replacement value.

## camelCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/string-utils.js`

Signature: `camelCase(= camelCase;
const constantCase = (input, options)`

JSDoc:

Normalize the string into something other libraries can manipulate easier.
/
const noCase = (input, options = {}) => {
  const {
    delimiter = " ",
    splitRegexp = DEFAULT_SPLIT_REGEXP,
    stripRegexp = DEFAULT_STRIP_REGEXP,
    transform = lowerCase
  } = options;
  const result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  let start = 0;
  let end = result.length;
  // Trim the delimiter from around the output string.
  while (result.charAt(start) === "\0") {
    start++;
  }
  while (result.charAt(end - 1) === "\0") {
    end--;
  }
  // Transform each token independently.
  return result.slice(start, end).split("\0").map(transform).join(delimiter);
};
const pascalCaseTransform = (input, index) => {
  const firstChar = input.charAt(0);
  const lowerChars = input.substring(1).toLowerCase();
  if (index > 0 && firstChar >= "0" && firstChar <= "9") {
    return `_${firstChar}${lowerChars}`;
  }
  return `${firstChar.toUpperCase()}${lowerChars}`;
};
/** @internal */
const pascalCase = (input, options) => noCase(input, {
  delimiter: "",
  transform: pascalCaseTransform,
  ...options
});
exports.pascalCase = pascalCase;
const camelCaseTransform = (input, index) => index === 0 ? input.toLowerCase() : pascalCaseTransform(input, index);
/** @internal */
const camelCase = (input, options) => pascalCase(input, {
  transform: camelCaseTransform,
  ...options
});
/** @internal

## constantCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/string-utils.js`

Signature: `constantCase(= constantCase;
const kebabCase = (input, options)`

JSDoc:

@internal

## kebabCase

Source: `my-backend/node_modules/effect/dist/cjs/internal/string-utils.js`

Signature: `kebabCase(= kebabCase;
const snakeCase = (input, options)`

JSDoc:

@internal

## get

Source: `my-backend/node_modules/effect/dist/cjs/internal/subscriptionRef.js`

Signature: `get(= get;
const make = value => (0, _Function.pipe)`

JSDoc:

@internal */
const SubscriptionRefSymbolKey = "effect/SubscriptionRef";
/** @internal */
const SubscriptionRefTypeId = exports.SubscriptionRefTypeId = /*#__PURE__*/Symbol.for(SubscriptionRefSymbolKey);
const subscriptionRefVariance = {
  /* c8 ignore next */
  _A: _ => _
};
/** @internal */
class SubscriptionRefImpl extends Effectable.Class {
  ref;
  pubsub;
  semaphore;
  [Readable.TypeId] = Readable.TypeId;
  [Subscribable.TypeId] = Subscribable.TypeId;
  [Ref.RefTypeId] = ref_.refVariance;
  [Synchronized.SynchronizedRefTypeId] = circular_.synchronizedVariance;
  [SubscriptionRefTypeId] = subscriptionRefVariance;
  constructor(ref, pubsub, semaphore) {
    super();
    this.ref = ref;
    this.pubsub = pubsub;
    this.semaphore = semaphore;
    this.get = Ref.get(this.ref);
  }
  commit() {
    return this.get;
  }
  get;
  get changes() {
    return (0, _Function.pipe)(Ref.get(this.ref), Effect.flatMap(a => Effect.map(stream.fromPubSub(this.pubsub, {
      scoped: true
    }), s => stream.concat(stream.make(a), s))), this.semaphore.withPermits(1), stream.unwrapScoped);
  }
  modify(f) {
    return this.modifyEffect(a => Effect.succeed(f(a)));
  }
  modifyEffect(f) {
    return (0, _Function.pipe)(Ref.get(this.ref), Effect.flatMap(f), Effect.flatMap(([b, a]) => (0, _Function.pipe)(Ref.set(this.ref, a), Effect.as(b), Effect.zipLeft(PubSub.publish(this.pubsub, a)))), this.semaphore.withPermits(1));
  }
}
/** @internal */
const get = self => Ref.get(self.ref);
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/subscriptionRef.js`

Signature: `make(= make;
const modify = exports.modify = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## combine

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor/patch.js`

Signature: `combine(= combine;
const patch = (self, supervisor)`

JSDoc:

@internal */
const OP_EMPTY = exports.OP_EMPTY = "Empty";
/** @internal */
const OP_ADD_SUPERVISOR = exports.OP_ADD_SUPERVISOR = "AddSupervisor";
/** @internal */
const OP_REMOVE_SUPERVISOR = exports.OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
/** @internal */
const OP_AND_THEN = exports.OP_AND_THEN = "AndThen";
/**
The empty `SupervisorPatch`.

@internal
/
const empty = exports.empty = {
  _tag: OP_EMPTY
};
/**
Combines two patches to produce a new patch that describes applying the
updates from this patch and then the updates from the specified patch.

@internal
/
const combine = (self, that) => {
  return {
    _tag: OP_AND_THEN,
    first: self,
    second: that
  };
};
/**
Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.

@internal

## patch

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor/patch.js`

Signature: `patch(= patch;
const patchLoop = (_supervisor, _patches)`

JSDoc:

@internal

## diff

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor/patch.js`

Signature: `diff(= diff;
const differ = exports.differ = /*#__PURE__*/Differ.make({
  empty,
  patch,
  combine,
  diff
})`

JSDoc:

@internal */
const removeSupervisor = (self, that) => {
  if (Equal.equals(self, that)) {
    return supervisor.none;
  } else {
    if (supervisor.isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
/** @internal */
const toSet = self => {
  if (Equal.equals(self, supervisor.none)) {
    return HashSet.empty();
  } else {
    if (supervisor.isZip(self)) {
      return (0, _Function.pipe)(toSet(self.left), HashSet.union(toSet(self.right)));
    } else {
      return HashSet.make(self);
    }
  }
};
/** @internal */
const diff = (oldValue, newValue) => {
  if (Equal.equals(oldValue, newValue)) {
    return empty;
  }
  const oldSupervisors = toSet(oldValue);
  const newSupervisors = toSet(newValue);
  const added = (0, _Function.pipe)(newSupervisors, HashSet.difference(oldSupervisors), HashSet.reduce(empty, (patch, supervisor) => combine(patch, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = (0, _Function.pipe)(oldSupervisors, HashSet.difference(newSupervisors), HashSet.reduce(empty, (patch, supervisor) => combine(patch, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine(added, removed);
};
/** @internal

## ProxySupervisor

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor.js`

Signature: `ProxySupervisor(= ProxySupervisor;
class Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left, right)`

JSDoc:

@internal */
const SupervisorSymbolKey = "effect/Supervisor";
/** @internal */
const SupervisorTypeId = exports.SupervisorTypeId = /*#__PURE__*/Symbol.for(SupervisorSymbolKey);
/** @internal */
const supervisorVariance = exports.supervisorVariance = {
  /* c8 ignore next */
  _T: _ => _
};
/** @internal */
class ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context, effect, parent, fiber) {
    this.underlying.onStart(context, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, (0, _Function.pipe)(this.value, core.map(f)));
  }
  zip(right) {
    return new Zip(this, right);
  }
}
/** @internal

## Zip

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor.js`

Signature: `Zip(= Zip;
const isZip = self => (0, _Predicate.hasProperty)`

JSDoc:

@internal

## isZip

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor.js`

Signature: `isZip(= isZip;
class Track {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /*#__PURE__*/new Set()`

JSDoc:

@internal

## Track

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor.js`

Signature: `Track(= Track;
class Const {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect)`

JSDoc:

@internal

## unsafeTrack

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor.js`

Signature: `unsafeTrack(= unsafeTrack;
const track = exports.track = /*#__PURE__*/core.sync(unsafeTrack)`

JSDoc:

@internal */
const unsafeTrack = () => {
  return new Track();
};
/** @internal

## fromEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/supervisor.js`

Signature: `fromEffect(= fromEffect;
const none = exports.none = /*#__PURE__*/(0, _GlobalValue.globalValue)`

JSDoc:

@internal */
const fromEffect = effect => {
  return new Const(effect);
};
/** @internal

## TakeImpl

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `TakeImpl(= TakeImpl;
const chunk = chunk => new TakeImpl(Exit.succeed(chunk)`

JSDoc:

@internal */
const TakeSymbolKey = "effect/Take";
/** @internal */
const TakeTypeId = exports.TakeTypeId = /*#__PURE__*/Symbol.for(TakeSymbolKey);
const takeVariance = {
  /* c8 ignore next */
  _A: _ => _,
  /* c8 ignore next */
  _E: _ => _
};
/** @internal */
class TakeImpl {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit) {
    this.exit = exit;
  }
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
}
/** @internal

## chunk

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `chunk(= chunk;
const die = defect => new TakeImpl(Exit.die(defect)`

JSDoc:

@internal

## die

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `die(= die;
const dieMessage = message => new TakeImpl(Exit.die(new Cause.RuntimeException(message)`

JSDoc:

@internal

## dieMessage

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `dieMessage(= dieMessage;
const done = self => Effect.suspend(()`

JSDoc:

@internal

## done

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `done(= done;
const end = exports.end = /*#__PURE__*/new TakeImpl(/*#__PURE__*/Exit.fail(/*#__PURE__*/Option.none()`

JSDoc:

@internal

## fail

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `fail(= fail;
const failCause = cause => new TakeImpl(Exit.failCause((0, _Function.pipe)`

JSDoc:

@internal */
const fail = error => new TakeImpl(Exit.fail(Option.some(error)));
/** @internal

## failCause

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `failCause(= failCause;
const fromEffect = effect => Effect.matchCause(effect, {
  onFailure: failCause,
  onSuccess: of
})`

JSDoc:

@internal

## fromEffect

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `fromEffect(= fromEffect;
const fromExit = exit => new TakeImpl((0, _Function.pipe)`

JSDoc:

@internal

## fromExit

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `fromExit(= fromExit;
const fromPull = pull => Effect.matchCause(pull, {
  onFailure: cause => Option.match(Cause.flipCauseOption(cause)`

JSDoc:

@internal

## fromPull

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `fromPull(= fromPull;
const isDone = self => Exit.match(self.exit, {
  onFailure: cause => Option.isNone(Cause.flipCauseOption(cause)`

JSDoc:

@internal

## isDone

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `isDone(= isDone;
const isFailure = self => Exit.match(self.exit, {
  onFailure: cause => Option.isSome(Cause.flipCauseOption(cause)`

JSDoc:

@internal

## isFailure

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `isFailure(= isFailure;
const isSuccess = self => Exit.match(self.exit, {
  onFailure: _Function.constFalse,
  onSuccess: _Function.constTrue
})`

JSDoc:

@internal

## isSuccess

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `isSuccess(= isSuccess;
const make = exit => new TakeImpl(exit)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `make(= make;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## of

Source: `my-backend/node_modules/effect/dist/cjs/internal/take.js`

Signature: `of(= of;
const tap = exports.tap = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const matchEffect = exports.matchEffect = /*#__PURE__*/(0, _Function.dual)(2, (self, {
  onEnd,
  onFailure,
  onSuccess
}) => Exit.matchEffect(self.exit, {
  onFailure: cause => Option.match(Cause.flipCauseOption(cause), {
    onNone: () => onEnd,
    onSome: onFailure
  }),
  onSuccess
}));
/** @internal */
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => new TakeImpl((0, _Function.pipe)(self.exit, Exit.map(Chunk.map(f)))));
/** @internal */
const of = value => new TakeImpl(Exit.succeed(Chunk.of(value)));
/** @internal

## pending

Source: `my-backend/node_modules/effect/dist/cjs/internal/testing/suspendedWarningData.js`

Signature: `pending(= pending;
const done = exports.done = {
  _tag: OP_SUSPENDED_WARNING_DATA_DONE
};
/** @internal */
const isStart = self => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_START;
};
/** @internal */
exports.isStart = isStart;
const isPending = self => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_PENDING;
};
/** @internal */
exports.isPending = isPending;
const isDone = self => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_DONE;
};
exports.isDone = isDone;
//# sourceMappingURL=suspendedWarningData.js.map)`

JSDoc:

@internal */
const OP_SUSPENDED_WARNING_DATA_START = exports.OP_SUSPENDED_WARNING_DATA_START = "Start";
/** @internal */
const OP_SUSPENDED_WARNING_DATA_PENDING = exports.OP_SUSPENDED_WARNING_DATA_PENDING = "Pending";
/** @internal */
const OP_SUSPENDED_WARNING_DATA_DONE = exports.OP_SUSPENDED_WARNING_DATA_DONE = "Done";
/**
State indicating that a test has not adjusted the clock.

@internal
/
const start = exports.start = {
  _tag: OP_SUSPENDED_WARNING_DATA_START
};
/**
State indicating that a test has adjusted the clock but a fiber is still
running with a reference to the fiber that will display the warning
message.

@internal
/
const pending = fiber => {
  return {
    _tag: OP_SUSPENDED_WARNING_DATA_PENDING,
    fiber
  };
};
/**
State indicating that the warning message has already been displayed.

@internal

## pending

Source: `my-backend/node_modules/effect/dist/cjs/internal/testing/warningData.js`

Signature: `pending(= pending;
const done = exports.done = {
  _tag: OP_WARNING_DATA_DONE
};
/** @internal */
const isStart = self => {
  return self._tag === OP_WARNING_DATA_START;
};
/** @internal */
exports.isStart = isStart;
const isPending = self => {
  return self._tag === OP_WARNING_DATA_PENDING;
};
/** @internal */
exports.isPending = isPending;
const isDone = self => {
  return self._tag === OP_WARNING_DATA_DONE;
};
exports.isDone = isDone;
//# sourceMappingURL=warningData.js.map)`

JSDoc:

@internal */
const OP_WARNING_DATA_START = exports.OP_WARNING_DATA_START = "Start";
/** @internal */
const OP_WARNING_DATA_PENDING = exports.OP_WARNING_DATA_PENDING = "Pending";
/** @internal */
const OP_WARNING_DATA_DONE = exports.OP_WARNING_DATA_DONE = "Done";
/**
State indicating that a test has not used time.

@internal
/
const start = exports.start = {
  _tag: OP_WARNING_DATA_START
};
/**
State indicating that a test has used time but has not adjusted the
`TestClock` with a reference to the fiber that will display the warning
message.

@internal
/
const pending = fiber => {
  return {
    _tag: OP_WARNING_DATA_PENDING,
    fiber
  };
};
/**
State indicating that a test has used time or the warning message has
already been displayed.

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/tracer.js`

Signature: `make(= make;
const tracerTag = exports.tracerTag = /*#__PURE__*/Context.GenericTag("effect/Tracer")`

JSDoc:

@since 2.0.0
/

/** @internal */
const TracerTypeId = exports.TracerTypeId = /*#__PURE__*/Symbol.for("effect/Tracer");
/** @internal */
const make = options => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
/** @internal

## NativeSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/tracer.js`

Signature: `NativeSpan(= NativeSpan;
const nativeTracer = exports.nativeTracer = /*#__PURE__*/make({
  span: (name, parent, context, links, startTime, kind)`

JSDoc:

@internal */
const spanTag = exports.spanTag = /*#__PURE__*/Context.GenericTag("effect/ParentSpan");
const randomHexString = /*#__PURE__*/function () {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function (length) {
    let result = "";
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
/** @internal */
class NativeSpan {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    // eslint-disable-next-line no-restricted-syntax
    this.links.push(...links);
  }
}
/** @internal

## externalSpan

Source: `my-backend/node_modules/effect/dist/cjs/internal/tracer.js`

Signature: `externalSpan(= externalSpan;
const addSpanStackTrace = options => {
  if (options?.captureStackTrace === false)`

JSDoc:

@internal */
const externalSpan = options => ({
  _tag: "ExternalSpan",
  spanId: options.spanId,
  traceId: options.traceId,
  sampled: options.sampled ?? true,
  context: options.context ?? Context.empty()
});
/** @internal

## addSpanStackTrace

Source: `my-backend/node_modules/effect/dist/cjs/internal/tracer.js`

Signature: `addSpanStackTrace(= addSpanStackTrace;
const DisablePropagation = exports.DisablePropagation = /*#__PURE__*/Context.Reference()`

JSDoc:

@internal

## isTrie

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `isTrie(= isTrie;
const empty = ()`

JSDoc:

@internal */
const TrieTypeId = exports.TrieTypeId = /*#__PURE__*/Symbol.for(TrieSymbolKey);
const trieVariance = {
  /* c8 ignore next */
  _Value: _ => _
};
const TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k, v) => [k, v], () => true);
  },
  [Hash.symbol]() {
    let hash = Hash.hash(TrieSymbolKey);
    for (const item of this) {
      hash ^= (0, _Function.pipe)(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])));
    }
    return Hash.cached(this, hash);
  },
  [Equal.symbol](that) {
    if (isTrie(that)) {
      const entries = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries[i];
        return Equal.equals(itemSelf[0], itemThat[0]) && Equal.equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return (0, _Inspectable.format)(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(_Inspectable.toJSON)
    };
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const makeImpl = root => {
  const trie = Object.create(TrieProto);
  trie._root = root;
  trie._count = root?.count ?? 0;
  return trie;
};
class TrieIterator {
  trie;
  f;
  filter;
  stack = [];
  constructor(trie, f, filter) {
    this.trie = trie;
    this.f = f;
    this.filter = filter;
    const root = trie._root !== undefined ? trie._root : undefined;
    if (root !== undefined) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value = node.value;
        if (value !== undefined) {
          const key = keyString + node.key;
          if (this.filter(key, value)) {
            return {
              done: false,
              value: this.f(key, value)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: undefined
    };
  }
  addToStack(node, keyString) {
    if (node.right !== undefined) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== undefined) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== undefined) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new TrieIterator(this.trie, this.f, this.filter);
  }
}
/** @internal */
const isTrie = u => (0, _Predicate.hasProperty)(u, TrieTypeId);
/** @internal

## empty

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `empty(= empty;
const fromIterable = entries => {
  let trie = empty()`

JSDoc:

@internal

## fromIterable

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `fromIterable(= fromIterable;
const make = (...entries)`

JSDoc:

@internal

## make

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `make(= make;
const insert = exports.insert = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## size

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `size(= size;
const isEmpty = self => size(self)`

JSDoc:

@internal */
const size = self => self._root?.count ?? 0;
/** @internal

## isEmpty

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `isEmpty(= isEmpty;
const keys = self => new TrieIterator(self, key => key, ()`

JSDoc:

@internal

## keys

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `keys(= keys;
const values = self => new TrieIterator(self, (_, value)`

JSDoc:

@internal

## values

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `values(= values;
const entries = self => new TrieIterator(self, (key, value)`

JSDoc:

@internal

## entries

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `entries(= entries;
const reduce = exports.reduce = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal

## compact

Source: `my-backend/node_modules/effect/dist/cjs/internal/trie.js`

Signature: `compact(= compact;
const forEach = exports.forEach = /*#__PURE__*/(0, _Function.dual)`

JSDoc:

@internal */
const map = exports.map = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduce(self, empty(), (trie, value, key) => insert(trie, key, f(value, key))));
/** @internal */
const filter = exports.filter = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduce(self, empty(), (trie, value, key) => f(value, key) ? insert(trie, key, value) : trie));
/** @internal */
const filterMap = exports.filterMap = /*#__PURE__*/(0, _Function.dual)(2, (self, f) => reduce(self, empty(), (trie, value, key) => {
  const option = f(value, key);
  return Option.isSome(option) ? insert(trie, key, option.value) : trie;
}));
/** @internal */
const compact = self => filterMap(self, _Function.identity);
/** @internal

## getRefinementExpected

Source: `my-backend/node_modules/effect/dist/esm/ParseResult.js`

Signature: `getRefinementExpected(ast)`

JSDoc:

@since 3.10.0
/
import * as Arr from "./Array.js";
import * as Cause from "./Cause.js";
import { TaggedError } from "./Data.js";
import * as Effect from "./Effect.js";
import * as Either from "./Either.js";
import * as Exit from "./Exit.js";
import { dual } from "./Function.js";
import { globalValue } from "./GlobalValue.js";
import * as Inspectable from "./Inspectable.js";
import * as util_ from "./internal/schema/util.js";
import * as Option from "./Option.js";
import * as Predicate from "./Predicate.js";
import * as Scheduler from "./Scheduler.js";
import * as AST from "./SchemaAST.js";
/**
@category model
@since 3.10.0
/
export class Pointer {
  path;
  actual;
  issue;
  /**
@since 3.10.0
/
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}
/**
Error that occurs when an unexpected key or index is present.

@category model
@since 3.10.0
/
export class Unexpected {
  actual;
  message;
  /**
@since 3.10.0
/
  _tag = "Unexpected";
  constructor(actual,
  /**
@since 3.10.0
/
  message) {
    this.actual = actual;
    this.message = message;
  }
}
/**
Error that occurs when a required key or index is missing.

@category model
@since 3.10.0
/
export class Missing {
  ast;
  message;
  /**
@since 3.10.0
/
  _tag = "Missing";
  /**
@since 3.10.0
/
  actual = undefined;
  constructor(
  /**
@since 3.10.0
/
  ast,
  /**
@since 3.10.0
/
  message) {
    this.ast = ast;
    this.message = message;
  }
}
/**
Error that contains multiple issues.

@category model
@since 3.10.0
/
export class Composite {
  ast;
  actual;
  issues;
  output;
  /**
@since 3.10.0
/
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}
/**
Error that occurs when a refinement has an error.

@category model
@since 3.10.0
/
export class Refinement {
  ast;
  actual;
  kind;
  issue;
  /**
@since 3.10.0
/
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}
/**
Error that occurs when a transformation has an error.

@category model
@since 3.10.0
/
export class Transformation {
  ast;
  actual;
  kind;
  issue;
  /**
@since 3.10.0
/
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}
/**
The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.

@category model
@since 3.10.0
/
export class Type {
  ast;
  actual;
  message;
  /**
@since 3.10.0
/
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
/**
The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).

@category model
@since 3.10.0
/
export class Forbidden {
  ast;
  actual;
  message;
  /**
@since 3.10.0
/
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
/**
@category type id
@since 3.10.0
/
export const ParseErrorTypeId = /*#__PURE__*/Symbol.for("effect/Schema/ParseErrorTypeId");
/**
@since 3.10.0
/
export const isParseError = u => Predicate.hasProperty(u, ParseErrorTypeId);
/**
@since 3.10.0
/
export class ParseError extends /*#__PURE__*/TaggedError("ParseError") {
  /**
@since 3.10.0
/
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  /**
@since 3.10.0
/
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
@since 3.10.0
/
  [Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  }
}
/**
@category constructors
@since 3.10.0
/
export const parseError = issue => new ParseError({
  issue
});
/**
@category constructors
@since 3.10.0
/
export const succeed = Either.right;
/**
@category constructors
@since 3.10.0
/
export const fail = Either.left;
const _try = Either.try;
export {
/**
@category constructors
@since 3.10.0
/
_try as try };
/**
@category constructors
@since 3.10.0
/
export const fromOption = Either.fromOption;
const isEither = Either.isEither;
/**
@category optimisation
@since 3.10.0
/
export const flatMap = /*#__PURE__*/dual(2, (self, f) => {
  return isEither(self) ? Either.match(self, {
    onLeft: Either.left,
    onRight: f
  }) : Effect.flatMap(self, f);
});
/**
@category optimisation
@since 3.10.0
/
export const map = /*#__PURE__*/dual(2, (self, f) => {
  return isEither(self) ? Either.map(self, f) : Effect.map(self, f);
});
/**
@category optimisation
@since 3.10.0
/
export const mapError = /*#__PURE__*/dual(2, (self, f) => {
  return isEither(self) ? Either.mapLeft(self, f) : Effect.mapError(self, f);
});
// TODO(4.0): remove
/**
@category optimisation
@since 3.10.0
/
export const eitherOrUndefined = self => {
  if (isEither(self)) {
    return self;
  }
};
/**
@category optimisation
@since 3.10.0
/
export const mapBoth = /*#__PURE__*/dual(2, (self, options) => {
  return isEither(self) ? Either.mapBoth(self, {
    onLeft: options.onFailure,
    onRight: options.onSuccess
  }) : Effect.mapBoth(self, options);
});
/**
@category optimisation
@since 3.10.0
/
export const orElse = /*#__PURE__*/dual(2, (self, f) => {
  return isEither(self) ? Either.match(self, {
    onLeft: f,
    onRight: Either.right
  }) : Effect.catchAll(self, f);
});
/** @internal */
export const mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === undefined || Predicate.isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
const getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
const getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => Either.getOrThrowWith(parser(input, overrideOptions), parseError);
};
/** @internal */
export const getOption = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => Option.getRight(parser(input, overrideOptions));
};
const getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
/**
@throws `ParseError`
@category decoding
@since 3.10.0
/
export const decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
/**
@category decoding
@since 3.10.0
/
export const decodeUnknownOption = (schema, options) => getOption(schema.ast, true, options);
/**
@category decoding
@since 3.10.0
/
export const decodeUnknownEither = (schema, options) => getEither(schema.ast, true, options);
/**
@category decoding
@since 3.10.0
/
export const decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
@category decoding
@since 3.10.0
/
export const decodeUnknown = (schema, options) => getEffect(schema.ast, true, options);
/**
@throws `ParseError`
@category encoding
@since 3.10.0
/
export const encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
/**
@category encoding
@since 3.10.0
/
export const encodeUnknownOption = (schema, options) => getOption(schema.ast, false, options);
/**
@category encoding
@since 3.10.0
/
export const encodeUnknownEither = (schema, options) => getEither(schema.ast, false, options);
/**
@category encoding
@since 3.10.0
/
export const encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
@category encoding
@since 3.10.0
/
export const encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
/**
@category decoding
@since 3.10.0
/
export const decodeSync = decodeUnknownSync;
/**
@category decoding
@since 3.10.0
/
export const decodeOption = decodeUnknownOption;
/**
@category decoding
@since 3.10.0
/
export const decodeEither = decodeUnknownEither;
/**
@category decoding
@since 3.10.0
/
export const decodePromise = decodeUnknownPromise;
/**
@category decoding
@since 3.10.0
/
export const decode = decodeUnknown;
/**
@throws `ParseError`
@category validation
@since 3.10.0
/
export const validateSync = (schema, options) => getSync(AST.typeAST(schema.ast), true, options);
/**
@category validation
@since 3.10.0
/
export const validateOption = (schema, options) => getOption(AST.typeAST(schema.ast), true, options);
/**
@category validation
@since 3.10.0
/
export const validateEither = (schema, options) => getEither(AST.typeAST(schema.ast), true, options);
/**
@category validation
@since 3.10.0
/
export const validatePromise = (schema, options) => {
  const parser = validate(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
@category validation
@since 3.10.0
/
export const validate = (schema, options) => getEffect(AST.typeAST(schema.ast), true, options);
/**
By default the option `exact` is set to `true`.

@category validation
@since 3.10.0
/
export const is = (schema, options) => {
  const parser = goMemo(AST.typeAST(schema.ast), true);
  return (u, overrideOptions) => Either.isRight(parser(u, {
    exact: true,
    ...mergeInternalOptions(options, overrideOptions)
  }));
};
/**
By default the option `exact` is set to `true`.

@throws `ParseError`
@category validation
@since 3.10.0
/
export const asserts = (schema, options) => {
  const parser = goMemo(AST.typeAST(schema.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions(options, overrideOptions)
    });
    if (Either.isLeft(result)) {
      throw parseError(result.left);
    }
  };
};
/**
@category encoding
@since 3.10.0
/
export const encodeSync = encodeUnknownSync;
/**
@category encoding
@since 3.10.0
/
export const encodeOption = encodeUnknownOption;
/**
@category encoding
@since 3.10.0
/
export const encodeEither = encodeUnknownEither;
/**
@category encoding
@since 3.10.0
/
export const encodePromise = encodeUnknownPromise;
/**
@category encoding
@since 3.10.0
/
export const encode = encodeUnknown;
const decodeMemoMap = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap());
const encodeMemoMap = /*#__PURE__*/globalValue(/*#__PURE__*/Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap());
const goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = AST.getParseOptionsAnnotation(ast);
  const parserWithOptions = Option.isSome(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = AST.getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && Option.isSome(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
const getConcurrency = ast => Option.getOrUndefined(AST.getConcurrencyAnnotation(ast));
const getBatching = ast => Option.getOrUndefined(AST.getBatchingAnnotation(ast));
const go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement":
      {
        if (isDecoding) {
          const from = goMemo(ast.from, true);
          return (i, options) => {
            options = options ?? AST.defaultParseOption;
            const allErrors = options?.errors === "all";
            const result = flatMap(orElse(from(i, options), ef => {
              const issue = new Refinement(ast, i, "From", ef);
              if (allErrors && AST.hasStableFilter(ast) && isComposite(ef)) {
                return Option.match(ast.filter(i, options, ast), {
                  onNone: () => Either.left(issue),
                  onSome: ep => Either.left(new Composite(ast, i, [issue, new Refinement(ast, i, "Predicate", ep)]))
                });
              }
              return Either.left(issue);
            }), a => Option.match(ast.filter(a, options, ast), {
              onNone: () => Either.right(a),
              onSome: ep => Either.left(new Refinement(ast, i, "Predicate", ep))
            }));
            return handleForbidden(result, ast, i, options);
          };
        } else {
          const from = goMemo(AST.typeAST(ast), true);
          const to = goMemo(dropRightRefinement(ast.from), false);
          return (i, options) => handleForbidden(flatMap(from(i, options), a => to(a, options)), ast, i, options);
        }
      }
    case "Transformation":
      {
        const transform = getFinalTransformation(ast.transformation, isDecoding);
        const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
        const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
        return (i, options) => handleForbidden(flatMap(mapError(from(i, options), e => new Transformation(ast, i, isDecoding ? "Encoded" : "Type", e)), a => flatMap(mapError(transform(a, options ?? AST.defaultParseOption, ast, i), e => new Transformation(ast, i, "Transformation", e)), i2 => mapError(to(i2, options), e => new Transformation(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
      }
    case "Declaration":
      {
        const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
        return (i, options) => handleForbidden(parse(i, options ?? AST.defaultParseOption, ast), ast, i, options);
      }
    case "Literal":
      return fromRefinement(ast, u => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, u => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, Predicate.isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, Predicate.isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return Either.right;
    case "StringKeyword":
      return fromRefinement(ast, Predicate.isString);
    case "NumberKeyword":
      return fromRefinement(ast, Predicate.isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, Predicate.isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, Predicate.isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, Predicate.isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, Predicate.isObject);
    case "Enums":
      return fromRefinement(ast, u => ast.enums.some(([_, value]) => value === u));
    case "TemplateLiteral":
      {
        const regex = AST.getTemplateLiteralRegExp(ast);
        return fromRefinement(ast, u => Predicate.isString(u) && regex.test(u));
      }
    case "TupleType":
      {
        const elements = ast.elements.map(e => goMemo(e.type, isDecoding));
        const rest = ast.rest.map(annotatedAST => goMemo(annotatedAST.type, isDecoding));
        let requiredTypes = ast.elements.filter(e => !e.isOptional);
        if (ast.rest.length > 0) {
          requiredTypes = requiredTypes.concat(ast.rest.slice(1));
        }
        const requiredLen = requiredTypes.length;
        const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options) => {
          if (!Arr.isArray(input)) {
            return Either.left(new Type(ast, input));
          }
          const allErrors = options?.errors === "all";
          const es = [];
          let stepKey = 0;
          const output = [];
          // ---------------------------------------------
          // handle missing indexes
          // ---------------------------------------------
          const len = input.length;
          for (let i = len; i <= requiredLen - 1; i++) {
            const e = new Pointer(i, input, new Missing(requiredTypes[i - len]));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return Either.left(new Composite(ast, input, e, output));
            }
          }
          // ---------------------------------------------
          // handle excess indexes
          // ---------------------------------------------
          if (ast.rest.length === 0) {
            for (let i = ast.elements.length; i <= len - 1; i++) {
              const e = new Pointer(i, input, new Unexpected(input[i], `is unexpected, expected: ${expectedIndexes}`));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return Either.left(new Composite(ast, input, e, output));
              }
            }
          }
          let i = 0;
          let queue = undefined;
          // ---------------------------------------------
          // handle elements
          // ---------------------------------------------
          for (; i < elements.length; i++) {
            if (len < i + 1) {
              if (ast.elements[i].isOptional) {
                // the input element is missing
                continue;
              }
            } else {
              const parser = elements[i];
              const te = parser(input[i], options);
              if (isEither(te)) {
                if (Either.isLeft(te)) {
                  // the input element is present but is not valid
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return Either.left(new Composite(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es,
                  output
                }) => Effect.flatMap(Effect.either(te), t => {
                  if (Either.isLeft(t)) {
                    // the input element is present but is not valid
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es.push([nk, e]);
                      return Effect.void;
                    } else {
                      return Either.left(new Composite(ast, input, e, sortByIndex(output)));
                    }
                  }
                  output.push([nk, t.right]);
                  return Effect.void;
                }));
              }
            }
          }
          // ---------------------------------------------
          // handle rest element
          // ---------------------------------------------
          if (Arr.isNonEmptyReadonlyArray(rest)) {
            const [head, ...tail] = rest;
            for (; i < len - tail.length; i++) {
              const te = head(input[i], options);
              if (isEither(te)) {
                if (Either.isLeft(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return Either.left(new Composite(ast, input, e, sortByIndex(output)));
                  }
                } else {
                  output.push([stepKey++, te.right]);
                }
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es,
                  output
                }) => Effect.flatMap(Effect.either(te), t => {
                  if (Either.isLeft(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es.push([nk, e]);
                      return Effect.void;
                    } else {
                      return Either.left(new Composite(ast, input, e, sortByIndex(output)));
                    }
                  } else {
                    output.push([nk, t.right]);
                    return Effect.void;
                  }
                }));
              }
            }
            // ---------------------------------------------
            // handle post rest elements
            // ---------------------------------------------
            for (let j = 0; j < tail.length; j++) {
              i += j;
              if (len < i + 1) {
                continue;
              } else {
                const te = tail[j](input[i], options);
                if (isEither(te)) {
                  if (Either.isLeft(te)) {
                    // the input element is present but is not valid
                    const e = new Pointer(i, input, te.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return Either.left(new Composite(ast, input, e, sortByIndex(output)));
                    }
                  }
                  output.push([stepKey++, te.right]);
                } else {
                  const nk = stepKey++;
                  const index = i;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es,
                    output
                  }) => Effect.flatMap(Effect.either(te), t => {
                    if (Either.isLeft(t)) {
                      // the input element is present but is not valid
                      const e = new Pointer(index, input, t.left);
                      if (allErrors) {
                        es.push([nk, e]);
                        return Effect.void;
                      } else {
                        return Either.left(new Composite(ast, input, e, sortByIndex(output)));
                      }
                    }
                    output.push([nk, t.right]);
                    return Effect.void;
                  }));
                }
              }
            }
          }
          // ---------------------------------------------
          // compute result
          // ---------------------------------------------
          const computeResult = ({
            es,
            output
          }) => Arr.isNonEmptyArray(es) ? Either.left(new Composite(ast, input, sortByIndex(es), sortByIndex(output))) : Either.right(sortByIndex(output));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return Effect.suspend(() => {
              const state = {
                es: Arr.copy(es),
                output: Arr.copy(output)
              };
              return Effect.flatMap(Effect.forEach(cqueue, f => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state));
            });
          }
          return computeResult({
            output,
            es
          });
        };
      }
    case "TypeLiteral":
      {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return fromRefinement(ast, Predicate.isNotNullable);
        }
        const propertySignatures = [];
        const expectedKeysMap = {};
        const expectedKeys = [];
        for (const ps of ast.propertySignatures) {
          propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
          expectedKeysMap[ps.name] = null;
          expectedKeys.push(ps.name);
        }
        const indexSignatures = ast.indexSignatures.map(is => [goMemo(is.parameter, isDecoding), goMemo(is.type, isDecoding), is.parameter]);
        const expectedAST = AST.Union.make(ast.indexSignatures.map(is => is.parameter).concat(expectedKeys.map(key => Predicate.isSymbol(key) ? new AST.UniqueSymbol(key) : new AST.Literal(key))));
        const expected = goMemo(expectedAST, isDecoding);
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options) => {
          if (!Predicate.isRecord(input)) {
            return Either.left(new Type(ast, input));
          }
          const allErrors = options?.errors === "all";
          const es = [];
          let stepKey = 0;
          // ---------------------------------------------
          // handle excess properties
          // ---------------------------------------------
          const onExcessPropertyError = options?.onExcessProperty === "error";
          const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
          const output = {};
          let inputKeys;
          if (onExcessPropertyError || onExcessPropertyPreserve) {
            inputKeys = util_.ownKeys(input);
            for (const key of inputKeys) {
              const te = expected(key, options);
              if (isEither(te) && Either.isLeft(te)) {
                // key is unexpected
                if (onExcessPropertyError) {
                  const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return Either.left(new Composite(ast, input, e, output));
                  }
                } else {
                  // preserve key
                  output[key] = input[key];
                }
              }
            }
          }
          let queue = undefined;
          const isExact = options?.exact === true;
          for (let i = 0; i < propertySignatures.length; i++) {
            const ps = propertySignatures[i][1];
            const name = ps.name;
            const hasKey = Object.prototype.hasOwnProperty.call(input, name);
            if (!hasKey) {
              if (ps.isOptional) {
                continue;
              } else if (isExact) {
                const e = new Pointer(name, input, new Missing(ps));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return Either.left(new Composite(ast, input, e, output));
                }
              }
            }
            const parser = propertySignatures[i][0];
            const te = parser(input[name], options);
            if (isEither(te)) {
              if (Either.isLeft(te)) {
                const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return Either.left(new Composite(ast, input, e, output));
                }
              }
              output[name] = te.right;
            } else {
              const nk = stepKey++;
              const index = name;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es,
                output
              }) => Effect.flatMap(Effect.either(te), t => {
                if (Either.isLeft(t)) {
                  const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                  if (allErrors) {
                    es.push([nk, e]);
                    return Effect.void;
                  } else {
                    return Either.left(new Composite(ast, input, e, output));
                  }
                }
                output[index] = t.right;
                return Effect.void;
              }));
            }
          }
          // ---------------------------------------------
          // handle index signatures
          // ---------------------------------------------
          for (let i = 0; i < indexSignatures.length; i++) {
            const indexSignature = indexSignatures[i];
            const parameter = indexSignature[0];
            const type = indexSignature[1];
            const keys = util_.getKeysForIndexSignature(input, indexSignature[2]);
            for (const key of keys) {
              // ---------------------------------------------
              // handle keys
              // ---------------------------------------------
              const keu = parameter(key, options);
              if (isEither(keu) && Either.isRight(keu)) {
                // ---------------------------------------------
                // handle values
                // ---------------------------------------------
                const vpr = type(input[key], options);
                if (isEither(vpr)) {
                  if (Either.isLeft(vpr)) {
                    const e = new Pointer(key, input, vpr.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return Either.left(new Composite(ast, input, e, output));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output[key] = vpr.right;
                    }
                  }
                } else {
                  const nk = stepKey++;
                  const index = key;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es,
                    output
                  }) => Effect.flatMap(Effect.either(vpr), tv => {
                    if (Either.isLeft(tv)) {
                      const e = new Pointer(index, input, tv.left);
                      if (allErrors) {
                        es.push([nk, e]);
                        return Effect.void;
                      } else {
                        return Either.left(new Composite(ast, input, e, output));
                      }
                    } else {
                      if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                        output[key] = tv.right;
                      }
                      return Effect.void;
                    }
                  }));
                }
              }
            }
          }
          // ---------------------------------------------
          // compute result
          // ---------------------------------------------
          const computeResult = ({
            es,
            output
          }) => {
            if (Arr.isNonEmptyArray(es)) {
              return Either.left(new Composite(ast, input, sortByIndex(es), output));
            }
            if (options?.propertyOrder === "original") {
              // preserve input keys order
              const keys = inputKeys || util_.ownKeys(input);
              for (const name of expectedKeys) {
                if (keys.indexOf(name) === -1) {
                  keys.push(name);
                }
              }
              const out = {};
              for (const key of keys) {
                if (Object.prototype.hasOwnProperty.call(output, key)) {
                  out[key] = output[key];
                }
              }
              return Either.right(out);
            }
            return Either.right(output);
          };
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return Effect.suspend(() => {
              const state = {
                es: Arr.copy(es),
                output: Object.assign({}, output)
              };
              return Effect.flatMap(Effect.forEach(cqueue, f => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state));
            });
          }
          return computeResult({
            es,
            output
          });
        };
      }
    case "Union":
      {
        const searchTree = getSearchTree(ast.types, isDecoding);
        const ownKeys = util_.ownKeys(searchTree.keys);
        const ownKeysLen = ownKeys.length;
        const astTypesLen = ast.types.length;
        const map = new Map();
        for (let i = 0; i < astTypesLen; i++) {
          map.set(ast.types[i], goMemo(ast.types[i], isDecoding));
        }
        const concurrency = getConcurrency(ast) ?? 1;
        const batching = getBatching(ast);
        return (input, options) => {
          const es = [];
          let stepKey = 0;
          let candidates = [];
          if (ownKeysLen > 0) {
            if (Predicate.isRecordOrArray(input)) {
              for (let i = 0; i < ownKeysLen; i++) {
                const name = ownKeys[i];
                const buckets = searchTree.keys[name].buckets;
                // for each property that should contain a literal, check if the input contains that property
                if (Object.prototype.hasOwnProperty.call(input, name)) {
                  const literal = String(input[name]);
                  // check that the value obtained from the input for the property corresponds to an existing bucket
                  if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                    // retrive the minimal set of candidates for decoding
                    candidates = candidates.concat(buckets[literal]);
                  } else {
                    const {
                      candidates,
                      literals
                    } = searchTree.keys[name];
                    const literalsUnion = AST.Union.make(literals);
                    const errorAst = candidates.length === astTypesLen ? new AST.TypeLiteral([new AST.PropertySignature(name, literalsUnion, false, true)], []) : AST.Union.make(candidates);
                    es.push([stepKey++, new Composite(errorAst, input, new Pointer(name, input, new Type(literalsUnion, input[name])))]);
                  }
                } else {
                  const {
                    candidates,
                    literals
                  } = searchTree.keys[name];
                  const fakePropertySignature = new AST.PropertySignature(name, AST.Union.make(literals), false, true);
                  const errorAst = candidates.length === astTypesLen ? new AST.TypeLiteral([fakePropertySignature], []) : AST.Union.make(candidates);
                  es.push([stepKey++, new Composite(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
                }
              }
            } else {
              const errorAst = searchTree.candidates.length === astTypesLen ? ast : AST.Union.make(searchTree.candidates);
              es.push([stepKey++, new Type(errorAst, input)]);
            }
          }
          if (searchTree.otherwise.length > 0) {
            candidates = candidates.concat(searchTree.otherwise);
          }
          let queue = undefined;
          for (let i = 0; i < candidates.length; i++) {
            const candidate = candidates[i];
            const pr = map.get(candidate)(input, options);
            // the members of a union are ordered based on which one should be decoded first,
            // therefore if one member has added a task, all subsequent members must
            // also add a task to the queue even if they are synchronous
            if (isEither(pr) && (!queue || queue.length === 0)) {
              if (Either.isRight(pr)) {
                return pr;
              } else {
                es.push([stepKey++, pr.left]);
              }
            } else {
              const nk = stepKey++;
              if (!queue) {
                queue = [];
              }
              queue.push(state => Effect.suspend(() => {
                if ("finalResult" in state) {
                  return Effect.void;
                } else {
                  return Effect.flatMap(Effect.either(pr), t => {
                    if (Either.isRight(t)) {
                      state.finalResult = t;
                    } else {
                      state.es.push([nk, t.left]);
                    }
                    return Effect.void;
                  });
                }
              }));
            }
          }
          // ---------------------------------------------
          // compute result
          // ---------------------------------------------
          const computeResult = es => Arr.isNonEmptyArray(es) ? es.length === 1 && es[0][1]._tag === "Type" ? Either.left(es[0][1]) : Either.left(new Composite(ast, input, sortByIndex(es))) :
          // this should never happen
          Either.left(new Type(ast, input));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return Effect.suspend(() => {
              const state = {
                es: Arr.copy(es)
              };
              return Effect.flatMap(Effect.forEach(cqueue, f => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => {
                if ("finalResult" in state) {
                  return state.finalResult;
                }
                return computeResult(state.es);
              });
            });
          }
          return computeResult(es);
        };
      }
    case "Suspend":
      {
        const get = util_.memoizeThunk(() => goMemo(AST.annotations(ast.f(), ast.annotations), isDecoding));
        return (a, options) => get()(a, options);
      }
  }
};
const fromRefinement = (ast, refinement) => u => refinement(u) ? Either.right(u) : Either.left(new Type(ast, u));
/** @internal */
export const getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration":
      {
        const annotation = AST.getSurrogateAnnotation(ast);
        if (Option.isSome(annotation)) {
          return getLiterals(annotation.value, isDecoding);
        }
        break;
      }
    case "TypeLiteral":
      {
        const out = [];
        for (let i = 0; i < ast.propertySignatures.length; i++) {
          const propertySignature = ast.propertySignatures[i];
          const type = isDecoding ? AST.encodedAST(propertySignature.type) : AST.typeAST(propertySignature.type);
          if (AST.isLiteral(type) && !propertySignature.isOptional) {
            out.push([propertySignature.name, type]);
          }
        }
        return out;
      }
    case "TupleType":
      {
        const out = [];
        for (let i = 0; i < ast.elements.length; i++) {
          const element = ast.elements[i];
          const type = isDecoding ? AST.encodedAST(element.type) : AST.typeAST(element.type);
          if (AST.isLiteral(type) && !element.isOptional) {
            out.push([i, type]);
          }
        }
        return out;
      }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
/**
The purpose of the algorithm is to narrow down the pool of possible
candidates for decoding as much as possible.

This function separates the schemas into two groups, `keys` and `otherwise`:

- `keys`: the schema has at least one property with a literal value
- `otherwise`: the schema has no properties with a literal value

If a schema has at least one property with a literal value, so it ends up in
`keys`, first a namespace is created for the name of the property containing
the literal, and then within this namespace a "bucket" is created for the
literal value in which to store all the schemas that have the same property
and literal value.

@internal
/
export const getSearchTree = (members, isDecoding) => {
  const keys = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      candidates.push(member);
      for (let j = 0; j < tags.length; j++) {
        const [key, literal] = tags[j];
        const hash = String(literal.literal);
        keys[key] = keys[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash].push(member);
          keys[key].literals.push(literal);
          keys[key].candidates.push(member);
        } else {
          buckets[hash] = [member];
          keys[key].literals.push(literal);
          keys[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys,
    otherwise,
    candidates
  };
};
const dropRightRefinement = ast => AST.isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
const handleForbidden = (effect, ast, actual, options) => {
  // If effects are allowed, return the original effect
  if (options?.isEffectAllowed === true) {
    return effect;
  }
  // If the effect is already an Either, return it directly
  if (isEither(effect)) {
    return effect;
  }
  // Otherwise, attempt to execute the effect synchronously
  const scheduler = new Scheduler.SyncScheduler();
  const fiber = Effect.runFork(effect, {
    scheduler
  });
  scheduler.flush();
  const exit = fiber.unsafePoll();
  if (exit) {
    if (Exit.isSuccess(exit)) {
      // If the effect successfully resolves, wrap the value in a Right
      return Either.right(exit.value);
    }
    const cause = exit.cause;
    if (Cause.isFailType(cause)) {
      // The effect executed synchronously but failed due to a ParseIssue
      return Either.left(cause.error);
    }
    // The effect executed synchronously but failed due to a defect (e.g., a missing dependency)
    return Either.left(new Forbidden(ast, actual, Cause.pretty(cause)));
  }
  // The effect could not be resolved synchronously, meaning it performs async work
  return Either.left(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
const compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map(t => t[1]);
}
// -------------------------------------------------------------------------------------
// transformations interpreter
// -------------------------------------------------------------------------------------
/** @internal */
export const getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return Either.right;
    case "TypeLiteralTransformation":
      return input => {
        let out = Either.right(input);
        // ---------------------------------------------
        // handle property signature transformations
        // ---------------------------------------------
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation = isDecoding ? pst.decode : pst.encode;
          const f = input => {
            const o = transformation(Object.prototype.hasOwnProperty.call(input, from) ? Option.some(input[from]) : Option.none());
            delete input[from];
            if (Option.isSome(o)) {
              input[to] = o.value;
            }
            return input;
          };
          out = map(out, f);
        }
        return out;
      };
  }
};
const makeTree = (value, forest = []) => ({
  value,
  forest
});
/**
@category formatting
@since 3.10.0
/
export const TreeFormatter = {
  formatIssue: issue => map(formatTree(issue), drawTree),
  formatIssueSync: issue => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither(e) ? Either.getOrThrow(e) : Effect.runSync(e);
  },
  formatError: error => TreeFormatter.formatIssue(error.issue),
  formatErrorSync: error => TreeFormatter.formatIssueSync(error.issue)
};
const drawTree = tree => tree.value + draw("\n", tree.forest);
const draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "" : "") + " " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest);
  }
  return r;
};
const formatTransformationKind = kind => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
const formatRefinementKind = kind => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
const getAnnotated = issue => "ast" in issue ? Option.some(issue.ast) : Option.none();
// TODO: replace with Either.void when 3.13 lands
const Either_void = /*#__PURE__*/Either.right(undefined);
const getCurrentMessage = issue => getAnnotated(issue).pipe(Option.flatMap(AST.getMessageAnnotation), Option.match({
  onNone: () => Either_void,
  onSome: messageAnnotation => {
    const union = messageAnnotation(issue);
    if (Predicate.isString(union)) {
      return Either.right({
        message: union,
        override: false
      });
    }
    if (Effect.isEffect(union)) {
      return Effect.map(union, message => ({
        message,
        override: false
      }));
    }
    if (Predicate.isString(union.message)) {
      return Either.right({
        message: union.message,
        override: union.override
      });
    }
    return Effect.map(union.message, message => ({
      message,
      override: union.override
    }));
  }
}));
const createParseIssueGuard = tag => issue => issue._tag === tag;
/**
Returns `true` if the value is a `Composite`.

@category guards
@since 3.10.0
/
export const isComposite = /*#__PURE__*/createParseIssueGuard("Composite");
const isRefinement = /*#__PURE__*/createParseIssueGuard("Refinement");
const isTransformation = /*#__PURE__*/createParseIssueGuard("Transformation");
const getMessage = issue => flatMap(getCurrentMessage(issue), currentMessage => {
  if (currentMessage !== undefined) {
    const useInnerMessage = !currentMessage.override && (isComposite(issue) || isRefinement(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : Either_void : Either.right(currentMessage.message);
  }
  return Either_void;
});
const getParseIssueTitleAnnotation = issue => getAnnotated(issue).pipe(Option.flatMap(AST.getParseIssueTitleAnnotation), Option.flatMapNullable(annotation => annotation(issue)), Option.getOrUndefined);
/** @internal

## make

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `make(ast)`

JSDoc:

@since 3.10.0
/
import * as array_ from "./Array.js";
import * as bigDecimal_ from "./BigDecimal.js";
import * as bigInt_ from "./BigInt.js";
import * as boolean_ from "./Boolean.js";
import * as cause_ from "./Cause.js";
import * as chunk_ from "./Chunk.js";
import * as config_ from "./Config.js";
import * as configError_ from "./ConfigError.js";
import * as data_ from "./Data.js";
import * as dateTime from "./DateTime.js";
import * as duration_ from "./Duration.js";
import * as Effect from "./Effect.js";
import * as either_ from "./Either.js";
import * as Encoding from "./Encoding.js";
import * as Equal from "./Equal.js";
import * as Equivalence from "./Equivalence.js";
import * as exit_ from "./Exit.js";
import * as fastCheck_ from "./FastCheck.js";
import * as fiberId_ from "./FiberId.js";
import { dual, identity } from "./Function.js";
import { globalValue } from "./GlobalValue.js";
import * as hashMap_ from "./HashMap.js";
import * as hashSet_ from "./HashSet.js";
import * as internalCause_ from "./internal/cause.js";
import * as errors_ from "./internal/schema/errors.js";
import * as schemaId_ from "./internal/schema/schemaId.js";
import * as util_ from "./internal/schema/util.js";
import * as list_ from "./List.js";
import * as number_ from "./Number.js";
import * as option_ from "./Option.js";
import * as ParseResult from "./ParseResult.js";
import { pipeArguments } from "./Pipeable.js";
import * as Predicate from "./Predicate.js";
import * as redacted_ from "./Redacted.js";
import * as Request from "./Request.js";
import * as scheduler_ from "./Scheduler.js";
import * as AST from "./SchemaAST.js";
import * as sortedSet_ from "./SortedSet.js";
import * as string_ from "./String.js";
import * as struct_ from "./Struct.js";
/**
@since 3.10.0
@category symbol
/
export const TypeId = /*#__PURE__*/Symbol.for("effect/Schema");
/**
@category constructors
@since 3.10.0

## asSchema

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `asSchema(schema)`

JSDoc:

Returns a "Standard Schema" object conforming to the [Standard Schema
v1](https://standardschema.dev/) specification.

This function creates a schema whose `validate` method attempts to decode and
validate the provided input synchronously. If the underlying `Schema`
includes any asynchronous components (e.g., asynchronous message resolutions
or checks), then validation will necessarily return a `Promise` instead.

Any detected defects will be reported via a single issue containing no
`path`.

@example
```ts
import { Schema } from "effect"

const schema = Schema.Struct({
  name: Schema.String
})

//       StandardSchemaV1<{ readonly name: string; }>
//      
const standardSchema = Schema.standardSchemaV1(schema)
```

@category Standard Schema
@since 3.13.0
/
export const standardSchemaV1 = (schema, overrideOptions) => {
  const decodeUnknown = ParseResult.decodeUnknown(schema, {
    errors: "all"
  });
  return class StandardSchemaV1Class extends make(schema.ast) {
    static "~standard" = {
      version: 1,
      vendor: "effect",
      validate(value) {
        const scheduler = new scheduler_.SyncScheduler();
        const fiber = Effect.runFork(Effect.matchEffect(decodeUnknown(value, overrideOptions), {
          onFailure: makeStandardFailureFromParseIssue,
          onSuccess: value => Effect.succeed({
            value
          })
        }), {
          scheduler
        });
        scheduler.flush();
        const exit = fiber.unsafePoll();
        if (exit) {
          return makeStandardResult(exit);
        }
        return new Promise(resolve => {
          fiber.addObserver(exit => {
            resolve(makeStandardResult(exit));
          });
        });
      }
    };
  };
};
const builtInAnnotations = {
  schemaId: AST.SchemaIdAnnotationId,
  message: AST.MessageAnnotationId,
  missingMessage: AST.MissingMessageAnnotationId,
  identifier: AST.IdentifierAnnotationId,
  title: AST.TitleAnnotationId,
  description: AST.DescriptionAnnotationId,
  examples: AST.ExamplesAnnotationId,
  default: AST.DefaultAnnotationId,
  documentation: AST.DocumentationAnnotationId,
  jsonSchema: AST.JSONSchemaAnnotationId,
  arbitrary: AST.ArbitraryAnnotationId,
  pretty: AST.PrettyAnnotationId,
  equivalence: AST.EquivalenceAnnotationId,
  concurrency: AST.ConcurrencyAnnotationId,
  batching: AST.BatchingAnnotationId,
  parseIssueTitle: AST.ParseIssueTitleAnnotationId,
  parseOptions: AST.ParseOptionsAnnotationId,
  decodingFallback: AST.DecodingFallbackAnnotationId
};
const toASTAnnotations = annotations => {
  if (!annotations) {
    return {};
  }
  const out = {
    ...annotations
  };
  for (const key in builtInAnnotations) {
    if (key in annotations) {
      const id = builtInAnnotations[key];
      out[id] = annotations[key];
      delete out[key];
    }
  }
  return out;
};
const mergeSchemaAnnotations = (ast, annotations) => AST.annotations(ast, toASTAnnotations(annotations));
/**
@since 3.10.0

## ArrayEnsure

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `ArrayEnsure(value)`

JSDoc:

@category formatting
@since 3.10.0
/
export const format = schema => String(schema.ast);
/**
The `encodedSchema` function allows you to extract the `Encoded` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without retaining any refinements or transformations that
were applied previously.

@since 3.10.0
/
export const encodedSchema = schema => make(AST.encodedAST(schema.ast));
/**
The `encodedBoundSchema` function is similar to `encodedSchema` but preserves
the refinements up to the first transformation point in the original schema.

@since 3.10.0
/
export const encodedBoundSchema = schema => make(AST.encodedBoundAST(schema.ast));
/**
The `typeSchema` function allows you to extract the `Type` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without considering the initial encoding or transformation
processes.

@since 3.10.0
/
export const typeSchema = schema => make(AST.typeAST(schema.ast));
/* c8 ignore start */
export {
/**
By default the option `exact` is set to `true`.

@throws `ParseError`
@category validation
@since 3.10.0
/
asserts,
/**
@category decoding
@since 3.10.0
/
decodeOption,
/**
@throws `ParseError`
@category decoding
@since 3.10.0
/
decodeSync,
/**
@category decoding
@since 3.10.0
/
decodeUnknownOption,
/**
@throws `ParseError`
@category decoding
@since 3.10.0
/
decodeUnknownSync,
/**
@category encoding
@since 3.10.0
/
encodeOption,
/**
@throws `ParseError`
@category encoding
@since 3.10.0
/
encodeSync,
/**
@category encoding
@since 3.10.0
/
encodeUnknownOption,
/**
@throws `ParseError`
@category encoding
@since 3.10.0
/
encodeUnknownSync,
/**
By default the option `exact` is set to `true`.

@category validation
@since 3.10.0
/
is,
/**
@category validation
@since 3.10.0
/
validateOption,
/**
@throws `ParseError`
@category validation
@since 3.10.0
/
validateSync } from "./ParseResult.js";
/* c8 ignore end */
/**
@category encoding
@since 3.10.0
/
export const encodeUnknown = (schema, options) => {
  const encodeUnknown = ParseResult.encodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
@category encoding
@since 3.10.0
/
export const encodeUnknownEither = (schema, options) => {
  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError);
};
/**
@category encoding
@since 3.10.0
/
export const encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
@category encoding
@since 3.10.0
/
export const encode = encodeUnknown;
/**
@category encoding
@since 3.10.0
/
export const encodeEither = encodeUnknownEither;
/**
@category encoding
@since 3.10.0
/
export const encodePromise = encodeUnknownPromise;
/**
@category decoding
@since 3.10.0
/
export const decodeUnknown = (schema, options) => {
  const decodeUnknown = ParseResult.decodeUnknown(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError);
};
/**
@category decoding
@since 3.10.0
/
export const decodeUnknownEither = (schema, options) => {
  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError);
};
/**
@category decoding
@since 3.10.0
/
export const decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
@category decoding
@since 3.10.0
/
export const decode = decodeUnknown;
/**
@category decoding
@since 3.10.0
/
export const decodeEither = decodeUnknownEither;
/**
@category decoding
@since 3.10.0
/
export const decodePromise = decodeUnknownPromise;
/**
@category validation
@since 3.10.0
/
export const validate = (schema, options) => {
  const validate = ParseResult.validate(schema, options);
  return (u, overrideOptions) => ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError);
};
/**
@category validation
@since 3.10.0
/
export const validateEither = (schema, options) => {
  const validateEither = ParseResult.validateEither(schema, options);
  return (u, overrideOptions) => either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError);
};
/**
@category validation
@since 3.10.0
/
export const validatePromise = (schema, options) => {
  const parser = validate(schema, options);
  return (u, overrideOptions) => Effect.runPromise(parser(u, overrideOptions));
};
/**
Tests if a value is a `Schema`.

@category guards
@since 3.10.0
/
export const isSchema = u => Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId]);
function getDefaultLiteralAST(literals) {
  return AST.isMembers(literals) ? AST.Union.make(AST.mapMembers(literals, literal => new AST.Literal(literal))) : new AST.Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make(ast) {
    static annotations(annotations) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations));
    }
    static literals = [...literals];
  };
}
export function Literal(...literals) {
  return array_.isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
/**
Creates a new `Schema` from a literal schema.

@example
```ts
import * as assert from "node:assert"
import { Either, Schema } from "effect"

const schema = Schema.Literal("a", "b", "c").pipe(Schema.pickLiteral("a", "b"))

assert.deepStrictEqual(Schema.decodeSync(schema)("a"), "a")
assert.deepStrictEqual(Schema.decodeSync(schema)("b"), "b")
assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)("c")), true)
```

@category constructors
@since 3.10.0
/
export const pickLiteral = (...literals) => _schema => Literal(...literals);
/**
@category constructors
@since 3.10.0
/
export const UniqueSymbolFromSelf = symbol => make(new AST.UniqueSymbol(symbol));
const getDefaultEnumsAST = enums => new AST.Enums(Object.keys(enums).filter(key => typeof enums[enums[key]] !== "number").map(key => [key, enums[key]]));
const makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) => class EnumsClass extends make(ast) {
  static annotations(annotations) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations));
  }
  static enums = {
    ...enums
  };
};
/**
@category constructors
@since 3.10.0
/
export const Enums = enums => makeEnumsClass(enums);
/**
@category template literal
@since 3.10.0
/
export const TemplateLiteral = (...[head, ...tail]) => {
  const spans = [];
  let h = "";
  let ts = tail;
  if (isSchema(head)) {
    if (AST.isLiteral(head.ast)) {
      h = String(head.ast.literal);
    } else {
      ts = [head, ...ts];
    }
  } else {
    h = String(head);
  }
  for (let i = 0; i < ts.length; i++) {
    const item = ts[i];
    if (isSchema(item)) {
      if (i < ts.length - 1) {
        const next = ts[i + 1];
        if (isSchema(next)) {
          if (AST.isLiteral(next.ast)) {
            spans.push(new AST.TemplateLiteralSpan(item.ast, String(next.ast.literal)));
            i++;
            continue;
          }
        } else {
          spans.push(new AST.TemplateLiteralSpan(item.ast, String(next)));
          i++;
          continue;
        }
      }
      spans.push(new AST.TemplateLiteralSpan(item.ast, ""));
    } else {
      spans.push(new AST.TemplateLiteralSpan(new AST.Literal(item), ""));
    }
  }
  if (array_.isNonEmptyArray(spans)) {
    return make(new AST.TemplateLiteral(h, spans));
  } else {
    return make(new AST.TemplateLiteral("", [new AST.TemplateLiteralSpan(new AST.Literal(h), "")]));
  }
};
function getTemplateLiteralParserCoercedElement(encoded, schema) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal":
      {
        const literal = ast.literal;
        if (!Predicate.isString(literal)) {
          const s = String(literal);
          return transform(Literal(s), schema, {
            strict: true,
            decode: () => literal,
            encode: () => s
          });
        }
        break;
      }
    case "NumberKeyword":
      return compose(NumberFromString, schema);
    case "Union":
      {
        const members = [];
        let hasCoercions = false;
        for (const member of ast.types) {
          const schema = make(member);
          const encoded = encodedSchema(schema);
          const coerced = getTemplateLiteralParserCoercedElement(encoded, schema);
          if (coerced) {
            hasCoercions = true;
          }
          members.push(coerced ?? schema);
        }
        return hasCoercions ? compose(Union(...members), schema) : schema;
      }
  }
}
/**
@category template literal
@since 3.10.0
/
export const TemplateLiteralParser = (...params) => {
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    const schema = isSchema(param) ? param : Literal(param);
    schemas.push(schema);
    const encoded = encodedSchema(schema);
    encodedSchemas.push(encoded);
    const element = getTemplateLiteralParserCoercedElement(encoded, schema);
    if (element) {
      elements.push(element);
      coerced = true;
    } else {
      elements.push(schema);
    }
  }
  const from = TemplateLiteral(...encodedSchemas);
  const re = AST.getTemplateLiteralCapturingRegExp(from.ast);
  let to = Tuple(...elements);
  if (coerced) {
    to = to.annotations({
      [AST.AutoTitleAnnotationId]: format(Tuple(...schemas))
    });
  }
  return class TemplateLiteralParserClass extends transformOrFail(from, to, {
    strict: false,
    decode: (i, _, ast) => {
      const match = re.exec(i);
      return match ? ParseResult.succeed(match.slice(1, params.length + 1)) : ParseResult.fail(new ParseResult.Type(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
    },
    encode: tuple => ParseResult.succeed(tuple.join(""))
  }) {
    static params = params.slice();
  };
};
const declareConstructor = (typeParameters, options, annotations) => makeDeclareClass(typeParameters, new AST.Declaration(typeParameters.map(tp => tp.ast), (...typeParameters) => options.decode(...typeParameters.map(make)), (...typeParameters) => options.encode(...typeParameters.map(make)), toASTAnnotations(annotations)));
const declarePrimitive = (is, annotations) => {
  const decodeUnknown = () => (input, _, ast) => is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input));
  const encodeUnknown = decodeUnknown;
  return makeDeclareClass([], new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make(ast) {
    static annotations(annotations) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations));
    }
    static typeParameters = [...typeParameters];
  };
}
/**
The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.

@category constructors
@since 3.10.0
/
export const declare = function () {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations = arguments[2];
    return declareConstructor(typeParameters, options, annotations);
  }
  const is = arguments[0];
  const annotations = arguments[1];
  return declarePrimitive(is, annotations);
};
/**
@category schema id
@since 3.10.0
/
export const BrandSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Brand");
/**
@category constructors
@since 3.10.0
/
export const fromBrand = (constructor, annotations) => self => {
  const out = makeBrandClass(self, new AST.Refinement(self.ast, function predicate(a, _, ast) {
    const either = constructor.either(a);
    return either_.isLeft(either) ? option_.some(new ParseResult.Type(ast, a, either.left.map(v => v.message).join(", "))) : option_.none();
  }, toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations
  })));
  return out;
};
/**
@category schema id
@since 3.10.0
/
export const InstanceOfSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/InstanceOf");
/**
@category constructors
@since 3.10.0
/
export const instanceOf = (constructor, annotations) => declare(u => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations
});
/**
@category primitives
@since 3.10.0
/
export class Undefined extends /*#__PURE__*/make(AST.undefinedKeyword) {}
/**
@category primitives
@since 3.10.0
/
export class Void extends /*#__PURE__*/make(AST.voidKeyword) {}
/**
@category primitives
@since 3.10.0
/
export class Null extends /*#__PURE__*/make(AST.null) {}
/**
@category primitives
@since 3.10.0
/
export class Never extends /*#__PURE__*/make(AST.neverKeyword) {}
/**
@category primitives
@since 3.10.0
/
export class Unknown extends /*#__PURE__*/make(AST.unknownKeyword) {}
/**
@category primitives
@since 3.10.0
/
export class Any extends /*#__PURE__*/make(AST.anyKeyword) {}
/**
@category primitives
@since 3.10.0
/
export class BigIntFromSelf extends /*#__PURE__*/make(AST.bigIntKeyword) {}
/**
@category primitives
@since 3.10.0
/
export class SymbolFromSelf extends /*#__PURE__*/make(AST.symbolKeyword) {}
/** @ignore */
class String$ extends /*#__PURE__*/make(AST.stringKeyword) {}
/** @ignore */
class Number$ extends /*#__PURE__*/make(AST.numberKeyword) {}
/** @ignore */
class Boolean$ extends /*#__PURE__*/make(AST.booleanKeyword) {}
/** @ignore */
class Object$ extends /*#__PURE__*/make(AST.objectKeyword) {}
export {
/**
@category primitives
@since 3.10.0
/
Boolean$ as Boolean,
/**
@category primitives
@since 3.10.0
/
Number$ as Number,
/**
@category primitives
@since 3.10.0
/
Object$ as Object,
/**
@category primitives
@since 3.10.0
/
String$ as String };
const getDefaultUnionAST = members => AST.Union.make(members.map(m => m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make(ast) {
    static annotations(annotations) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations));
    }
    static members = [...members];
  };
}
export function Union(...members) {
  return AST.isMembers(members) ? makeUnionClass(members) : array_.isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
/**
@category combinators
@since 3.10.0
/
export const NullOr = self => Union(self, Null);
/**
@category combinators
@since 3.10.0
/
export const UndefinedOr = self => Union(self, Undefined);
/**
@category combinators
@since 3.10.0
/
export const NullishOr = self => Union(self, Null, Undefined);
/**
@category combinators
@since 3.10.0
/
export const keyof = self => make(AST.keyof(self.ast));
/**
@since 3.10.0
/
export const element = self => new ElementImpl(new AST.OptionalType(self.ast, false), self);
/**
@since 3.10.0
/
export const optionalElement = self => new ElementImpl(new AST.OptionalType(self.ast, true), self);
class ElementImpl {
  ast;
  from;
  [TypeId];
  _Token;
  constructor(ast, from) {
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations) {
    return new ElementImpl(new AST.OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
}
const getDefaultTupleTypeAST = (elements, rest) => new AST.TupleType(elements.map(el => isSchema(el) ? new AST.OptionalType(el.ast, false) : el.ast), rest.map(el => isSchema(el) ? new AST.Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class TupleTypeClass extends make(ast) {
    static annotations(annotations) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations));
    }
    static elements = [...elements];
    static rest = [...rest];
  };
}
export function Tuple(...args) {
  return Array.isArray(args[0]) ? makeTupleTypeClass(args[0], args.slice(1)) : makeTupleTypeClass(args, []);
}
function makeArrayClass(value, ast) {
  return class ArrayClass extends makeTupleTypeClass([], [value], ast) {
    static annotations(annotations) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations));
    }
    static value = value;
  };
}
const Array$ = value => makeArrayClass(value);
export {
/**
@category constructors
@since 3.10.0
/
Array$ as Array };
function makeNonEmptyArrayClass(value, ast) {
  return class NonEmptyArrayClass extends makeTupleTypeClass([value], [value], ast) {
    static annotations(annotations) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations));
    }
    static value = value;
  };
}
/**
@category constructors
@since 3.10.0
/
export const NonEmptyArray = value => makeNonEmptyArrayClass(value);
/**
@category constructors
@since 3.10.0

## NonEmptyArrayEnsure

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `NonEmptyArrayEnsure(value)`

JSDoc:

@category constructors
@since 3.10.0

## transformLiteral

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `transformLiteral(from, to)`

JSDoc:

@category PropertySignature
@since 3.10.0
/
export class PropertySignatureDeclaration extends AST.OptionalType {
  isReadonly;
  defaultValue;
  /**
@since 3.10.0
/
  _tag = "PropertySignatureDeclaration";
  constructor(type, isOptional, isReadonly, annotations, defaultValue) {
    super(type, isOptional, annotations);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
@since 3.10.0
/
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
}
/**
@category PropertySignature
@since 3.10.0
/
export class FromPropertySignature extends AST.OptionalType {
  isReadonly;
  fromKey;
  constructor(type, isOptional, isReadonly, annotations, fromKey) {
    super(type, isOptional, annotations);
    this.isReadonly = isReadonly;
    this.fromKey = fromKey;
  }
}
/**
@category PropertySignature
@since 3.10.0
/
export class ToPropertySignature extends AST.OptionalType {
  isReadonly;
  defaultValue;
  constructor(type, isOptional, isReadonly, annotations, defaultValue) {
    super(type, isOptional, annotations);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
}
const formatPropertyKey = p => {
  if (p === undefined) {
    return "never";
  }
  if (Predicate.isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
/**
@category PropertySignature
@since 3.10.0
/
export class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  /**
@since 3.10.0
/
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
  /**
@since 3.10.0
/
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
const mergeSignatureAnnotations = (ast, annotations) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations
        }, ast.defaultValue);
      }
    case "PropertySignatureTransformation":
      {
        return new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations
        }, ast.to.defaultValue), ast.decode, ast.encode);
      }
  }
};
/**
@since 3.10.0
@category symbol
/
export const PropertySignatureTypeId = /*#__PURE__*/Symbol.for("effect/PropertySignature");
/**
@since 3.10.0
@category guards
/
export const isPropertySignature = u => Predicate.hasProperty(u, PropertySignatureTypeId);
class PropertySignatureImpl {
  ast;
  [TypeId];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)));
  }
  toString() {
    return String(this.ast);
  }
}
/**
@category PropertySignature
@since 3.10.0
/
export const makePropertySignature = ast => new PropertySignatureImpl(ast);
class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)), this.from);
  }
}
/**
Lifts a `Schema` into a `PropertySignature`.

@category PropertySignature
@since 3.10.0
/
export const propertySignature = self => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, undefined), self);
/**
Enhances a property signature with a default constructor value.

@category PropertySignature
@since 3.10.0
/
export const withConstructorDefault = /*#__PURE__*/dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
const applyDefaultValue = (o, defaultValue) => option_.match(o, {
  onNone: () => option_.some(defaultValue()),
  onSome: value => option_.some(value === undefined ? defaultValue() : value)
});
const pruneUndefined = ast => AST.pruneUndefined(ast, pruneUndefined, ast => {
  const pruned = pruneUndefined(ast.to);
  if (pruned) {
    return new AST.Transformation(ast.from, pruned, ast.transformation);
  }
});
/**
Enhances a property signature with a default decoding value.

@category PropertySignature
@since 3.10.0
/
export const withDecodingDefault = /*#__PURE__*/dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        const to = AST.typeAST(ast.type);
        return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined(to) ?? to, false, true, {}, ast.defaultValue), o => applyDefaultValue(o, defaultValue), identity));
      }
    case "PropertySignatureTransformation":
      {
        const to = ast.to.type;
        return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(pruneUndefined(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), o => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
      }
  }
});
/**
Enhances a property signature with a default decoding value and a default constructor value.

@category PropertySignature
@since 3.10.0
/
export const withDefaults = /*#__PURE__*/dual(2, (self, defaults) => self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
/**
Enhances a property signature by specifying a different key for it in the Encoded type.

@category PropertySignature
@since 3.10.0
/
export const fromKey = /*#__PURE__*/dual(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      {
        return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
      }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
/**
Converts an optional property to a required one through a transformation `Option -> Type`.

- `decode`: `none` as argument means the value is missing in the input.
- `encode`: `none` as return value means the value will be missing in the output.

@category PropertySignature
@since 3.10.0
/
export const optionalToRequired = (from, to, options) => makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, false, true, {}, undefined), o => option_.some(options.decode(o)), option_.flatMap(options.encode)));
/**
Converts an optional property to a required one through a transformation `Type -> Option`.

- `decode`: `none` as return value means the value will be missing in the output.
- `encode`: `none` as argument means the value is missing in the input.

@category PropertySignature
@since 3.10.0
/
export const requiredToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, false, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), option_.flatMap(options.decode), o => option_.some(options.encode(o))));
/**
Converts an optional property to another optional property through a transformation `Option -> Option`.

- `decode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.
- `encode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.

@category PropertySignature
@since 3.10.0
/
export const optionalToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), options.decode, options.encode));
const optionalPropertySignatureAST = (self, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable = options?.nullable;
  const asOption = options?.as == "Option";
  const asOptionEncode = options?.onNoneEncoding ? option_.orElse(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable) {
        return withConstructorDefault(optionalToRequired(NullOr(self), typeSchema(self), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a === null ? defaultValue() : a
          }),
          encode: option_.some
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(self, typeSchema(self), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: option_.some
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(NullOr(self), OptionFromSelf(typeSchema(self)), {
          decode: option_.filter(Predicate.isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(self, OptionFromSelf(typeSchema(self)), {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable) {
        return optionalToOptional(NullOr(self), typeSchema(self), {
          decode: option_.filter(Predicate.isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(self.ast, true, true, {}, undefined);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable) {
        return withConstructorDefault(optionalToRequired(NullishOr(self), typeSchema(self), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a == null ? defaultValue() : a
          }),
          encode: option_.some
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(self), typeSchema(self), {
          decode: option_.match({
            onNone: defaultValue,
            onSome: a => a === undefined ? defaultValue() : a
          }),
          encode: option_.some
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(NullishOr(self), OptionFromSelf(typeSchema(self)), {
          decode: option_.filter(a => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(self), OptionFromSelf(typeSchema(self)), {
          decode: option_.filter(Predicate.isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable) {
        return optionalToOptional(NullishOr(self), UndefinedOr(typeSchema(self)), {
          decode: option_.filter(Predicate.isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, undefined);
      }
    }
  }
};
/**
@category PropertySignature
@since 3.10.0
/
export const optional = self => {
  const ast = self.ast === AST.undefinedKeyword || self.ast === AST.neverKeyword ? AST.undefinedKeyword : UndefinedOr(self).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self);
};
/**
@category PropertySignature
@since 3.10.0
/
export const optionalWith = /*#__PURE__*/dual(args => isSchema(args[0]), (self, options) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self);
});
const preserveMissingMessageAnnotation = /*#__PURE__*/AST.pickAnnotations([AST.MissingMessageAnnotationId]);
const getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys = util_.ownKeys(fields);
  const pss = [];
  if (ownKeys.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys.length; i++) {
      const key = ownKeys[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration":
            {
              const type = ast.type;
              const isOptional = ast.isOptional;
              const toAnnotations = ast.annotations;
              from.push(new AST.PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
              to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations));
              pss.push(new AST.PropertySignature(key, type, isOptional, true, toAnnotations));
              break;
            }
          case "PropertySignatureTransformation":
            {
              const fromKey = ast.from.fromKey ?? key;
              from.push(new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
              to.push(new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
              transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
              break;
            }
        }
      } else {
        from.push(new AST.PropertySignature(key, field.ast, false, true));
        to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true));
        pss.push(new AST.PropertySignature(key, field.ast, false, true));
      }
    }
    if (array_.isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = AST.record(r.key.ast, r.value.ast);
        propertySignatures.forEach(ps => {
          from.push(ps);
          to.push(new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach(is => {
          issFrom.push(is);
          issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly));
        });
      }
      return new AST.Transformation(new AST.TypeLiteral(from, issFrom, {
        [AST.AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new AST.TypeLiteral(to, issTo, {
        [AST.AutoTitleAnnotationId]: "Struct (Type side)"
      }), new AST.TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = AST.record(r.key.ast, r.value.ast);
    propertySignatures.forEach(ps => pss.push(ps));
    indexSignatures.forEach(is => iss.push(is));
  }
  return new AST.TypeLiteral(pss, iss);
};
const lazilyMergeDefaults = (fields, out) => {
  const ownKeys = util_.ownKeys(fields);
  for (const key of ownKeys) {
    const field = fields[key];
    if (out[key] === undefined && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== undefined) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make(ast) {
    static annotations(annotations) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options) ? propsWithDefaults : ParseResult.validateSync(this)(propsWithDefaults);
    };
    static pick(...keys) {
      return Struct(struct_.pick(fields, ...keys));
    }
    static omit(...keys) {
      return Struct(struct_.omit(fields, ...keys));
    }
  };
}
export function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
/**
Returns a property signature that represents a tag.
A tag is a literal value that is used to distinguish between different types of objects.
The tag is optional when using the `make` method.

@example
```ts
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.Struct({
  _tag: Schema.tag("User"),
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

@see {@link TaggedStruct}

@since 3.10.0
/
export const tag = tag => Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag));
/**
A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.

The tag is optional when using the `make` method.

@example
```ts
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.TaggedStruct("User", {
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

@category constructors
@since 3.10.0
/
export const TaggedStruct = (value, fields) => Struct({
  _tag: tag(value),
  ...fields
});
function makeRecordClass(key, value, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value
  }], ast) {
    static annotations(annotations) {
      return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations));
    }
    static key = key;
    static value = value;
  };
}
/**
@category constructors
@since 3.10.0
/
export const Record = options => makeRecordClass(options.key, options.value);
/**
@category struct transformations
@since 3.10.0
/
export const pick = (...keys) => self => make(AST.pick(self.ast, keys));
/**
@category struct transformations
@since 3.10.0
/
export const omit = (...keys) => self => make(AST.omit(self.ast, keys));
/**
Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

@example
```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

@category struct transformations
@since 3.10.0
/
export const pluck = /*#__PURE__*/dual(2, (schema, key) => {
  const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key);
  const value = make(ps.isOptional ? AST.orUndefined(ps.type) : ps.type);
  const out = transform(schema.pipe(pick(key)), value, {
    strict: true,
    decode: i => i[key],
    encode: a => ps.isOptional && a === undefined ? {} : {
      [key]: a
    }
  });
  return out;
});
function makeBrandClass(from, ast) {
  return class BrandClass extends make(ast) {
    static annotations(annotations) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations));
    }
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a);
    };
    static from = from;
  };
}
/**
Returns a nominal branded schema by applying a brand to a given schema.

```
Schema<A> + B -> Schema<A & Brand<B>>
```

@example
```ts
import * as Schema from "effect/Schema"

const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
```

@category branding
@since 3.10.0
/
export const brand = (brand, annotations) => self => {
  const annotation = option_.match(AST.getBrandAnnotation(self.ast), {
    onNone: () => [brand],
    onSome: brands => [...brands, brand]
  });
  const ast = AST.annotations(self.ast, toASTAnnotations({
    [AST.BrandAnnotationId]: annotation,
    ...annotations
  }));
  return makeBrandClass(self, ast);
};
/**
@category combinators
@since 3.10.0
/
export const partial = self => make(AST.partial(self.ast));
/**
@category combinators
@since 3.10.0
/
export const partialWith = /*#__PURE__*/dual(args => isSchema(args[0]), (self, options) => make(AST.partial(self.ast, options)));
/**
@category combinators
@since 3.10.0
/
export const required = self => make(AST.required(self.ast));
/**
Creates a new schema with shallow mutability applied to its properties.

@category combinators
@since 3.10.0
/
export const mutable = schema => make(AST.mutable(schema.ast));
const intersectTypeLiterals = (x, y, path) => {
  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex(ps => ps.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type
        } = propertySignatures[i];
        propertySignatures[i] = new AST.PropertySignature(name, extendAST(type, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new AST.TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path));
};
const preserveRefinementAnnotations = /*#__PURE__*/AST.omitAnnotations([AST.IdentifierAnnotationId]);
const addRefinementToMembers = (refinement, asts) => asts.map(ast => new AST.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
const extendAST = (x, y, path) => AST.Union.make(intersectUnionMembers([x], [y], path));
const getTypes = ast => AST.isUnion(ast) ? ast.types : [ast];
const intersectUnionMembers = (xs, ys, path) => array_.flatMap(xs, x => array_.flatMap(ys, y => {
  switch (y._tag) {
    case "Literal":
      {
        if (Predicate.isString(y.literal) && AST.isStringKeyword(x) || Predicate.isNumber(y.literal) && AST.isNumberKeyword(x) || Predicate.isBoolean(y.literal) && AST.isBooleanKeyword(x)) {
          return [y];
        }
        break;
      }
    case "StringKeyword":
      {
        if (y === AST.stringKeyword) {
          if (AST.isStringKeyword(x) || AST.isLiteral(x) && Predicate.isString(x.literal)) {
            return [x];
          } else if (AST.isRefinement(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === AST.stringKeyword) {
          return [y];
        }
        break;
      }
    case "NumberKeyword":
      {
        if (y === AST.numberKeyword) {
          if (AST.isNumberKeyword(x) || AST.isLiteral(x) && Predicate.isNumber(x.literal)) {
            return [x];
          } else if (AST.isRefinement(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === AST.numberKeyword) {
          return [y];
        }
        break;
      }
    case "BooleanKeyword":
      {
        if (y === AST.booleanKeyword) {
          if (AST.isBooleanKeyword(x) || AST.isLiteral(x) && Predicate.isBoolean(x.literal)) {
            return [x];
          } else if (AST.isRefinement(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === AST.booleanKeyword) {
          return [y];
        }
        break;
      }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path);
    case "Suspend":
      return [new AST.Suspend(() => extendAST(x, y.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
    case "TypeLiteral":
      {
        switch (x._tag) {
          case "Union":
            return intersectUnionMembers(x.types, [y], path);
          case "Suspend":
            return [new AST.Suspend(() => extendAST(x.f(), y, path))];
          case "Refinement":
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          case "TypeLiteral":
            return [intersectTypeLiterals(x, y, path)];
          case "Transformation":
            {
              const transformation = x.transformation;
              const from = intersectTypeLiterals(x.from, y, path);
              const to = intersectTypeLiterals(x.to, AST.typeAST(y), path);
              switch (transformation._tag) {
                case "TypeLiteralTransformation":
                  return [new AST.Transformation(from, to, new AST.TypeLiteralTransformation(transformation.propertySignatureTransformations))];
                case "ComposeTransformation":
                  return [new AST.Transformation(from, to, AST.composeTransformation)];
                case "FinalTransformation":
                  return [new AST.Transformation(from, to, new AST.FinalTransformation((fromA, options, ast, fromI) => ParseResult.map(transformation.decode(fromA, options, ast, fromI), partial => ({
                    ...fromA,
                    ...partial
                  })), (toI, options, ast, toA) => ParseResult.map(transformation.encode(toI, options, ast, toA), partial => ({
                    ...toI,
                    ...partial
                  }))))];
              }
            }
        }
        break;
      }
    case "Transformation":
      {
        if (AST.isTransformation(x)) {
          if (AST.isTypeLiteralTransformation(y.transformation) && AST.isTypeLiteralTransformation(x.transformation)) {
            return [new AST.Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new AST.TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
          }
        } else {
          return intersectUnionMembers([y], [x], path);
        }
        break;
      }
  }
  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path));
}));
/**
Extends a schema with another schema.

Not all extensions are supported, and their support depends on the nature of
the involved schemas.

Possible extensions include:
- `Schema.String` with another `Schema.String` refinement or a string literal
- `Schema.Number` with another `Schema.Number` refinement or a number literal
- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean
  literal
- A struct with another struct where overlapping fields support extension
- A struct with in index signature
- A struct with a union of supported schemas
- A refinement of a struct with a supported schema
- A suspend of a struct with a supported schema
- A transformation between structs where the from and to sides have no
  overlapping fields with the target struct

@example
```ts
import * as Schema from "effect/Schema"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

// const extended: Schema<
//   {
//     readonly a: string
//     readonly b: string
//   } & {
//     readonly c: string
//   } & {
//     readonly [x: string]: string
//   }
// >
const extended = Schema.asSchema(schema.pipe(
  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures
))
```

@category combinators
@since 3.10.0
/
export const extend = /*#__PURE__*/dual(2, (self, that) => make(extendAST(self.ast, that.ast, [])));
/**
@category combinators
@since 3.10.0
/
export const compose = /*#__PURE__*/dual(args => isSchema(args[1]), (from, to) => makeTransformationClass(from, to, AST.compose(from.ast, to.ast)));
/**
@category constructors
@since 3.10.0
/
export const suspend = f => make(new AST.Suspend(() => f().ast));
/**
@since 3.10.0
@category symbol
/
export const RefineSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter, ast) {
  return class RefineClass extends make(ast) {
    static annotations(annotations) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter;
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a);
    };
  };
}
const fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (Predicate.isBoolean(item)) {
    return item ? option_.none() : option_.some(new ParseResult.Type(ast, input));
  }
  if (Predicate.isString(item)) {
    return option_.some(new ParseResult.Type(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return option_.some(item);
    }
    const issue = new ParseResult.Type(ast, input, item.message);
    return option_.some(array_.isNonEmptyReadonlyArray(item.path) ? new ParseResult.Pointer(item.path, input, issue) : issue);
  }
  return option_.none();
};
const toFilterParseIssue = (out, ast, input) => {
  if (util_.isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (array_.isNonEmptyReadonlyArray(out)) {
    const issues = array_.filterMap(out, issue => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (array_.isNonEmptyReadonlyArray(issues)) {
      return option_.some(issues.length === 1 ? issues[0] : new ParseResult.Composite(ast, input, issues));
    }
  }
  return option_.none();
};
export function filter(predicate, annotations) {
  return self => {
    function filter(input, options, ast) {
      return toFilterParseIssue(predicate(input, options, ast), ast, input);
    }
    const ast = new AST.Refinement(self.ast, filter, toASTAnnotations(annotations));
    return makeRefineClass(self, filter, ast);
  };
}
/**
@category transformations
@since 3.10.0
/
export const filterEffect = /*#__PURE__*/dual(2, (self, f) => transformOrFail(self, typeSchema(self), {
  strict: true,
  decode: (i, options, ast) => ParseResult.flatMap(f(i, options, ast), filterReturnType => option_.match(toFilterParseIssue(filterReturnType, ast, i), {
    onNone: () => ParseResult.succeed(i),
    onSome: ParseResult.fail
  })),
  encode: a => ParseResult.succeed(a)
}));
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make(ast) {
    static annotations(annotations) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations));
    }
    static from = from;
    static to = to;
  };
}
/**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided decoding functions.

@category transformations
@since 3.10.0
/
export const transformOrFail = /*#__PURE__*/dual(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => makeTransformationClass(from, to, new AST.Transformation(from.ast, to.ast, new AST.FinalTransformation(options.decode, options.encode))));
/**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided mapping functions.

@category transformations
@since 3.10.0
/
export const transform = /*#__PURE__*/dual(args => isSchema(args[0]) && isSchema(args[1]), (from, to, options) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => ParseResult.succeed(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => ParseResult.succeed(options.encode(toI, toA))
}));
/**
Creates a new `Schema` which transforms literal values.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"

const schema = S.transformLiteral(0, "a")

assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
```

@category constructors
@since 3.10.0

## parseNumber

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `parseNumber(self)`

JSDoc:

Attaches a property signature with the specified key and value to the schema.
This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
but rather maps to another schema, for example when you want to add a discriminant to a simple union.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"
import { pipe } from "effect/Function"

const Circle = S.Struct({ radius: S.Number })
const Square = S.Struct({ sideLength: S.Number })
const Shape = S.Union(
  Circle.pipe(S.attachPropertySignature("kind", "circle")),
  Square.pipe(S.attachPropertySignature("kind", "square"))
)

assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
  kind: "circle",
  radius: 10
})
```

@category combinators
@since 3.10.0
/
export const attachPropertySignature = /*#__PURE__*/dual(args => isSchema(args[0]), (schema, key, value, annotations) => {
  const ast = extend(typeSchema(schema), Struct({
    [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value)
  })).ast;
  return make(new AST.Transformation(schema.ast, annotations ? mergeSchemaAnnotations(ast, annotations) : ast, new AST.TypeLiteralTransformation([new AST.PropertySignatureTransformation(key, key, () => option_.some(value), () => option_.none())])));
});
/**
Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

@category annotations
@since 3.10.0
/
export const annotations = /*#__PURE__*/dual(2, (self, annotations) => self.annotations(annotations));
/**
@category renaming
@since 3.10.0
/
export const rename = /*#__PURE__*/dual(2, (self, mapping) => make(AST.rename(self.ast, mapping)));
/**
@category schema id
@since 3.10.0
/
export const TrimmedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Trimmed");
/**
Verifies that a string contains no leading or trailing whitespaces.

Note. This combinator does not make any transformations, it only validates.
If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.

@category string filters
@since 3.10.0
/
export const trimmed = annotations => self => self.pipe(filter(a => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const MaxLengthSchemaId = schemaId_.MaxLengthSchemaId;
/**
@category string filters
@since 3.10.0
/
export const maxLength = (maxLength, annotations) => self => self.pipe(filter(a => a.length <= maxLength, {
  schemaId: MaxLengthSchemaId,
  title: `maxLength(${maxLength})`,
  description: `a string at most ${maxLength} character(s) long`,
  jsonSchema: {
    maxLength
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const MinLengthSchemaId = schemaId_.MinLengthSchemaId;
/**
@category string filters
@since 3.10.0
/
export const minLength = (minLength, annotations) => self => self.pipe(filter(a => a.length >= minLength, {
  schemaId: MinLengthSchemaId,
  title: `minLength(${minLength})`,
  description: `a string at least ${minLength} character(s) long`,
  jsonSchema: {
    minLength
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const LengthSchemaId = schemaId_.LengthSchemaId;
/**
@category string filters
@since 3.10.0
/
export const length = (length, annotations) => self => {
  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length));
  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength;
  if (minLength !== maxLength) {
    return self.pipe(filter(a => a.length >= minLength && a.length <= maxLength, {
      schemaId: LengthSchemaId,
      title: `length({ min: ${minLength}, max: ${maxLength})`,
      description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,
      jsonSchema: {
        minLength,
        maxLength
      },
      ...annotations
    }));
  }
  return self.pipe(filter(a => a.length === minLength, {
    schemaId: LengthSchemaId,
    title: `length(${minLength})`,
    description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,
    jsonSchema: {
      minLength,
      maxLength: minLength
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const PatternSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Pattern");
/**
@category string filters
@since 3.10.0
/
export const pattern = (regex, annotations) => self => {
  const source = regex.source;
  return self.pipe(filter(a => {
    // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const StartsWithSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/StartsWith");
/**
@category string filters
@since 3.10.0
/
export const startsWith = (startsWith, annotations) => self => {
  const formatted = JSON.stringify(startsWith);
  return self.pipe(filter(a => a.startsWith(startsWith), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith}`
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const EndsWithSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/EndsWith");
/**
@category string filters
@since 3.10.0
/
export const endsWith = (endsWith, annotations) => self => {
  const formatted = JSON.stringify(endsWith);
  return self.pipe(filter(a => a.endsWith(endsWith), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith}$`
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const IncludesSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Includes");
/**
@category string filters
@since 3.10.0
/
export const includes = (searchString, annotations) => self => {
  const formatted = JSON.stringify(searchString);
  return self.pipe(filter(a => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const LowercasedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Lowercased");
/**
Verifies that a string is lowercased.

@category string filters
@since 3.10.0
/
export const lowercased = annotations => self => self.pipe(filter(a => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations
}));
/**
@category string constructors
@since 3.10.0
/
export class Lowercased extends /*#__PURE__*/String$.pipe(/*#__PURE__*/lowercased({
  identifier: "Lowercased"
})) {}
/**
@category schema id
@since 3.10.0
/
export const UppercasedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Uppercased");
/**
Verifies that a string is uppercased.

@category string filters
@since 3.10.0
/
export const uppercased = annotations => self => self.pipe(filter(a => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations
}));
/**
@category string constructors
@since 3.10.0
/
export class Uppercased extends /*#__PURE__*/String$.pipe(/*#__PURE__*/uppercased({
  identifier: "Uppercased"
})) {}
/**
@category schema id
@since 3.10.0
/
export const CapitalizedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Capitalized");
/**
Verifies that a string is capitalized.

@category string filters
@since 3.10.0
/
export const capitalized = annotations => self => self.pipe(filter(a => a[0]?.toUpperCase() === a[0], {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations
}));
/**
@category string constructors
@since 3.10.0
/
export class Capitalized extends /*#__PURE__*/String$.pipe(/*#__PURE__*/capitalized({
  identifier: "Capitalized"
})) {}
/**
@category schema id
@since 3.10.0
/
export const UncapitalizedSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/Uncapitalized");
/**
Verifies that a string is uncapitalized.

@category string filters
@since 3.10.0
/
export const uncapitalized = annotations => self => self.pipe(filter(a => a[0]?.toLowerCase() === a[0], {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations
}));
/**
@category string constructors
@since 3.10.0
/
export class Uncapitalized extends /*#__PURE__*/String$.pipe(/*#__PURE__*/uncapitalized({
  identifier: "Uncapitalized"
})) {}
/**
A schema representing a single character.

@category string constructors
@since 3.10.0
/
export class Char extends /*#__PURE__*/String$.pipe(/*#__PURE__*/length(1, {
  identifier: "Char"
})) {}
/**
@category string filters
@since 3.10.0
/
export const nonEmptyString = annotations => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations
});
/**
This schema converts a string to lowercase.

@category string transformations
@since 3.10.0
/
export class Lowercase extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased, {
  strict: true,
  decode: i => i.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
}) {}
/**
This schema converts a string to uppercase.

@category string transformations
@since 3.10.0
/
export class Uppercase extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased, {
  strict: true,
  decode: i => i.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
}) {}
/**
This schema converts a string to capitalized one.

@category string transformations
@since 3.10.0
/
export class Capitalize extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized, {
  strict: true,
  decode: i => string_.capitalize(i),
  encode: identity
}).annotations({
  identifier: "Capitalize"
}) {}
/**
This schema converts a string to uncapitalized one.

@category string transformations
@since 3.10.0
/
export class Uncapitalize extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
  strict: true,
  decode: i => string_.uncapitalize(i),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
}) {}
/**
@category string constructors
@since 3.10.0
/
export class Trimmed extends /*#__PURE__*/String$.pipe(/*#__PURE__*/trimmed({
  identifier: "Trimmed"
})) {}
/**
Useful for validating strings that must contain meaningful characters without
leading or trailing whitespace.

@example
```ts
import { Schema } from "effect"

console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(" a ")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("a")) // Option.some("a")
```

@category string constructors
@since 3.10.0
/
export class NonEmptyTrimmedString extends /*#__PURE__*/Trimmed.pipe(/*#__PURE__*/nonEmptyString({
  identifier: "NonEmptyTrimmedString"
})) {}
/**
This schema allows removing whitespaces from the beginning and end of a string.

@category string transformations
@since 3.10.0
/
export class Trim extends /*#__PURE__*/transform(String$.annotations({
  description: "a string that will be trimmed"
}), Trimmed, {
  strict: true,
  decode: i => i.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
}) {}
/**
Returns a schema that allows splitting a string into an array of strings.

@category string transformations
@since 3.10.0
/
export const split = separator => transform(String$.annotations({
  description: "a string that will be split"
}), Array$(String$), {
  strict: true,
  decode: i => i.split(separator),
  encode: a => a.join(separator)
});
const getErrorMessage = e => e instanceof Error ? e.message : String(e);
const getParseJsonTransformation = options => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: (i, _, ast) => ParseResult.try({
    try: () => JSON.parse(i, options?.reviver),
    catch: e => new ParseResult.Type(ast, i, getErrorMessage(e))
  }),
  encode: (a, _, ast) => ParseResult.try({
    try: () => JSON.stringify(a, options?.replacer, options?.space),
    catch: e => new ParseResult.Type(ast, a, getErrorMessage(e))
  })
}).annotations({
  title: "parseJson",
  schemaId: AST.ParseJsonSchemaId
});
/**
The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.

You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.

Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.

@example
```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{"a":"1"}`), { a: "1" })
assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{"a":"1"}`), { a: 1 })
```

@category string transformations
@since 3.10.0
/
export const parseJson = (schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
/**
@category string constructors
@since 3.10.0
/
export class NonEmptyString extends /*#__PURE__*/String$.pipe(/*#__PURE__*/nonEmptyString({
  identifier: "NonEmptyString"
})) {}
/**
@category schema id
@since 3.10.0
/
export const UUIDSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/UUID");
const uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
Represents a Universally Unique Identifier (UUID).

This schema ensures that the provided string adheres to the standard UUID format.

@category string constructors
@since 3.10.0
/
export class UUID extends /*#__PURE__*/String$.pipe(/*#__PURE__*/pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => fc => fc.uuid()
})) {}
/**
@category schema id
@since 3.10.0
/
export const ULIDSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/ULID");
const ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
/**
Represents a Universally Unique Lexicographically Sortable Identifier (ULID).

ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
This schema ensures that the provided string adheres to the standard ULID format.

@category string constructors
@since 3.10.0
/
export class ULID extends /*#__PURE__*/String$.pipe(/*#__PURE__*/pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => fc => fc.ulid()
})) {}
/**
Defines a schema that represents a `URL` object.

@category URL constructors
@since 3.11.0
/
export class URLFromSelf extends /*#__PURE__*/instanceOf(URL, {
  identifier: "URLFromSelf",
  arbitrary: () => fc => fc.webUrl().map(s => new URL(s)),
  pretty: () => url => url.toString()
}) {}
/** @ignore */
class URL$ extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
}), URLFromSelf, {
  strict: true,
  decode: (i, _, ast) => ParseResult.try({
    try: () => new URL(i),
    catch: e => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage(e)}`)
  }),
  encode: a => ParseResult.succeed(a.toString())
}).annotations({
  identifier: "URL",
  pretty: () => url => url.toString()
}) {}
export {
/**
Defines a schema that attempts to convert a `string` to a `URL` object using
the `new URL` constructor.

@category URL transformations
@since 3.11.0
/
URL$ as URL };
/**
@category schema id
@since 3.10.0
/
export const FiniteSchemaId = schemaId_.FiniteSchemaId;
/**
Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).

@category number filters
@since 3.10.0
/
export const finite = annotations => self => self.pipe(filter(Number.isFinite, {
  schemaId: FiniteSchemaId,
  title: "finite",
  description: "a finite number",
  jsonSchema: {
    "type": "number"
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const GreaterThanSchemaId = schemaId_.GreaterThanSchemaId;
/**
This filter checks whether the provided number is greater than the specified minimum.

@category number filters
@since 3.10.0
/
export const greaterThan = (exclusiveMinimum, annotations) => self => self.pipe(filter(a => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToSchemaId = schemaId_.GreaterThanOrEqualToSchemaId;
/**
This filter checks whether the provided number is greater than or equal to the specified minimum.

@category number filters
@since 3.10.0
/
export const greaterThanOrEqualTo = (minimum, annotations) => self => self.pipe(filter(a => a >= minimum, {
  schemaId: GreaterThanOrEqualToSchemaId,
  title: `greaterThanOrEqualTo(${minimum})`,
  description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
  jsonSchema: {
    minimum
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const MultipleOfSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/MultipleOf");
/**
@category number filters
@since 3.10.0
/
export const multipleOf = (divisor, annotations) => self => {
  const positiveDivisor = Math.abs(divisor); // spec requires positive divisor
  return self.pipe(filter(a => number_.remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const IntSchemaId = schemaId_.IntSchemaId;
/**
Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).

@category number filters
@since 3.10.0
/
export const int = annotations => self => self.pipe(filter(a => Number.isSafeInteger(a), {
  schemaId: IntSchemaId,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const LessThanSchemaId = schemaId_.LessThanSchemaId;
/**
This filter checks whether the provided number is less than the specified maximum.

@category number filters
@since 3.10.0
/
export const lessThan = (exclusiveMaximum, annotations) => self => self.pipe(filter(a => a < exclusiveMaximum, {
  schemaId: LessThanSchemaId,
  title: `lessThan(${exclusiveMaximum})`,
  description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
  jsonSchema: {
    exclusiveMaximum
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToSchemaId = schemaId_.LessThanOrEqualToSchemaId;
/**
This schema checks whether the provided number is less than or equal to the specified maximum.

@category number filters
@since 3.10.0
/
export const lessThanOrEqualTo = (maximum, annotations) => self => self.pipe(filter(a => a <= maximum, {
  schemaId: LessThanOrEqualToSchemaId,
  title: `lessThanOrEqualTo(${maximum})`,
  description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
  jsonSchema: {
    maximum
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const BetweenSchemaId = schemaId_.BetweenSchemaId;
/**
This filter checks whether the provided number falls within the specified minimum and maximum values.

@category number filters
@since 3.10.0
/
export const between = (minimum, maximum, annotations) => self => self.pipe(filter(a => a >= minimum && a <= maximum, {
  schemaId: BetweenSchemaId,
  title: `between(${minimum}, ${maximum})`,
  description: `a number between ${minimum} and ${maximum}`,
  jsonSchema: {
    minimum,
    maximum
  },
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const NonNaNSchemaId = schemaId_.NonNaNSchemaId;
/**
@category number filters
@since 3.10.0
/
export const nonNaN = annotations => self => self.pipe(filter(a => !Number.isNaN(a), {
  schemaId: NonNaNSchemaId,
  title: "nonNaN",
  description: "a number excluding NaN",
  ...annotations
}));
/**
@category number filters
@since 3.10.0
/
export const positive = annotations => greaterThan(0, {
  title: "positive",
  ...annotations
});
/**
@category number filters
@since 3.10.0
/
export const negative = annotations => lessThan(0, {
  title: "negative",
  ...annotations
});
/**
@category number filters
@since 3.10.0
/
export const nonPositive = annotations => lessThanOrEqualTo(0, {
  title: "nonPositive",
  ...annotations
});
/**
@category number filters
@since 3.10.0
/
export const nonNegative = annotations => greaterThanOrEqualTo(0, {
  title: "nonNegative",
  ...annotations
});
/**
Clamps a number between a minimum and a maximum value.

@category number transformations
@since 3.10.0
/
export const clamp = (minimum, maximum) => self => {
  return transform(self, typeSchema(self).pipe(between(minimum, maximum)), {
    strict: false,
    decode: i => number_.clamp(i, {
      minimum,
      maximum
    }),
    encode: identity
  });
};
/**
Transforms a `string` into a `number` by parsing the string using the `parse`
function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when
non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity",
"-Infinity".

@category number transformations
@since 3.10.0

## Redacted

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `Redacted(value)`

JSDoc:

This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity", "-Infinity".

@category number transformations
@since 3.10.0
/
export class NumberFromString extends /*#__PURE__*/parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
}) {}
/**
@category number constructors
@since 3.10.0
/
export class Finite extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/finite({
  identifier: "Finite"
})) {}
/**
@category number constructors
@since 3.10.0
/
export class Int extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/int({
  identifier: "Int"
})) {}
/**
@category number constructors
@since 3.10.0
/
export class NonNaN extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/nonNaN({
  identifier: "NonNaN"
})) {}
/**
@category number constructors
@since 3.10.0
/
export class Positive extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/positive({
  identifier: "Positive"
})) {}
/**
@category number constructors
@since 3.10.0
/
export class Negative extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/negative({
  identifier: "Negative"
})) {}
/**
@category number constructors
@since 3.10.0
/
export class NonPositive extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/nonPositive({
  identifier: "NonPositive"
})) {}
/**
@category number constructors
@since 3.10.0
/
export class NonNegative extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/nonNegative({
  identifier: "NonNegative"
})) {}
/**
@category schema id
@since 3.10.0
/
export const JsonNumberSchemaId = schemaId_.JsonNumberSchemaId;
/**
The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
format.

@example
```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

const is = Schema.is(S.JsonNumber)

assert.deepStrictEqual(is(42), true)
assert.deepStrictEqual(is(Number.NaN), false)
assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
```

@category number constructors
@since 3.10.0
/
export class JsonNumber extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/finite({
  schemaId: JsonNumberSchemaId,
  identifier: "JsonNumber"
})) {}
/**
@category boolean transformations
@since 3.10.0
/
export class Not extends /*#__PURE__*/transform(/*#__PURE__*/Boolean$.annotations({
  description: "a boolean that will be negated"
}), Boolean$, {
  strict: true,
  decode: i => boolean_.not(i),
  encode: a => boolean_.not(a)
}) {}
const encodeSymbol = (sym, ast) => {
  const key = Symbol.keyFor(sym);
  return key === undefined ? ParseResult.fail(new ParseResult.Type(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : ParseResult.succeed(key);
};
const decodeSymbol = s => ParseResult.succeed(Symbol.for(s));
/** @ignore */
class Symbol$ extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: i => decodeSymbol(i),
  encode: (a, _, ast) => encodeSymbol(a, ast)
}).annotations({
  identifier: "Symbol"
}) {}
export {
/**
Converts a string key into a globally shared symbol.

@category symbol transformations
@since 3.10.0
/
Symbol$ as Symbol };
/**
@category schema id
@since 3.10.0
/
export const GreaterThanBigIntSchemaId = schemaId_.GreaterThanBigintSchemaId;
/**
@category bigint filters
@since 3.10.0
/
export const greaterThanBigInt = (min, annotations) => self => self.pipe(filter(a => a > min, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min
  },
  title: `greaterThanBigInt(${min})`,
  description: min === 0n ? "a positive bigint" : `a bigint greater than ${min}n`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToBigIntSchemaId = schemaId_.GreaterThanOrEqualToBigIntSchemaId;
/**
@category bigint filters
@since 3.10.0
/
export const greaterThanOrEqualToBigInt = (min, annotations) => self => self.pipe(filter(a => a >= min, {
  schemaId: GreaterThanOrEqualToBigIntSchemaId,
  [GreaterThanOrEqualToBigIntSchemaId]: {
    min
  },
  title: `greaterThanOrEqualToBigInt(${min})`,
  description: min === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min}n`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const LessThanBigIntSchemaId = schemaId_.LessThanBigIntSchemaId;
/**
@category bigint filters
@since 3.10.0
/
export const lessThanBigInt = (max, annotations) => self => self.pipe(filter(a => a < max, {
  schemaId: LessThanBigIntSchemaId,
  [LessThanBigIntSchemaId]: {
    max
  },
  title: `lessThanBigInt(${max})`,
  description: max === 0n ? "a negative bigint" : `a bigint less than ${max}n`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToBigIntSchemaId = schemaId_.LessThanOrEqualToBigIntSchemaId;
/**
@category bigint filters
@since 3.10.0
/
export const lessThanOrEqualToBigInt = (max, annotations) => self => self.pipe(filter(a => a <= max, {
  schemaId: LessThanOrEqualToBigIntSchemaId,
  [LessThanOrEqualToBigIntSchemaId]: {
    max
  },
  title: `lessThanOrEqualToBigInt(${max})`,
  description: max === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max}n`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const BetweenBigIntSchemaId = schemaId_.BetweenBigintSchemaId;
/**
@category bigint filters
@since 3.10.0
/
export const betweenBigInt = (min, max, annotations) => self => self.pipe(filter(a => a >= min && a <= max, {
  schemaId: BetweenBigIntSchemaId,
  [BetweenBigIntSchemaId]: {
    min,
    max
  },
  title: `betweenBigInt(${min}, ${max})`,
  description: `a bigint between ${min}n and ${max}n`,
  ...annotations
}));
/**
@category bigint filters
@since 3.10.0
/
export const positiveBigInt = annotations => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations
});
/**
@category bigint filters
@since 3.10.0
/
export const negativeBigInt = annotations => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations
});
/**
@category bigint filters
@since 3.10.0
/
export const nonNegativeBigInt = annotations => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations
});
/**
@category bigint filters
@since 3.10.0
/
export const nonPositiveBigInt = annotations => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations
});
/**
Clamps a bigint between a minimum and a maximum value.

@category bigint transformations
@since 3.10.0
/
export const clampBigInt = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: i => bigInt_.clamp(i, {
    minimum,
    maximum
  }),
  encode: identity
});
/** @ignore */
class BigInt$ extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: (i, _, ast) => ParseResult.fromOption(bigInt_.fromString(i), () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)),
  encode: a => ParseResult.succeed(String(a))
}).annotations({
  identifier: "BigInt"
}) {}
export {
/**
This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

@category bigint transformations
@since 3.10.0
/
BigInt$ as BigInt };
/**
@category bigint constructors
@since 3.10.0
/
export const PositiveBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe(/*#__PURE__*/positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
/**
@category bigint constructors
@since 3.10.0
/
export const PositiveBigInt = /*#__PURE__*/BigInt$.pipe(/*#__PURE__*/positiveBigInt({
  identifier: "PositiveBigint"
}));
/**
@category bigint constructors
@since 3.10.0
/
export const NegativeBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe(/*#__PURE__*/negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
/**
@category bigint constructors
@since 3.10.0
/
export const NegativeBigInt = /*#__PURE__*/BigInt$.pipe(/*#__PURE__*/negativeBigInt({
  identifier: "NegativeBigint"
}));
/**
@category bigint constructors
@since 3.10.0
/
export const NonPositiveBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe(/*#__PURE__*/nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
/**
@category bigint constructors
@since 3.10.0
/
export const NonPositiveBigInt = /*#__PURE__*/BigInt$.pipe(/*#__PURE__*/nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
/**
@category bigint constructors
@since 3.10.0
/
export const NonNegativeBigIntFromSelf = /*#__PURE__*/BigIntFromSelf.pipe(/*#__PURE__*/nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
/**
@category bigint constructors
@since 3.10.0
/
export const NonNegativeBigInt = /*#__PURE__*/BigInt$.pipe(/*#__PURE__*/nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));
/**
This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.

It returns an error if the value can't be safely encoded as a `number` due to being out of range.

@category bigint transformations
@since 3.10.0
/
export class BigIntFromNumber extends /*#__PURE__*/transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: (i, _, ast) => ParseResult.fromOption(bigInt_.fromNumber(i), () => new ParseResult.Type(ast, i, `Unable to decode ${i} into a bigint`)),
  encode: (a, _, ast) => ParseResult.fromOption(bigInt_.toNumber(a), () => new ParseResult.Type(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
  identifier: "BigIntFromNumber"
}) {}
const redactedArbitrary = value => fc => value(fc).map(redacted_.make);
const toComposite = (eff, onSuccess, ast, actual) => ParseResult.mapBoth(eff, {
  onFailure: e => new ParseResult.Composite(ast, actual, e),
  onSuccess
});
const redactedParse = decodeUnknown => (u, options, ast) => redacted_.isRedacted(u) ? toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Redacted constructors
@since 3.10.0
/
export const RedactedFromSelf = value => declare([value], {
  decode: value => redactedParse(ParseResult.decodeUnknown(value)),
  encode: value => redactedParse(ParseResult.encodeUnknown(value))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: redacted_.getEquivalence
});
/**
A transformation that transform a `Schema<A, I, R>` into a
`RedactedFromSelf<A>`.

@category Redacted transformations
@since 3.10.0

## head

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `head(self)`

JSDoc:

@category Duration constructors
@since 3.10.0
/
export class DurationFromSelf extends /*#__PURE__*/declare(duration_.isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => fc => fc.oneof(fc.constant(duration_.infinity), fc.bigInt({
    min: 0n
  }).map(_ => duration_.nanos(_)), fc.maxSafeNat().map(_ => duration_.millis(_))),
  equivalence: () => duration_.Equivalence
}) {}
/**
A schema that transforms a non negative `bigint` into a `Duration`. Treats
the value as the number of nanoseconds.

@category Duration transformations
@since 3.10.0
/
export class DurationFromNanos extends /*#__PURE__*/transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter(duration => duration_.isFinite(duration), {
  description: "a finite duration"
})), {
  strict: true,
  decode: i => ParseResult.succeed(duration_.nanos(i)),
  encode: (a, _, ast) => option_.match(duration_.toNanos(a), {
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, a, `Unable to encode ${a} into a bigint`)),
    onSome: nanos => ParseResult.succeed(nanos)
  })
}).annotations({
  identifier: "DurationFromNanos"
}) {}
/**
A non-negative integer. +Infinity is excluded.

@category number constructors
@since 3.11.10
/
export const NonNegativeInt = /*#__PURE__*/NonNegative.pipe(int()).annotations({
  identifier: "NonNegativeInt"
});
/**
A schema that transforms a (possibly Infinite) non negative number into a
`Duration`. Treats the value as the number of milliseconds.

@category Duration transformations
@since 3.10.0
/
export class DurationFromMillis extends /*#__PURE__*/transform(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: i => duration_.millis(i),
  encode: a => duration_.toMillis(a)
}).annotations({
  identifier: "DurationFromMillis"
}) {}
const DurationValueMillis = /*#__PURE__*/TaggedStruct("Millis", {
  millis: NonNegativeInt
});
const DurationValueNanos = /*#__PURE__*/TaggedStruct("Nanos", {
  nanos: BigInt$
});
const DurationValueInfinity = /*#__PURE__*/TaggedStruct("Infinity", {});
const durationValueInfinity = /*#__PURE__*/DurationValueInfinity.make({});
const DurationValue = /*#__PURE__*/Union(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
const FiniteHRTime = /*#__PURE__*/Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
const InfiniteHRTime = /*#__PURE__*/Tuple(Literal(-1), Literal(0)).annotations({
  identifier: "InfiniteHRTime"
});
const HRTime = /*#__PURE__*/Union(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
const isDurationValue = u => typeof u === "object";
// TODO(4.0): remove HRTime union member
/**
A schema that converts a JSON-compatible tagged union into a `Duration`.

@category Duration transformations
@since 3.10.0
/
export class Duration extends /*#__PURE__*/transform(Union(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: i => {
    if (isDurationValue(i)) {
      switch (i._tag) {
        case "Millis":
          return duration_.millis(i.millis);
        case "Nanos":
          return duration_.nanos(i.nanos);
        case "Infinity":
          return duration_.infinity;
      }
    }
    const [seconds, nanos] = i;
    return seconds === -1 ? duration_.infinity : duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos));
  },
  encode: a => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }
}).annotations({
  identifier: "Duration"
}) {}
/**
Clamps a `Duration` between a minimum and a maximum value.

@category Duration transformations
@since 3.10.0
/
export const clampDuration = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: i => duration_.clamp(i, {
    minimum,
    maximum
  }),
  encode: identity
});
/**
@category schema id
@since 3.10.0
/
export const LessThanDurationSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/LessThanDuration");
/**
@category Duration filters
@since 3.10.0
/
export const lessThanDuration = (max, annotations) => self => self.pipe(filter(a => duration_.lessThan(a, max), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max
  },
  title: `lessThanDuration(${max})`,
  description: `a Duration less than ${duration_.decode(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToDurationSchemaId = /*#__PURE__*/Symbol.for("effect/schema/LessThanOrEqualToDuration");
/**
@category Duration filters
@since 3.10.0
/
export const lessThanOrEqualToDuration = (max, annotations) => self => self.pipe(filter(a => duration_.lessThanOrEqualTo(a, max), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max
  },
  title: `lessThanOrEqualToDuration(${max})`,
  description: `a Duration less than or equal to ${duration_.decode(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const GreaterThanDurationSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/GreaterThanDuration");
/**
@category Duration filters
@since 3.10.0
/
export const greaterThanDuration = (min, annotations) => self => self.pipe(filter(a => duration_.greaterThan(a, min), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min
  },
  title: `greaterThanDuration(${min})`,
  description: `a Duration greater than ${duration_.decode(min)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToDurationSchemaId = /*#__PURE__*/Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
/**
@category Duration filters
@since 3.10.0
/
export const greaterThanOrEqualToDuration = (min, annotations) => self => self.pipe(filter(a => duration_.greaterThanOrEqualTo(a, min), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min
  },
  title: `greaterThanOrEqualToDuration(${min})`,
  description: `a Duration greater than or equal to ${duration_.decode(min)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const BetweenDurationSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/BetweenDuration");
/**
@category Duration filters
@since 3.10.0
/
export const betweenDuration = (minimum, maximum, annotations) => self => self.pipe(filter(a => duration_.between(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,
  ...annotations
}));
/**
@category Uint8Array constructors
@since 3.10.0
/
export class Uint8ArrayFromSelf extends /*#__PURE__*/declare(Predicate.isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => u8arr => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => fc => fc.uint8Array(),
  equivalence: () => array_.getEquivalence(Equal.equals)
}) {}
/**
@category number constructors
@since 3.11.10
/
export class Uint8 extends /*#__PURE__*/Number$.pipe(/*#__PURE__*/between(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
})) {}
/** @ignore */
class Uint8Array$ extends /*#__PURE__*/transform(Array$(Uint8).annotations({
  description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: i => Uint8Array.from(i),
  encode: a => Array.from(a)
}).annotations({
  identifier: "Uint8Array"
}) {}
export {
/**
A schema that transforms an array of numbers into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
Uint8Array$ as Uint8Array };
const makeUint8ArrayTransformation = (id, decode, encode) => transformOrFail(String$.annotations({
  description: "a string to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i, _, ast) => either_.mapLeft(decode(i), decodeException => new ParseResult.Type(ast, i, decodeException.message)),
  encode: a => ParseResult.succeed(encode(a))
}).annotations({
  identifier: id
});
/**
Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
export const Uint8ArrayFromBase64 = /*#__PURE__*/makeUint8ArrayTransformation("Uint8ArrayFromBase64", Encoding.decodeBase64, Encoding.encodeBase64);
/**
Decodes a base64 (URL) encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
export const Uint8ArrayFromBase64Url = /*#__PURE__*/makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", Encoding.decodeBase64Url, Encoding.encodeBase64Url);
/**
Decodes a hex encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
export const Uint8ArrayFromHex = /*#__PURE__*/makeUint8ArrayTransformation("Uint8ArrayFromHex", Encoding.decodeHex, Encoding.encodeHex);
const makeEncodingTransformation = (id, decode, encode) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => either_.mapLeft(decode(i), decodeException => new ParseResult.Type(ast, i, decodeException.message)),
  encode: a => ParseResult.succeed(encode(a))
}).annotations({
  identifier: `StringFrom${id}`
});
/**
Decodes a base64 (RFC4648) encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
export const StringFromBase64 = /*#__PURE__*/makeEncodingTransformation("Base64", Encoding.decodeBase64String, Encoding.encodeBase64);
/**
Decodes a base64 (URL) encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
export const StringFromBase64Url = /*#__PURE__*/makeEncodingTransformation("Base64Url", Encoding.decodeBase64UrlString, Encoding.encodeBase64Url);
/**
Decodes a hex encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
export const StringFromHex = /*#__PURE__*/makeEncodingTransformation("Hex", Encoding.decodeHexString, Encoding.encodeHex);
/**
Decodes a URI component encoded string into a UTF-8 string.
Can be used to store data in a URL.

@example
```ts
import { Schema } from "effect"

const PaginationSchema = Schema.Struct({
  maxItemPerPage: Schema.Number,
  page: Schema.Number
})

const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))

console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))
// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D
```

@category string transformations
@since 3.12.0
/
export const StringFromUriComponent = /*#__PURE__*/transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => either_.mapLeft(Encoding.decodeUriComponent(i), decodeException => new ParseResult.Type(ast, i, decodeException.message)),
  encode: (a, _, ast) => either_.mapLeft(Encoding.encodeUriComponent(a), encodeException => new ParseResult.Type(ast, a, encodeException.message))
}).annotations({
  identifier: `StringFromUriComponent`
});
/**
@category schema id
@since 3.10.0
/
export const MinItemsSchemaId = schemaId_.MinItemsSchemaId;
/**
@category ReadonlyArray filters
@since 3.10.0
/
export const minItems = (n, annotations) => self => {
  const minItems = Math.floor(n);
  if (minItems < 1) {
    throw new Error(errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter(a => a.length >= minItems, {
    schemaId: MinItemsSchemaId,
    title: `minItems(${minItems})`,
    description: `an array of at least ${minItems} item(s)`,
    jsonSchema: {
      minItems
    },
    [AST.StableFilterAnnotationId]: true,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const MaxItemsSchemaId = schemaId_.MaxItemsSchemaId;
/**
@category ReadonlyArray filters
@since 3.10.0
/
export const maxItems = (n, annotations) => self => {
  const maxItems = Math.floor(n);
  if (maxItems < 1) {
    throw new Error(errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter(a => a.length <= maxItems, {
    schemaId: MaxItemsSchemaId,
    title: `maxItems(${maxItems})`,
    description: `an array of at most ${maxItems} item(s)`,
    jsonSchema: {
      maxItems
    },
    [AST.StableFilterAnnotationId]: true,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const ItemsCountSchemaId = schemaId_.ItemsCountSchemaId;
/**
@category ReadonlyArray filters
@since 3.10.0
/
export const itemsCount = (n, annotations) => self => {
  const itemsCount = Math.floor(n);
  if (itemsCount < 0) {
    throw new Error(errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
  }
  return self.pipe(filter(a => a.length === itemsCount, {
    schemaId: ItemsCountSchemaId,
    title: `itemsCount(${itemsCount})`,
    description: `an array of exactly ${itemsCount} item(s)`,
    jsonSchema: {
      minItems: itemsCount,
      maxItems: itemsCount
    },
    [AST.StableFilterAnnotationId]: true,
    ...annotations
  }));
};
/**
@category ReadonlyArray transformations
@since 3.10.0
/
export const getNumberIndexedAccess = self => make(AST.getNumberIndexedAccess(self.ast));
/**
Get the first element of a `ReadonlyArray`, or `None` if the array is empty.

@category ReadonlyArray transformations
@since 3.10.0

## headNonEmpty

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `headNonEmpty(self)`

JSDoc:

Get the first element of a `NonEmptyReadonlyArray`.

@category NonEmptyReadonlyArray transformations
@since 3.12.0

## Option

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `Option(value)`

JSDoc:

Retrieves the first element of a `ReadonlyArray`.

If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.

@category ReadonlyArray transformations
@since 3.10.0
/
export const headOrElse = /*#__PURE__*/dual(args => isSchema(args[0]), (self, fallback) => transformOrFail(self, getNumberIndexedAccess(typeSchema(self)), {
  strict: true,
  decode: (i, _, ast) => i.length > 0 ? ParseResult.succeed(i[0]) : fallback ? ParseResult.succeed(fallback()) : ParseResult.fail(new ParseResult.Type(ast, i, "Unable to retrieve the first element of an empty array")),
  encode: a => ParseResult.succeed(array_.of(a))
}));
/**
@category schema id
@since 3.10.0
/
export const ValidDateSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/ValidDate");
/**
Defines a filter that specifically rejects invalid dates, such as `new
Date("Invalid Date")`. This filter ensures that only properly formatted and
valid date objects are accepted, enhancing data integrity by preventing
erroneous date values from being processed.

@category Date filters
@since 3.10.0
/
export const validDate = annotations => self => self.pipe(filter(a => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const LessThanDateSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/LessThanDate");
/**
@category Date filters
@since 3.10.0
/
export const lessThanDate = (max, annotations) => self => self.pipe(filter(a => a < max, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max
  },
  title: `lessThanDate(${util_.formatDate(max)})`,
  description: `a date before ${util_.formatDate(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToDateSchemaId = /*#__PURE__*/Symbol.for("effect/schema/LessThanOrEqualToDate");
/**
@category Date filters
@since 3.10.0
/
export const lessThanOrEqualToDate = (max, annotations) => self => self.pipe(filter(a => a <= max, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max
  },
  title: `lessThanOrEqualToDate(${util_.formatDate(max)})`,
  description: `a date before or equal to ${util_.formatDate(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const GreaterThanDateSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/GreaterThanDate");
/**
@category Date filters
@since 3.10.0
/
export const greaterThanDate = (min, annotations) => self => self.pipe(filter(a => a > min, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min
  },
  title: `greaterThanDate(${util_.formatDate(min)})`,
  description: `a date after ${util_.formatDate(min)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToDateSchemaId = /*#__PURE__*/Symbol.for("effect/schema/GreaterThanOrEqualToDate");
/**
@category Date filters
@since 3.10.0
/
export const greaterThanOrEqualToDate = (min, annotations) => self => self.pipe(filter(a => a >= min, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min
  },
  title: `greaterThanOrEqualToDate(${util_.formatDate(min)})`,
  description: `a date after or equal to ${util_.formatDate(min)}`,
  ...annotations
}));
/**
@category schema id
@since 3.10.0
/
export const BetweenDateSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/BetweenDate");
/**
@category Date filters
@since 3.10.0
/
export const betweenDate = (min, max, annotations) => self => self.pipe(filter(a => a <= max && a >= min, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max,
    min
  },
  title: `betweenDate(${util_.formatDate(min)}, ${util_.formatDate(max)})`,
  description: `a date between ${util_.formatDate(min)} and ${util_.formatDate(max)}`,
  ...annotations
}));
/**
@category schema id
@since 3.11.8
/
export const DateFromSelfSchemaId = schemaId_.DateFromSelfSchemaId;
/**
Describes a schema that accommodates potentially invalid `Date` instances,
such as `new Date("Invalid Date")`, without rejection.

@category Date constructors
@since 3.10.0
/
export class DateFromSelf extends /*#__PURE__*/declare(Predicate.isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId,
  [DateFromSelfSchemaId]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => date => `new Date(${JSON.stringify(date)})`,
  arbitrary: () => fc => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Equivalence.Date
}) {}
/**
Defines a schema that ensures only valid dates are accepted. This schema
rejects values like `new Date("Invalid Date")`, which, despite being a `Date`
instance, represents an invalid date. Such stringent validation ensures that
all date objects processed through this schema are properly formed and
represent real dates.

@category Date constructors
@since 3.10.0
/
export class ValidDateFromSelf extends /*#__PURE__*/DateFromSelf.pipe(/*#__PURE__*/validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
})) {}
/**
Defines a schema that attempts to convert a `string` to a `Date` object using
the `new Date` constructor. This conversion is lenient, meaning it does not
reject strings that do not form valid dates (e.g., using `new Date("Invalid
Date")` results in a `Date` object, despite being invalid).

@category Date transformations
@since 3.10.0
/
export class DateFromString extends /*#__PURE__*/transform(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: i => new Date(i),
  encode: a => util_.formatDate(a)
}).annotations({
  identifier: "DateFromString"
}) {}
/** @ignore */
class Date$ extends /*#__PURE__*/DateFromString.pipe(/*#__PURE__*/validDate({
  identifier: "Date"
})) {}
export {
/**
This schema converts a `string` into a `Date` object using the `new Date`
constructor. It ensures that only valid date strings are accepted,
rejecting any strings that would result in an invalid date, such as `new
Date("Invalid Date")`.

@category Date transformations
@since 3.10.0
/
Date$ as Date };
/**
Defines a schema that converts a `number` into a `Date` object using the `new
Date` constructor. This schema does not validate the numerical input,
allowing potentially invalid values such as `NaN`, `Infinity`, and
`-Infinity` to be converted into `Date` objects. During the encoding process,
any invalid `Date` object will be encoded to `NaN`.

@category Date transformations
@since 3.10.0
/
export class DateFromNumber extends /*#__PURE__*/transform(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: i => new Date(i),
  encode: a => a.getTime()
}).annotations({
  identifier: "DateFromNumber"
}) {}
/**
Describes a schema that represents a `DateTime.Utc` instance.

@category DateTime.Utc constructors
@since 3.10.0
/
export class DateTimeUtcFromSelf extends /*#__PURE__*/declare(u => dateTime.isDateTime(u) && dateTime.isUtc(u), {
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: () => dateTime => dateTime.toString(),
  arbitrary: () => fc => fc.date({
    noInvalidDate: true
  }).map(date => dateTime.unsafeFromDate(date)),
  equivalence: () => dateTime.Equivalence
}) {}
const decodeDateTimeUtc = (input, ast) => ParseResult.try({
  try: () => dateTime.unsafeMake(input),
  catch: () => new ParseResult.Type(ast, input, `Unable to decode ${util_.formatUnknown(input)} into a DateTime.Utc`)
});
/**
Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.10.0
/
export class DateTimeUtcFromNumber extends /*#__PURE__*/transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: a => ParseResult.succeed(dateTime.toEpochMillis(a))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
}) {}
/**
Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.12.0
/
export class DateTimeUtcFromDate extends /*#__PURE__*/transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: a => ParseResult.succeed(dateTime.toDateUtc(a))
}).annotations({
  identifier: "DateTimeUtcFromDate"
}) {}
/**
Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.10.0
/
export class DateTimeUtc extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: a => ParseResult.succeed(dateTime.formatIso(a))
}).annotations({
  identifier: "DateTimeUtc"
}) {}
const timeZoneOffsetArbitrary = () => fc => fc.integer({
  min: -12 * 60 * 60 * 1000,
  max: 14 * 60 * 60 * 1000
}).map(dateTime.zoneMakeOffset);
/**
Describes a schema that represents a `TimeZone.Offset` instance.

@category TimeZone constructors
@since 3.10.0
/
export class TimeZoneOffsetFromSelf extends /*#__PURE__*/declare(dateTime.isTimeZoneOffset, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => zone => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary
}) {}
/**
Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.

@category TimeZone transformations
@since 3.10.0
/
export class TimeZoneOffset extends /*#__PURE__*/transform(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
  strict: true,
  decode: i => dateTime.zoneMakeOffset(i),
  encode: a => a.offset
}).annotations({
  identifier: "TimeZoneOffset"
}) {}
const timeZoneNamedArbitrary = () => fc => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(dateTime.zoneUnsafeMakeNamed);
/**
Describes a schema that represents a `TimeZone.Named` instance.

@category TimeZone constructors
@since 3.10.0
/
export class TimeZoneNamedFromSelf extends /*#__PURE__*/declare(dateTime.isTimeZoneNamed, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => zone => zone.toString(),
  arbitrary: timeZoneNamedArbitrary
}) {}
/**
Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.

@category TimeZone transformations
@since 3.10.0
/
export class TimeZoneNamed extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
  strict: true,
  decode: (i, _, ast) => ParseResult.try({
    try: () => dateTime.zoneUnsafeMakeNamed(i),
    catch: () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)
  }),
  encode: a => ParseResult.succeed(a.id)
}).annotations({
  identifier: "TimeZoneNamed"
}) {}
/**
@category TimeZone constructors
@since 3.10.0
/
export class TimeZoneFromSelf extends /*#__PURE__*/Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf) {}
/**
Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.

@category TimeZone transformations
@since 3.10.0
/
export class TimeZone extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
  strict: true,
  decode: (i, _, ast) => option_.match(dateTime.zoneFromString(i), {
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),
    onSome: ParseResult.succeed
  }),
  encode: a => ParseResult.succeed(dateTime.zoneToString(a))
}).annotations({
  identifier: "TimeZone"
}) {}
const timeZoneArbitrary = fc => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc));
/**
Describes a schema that represents a `DateTime.Zoned` instance.

@category DateTime.Zoned constructors
@since 3.10.0
/
export class DateTimeZonedFromSelf extends /*#__PURE__*/declare(u => dateTime.isDateTime(u) && dateTime.isZoned(u), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => dateTime => dateTime.toString(),
  arbitrary: () => fc => fc.tuple(fc.integer({
    // time zone db supports +/- 1000 years or so
    min: -31536000000000,
    max: 31536000000000
  }), timeZoneArbitrary(fc)).map(([millis, timeZone]) => dateTime.unsafeMakeZoned(millis, {
    timeZone
  })),
  equivalence: () => dateTime.Equivalence
}) {}
/**
Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.

@category DateTime.Zoned transformations
@since 3.10.0
/
export class DateTimeZoned extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
  strict: true,
  decode: (i, _, ast) => option_.match(dateTime.makeZonedFromString(i), {
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),
    onSome: ParseResult.succeed
  }),
  encode: a => ParseResult.succeed(dateTime.formatIsoZoned(a))
}).annotations({
  identifier: "DateTimeZoned"
}) {}
const OptionNoneEncoded = /*#__PURE__*/Struct({
  _tag: Literal("None")
}).annotations({
  description: "NoneEncoded"
});
const optionSomeEncoded = value => Struct({
  _tag: Literal("Some"),
  value
}).annotations({
  description: `SomeEncoded<${format(value)}>`
});
const optionEncoded = value => Union(OptionNoneEncoded, optionSomeEncoded(value)).annotations({
  description: `OptionEncoded<${format(value)}>`
});
const optionDecode = input => input._tag === "None" ? option_.none() : option_.some(input.value);
const optionArbitrary = (value, ctx) => fc => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value(fc)
})).map(optionDecode);
const optionPretty = value => option_.match({
  onNone: () => "none()",
  onSome: a => `some(${value(a)})`
});
const optionParse = decodeUnknown => (u, options, ast) => option_.isOption(u) ? option_.isNone(u) ? ParseResult.succeed(option_.none()) : toComposite(decodeUnknown(u.value, options), option_.some, ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Option transformations
@since 3.10.0
/
export const OptionFromSelf = value => {
  return declare([value], {
    decode: value => optionParse(ParseResult.decodeUnknown(value)),
    encode: value => optionParse(ParseResult.encodeUnknown(value))
  }, {
    description: `Option<${format(value)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: option_.getEquivalence
  });
};
const makeNoneEncoded = {
  _tag: "None"
};
const makeSomeEncoded = value => ({
  _tag: "Some",
  value
});
/**
@category Option transformations
@since 3.10.0

## OptionFromNullOr

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `OptionFromNullOr(value)`

JSDoc:

@category Option transformations
@since 3.10.0

## OptionFromNullishOr

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `OptionFromNullishOr(value, onNoneEncoding)`

JSDoc:

@category Option transformations
@since 3.10.0

## OptionFromUndefinedOr

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `OptionFromUndefinedOr(value)`

JSDoc:

@category Option transformations
@since 3.10.0

## ReadonlyMap

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `ReadonlyMap({
  key,
  value
})`

JSDoc:

Transforms strings into an Option type, effectively filtering out empty or
whitespace-only strings by trimming them and checking their length. Returns
`none` for invalid inputs and `some` for valid non-empty strings.

@example
```ts
import { Schema } from "effect"

console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(" a ")) // Option.some("a")
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("a")) // Option.some("a")
```

@category Option transformations
@since 3.10.0
/
export class OptionFromNonEmptyTrimmedString extends /*#__PURE__*/transform(String$, /*#__PURE__*/OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: i => option_.filter(option_.some(i.trim()), string_.isNonEmpty),
  encode: a => option_.getOrElse(a, () => "")
}) {}
const rightEncoded = right => Struct({
  _tag: Literal("Right"),
  right
}).annotations({
  description: `RightEncoded<${format(right)}>`
});
const leftEncoded = left => Struct({
  _tag: Literal("Left"),
  left
}).annotations({
  description: `LeftEncoded<${format(left)}>`
});
const eitherEncoded = (right, left) => Union(rightEncoded(right), leftEncoded(left)).annotations({
  description: `EitherEncoded<${format(left)}, ${format(right)}>`
});
const eitherDecode = input => input._tag === "Left" ? either_.left(input.left) : either_.right(input.right);
const eitherArbitrary = (right, left) => fc => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right(fc)
})).map(eitherDecode);
const eitherPretty = (right, left) => either_.match({
  onLeft: e => `left(${left(e)})`,
  onRight: a => `right(${right(a)})`
});
const eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => either_.isEither(u) ? either_.match(u, {
  onLeft: left => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),
  onRight: right => toComposite(parseRight(right, options), either_.right, ast, u)
}) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Either transformations
@since 3.10.0
/
export const EitherFromSelf = ({
  left,
  right
}) => {
  return declare([right, left], {
    decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),
    encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))
  }, {
    description: `Either<${format(right)}, ${format(left)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right, left) => either_.getEquivalence({
      left,
      right
    })
  });
};
const makeLeftEncoded = left => ({
  _tag: "Left",
  left
});
const makeRightEncoded = right => ({
  _tag: "Right",
  right
});
/**
@category Either transformations
@since 3.10.0
/
export const Either = ({
  left,
  right
}) => {
  const right_ = asSchema(right);
  const left_ = asSchema(left);
  const out = transform(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: i => eitherDecode(i),
    encode: a => either_.match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
/**
@example
```ts
import * as Schema from "effect/Schema"

// Schema<string | number, Either<string, number>>
Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })
```

@category Either transformations
@since 3.10.0
/
export const EitherFromUnion = ({
  left,
  right
}) => {
  const right_ = asSchema(right);
  const left_ = asSchema(left);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform(right_, rightEncoded(toright), {
    strict: true,
    decode: i => makeRightEncoded(i),
    encode: a => a.right
  });
  const fromLeft = transform(left_, leftEncoded(toleft), {
    strict: true,
    decode: i => makeLeftEncoded(i),
    encode: a => a.left
  });
  const out = transform(Union(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: i => i._tag === "Left" ? either_.left(i.left) : either_.right(i.right),
    encode: a => either_.match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
const mapArbitrary = (key, value, ctx) => {
  return fc => {
    const items = fc.array(fc.tuple(key(fc), value(fc)));
    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(as => new Map(as));
  };
};
const readonlyMapPretty = (key, value) => map => `new Map([${Array.from(map.entries()).map(([k, v]) => `[${key(k)}, ${value(v)}]`).join(", ")}])`;
const readonlyMapEquivalence = (key, value) => {
  const arrayEquivalence = array_.getEquivalence(Equivalence.make(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb)));
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
const readonlyMapParse = decodeUnknown => (u, options, ast) => Predicate.isMap(u) ? toComposite(decodeUnknown(Array.from(u.entries()), options), as => new Map(as), ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
const mapFromSelf_ = (key, value, description) => declare([key, value], {
  decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown(Array$(Tuple(Key, Value)))),
  encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown(Array$(Tuple(Key, Value))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
/**
@category ReadonlyMap
@since 3.10.0
/
export const ReadonlyMapFromSelf = ({
  key,
  value
}) => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`);
/**
@category Map
@since 3.10.0
/
export const MapFromSelf = ({
  key,
  value
}) => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`);
/**
@category ReadonlyMap transformations
@since 3.10.0

## ReadonlySet

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `ReadonlySet(value)`

JSDoc:

@ignore */
function map({
  key,
  value
}) {
  return transform(Array$(Tuple(key, value)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value))
  }), {
    strict: true,
    decode: i => new Map(i),
    encode: a => Array.from(a.entries())
  });
}
export {
/**
@category Map transformations
@since 3.10.0
/
map as Map };
/**
@category ReadonlyMap transformations
@since 3.10.0
/
export const ReadonlyMapFromRecord = ({
  key,
  value
}) => transform(Record({
  key: encodedBoundSchema(key),
  value
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value)
}), {
  strict: true,
  decode: i => new Map(Object.entries(i)),
  encode: a => Object.fromEntries(a)
});
/**
@category Map transformations
@since 3.10.0
/
export const MapFromRecord = ({
  key,
  value
}) => transform(Record({
  key: encodedBoundSchema(key),
  value
}).annotations({
  description: "a record to be decoded into a Map"
}), MapFromSelf({
  key,
  value: typeSchema(value)
}), {
  strict: true,
  decode: i => new Map(Object.entries(i)),
  encode: a => Object.fromEntries(a)
});
const setArbitrary = (item, ctx) => fc => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(as => new Set(as));
};
const readonlySetPretty = item => set => `new Set([${Array.from(set.values()).map(a => item(a)).join(", ")}])`;
const readonlySetEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
const readonlySetParse = decodeUnknown => (u, options, ast) => Predicate.isSet(u) ? toComposite(decodeUnknown(Array.from(u.values()), options), as => new Set(as), ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
const setFromSelf_ = (value, description) => declare([value], {
  decode: item => readonlySetParse(ParseResult.decodeUnknown(Array$(item))),
  encode: item => readonlySetParse(ParseResult.encodeUnknown(Array$(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
/**
@category ReadonlySet
@since 3.10.0
/
export const ReadonlySetFromSelf = value => setFromSelf_(value, `ReadonlySet<${format(value)}>`);
/**
@category Set
@since 3.10.0
/
export const SetFromSelf = value => setFromSelf_(value, `Set<${format(value)}>`);
/**
@category ReadonlySet transformations
@since 3.10.0

## Chunk

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `Chunk(value)`

JSDoc:

@ignore */
function set(value) {
  return transform(Array$(value), SetFromSelf(typeSchema(asSchema(value))), {
    strict: true,
    decode: i => new Set(i),
    encode: a => Array.from(a)
  });
}
export {
/**
@category Set transformations
@since 3.10.0
/
set as Set };
const bigDecimalPretty = () => val => `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`;
const bigDecimalArbitrary = () => fc => fc.tuple(fc.bigInt(), fc.integer({
  min: 0,
  max: 18
})).map(([value, scale]) => bigDecimal_.make(value, scale));
/**
@category BigDecimal constructors
@since 3.10.0
/
export class BigDecimalFromSelf extends /*#__PURE__*/declare(bigDecimal_.isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => bigDecimal_.Equivalence
}) {}
/**
@category BigDecimal transformations
@since 3.10.0
/
export class BigDecimal extends /*#__PURE__*/transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i, _, ast) => bigDecimal_.fromString(i).pipe(option_.match({
    onNone: () => ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),
    onSome: val => ParseResult.succeed(bigDecimal_.normalize(val))
  })),
  encode: a => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(a)))
}).annotations({
  identifier: "BigDecimal"
}) {}
/**
A schema that transforms a `number` into a `BigDecimal`.
When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.

@category BigDecimal transformations
@since 3.10.0
/
export class BigDecimalFromNumber extends /*#__PURE__*/transform(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: i => bigDecimal_.unsafeFromNumber(i),
  encode: a => bigDecimal_.unsafeToNumber(a)
}).annotations({
  identifier: "BigDecimalFromNumber"
}) {}
/**
@category schema id
@since 3.10.0
/
export const GreaterThanBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const greaterThanBigDecimal = (min, annotations) => self => {
  const formatted = bigDecimal_.format(min);
  return self.pipe(filter(a => bigDecimal_.greaterThan(a, min), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const greaterThanOrEqualToBigDecimal = (min, annotations) => self => {
  const formatted = bigDecimal_.format(min);
  return self.pipe(filter(a => bigDecimal_.greaterThanOrEqualTo(a, min), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const LessThanBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/LessThanBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const lessThanBigDecimal = (max, annotations) => self => {
  const formatted = bigDecimal_.format(max);
  return self.pipe(filter(a => bigDecimal_.lessThan(a, max), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const lessThanOrEqualToBigDecimal = (max, annotations) => self => {
  const formatted = bigDecimal_.format(max);
  return self.pipe(filter(a => bigDecimal_.lessThanOrEqualTo(a, max), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations
  }));
};
/**
@category schema id
@since 3.10.0
/
export const PositiveBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/PositiveBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const positiveBigDecimal = annotations => self => self.pipe(filter(a => bigDecimal_.isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations
}));
/**
@category BigDecimal constructors
@since 3.10.0
/
export const PositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe(/*#__PURE__*/positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
}));
/**
@category schema id
@since 3.10.0
/
export const NonNegativeBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/NonNegativeBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const nonNegativeBigDecimal = annotations => self => self.pipe(filter(a => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations
}));
/**
@category BigDecimal constructors
@since 3.10.0
/
export const NonNegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe(/*#__PURE__*/nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
}));
/**
@category schema id
@since 3.10.0
/
export const NegativeBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/NegativeBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const negativeBigDecimal = annotations => self => self.pipe(filter(a => bigDecimal_.isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations
}));
/**
@category BigDecimal constructors
@since 3.10.0
/
export const NegativeBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe(/*#__PURE__*/negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
}));
/**
@category schema id
@since 3.10.0
/
export const NonPositiveBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/schema/NonPositiveBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const nonPositiveBigDecimal = annotations => self => self.pipe(filter(a => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations
}));
/**
@category BigDecimal constructors
@since 3.10.0
/
export const NonPositiveBigDecimalFromSelf = /*#__PURE__*/BigDecimalFromSelf.pipe(/*#__PURE__*/nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
}));
/**
@category schema id
@since 3.10.0
/
export const BetweenBigDecimalSchemaId = /*#__PURE__*/Symbol.for("effect/SchemaId/BetweenBigDecimal");
/**
@category BigDecimal filters
@since 3.10.0
/
export const betweenBigDecimal = (minimum, maximum, annotations) => self => {
  const formattedMinimum = bigDecimal_.format(minimum);
  const formattedMaximum = bigDecimal_.format(maximum);
  return self.pipe(filter(a => bigDecimal_.between(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations
  }));
};
/**
Clamps a `BigDecimal` between a minimum and a maximum value.

@category BigDecimal transformations
@since 3.10.0
/
export const clampBigDecimal = (minimum, maximum) => self => transform(self, self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: i => bigDecimal_.clamp(i, {
    minimum,
    maximum
  }),
  encode: identity
});
const chunkArbitrary = (item, ctx) => fc => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(chunk_.fromIterable);
};
const chunkPretty = item => c => `Chunk(${chunk_.toReadonlyArray(c).map(item).join(", ")})`;
const chunkParse = decodeUnknown => (u, options, ast) => chunk_.isChunk(u) ? chunk_.isEmpty(u) ? ParseResult.succeed(chunk_.empty()) : toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable, ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Chunk
@since 3.10.0
/
export const ChunkFromSelf = value => {
  return declare([value], {
    decode: item => chunkParse(ParseResult.decodeUnknown(Array$(item))),
    encode: item => chunkParse(ParseResult.encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format(value)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: chunk_.getEquivalence
  });
};
/**
@category Chunk transformations
@since 3.10.0

## NonEmptyChunk

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `NonEmptyChunk(value)`

JSDoc:

@category Chunk
@since 3.10.0
/
export const NonEmptyChunkFromSelf = value => {
  return declare([value], {
    decode: item => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),
    encode: item => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format(value)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: chunk_.getEquivalence
  });
};
/**
@category Chunk transformations
@since 3.10.0

## HashSet

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `HashSet(value)`

JSDoc:

Type and Encoded must extend `Readonly<Record<string, any>> |
ReadonlyArray<any>` to be compatible with this API.

@category Data transformations
@since 3.10.0
/
export const DataFromSelf = value => {
  return declare([value], {
    decode: item => dataParse(ParseResult.decodeUnknown(item)),
    encode: item => dataParse(ParseResult.encodeUnknown(item))
  }, {
    description: `Data<${format(value)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
/**
Type and Encoded must extend `Readonly<Record<string, any>> |
ReadonlyArray<any>` to be compatible with this API.

@category Data transformations
@since 3.10.0
/
export const Data = value => {
  return transform(value, DataFromSelf(typeSchema(value)), {
    strict: false,
    decode: i => decodeData(i),
    encode: a => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
  });
};
const isField = u => isSchema(u) || isPropertySignature(u);
const isFields = fields => util_.ownKeys(fields).every(key => isField(fields[key]));
const getFields = hasFields => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
const getSchemaFromFieldsOr = fieldsOr => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
const getFieldsFromFieldsOr = fieldsOr => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
/**
@example
```ts
import { Schema } from "effect"

class MyClass extends Schema.Class<MyClass>("MyClass")({
 someField: Schema.String
}) {
 someMethod() {
   return this.someField + "bar"
 }
}
```

@category classes
@since 3.10.0
/
export const Class = identifier => (fieldsOr, annotations) => makeClass({
  kind: "Class",
  identifier,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: data_.Class,
  annotations
});
/** @internal */
export const getClassTag = tag => withConstructorDefault(propertySignature(Literal(tag)), () => tag);
/**
@example
```ts
import { Schema } from "effect"

class MyClass extends Schema.TaggedClass<MyClass>("MyClass")("MyClass", {
 a: Schema.String
}) {}
```

@category classes
@since 3.10.0
/
export const TaggedClass = identifier => (tag, fieldsOr, annotations) => {
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedClass extends makeClass({
    kind: "TaggedClass",
    identifier: identifier ?? tag,
    schema: extend(schema, Struct(newFields)),
    fields: taggedFields,
    Base: data_.Class,
    annotations
  }) {
    static _tag = tag;
  };
};
/**
@example
```ts
import { Schema } from "effect"

class MyError extends Schema.TaggedError<MyError>("MyError")(
  "MyError",
  {
    module: Schema.String,
    method: Schema.String,
    description: Schema.String
  }
) {
  get message(): string {
    return `${this.module}.${this.method}: ${this.description}`
  }
}
```
@category classes
@since 3.10.0
/
export const TaggedError = identifier => (tag, fieldsOr, annotations) => {
  class Base extends data_.Error {}
  ;
  Base.prototype.name = tag;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier ?? tag,
    schema: extend(schema, Struct(newFields)),
    fields: taggedFields,
    Base,
    annotations,
    disableToString: true
  }) {
    static _tag = tag;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${util_.ownKeys(fields).map(p => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
};
const extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of util_.ownKeys(b)) {
    if (key in a) {
      throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
};
function getDisableValidationMakeOption(options) {
  return Predicate.isBoolean(options) ? options : options?.disableValidation ?? false;
}
const astCache = /*#__PURE__*/globalValue("effect/Schema/astCache", () => new WeakMap());
const getClassAnnotations = annotations => {
  if (annotations === undefined) {
    return [];
  } else if (Array.isArray(annotations)) {
    return annotations;
  } else {
    return [annotations];
  }
};
const makeClass = ({
  Base,
  annotations,
  disableToString,
  fields,
  identifier,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AST.AutoTitleAnnotationId]: `${identifier} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AST.AutoTitleAnnotationId]: `${identifier} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AST.AutoTitleAnnotationId]: `${identifier} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    [AST.JSONIdentifierAnnotationId]: identifier,
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = u => Predicate.hasProperty(u, classSymbol) && ParseResult.is(typeSide)(u);
  const klass = class extends Base {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options)) {
        props = ParseResult.validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId] = variance;
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input)),
        encode: () => (input, options) => input instanceof this ? ParseResult.succeed(input) : ParseResult.map(ParseResult.encodeUnknown(typeSide)(input, options), props => new this(props, true))
      }, {
        identifier,
        pretty: pretty => self => `${identifier}(${pretty(self)})`,
        // @ts-expect-error
        arbitrary: arb => fc => arb(fc).map(props => new this(props)),
        equivalence: identity,
        [AST.SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform(encodedSide, declaration, {
        strict: true,
        decode: i => new this(i, true),
        encode: identity
      }).annotations({
        [AST.SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations) {
      return make(this.ast).annotations(annotations);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args) {
      return new this(...args);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier;
    static extend(identifier) {
      return (newFieldsOr, annotations) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier,
          schema: extend(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations
        });
      };
    }
    static transformOrFail(identifier) {
      return (newFieldsOr, options, annotations) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations
        });
      };
    }
    static transformOrFailFrom(identifier) {
      return (newFields, options, annotations) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier}({ ${util_.ownKeys(fields).map(p => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
const FiberIdNoneEncoded = /*#__PURE__*/Struct({
  _tag: Literal("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
const FiberIdRuntimeEncoded = /*#__PURE__*/Struct({
  _tag: Literal("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
const FiberIdCompositeEncoded = /*#__PURE__*/Struct({
  _tag: Literal("Composite"),
  left: suspend(() => FiberIdEncoded),
  right: suspend(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
const FiberIdEncoded = /*#__PURE__*/Union(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
const fiberIdArbitrary = fc => fc.letrec(tie => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
const fiberIdPretty = fiberId => {
  switch (fiberId._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`;
  }
};
/**
@category FiberId constructors
@since 3.10.0
/
export class FiberIdFromSelf extends /*#__PURE__*/declare(fiberId_.isFiberId, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
}) {}
const fiberIdDecode = input => {
  switch (input._tag) {
    case "None":
      return fiberId_.none;
    case "Runtime":
      return fiberId_.runtime(input.id, input.startTimeMillis);
    case "Composite":
      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
const fiberIdEncode = input => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
/**
@category FiberId transformations
@since 3.10.0
/
export class FiberId extends /*#__PURE__*/transform(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: i => fiberIdDecode(i),
  encode: a => fiberIdEncode(a)
}).annotations({
  identifier: "FiberId"
}) {}
const causeDieEncoded = defect => Struct({
  _tag: Literal("Die"),
  defect
});
const CauseEmptyEncoded = /*#__PURE__*/Struct({
  _tag: /*#__PURE__*/Literal("Empty")
});
const causeFailEncoded = error => Struct({
  _tag: Literal("Fail"),
  error
});
const CauseInterruptEncoded = /*#__PURE__*/Struct({
  _tag: /*#__PURE__*/Literal("Interrupt"),
  fiberId: FiberIdEncoded
});
let causeEncodedId = 0;
const causeEncoded = (error, defect) => {
  const error_ = asSchema(error);
  const defect_ = asSchema(defect);
  const suspended = suspend(() => out);
  const out = Union(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal("Sequential"),
    left: suspended,
    right: suspended
  }), Struct({
    _tag: Literal("Parallel"),
    left: suspended,
    right: suspended
  })).annotations({
    title: `CauseEncoded<${format(error)}>`,
    [AST.JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
};
const causeArbitrary = (error, defect) => fc => fc.letrec(tie => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
const causePretty = error => cause => {
  const f = cause => {
    switch (cause._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error(cause.error)})`;
      case "Die":
        return `Cause.die(${cause_.pretty(cause)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`;
    }
  };
  return f(cause);
};
const causeParse = decodeUnknown => (u, options, ast) => cause_.isCause(u) ? toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Cause transformations
@since 3.10.0
/
export const CauseFromSelf = ({
  defect,
  error
}) => {
  return declare([error, defect], {
    decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),
    encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))
  }, {
    title: `Cause<${error.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause) {
  switch (cause._tag) {
    case "Empty":
      return cause_.empty;
    case "Fail":
      return cause_.fail(cause.error);
    case "Die":
      return cause_.die(cause.defect);
    case "Interrupt":
      return cause_.interrupt(fiberIdDecode(cause.fiberId));
    case "Sequential":
      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right));
    case "Parallel":
      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right));
  }
}
function causeEncode(cause) {
  switch (cause._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      };
  }
}
/**
@category Cause transformations
@since 3.10.0
/
export const Cause = ({
  defect,
  error
}) => {
  const error_ = asSchema(error);
  const defect_ = asSchema(defect);
  const out = transform(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: i => causeDecode(i),
    encode: a => causeEncode(a)
  });
  return out;
};
/**
Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.
It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),
or converts other values to their string representations.

When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,
or other values into their string forms.

This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.

@category defect
@since 3.10.0
/
export class Defect extends /*#__PURE__*/transform(Unknown, Unknown, {
  strict: true,
  decode: i => {
    if (Predicate.isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return String(i);
  },
  encode: a => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return internalCause_.prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
}) {}
const exitFailureEncoded = (error, defect) => Struct({
  _tag: Literal("Failure"),
  cause: causeEncoded(error, defect)
});
const exitSuccessEncoded = value => Struct({
  _tag: Literal("Success"),
  value
});
const exitEncoded = (value, error, defect) => {
  return Union(exitFailureEncoded(error, defect), exitSuccessEncoded(value)).annotations({
    title: `ExitEncoded<${format(value)}, ${format(error)}, ${format(defect)}>`
  });
};
const exitDecode = input => {
  switch (input._tag) {
    case "Failure":
      return exit_.failCause(causeDecode(input.cause));
    case "Success":
      return exit_.succeed(input.value);
  }
};
const exitArbitrary = (value, error, defect) => fc => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value(fc)
})).map(exitDecode);
const exitPretty = (value, error) => exit => exit._tag === "Failure" ? `Exit.failCause(${causePretty(error)(exit.cause)})` : `Exit.succeed(${value(exit.value)})`;
const exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => exit_.isExit(u) ? exit_.match(u, {
  onFailure: cause => toComposite(decodeUnknownCause(cause, options), exit_.failCause, ast, u),
  onSuccess: value => toComposite(decodeUnknownValue(value, options), exit_.succeed, ast, u)
}) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category Exit transformations
@since 3.10.0
/
export const ExitFromSelf = ({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success, failure, defect) => exitParse(ParseResult.decodeUnknown(success), ParseResult.decodeUnknown(CauseFromSelf({
    error: failure,
    defect
  }))),
  encode: (success, failure, defect) => exitParse(ParseResult.encodeUnknown(success), ParseResult.encodeUnknown(CauseFromSelf({
    error: failure,
    defect
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
/**
@category Exit transformations
@since 3.10.0
/
export const Exit = ({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out = transform(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: i => exitDecode(i),
    encode: a => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }
  });
  return out;
};
const hashSetArbitrary = (item, ctx) => fc => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(hashSet_.fromIterable);
};
const hashSetPretty = item => set => `HashSet(${Array.from(set).map(a => item(a)).join(", ")})`;
const hashSetEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const hashSetParse = decodeUnknown => (u, options, ast) => hashSet_.isHashSet(u) ? toComposite(decodeUnknown(Array.from(u), options), hashSet_.fromIterable, ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category HashSet transformations
@since 3.10.0
/
export const HashSetFromSelf = value => {
  return declare([value], {
    decode: item => hashSetParse(ParseResult.decodeUnknown(Array$(item))),
    encode: item => hashSetParse(ParseResult.encodeUnknown(Array$(item)))
  }, {
    description: `HashSet<${format(value)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
/**
@category HashSet transformations
@since 3.10.0

## List

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `List(value)`

JSDoc:

@category HashMap transformations
@since 3.10.0
/
export const HashMapFromSelf = ({
  key,
  value
}) => {
  return declare([key, value], {
    decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),
    encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))
  }, {
    description: `HashMap<${format(key)}, ${format(value)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
/**
@category HashMap transformations
@since 3.10.0
/
export const HashMap = ({
  key,
  value
}) => {
  return transform(Array$(Tuple(key, value)), HashMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value))
  }), {
    strict: true,
    decode: i => hashMap_.fromIterable(i),
    encode: a => Array.from(a)
  });
};
const listArbitrary = (item, ctx) => fc => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(list_.fromIterable);
};
const listPretty = item => set => `List(${Array.from(set).map(a => item(a)).join(", ")})`;
const listEquivalence = item => {
  const arrayEquivalence = array_.getEquivalence(item);
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
const listParse = decodeUnknown => (u, options, ast) => list_.isList(u) ? toComposite(decodeUnknown(Array.from(u), options), list_.fromIterable, ast, u) : ParseResult.fail(new ParseResult.Type(ast, u));
/**
@category List transformations
@since 3.10.0
/
export const ListFromSelf = value => {
  return declare([value], {
    decode: item => listParse(ParseResult.decodeUnknown(Array$(item))),
    encode: item => listParse(ParseResult.encodeUnknown(Array$(item)))
  }, {
    description: `List<${format(value)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
/**
@category List transformations
@since 3.10.0

## SortedSet

Source: `my-backend/node_modules/effect/dist/esm/Schema.js`

Signature: `SortedSet(value, ordA)`

JSDoc:

@category SortedSet transformations
@since 3.10.0
/
export const SortedSetFromSelf = (value, ordA, ordI) => {
  return declare([value], {
    decode: item => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),
    encode: item => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format(value)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
    equivalence: () => sortedSet_.getEquivalence()
  });
};
/**
@category SortedSet transformations
@since 3.10.0

## yieldWrapGet

Source: `my-backend/node_modules/effect/dist/esm/Utils.js`

Signature: `yieldWrapGet(self)`

JSDoc:

@since 2.0.0
/
import { identity } from "./Function.js";
import { globalValue } from "./GlobalValue.js";
import { getBugErrorMessage } from "./internal/errors.js";
import { isNullable, isObject } from "./Predicate.js";
/*
Copyright 2014 Thom Chiovoloni, released under the MIT license.

A random number generator based on the basic implementation of the PCG algorithm,
as described here: http://www.pcg-random.org/

Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random

forked from https://github.com/frptools

@since 2.0.0
/
/**
@category symbols
@since 2.0.0
/
export const GenKindTypeId = /*#__PURE__*/Symbol.for("effect/Gen/GenKind");
/**
@category predicates
@since 3.0.6
/
export const isGenKind = u => isObject(u) && GenKindTypeId in u;
/**
@category constructors
@since 2.0.0
/
export class GenKindImpl {
  value;
  constructor(
  /**
@since 2.0.0
/
  value) {
    this.value = value;
  }
  /**
@since 2.0.0
/
  get _F() {
    return identity;
  }
  /**
@since 2.0.0
/
  get _R() {
    return _ => _;
  }
  /**
@since 2.0.0
/
  get _O() {
    return _ => _;
  }
  /**
@since 2.0.0
/
  get _E() {
    return _ => _;
  }
  /**
@since 2.0.0
/
  [GenKindTypeId] = GenKindTypeId;
  /**
@since 2.0.0
/
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
}
/**
@category constructors
@since 2.0.0
/
export class SingleShotGen {
  self;
  called = false;
  constructor(self) {
    this.self = self;
  }
  /**
@since 2.0.0
/
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
@since 2.0.0
/
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
@since 2.0.0
/
  throw(e) {
    throw e;
  }
  /**
@since 2.0.0
/
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}
/**
@category constructors
@since 2.0.0
/
export const makeGenKind = kind => new GenKindImpl(kind);
/**
@category adapters
@since 2.0.0
/
export const adapter = () => function () {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
};
const defaultIncHi = 0x14057b7e;
const defaultIncLo = 0xf767814f;
const MUL_HI = 0x5851f42d >>> 0;
const MUL_LO = 0x4c957f2d >>> 0;
const BIT_53 = 9007199254740992.0;
const BIT_27 = 134217728.0;
/**
PCG is a family of simple fast space-efficient statistically good algorithms
for random number generation. Unlike many general-purpose RNGs, they are also
hard to predict.

@category model
@since 2.0.0
/
export class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 0xffffffff >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
Returns a copy of the internal state of this random number generator as a
JavaScript Array.

@category getters
@since 2.0.0
/
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
Restore state previously retrieved using `getState()`.

@since 2.0.0
/
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
Get a uniformly distributed 32 bit integer between [0, max).

@category getter
@since 2.0.0
/
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  /**
Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
53 bits of precision (every bit of the mantissa is randomized).

@category getters
@since 2.0.0
/
  number() {
    const hi = (this._next() & 0x03ffffff) * 1.0;
    const lo = (this._next() & 0x07ffffff) * 1.0;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    // save current state (what we'll use for this number)
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    // churn LCG.
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    // rotate xorshifted right a random amount, based on the most sig. 5 bits
    // bits of the old state.
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;
  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
// add two 64 bit numbers (given in parts), and store the result in `out`.
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
/**
@since 3.0.6
/
export const YieldWrapTypeId = /*#__PURE__*/Symbol.for("effect/Utils/YieldWrap");
/**
@since 3.0.6
/
export class YieldWrap {
  /**
@since 3.0.6
/
  #value;
  constructor(value) {
    this.#value = value;
  }
  /**
@since 3.0.6
/
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
/**
@since 3.0.6

## unsafeMake

Source: `my-backend/node_modules/effect/dist/esm/internal/fiberRefs.js`

Signature: `unsafeMake(fiberRefLocals)`

JSDoc:

@internal

## empty

Source: `my-backend/node_modules/effect/dist/esm/internal/fiberRefs.js`

Signature: `empty()`

JSDoc:

@internal

## arrayUpdate

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/array.js`

Signature: `arrayUpdate(mutate, at, v, arr)`

JSDoc:

@internal

## arraySpliceOut

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/array.js`

Signature: `arraySpliceOut(mutate, at, arr)`

JSDoc:

@internal

## arraySpliceIn

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/array.js`

Signature: `arraySpliceIn(mutate, at, v, arr)`

JSDoc:

@internal

## popcount

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/bitwise.js`

Signature: `popcount(x)`

JSDoc:

Hamming weight.

Taken from: http://jsperf.com/hamming-weight

@internal

## hashFragment

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/bitwise.js`

Signature: `hashFragment(shift, h)`

JSDoc:

@internal

## toBitmap

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/bitwise.js`

Signature: `toBitmap(x)`

JSDoc:

@internal

## fromBitmap

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/bitwise.js`

Signature: `fromBitmap(bitmap, bit)`

JSDoc:

@internal

## keySet

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/keySet.js`

Signature: `keySet(self)`

JSDoc:

@internal

## isEmptyNode

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/node.js`

Signature: `isEmptyNode(a)`

JSDoc:

@internal */
export class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash, key, size) {
    const v = f(O.none());
    if (O.isNone(v)) return new EmptyNode();
    ++size.value;
    return new LeafNode(edit, hash, key, v);
  }
}
/** @internal

## isLeafNode

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/node.js`

Signature: `isLeafNode(node)`

JSDoc:

@internal

## canEditNode

Source: `my-backend/node_modules/effect/dist/esm/internal/hashMap/node.js`

Signature: `canEditNode(node, edit)`

JSDoc:

@internal

## fromEffectContext

Source: `my-backend/node_modules/effect/dist/esm/internal/layer.js`

Signature: `fromEffectContext(effect)`

JSDoc:

@internal */
const LayerSymbolKey = "effect/Layer";
/** @internal */
export const LayerTypeId = /*#__PURE__*/Symbol.for(LayerSymbolKey);
const layerVariance = {
  /* c8 ignore next */
  _RIn: _ => _,
  /* c8 ignore next */
  _E: _ => _,
  /* c8 ignore next */
  _ROut: _ => _
};
/** @internal */
export const proto = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
/** @internal */
const MemoMapTypeIdKey = "effect/Layer/MemoMap";
/** @internal */
export const MemoMapTypeId = /*#__PURE__*/Symbol.for(MemoMapTypeIdKey);
/** @internal */
export const CurrentMemoMap = /*#__PURE__*/Context.Reference()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
/** @internal */
export const isLayer = u => hasProperty(u, LayerTypeId);
/** @internal */
export const isFresh = self => {
  return self._op_layer === OpCodes.OP_FRESH;
};
// -----------------------------------------------------------------------------
// MemoMap
// -----------------------------------------------------------------------------
/** @internal */
class MemoMapImpl {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
Checks the memo map to see if a layer exists. If it is, immediately
returns it. Otherwise, obtains the layer, stores it in the memo map,
and adds a finalizer to the `Scope`.
/
  getOrElseMemoize(layer, scope) {
    return pipe(synchronized.modifyEffect(this.ref, map => {
      const inMap = map.get(layer);
      if (inMap !== undefined) {
        const [acquire, release] = inMap;
        const cached = pipe(acquire, core.flatMap(([patch, b]) => pipe(effect.patchFiberRefs(patch), core.as(b))), core.onExit(core.exitMatch({
          onFailure: () => core.void,
          onSuccess: () => core.scopeAddFinalizerExit(scope, release)
        })));
        return core.succeed([cached, map]);
      }
      return pipe(ref.make(0), core.flatMap(observers => pipe(core.deferredMake(), core.flatMap(deferred => pipe(ref.make(() => core.void), core.map(finalizerRef => {
        const resource = core.uninterruptibleMask(restore => pipe(fiberRuntime.scopeMake(), core.flatMap(innerScope => pipe(restore(core.flatMap(makeBuilder(layer, innerScope, true), f => effect.diffFiberRefs(f(this)))), core.exit, core.flatMap(exit => {
          switch (exit._tag) {
            case EffectOpCodes.OP_FAILURE:
              {
                return pipe(core.deferredFailCause(deferred, exit.effect_instruction_i0), core.zipRight(core.scopeClose(innerScope, exit)), core.zipRight(core.failCause(exit.effect_instruction_i0)));
              }
            case EffectOpCodes.OP_SUCCESS:
              {
                return pipe(ref.set(finalizerRef, exit => pipe(core.scopeClose(innerScope, exit), core.whenEffect(ref.modify(observers, n => [n === 1, n - 1])), core.asVoid)), core.zipRight(ref.update(observers, n => n + 1)), core.zipRight(core.scopeAddFinalizerExit(scope, exit => pipe(core.sync(() => map.delete(layer)), core.zipRight(ref.get(finalizerRef)), core.flatMap(finalizer => finalizer(exit))))), core.zipRight(core.deferredSucceed(deferred, exit.effect_instruction_i0)), core.as(exit.effect_instruction_i0[1]));
              }
          }
        })))));
        const memoized = [pipe(core.deferredAwait(deferred), core.onExit(core.exitMatchEffect({
          onFailure: () => core.void,
          onSuccess: () => ref.update(observers, n => n + 1)
        }))), exit => pipe(ref.get(finalizerRef), core.flatMap(finalizer => finalizer(exit)))];
        return [resource, isFresh(layer) ? map : map.set(layer, memoized)];
      }))))));
    }), core.flatten);
  }
}
/** @internal */
export const makeMemoMap = /*#__PURE__*/core.suspend(() => core.map(circular.makeSynchronized(new Map()), ref => new MemoMapImpl(ref)));
/** @internal */
export const unsafeMakeMemoMap = () => new MemoMapImpl(circular.unsafeMakeSynchronized(new Map()));
/** @internal */
export const build = self => fiberRuntime.scopeWith(scope => buildWithScope(self, scope));
/** @internal */
export const buildWithScope = /*#__PURE__*/dual(2, (self, scope) => core.flatMap(makeMemoMap, memoMap => buildWithMemoMap(self, memoMap, scope)));
/** @internal */
export const buildWithMemoMap = /*#__PURE__*/dual(3, (self, memoMap, scope) => core.flatMap(makeBuilder(self, scope), run => effect.provideService(run(memoMap), CurrentMemoMap, memoMap)));
const makeBuilder = (self, scope, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally":
      {
        return core.sync(() => memoMap => op.f(memoMap.getOrElseMemoize(op.self, scope)));
      }
    case "ExtendScope":
      {
        return core.sync(() => memoMap => fiberRuntime.scopeWith(scope => memoMap.getOrElseMemoize(op.layer, scope)));
      }
    case "Fold":
      {
        return core.sync(() => memoMap => pipe(memoMap.getOrElseMemoize(op.layer, scope), core.matchCauseEffect({
          onFailure: cause => memoMap.getOrElseMemoize(op.failureK(cause), scope),
          onSuccess: value => memoMap.getOrElseMemoize(op.successK(value), scope)
        })));
      }
    case "Fresh":
      {
        return core.sync(() => _ => pipe(op.layer, buildWithScope(scope)));
      }
    case "FromEffect":
      {
        return inMemoMap ? core.sync(() => _ => op.effect) : core.sync(() => memoMap => memoMap.getOrElseMemoize(self, scope));
      }
    case "Provide":
      {
        return core.sync(() => memoMap => pipe(memoMap.getOrElseMemoize(op.first, scope), core.flatMap(env => pipe(memoMap.getOrElseMemoize(op.second, scope), core.provideContext(env)))));
      }
    case "Scoped":
      {
        return inMemoMap ? core.sync(() => _ => fiberRuntime.scopeExtend(op.effect, scope)) : core.sync(() => memoMap => memoMap.getOrElseMemoize(self, scope));
      }
    case "Suspend":
      {
        return core.sync(() => memoMap => memoMap.getOrElseMemoize(op.evaluate(), scope));
      }
    case "ProvideMerge":
      {
        return core.sync(() => memoMap => pipe(memoMap.getOrElseMemoize(op.first, scope), core.zipWith(memoMap.getOrElseMemoize(op.second, scope), op.zipK)));
      }
    case "ZipWith":
      {
        return core.sync(() => memoMap => pipe(memoMap.getOrElseMemoize(op.first, scope), fiberRuntime.zipWithOptions(memoMap.getOrElseMemoize(op.second, scope), op.zipK, {
          concurrent: true
        })));
      }
  }
};
// -----------------------------------------------------------------------------
// Layer
// -----------------------------------------------------------------------------
/** @internal */
export const catchAll = /*#__PURE__*/dual(2, (self, onFailure) => match(self, {
  onFailure,
  onSuccess: succeedContext
}));
/** @internal */
export const catchAllCause = /*#__PURE__*/dual(2, (self, onFailure) => matchCause(self, {
  onFailure,
  onSuccess: succeedContext
}));
/** @internal */
export const die = defect => failCause(Cause.die(defect));
/** @internal */
export const dieSync = evaluate => failCauseSync(() => Cause.die(evaluate()));
/** @internal */
export const discard = self => map(self, () => Context.empty());
/** @internal */
export const context = () => fromEffectContext(core.context());
/** @internal */
export const extendScope = self => {
  const extendScope = Object.create(proto);
  extendScope._op_layer = OpCodes.OP_EXTEND_SCOPE;
  extendScope.layer = self;
  return extendScope;
};
/** @internal */
export const fail = error => failCause(Cause.fail(error));
/** @internal */
export const failSync = evaluate => failCauseSync(() => Cause.fail(evaluate()));
/** @internal */
export const failCause = cause => fromEffectContext(core.failCause(cause));
/** @internal */
export const failCauseSync = evaluate => fromEffectContext(core.failCauseSync(evaluate));
/** @internal */
export const flatMap = /*#__PURE__*/dual(2, (self, f) => match(self, {
  onFailure: fail,
  onSuccess: f
}));
/** @internal */
export const flatten = /*#__PURE__*/dual(2, (self, tag) => flatMap(self, Context.get(tag)));
/** @internal */
export const fresh = self => {
  const fresh = Object.create(proto);
  fresh._op_layer = OpCodes.OP_FRESH;
  fresh.layer = self;
  return fresh;
};
/** @internal */
export const fromEffect = /*#__PURE__*/dual(2, (a, b) => {
  const tagFirst = Context.isTag(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return fromEffectContext(core.map(effect, service => Context.make(tag, service)));
});
/** @internal */
export const fromEffectDiscard = effect => fromEffectContext(core.map(effect, () => Context.empty()));
/** @internal

## swap

Source: `my-backend/node_modules/effect/dist/esm/internal/redBlackTree/node.js`

Signature: `swap(n, v)`

JSDoc:

@internal */
export const Color = {
  Red: 0,
  Black: 1 << 0
};
/** @internal */
export const clone = ({
  color,
  count,
  key,
  left,
  right,
  value
}) => ({
  color,
  key,
  value,
  left,
  right,
  count
});
/** @internal

## refined

Source: `my-backend/node_modules/effect/src/Brand.ts`

Signature: `refined(<A extends Brand<any>>(
  f: (unbranded: Brand.Unbranded<A>)`

JSDoc:

This module provides types and utility functions to create and work with branded types,
which are TypeScript types with an added type tag to prevent accidental usage of a value in the wrong context.

The `refined` and `nominal` functions are both used to create branded types in TypeScript.
The main difference between them is that `refined` allows for validation of the data, while `nominal` does not.

The `nominal` function is used to create a new branded type that has the same underlying type as the input, but with a different name.
This is useful when you want to distinguish between two values of the same type that have different meanings.
The `nominal` function does not perform any validation of the input data.

On the other hand, the `refined` function is used to create a new branded type that has the same underlying type as the input,
but with a different name, and it also allows for validation of the input data.
The `refined` function takes a predicate that is used to validate the input data.
If the input data fails the validation, a `BrandErrors` is returned, which provides information about the specific validation failure.

@since 2.0.0
/
import * as Arr from "./Array.js"
import * as Either from "./Either.js"
import { identity, unsafeCoerce } from "./Function.js"
import * as Option from "./Option.js"
import type { Predicate } from "./Predicate.js"
import type * as Types from "./Types.js"

/**
@since 2.0.0
@category symbols
/
export const BrandTypeId: unique symbol = Symbol.for("effect/Brand")

/**
@since 2.0.0
@category symbols
/
export type BrandTypeId = typeof BrandTypeId

/**
@since 2.0.0
@category symbols
/
export const RefinedConstructorsTypeId: unique symbol = Symbol.for("effect/Brand/Refined")

/**
@since 2.0.0
@category symbols
/
export type RefinedConstructorsTypeId = typeof RefinedConstructorsTypeId

/**
A generic interface that defines a branded type.

@since 2.0.0
@category models
/
export interface Brand<in out K extends string | symbol> {
  readonly [BrandTypeId]: {
    readonly [k in K]: K
  }
}

/**
@since 2.0.0
/
export declare namespace Brand {
  /**
Represents a list of refinement errors.

@since 2.0.0
@category models
/
  export interface BrandErrors extends Array<RefinementError> {}

  /**
Represents an error that occurs when the provided value of the branded type does not pass the refinement predicate.

@since 2.0.0
@category models
/
  export interface RefinementError {
    readonly meta: unknown
    readonly message: string
  }

  /**
@since 2.0.0
@category models
/
  export interface Constructor<in out A extends Brand<any>> {
    readonly [RefinedConstructorsTypeId]: RefinedConstructorsTypeId
    /**
Constructs a branded type from a value of type `A`, throwing an error if
the provided `A` is not valid.
/
    (args: Brand.Unbranded<A>): A
    /**
Constructs a branded type from a value of type `A`, returning `Some<A>`
if the provided `A` is valid, `None` otherwise.
/
    option(args: Brand.Unbranded<A>): Option.Option<A>
    /**
Constructs a branded type from a value of type `A`, returning `Right<A>`
if the provided `A` is valid, `Left<BrandError>` otherwise.
/
    either(args: Brand.Unbranded<A>): Either.Either<A, Brand.BrandErrors>
    /**
Attempts to refine the provided value of type `A`, returning `true` if
the provided `A` is valid, `false` otherwise.
/
    is(a: Brand.Unbranded<A>): a is Brand.Unbranded<A> & A
  }

  /**
A utility type to extract a branded type from a `Brand.Constructor`.

@since 2.0.0
@category models
/
  export type FromConstructor<A> = A extends Brand.Constructor<infer B> ? B : never

  /**
A utility type to extract the value type from a brand.

@since 2.0.0
@category models
/
  export type Unbranded<P> = P extends infer Q & Brands<P> ? Q : P

  /**
A utility type to extract the brands from a branded type.

@since 2.0.0
@category models
/
  export type Brands<P> = P extends Brand<any> ? Types.UnionToIntersection<
      {
        [k in keyof P[BrandTypeId]]: k extends string | symbol ? Brand<k>
          : never
      }[keyof P[BrandTypeId]]
    >
    : never

  /**
A utility type that checks that all brands have the same base type.

@since 2.0.0
@category models
/
  export type EnsureCommonBase<
    Brands extends readonly [Brand.Constructor<any>, ...Array<Brand.Constructor<any>>]
  > = {
    [B in keyof Brands]: Brand.Unbranded<Brand.FromConstructor<Brands[0]>> extends
      Brand.Unbranded<Brand.FromConstructor<Brands[B]>>
      ? Brand.Unbranded<Brand.FromConstructor<Brands[B]>> extends Brand.Unbranded<Brand.FromConstructor<Brands[0]>>
        ? Brands[B]
      : Brands[B]
      : "ERROR: All brands should have the same base type"
  }
}

/**
@category alias
@since 2.0.0
/
export type Branded<A, K extends string | symbol> = A & Brand<K>

/**
Returns a `BrandErrors` that contains a single `RefinementError`.

@since 2.0.0
@category constructors
/
export const error = (message: string, meta?: unknown): Brand.BrandErrors => [{
  message,
  meta
}]

/**
Takes a variable number of `BrandErrors` and returns a single `BrandErrors` that contains all refinement errors.

@since 2.0.0
@category constructors
/
export const errors: (...errors: Array<Brand.BrandErrors>) => Brand.BrandErrors = (
  ...errors: Array<Brand.BrandErrors>
): Brand.BrandErrors => Arr.flatten(errors)

/**
Returns a `Brand.Constructor` that can construct a branded type from an unbranded value using the provided `refinement`
predicate as validation of the input data.

If you don't want to perform any validation but only distinguish between two values of the same type but with different meanings,
see {@link nominal}.

**Example**

```ts
import * as assert from "node:assert"
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">

const Int = Brand.refined<Int>(
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)

console.log(Int(1))
// 1

assert.throws(() => Int(1.1))
```

@since 2.0.0
@category constructors

## equals

Source: `my-backend/node_modules/effect/src/Equal.ts`

Signature: `equals(<B>(that: B)`

JSDoc:

@since 2.0.0
/
import type { Equivalence } from "./Equivalence.js"
import * as Hash from "./Hash.js"
import { hasProperty } from "./Predicate.js"
import { structuralRegionState } from "./Utils.js"

/**
@since 2.0.0
@category symbols
/
export const symbol: unique symbol = Symbol.for("effect/Equal")

/**
@since 2.0.0
@category models
/
export interface Equal extends Hash.Hash {
  [symbol](that: Equal): boolean
}

/**
@since 2.0.0
@category equality

## pipe

Source: `my-backend/node_modules/effect/src/Function.ts`

Signature: `pipe(<A>(a: A)`

JSDoc:

@since 2.0.0
/
import type { TypeLambda } from "./HKT.js"

/**
@category type lambdas
@since 2.0.0
/
export interface FunctionTypeLambda extends TypeLambda {
  readonly type: (a: this["In"]) => this["Target"]
}

/**
Tests if a value is a `function`.

@example
```ts
import * as assert from "node:assert"
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)
assert.deepStrictEqual(isFunction("function"), false)
```

@category guards
@since 2.0.0
/
export const isFunction = (input: unknown): input is Function => typeof input === "function"

/**
Creates a function that can be used in a data-last (aka `pipe`able) or
data-first style.

The first parameter to `dual` is either the arity of the uncurried function
or a predicate that determines if the function is being used in a data-first
or data-last style.

Using the arity is the most common use case, but there are some cases where
you may want to use a predicate. For example, if you have a function that
takes an optional argument, you can use a predicate to determine if the
function is being used in a data-first or data-last style.

You can pass either the arity of the uncurried function or a predicate
which determines if the function is being used in a data-first or
data-last style.

**Example** (Using arity to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(2, (self, that) => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using call signatures to define the overloads)

```ts
import { dual, pipe } from "effect/Function"

const sum: {
  (that: number): (self: number) => number
  (self: number, that: number): number
} = dual(2, (self: number, that: number): number => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using a predicate to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(
  (args) => args.length === 2,
  (self, that) => self + that
)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

@since 2.0.0
/
export const dual: {
  /**
Creates a function that can be used in a data-last (aka `pipe`able) or
data-first style.

The first parameter to `dual` is either the arity of the uncurried function
or a predicate that determines if the function is being used in a data-first
or data-last style.

Using the arity is the most common use case, but there are some cases where
you may want to use a predicate. For example, if you have a function that
takes an optional argument, you can use a predicate to determine if the
function is being used in a data-first or data-last style.

You can pass either the arity of the uncurried function or a predicate
which determines if the function is being used in a data-first or
data-last style.

**Example** (Using arity to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(2, (self, that) => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using call signatures to define the overloads)

```ts
import { dual, pipe } from "effect/Function"

const sum: {
  (that: number): (self: number) => number
  (self: number, that: number): number
} = dual(2, (self: number, that: number): number => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using a predicate to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(
  (args) => args.length === 2,
  (self, that) => self + that
)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

@since 2.0.0
/
  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(arity: Parameters<DataFirst>["length"], body: DataFirst): DataLast & DataFirst
  /**
Creates a function that can be used in a data-last (aka `pipe`able) or
data-first style.

The first parameter to `dual` is either the arity of the uncurried function
or a predicate that determines if the function is being used in a data-first
or data-last style.

Using the arity is the most common use case, but there are some cases where
you may want to use a predicate. For example, if you have a function that
takes an optional argument, you can use a predicate to determine if the
function is being used in a data-first or data-last style.

You can pass either the arity of the uncurried function or a predicate
which determines if the function is being used in a data-first or
data-last style.

**Example** (Using arity to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(2, (self, that) => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using call signatures to define the overloads)

```ts
import { dual, pipe } from "effect/Function"

const sum: {
  (that: number): (self: number) => number
  (self: number, that: number): number
} = dual(2, (self: number, that: number): number => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

**Example** (Using a predicate to determine data-first or data-last style)

```ts
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(
  (args) => args.length === 2,
  (self, that) => self + that
)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5
```

@since 2.0.0
/
  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(isDataFirst: (args: IArguments) => boolean, body: DataFirst): DataLast & DataFirst
} = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        // @ts-expect-error
        return body.apply(this, arguments)
      }
      return ((self: any) => body(self, ...arguments)) as any
    }
  }

  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`)

    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b)
        }
        return function(self: any) {
          return body(self, a)
        }
      }

    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c)
        }
        return function(self: any) {
          return body(self, a, b)
        }
      }

    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d)
        }
        return function(self: any) {
          return body(self, a, b, c)
        }
      }

    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e)
        }
        return function(self: any) {
          return body(self, a, b, c, d)
        }
      }

    default:
      return function() {
        if (arguments.length >= arity) {
          // @ts-expect-error
          return body.apply(this, arguments)
        }
        const args = arguments
        return function(self: any) {
          return body(self, ...args)
        }
      }
  }
}
/**
Apply a function to given values.

@example
```ts
import * as assert from "node:assert"
import { pipe, apply } from "effect/Function"
import { length } from "effect/String"

assert.deepStrictEqual(pipe(length, apply("hello")), 5)
```

@since 2.0.0
/
export const apply = <A extends ReadonlyArray<unknown>>(...a: A) => <B>(self: (...a: A) => B): B => self(...a)

/**
A lazy argument.

@example
```ts
import * as assert from "node:assert"
import { LazyArg, constant } from "effect/Function"

const constNull: LazyArg<null> = constant(null)
```

@since 2.0.0
/
export interface LazyArg<A> {
  (): A
}

/**
@example
```ts
import * as assert from "node:assert"
import { FunctionN } from "effect/Function"

const sum: FunctionN<[number, number], number> = (a, b) => a + b
```

@since 2.0.0
/
export interface FunctionN<A extends ReadonlyArray<unknown>, B> {
  (...args: A): B
}

/**
The identity function, i.e. A function that returns its input argument.

@example
```ts
import * as assert from "node:assert"
import { identity } from "effect/Function"

assert.deepStrictEqual(identity(5), 5)
```

@since 2.0.0
/
export const identity = <A>(a: A): A => a

/**
A function that ensures that the type of an expression matches some type,
without changing the resulting type of that expression.

@example
```ts
import * as assert from "node:assert"
import { satisfies } from "effect/Function"

const test1 = satisfies<number>()(5 as const)
    //^? const test: 5
    // @ts-expect-error
const test2 = satisfies<string>()(5)
    //^? Argument of type 'number' is not assignable to parameter of type 'string'

assert.deepStrictEqual(satisfies<number>()(5), 5)
```

@since 2.0.0
/
export const satisfies = <A>() => <B extends A>(b: B) => b

/**
Casts the result to the specified type.

@example
```ts
import * as assert from "node:assert"
import { unsafeCoerce, identity } from "effect/Function"

assert.deepStrictEqual(unsafeCoerce, identity)
```

@since 2.0.0
/
export const unsafeCoerce: <A, B>(a: A) => B = identity as any

/**
Creates a constant value that never changes.

This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)
and want that inner function to always use the same value, no matter how many times it is called.

@example
```ts
import * as assert from "node:assert"
import { constant } from "effect/Function"

const constNull = constant(null)

assert.deepStrictEqual(constNull(), null)
assert.deepStrictEqual(constNull(), null)
```

@since 2.0.0
/
export const constant = <A>(value: A): LazyArg<A> => () => value

/**
A thunk that returns always `true`.

@example
```ts
import * as assert from "node:assert"
import { constTrue } from "effect/Function"

assert.deepStrictEqual(constTrue(), true)
```

@since 2.0.0
/
export const constTrue: LazyArg<boolean> = constant(true)

/**
A thunk that returns always `false`.

@example
```ts
import * as assert from "node:assert"
import { constFalse } from "effect/Function"

assert.deepStrictEqual(constFalse(), false)
```

@since 2.0.0
/
export const constFalse: LazyArg<boolean> = constant(false)

/**
A thunk that returns always `null`.

@example
```ts
import * as assert from "node:assert"
import { constNull } from "effect/Function"

assert.deepStrictEqual(constNull(), null)
```

@since 2.0.0
/
export const constNull: LazyArg<null> = constant(null)

/**
A thunk that returns always `undefined`.

@example
```ts
import * as assert from "node:assert"
import { constUndefined } from "effect/Function"

assert.deepStrictEqual(constUndefined(), undefined)
```

@since 2.0.0
/
export const constUndefined: LazyArg<undefined> = constant(undefined)

/**
A thunk that returns always `void`.

@example
```ts
import * as assert from "node:assert"
import { constVoid } from "effect/Function"

assert.deepStrictEqual(constVoid(), undefined)
```

@since 2.0.0
/
export const constVoid: LazyArg<void> = constUndefined

/**
Reverses the order of arguments for a curried function.

@example
```ts
import * as assert from "node:assert"
import { flip } from "effect/Function"

const f = (a: number) => (b: string) => a - b.length

assert.deepStrictEqual(flip(f)('aaa')(2), -1)
```

@since 2.0.0
/
export const flip = <A extends Array<unknown>, B extends Array<unknown>, C>(
  f: (...a: A) => (...b: B) => C
): (...b: B) => (...a: A) => C =>
(...b) =>
(...a) => f(...a)(...b)

/**
Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.
The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.

@example
```ts
import * as assert from "node:assert"
import { compose } from "effect/Function"

const increment = (n: number) => n + 1;
const square = (n: number) => n * n;

assert.strictEqual(compose(increment, square)(2), 9);
```

@since 2.0.0
/
export const compose: {
  /**
Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.
The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.

@example
```ts
import * as assert from "node:assert"
import { compose } from "effect/Function"

const increment = (n: number) => n + 1;
const square = (n: number) => n * n;

assert.strictEqual(compose(increment, square)(2), 9);
```

@since 2.0.0
/
  <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C
  /**
Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.
The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.

@example
```ts
import * as assert from "node:assert"
import { compose } from "effect/Function"

const increment = (n: number) => n + 1;
const square = (n: number) => n * n;

assert.strictEqual(compose(increment, square)(2), 9);
```

@since 2.0.0
/
  <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C
} = dual(2, <A, B, C>(ab: (a: A) => B, bc: (b: B) => C): (a: A) => C => (a) => bc(ab(a)))

/**
The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,
meaning that it should be impossible for this code to be executed.

This function is particularly useful when it's necessary to specify that certain cases are impossible.

@since 2.0.0
/
export const absurd = <A>(_: never): A => {
  throw new Error("Called `absurd` function which should be uncallable")
}

/**
Creates a   version of this function: instead of `n` arguments, it accepts a single tuple argument.

@example
```ts
import * as assert from "node:assert"
import { tupled } from "effect/Function"

const sumTupled = tupled((x: number, y: number): number => x + y)

assert.deepStrictEqual(sumTupled([1, 2]), 3)
```

@since 2.0.0
/
export const tupled = <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): (a: A) => B => (a) => f(...a)

/**
Inverse function of `tupled`

@example
```ts
import * as assert from "node:assert"
import { untupled } from "effect/Function"

const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])

assert.deepStrictEqual(getFirst(1, 2), 1)
```

@since 2.0.0
/
export const untupled = <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B): (...a: A) => B => (...a) => f(a)

/**
Pipes the value of an expression into a pipeline of functions.

**Details**

The `pipe` function is a utility that allows us to compose functions in a
readable and sequential manner. It takes the output of one function and
passes it as the input to the next function in the pipeline. This enables us
to build complex transformations by chaining multiple functions together.

```ts skip-type-checking
import { pipe } from "effect"

const result = pipe(input, func1, func2, ..., funcN)
```

In this syntax, `input` is the initial value, and `func1`, `func2`, ...,
`funcN` are the functions to be applied in sequence. The result of each
function becomes the input for the next function, and the final result is
returned.

Here's an illustration of how `pipe` works:

```
                    
 input  func1  func2   ...   funcN  result 
                    
```

It's important to note that functions passed to `pipe` must have a **single
argument** because they are only called with a single argument.

**When to Use**

This is useful in combination with data-last functions as a simulation of
methods:

```ts skip-type-checking
as.map(f).filter(g)
```

becomes:

```ts skip-type-checking
import { pipe, Array } from "effect"

pipe(as, Array.map(f), Array.filter(g))
```

**Example** (Chaining Arithmetic Operations)

```ts
import { pipe } from "effect"

// Define simple arithmetic operations
const increment = (x: number) => x + 1
const double = (x: number) => x * 2
const subtractTen = (x: number) => x - 10

// Sequentially apply these operations using `pipe`
const result = pipe(5, increment, double, subtractTen)

console.log(result)
// Output: 2
```

@since 2.0.0

## flow

Source: `my-backend/node_modules/effect/src/Function.ts`

Signature: `flow(<A extends ReadonlyArray<unknown>, B = never>(
  ab: (...a: A)`

JSDoc:

Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.

See also [`pipe`](#pipe).

@example
```ts
import * as assert from "node:assert"
import { flow } from "effect/Function"

const len = (s: string): number => s.length
const double = (n: number): number => n * 2

const f = flow(len, double)

assert.strictEqual(f('aaa'), 6)
```

@since 2.0.0

## getRefinementExpected

Source: `my-backend/node_modules/effect/src/ParseResult.ts`

Signature: `getRefinementExpected(ast: AST.Refinement)`

JSDoc:

@since 3.10.0
/

import * as Arr from "./Array.js"
import * as Cause from "./Cause.js"
import { TaggedError } from "./Data.js"
import * as Effect from "./Effect.js"
import * as Either from "./Either.js"
import * as Exit from "./Exit.js"
import type { LazyArg } from "./Function.js"
import { dual } from "./Function.js"
import { globalValue } from "./GlobalValue.js"
import * as Inspectable from "./Inspectable.js"
import * as util_ from "./internal/schema/util.js"
import * as Option from "./Option.js"
import * as Predicate from "./Predicate.js"
import * as Scheduler from "./Scheduler.js"
import type * as Schema from "./Schema.js"
import * as AST from "./SchemaAST.js"
import type { Concurrency } from "./Types.js"

/**
`ParseIssue` is a type that represents the different types of errors that can occur when decoding/encoding a value.

@category model
@since 3.10.0
/
export type ParseIssue =
  // leaf
  | Type
  | Missing
  | Unexpected
  | Forbidden
  // composite
  | Pointer
  | Refinement
  | Transformation
  | Composite

/**
@category model
@since 3.10.0
/
export type SingleOrNonEmpty<A> = A | Arr.NonEmptyReadonlyArray<A>

/**
@category model
@since 3.10.0
/
export type Path = SingleOrNonEmpty<PropertyKey>

/**
@category model
@since 3.10.0
/
export class Pointer {
  /**
@since 3.10.0
/
  readonly _tag = "Pointer"
  constructor(
    readonly path: Path,
    readonly actual: unknown,
    readonly issue: ParseIssue
  ) {}
}

/**
Error that occurs when an unexpected key or index is present.

@category model
@since 3.10.0
/
export class Unexpected {
  /**
@since 3.10.0
/
  readonly _tag = "Unexpected"
  constructor(
    readonly actual: unknown,
    /**
@since 3.10.0
/
    readonly message?: string
  ) {}
}

/**
Error that occurs when a required key or index is missing.

@category model
@since 3.10.0
/
export class Missing {
  /**
@since 3.10.0
/
  readonly _tag = "Missing"
  /**
@since 3.10.0
/
  readonly actual = undefined
  constructor(
    /**
@since 3.10.0
/
    readonly ast: AST.Type,
    /**
@since 3.10.0
/
    readonly message?: string
  ) {}
}

/**
Error that contains multiple issues.

@category model
@since 3.10.0
/
export class Composite {
  /**
@since 3.10.0
/
  readonly _tag = "Composite"
  constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly issues: SingleOrNonEmpty<ParseIssue>,
    readonly output?: unknown
  ) {}
}

/**
Error that occurs when a refinement has an error.

@category model
@since 3.10.0
/
export class Refinement {
  /**
@since 3.10.0
/
  readonly _tag = "Refinement"
  constructor(
    readonly ast: AST.Refinement,
    readonly actual: unknown,
    readonly kind: "From" | "Predicate",
    readonly issue: ParseIssue
  ) {}
}

/**
Error that occurs when a transformation has an error.

@category model
@since 3.10.0
/
export class Transformation {
  /**
@since 3.10.0
/
  readonly _tag = "Transformation"
  constructor(
    readonly ast: AST.Transformation,
    readonly actual: unknown,
    readonly kind: "Encoded" | "Transformation" | "Type",
    readonly issue: ParseIssue
  ) {}
}

/**
The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.

@category model
@since 3.10.0
/
export class Type {
  /**
@since 3.10.0
/
  readonly _tag = "Type"
  constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly message?: string
  ) {}
}

/**
The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).

@category model
@since 3.10.0
/
export class Forbidden {
  /**
@since 3.10.0
/
  readonly _tag = "Forbidden"
  constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly message?: string
  ) {}
}

/**
@category type id
@since 3.10.0
/
export const ParseErrorTypeId: unique symbol = Symbol.for("effect/Schema/ParseErrorTypeId")

/**
@category type id
@since 3.10.0
/
export type ParseErrorTypeId = typeof ParseErrorTypeId

/**
@since 3.10.0
/
export const isParseError = (u: unknown): u is ParseError => Predicate.hasProperty(u, ParseErrorTypeId)

/**
@since 3.10.0
/
export class ParseError extends TaggedError("ParseError")<{ readonly issue: ParseIssue }> {
  /**
@since 3.10.0
/
  readonly [ParseErrorTypeId] = ParseErrorTypeId

  get message() {
    return this.toString()
  }
  /**
@since 3.10.0
/
  toString() {
    return TreeFormatter.formatIssueSync(this.issue)
  }
  /**
@since 3.10.0
/
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    }
  }
  /**
@since 3.10.0
/
  [Inspectable.NodeInspectSymbol]() {
    return this.toJSON()
  }
}

/**
@category constructors
@since 3.10.0
/
export const parseError = (issue: ParseIssue): ParseError => new ParseError({ issue })

/**
@category constructors
@since 3.10.0
/
export const succeed: <A>(a: A) => Either.Either<A, ParseIssue> = Either.right

/**
@category constructors
@since 3.10.0
/
export const fail: (issue: ParseIssue) => Either.Either<never, ParseIssue> = Either.left

const _try: <A>(options: {
  try: LazyArg<A>
  catch: (e: unknown) => ParseIssue
}) => Either.Either<A, ParseIssue> = Either.try

export {
  /**
@category constructors
@since 3.10.0
/
  _try as try
}

/**
@category constructors
@since 3.10.0
/
export const fromOption: {
  /**
@category constructors
@since 3.10.0
/
  (onNone: () => ParseIssue): <A>(self: Option.Option<A>) => Either.Either<A, ParseIssue>
  /**
@category constructors
@since 3.10.0
/
  <A>(self: Option.Option<A>, onNone: () => ParseIssue): Either.Either<A, ParseIssue>
} = Either.fromOption

const isEither: <A, E, R>(self: Effect.Effect<A, E, R>) => self is Either.Either<A, E> = Either.isEither as any

/**
@category optimisation
@since 3.10.0
/
export const flatMap: {
  /**
@category optimisation
@since 3.10.0
/
  <A, B, E1, R1>(f: (a: A) => Effect.Effect<B, E1, R1>): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>
  /**
@category optimisation
@since 3.10.0
/
  <A, E, R, B, E1, R1>(self: Effect.Effect<A, E, R>, f: (a: A) => Effect.Effect<B, E1, R1>): Effect.Effect<B, E | E1, R | R1>
} = dual(2, <A, E, R, B, E1, R1>(
  self: Effect.Effect<A, E, R>,
  f: (a: A) => Effect.Effect<B, E1, R1>
): Effect.Effect<B, E | E1, R | R1> => {
  return isEither(self) ?
    Either.match(self, { onLeft: Either.left, onRight: f }) :
    Effect.flatMap(self, f)
})

/**
@category optimisation
@since 3.10.0
/
export const map: {
  /**
@category optimisation
@since 3.10.0
/
  <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>
  /**
@category optimisation
@since 3.10.0
/
  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>
} = dual(2, <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R> => {
  return isEither(self) ?
    Either.map(self, f) :
    Effect.map(self, f)
})

/**
@category optimisation
@since 3.10.0
/
export const mapError: {
  /**
@category optimisation
@since 3.10.0
/
  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>
  /**
@category optimisation
@since 3.10.0
/
  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>
} = dual(2, <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R> => {
  return isEither(self) ?
    Either.mapLeft(self, f) :
    Effect.mapError(self, f)
})

// TODO(4.0): remove
/**
@category optimisation
@since 3.10.0
/
export const eitherOrUndefined = <A, E, R>(
  self: Effect.Effect<A, E, R>
): Either.Either<A, E> | undefined => {
  if (isEither(self)) {
    return self
  }
}

/**
@category optimisation
@since 3.10.0
/
export const mapBoth: {
  /**
@category optimisation
@since 3.10.0
/
  <E, E2, A, A2>(
    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }
  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>
  /**
@category optimisation
@since 3.10.0
/
  <A, E, R, E2, A2>(
    self: Effect.Effect<A, E, R>,
    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }
  ): Effect.Effect<A2, E2, R>
} = dual(2, <A, E, R, E2, A2>(
  self: Effect.Effect<A, E, R>,
  options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }
): Effect.Effect<A2, E2, R> => {
  return isEither(self) ?
    Either.mapBoth(self, { onLeft: options.onFailure, onRight: options.onSuccess }) :
    Effect.mapBoth(self, options)
})

/**
@category optimisation
@since 3.10.0
/
export const orElse: {
  /**
@category optimisation
@since 3.10.0
/
  <E, A2, E2, R2>(f: (e: E) => Effect.Effect<A2, E2, R2>): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>
  /**
@category optimisation
@since 3.10.0
/
  <A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (e: E) => Effect.Effect<A2, E2, R2>): Effect.Effect<A2 | A, E2, R2 | R>
} = dual(2, <A, E, R, A2, E2, R2>(
  self: Effect.Effect<A, E, R>,
  f: (e: E) => Effect.Effect<A2, E2, R2>
): Effect.Effect<A2 | A, E2, R2 | R> => {
  return isEither(self) ?
    Either.match(self, { onLeft: f, onRight: Either.right }) :
    Effect.catchAll(self, f)
})

/**
@since 3.10.0
/
export type DecodeUnknown<Out, R> = (u: unknown, options?: AST.ParseOptions) => Effect.Effect<Out, ParseIssue, R>

/**
@since 3.10.0
/
export type DeclarationDecodeUnknown<Out, R> = (
  u: unknown,
  options: AST.ParseOptions,
  ast: AST.Declaration
) => Effect.Effect<Out, ParseIssue, R>

/** @internal */
export const mergeInternalOptions = (
  options: InternalOptions | undefined,
  overrideOptions: InternalOptions | number | undefined
): InternalOptions | undefined => {
  if (overrideOptions === undefined || Predicate.isNumber(overrideOptions)) {
    return options
  }
  if (options === undefined) {
    return overrideOptions
  }
  return { ...options, ...overrideOptions }
}

const getEither = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {
  const parser = goMemo(ast, isDecoding)
  return (u: unknown, overrideOptions?: AST.ParseOptions): Either.Either<any, ParseIssue> =>
    parser(u, mergeInternalOptions(options, overrideOptions)) as any
}

const getSync = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {
  const parser = getEither(ast, isDecoding, options)
  return (input: unknown, overrideOptions?: AST.ParseOptions) =>
    Either.getOrThrowWith(parser(input, overrideOptions), parseError)
}

/** @internal */
export const getOption = (ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {
  const parser = getEither(ast, isDecoding, options)
  return (input: unknown, overrideOptions?: AST.ParseOptions): Option.Option<any> =>
    Option.getRight(parser(input, overrideOptions))
}

const getEffect = <R>(ast: AST.AST, isDecoding: boolean, options?: AST.ParseOptions) => {
  const parser = goMemo(ast, isDecoding)
  return (input: unknown, overrideOptions?: AST.ParseOptions): Effect.Effect<any, ParseIssue, R> =>
    parser(input, { ...mergeInternalOptions(options, overrideOptions), isEffectAllowed: true })
}

/**
@throws `ParseError`
@category decoding
@since 3.10.0
/
export const decodeUnknownSync = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => A => getSync(schema.ast, true, options)

/**
@category decoding
@since 3.10.0
/
export const decodeUnknownOption = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A> => getOption(schema.ast, true, options)

/**
@category decoding
@since 3.10.0
/
export const decodeUnknownEither = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> =>
  getEither(schema.ast, true, options)

/**
@category decoding
@since 3.10.0
/
export const decodeUnknownPromise = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => {
  const parser = decodeUnknown(schema, options)
  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))
}

/**
@category decoding
@since 3.10.0
/
export const decodeUnknown = <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> =>
  getEffect(schema.ast, true, options)

/**
@throws `ParseError`
@category encoding
@since 3.10.0
/
export const encodeUnknownSync = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => I => getSync(schema.ast, false, options)

/**
@category encoding
@since 3.10.0
/
export const encodeUnknownOption = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<I> => getOption(schema.ast, false, options)

/**
@category encoding
@since 3.10.0
/
export const encodeUnknownEither = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue> =>
  getEither(schema.ast, false, options)

/**
@category encoding
@since 3.10.0
/
export const encodeUnknownPromise = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => {
  const parser = encodeUnknown(schema, options)
  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))
}

/**
@category encoding
@since 3.10.0
/
export const encodeUnknown = <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R> =>
  getEffect(schema.ast, false, options)

/**
@category decoding
@since 3.10.0
/
export const decodeSync: <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => (i: I, overrideOptions?: AST.ParseOptions) => A = decodeUnknownSync

/**
@category decoding
@since 3.10.0
/
export const decodeOption: <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => (i: I, overrideOptions?: AST.ParseOptions) => Option.Option<A> = decodeUnknownOption

/**
@category decoding
@since 3.10.0
/
export const decodeEither: <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => (i: I, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> = decodeUnknownEither

/**
@category decoding
@since 3.10.0
/
export const decodePromise: <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => (i: I, overrideOptions?: AST.ParseOptions) => Promise<A> = decodeUnknownPromise

/**
@category decoding
@since 3.10.0
/
export const decode: <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
) => (i: I, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> = decodeUnknown

/**
@throws `ParseError`
@category validation
@since 3.10.0
/
export const validateSync = <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => A => getSync(AST.typeAST(schema.ast), true, options)

/**
@category validation
@since 3.10.0
/
export const validateOption = <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => Option.Option<A> =>
  getOption(AST.typeAST(schema.ast), true, options)

/**
@category validation
@since 3.10.0
/
export const validateEither = <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
): (u: unknown, overrideOptions?: AST.ParseOptions) => Either.Either<A, ParseIssue> =>
  getEither(AST.typeAST(schema.ast), true, options)

/**
@category validation
@since 3.10.0
/
export const validatePromise = <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => {
  const parser = validate(schema, options)
  return (u: unknown, overrideOptions?: AST.ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))
}

/**
@category validation
@since 3.10.0
/
export const validate = <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
): (a: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<A, ParseIssue, R> =>
  getEffect(AST.typeAST(schema.ast), true, options)

/**
By default the option `exact` is set to `true`.

@category validation
@since 3.10.0
/
export const is = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => {
  const parser = goMemo(AST.typeAST(schema.ast), true)
  return (u: unknown, overrideOptions?: AST.ParseOptions | number): u is A =>
    Either.isRight(parser(u, { exact: true, ...mergeInternalOptions(options, overrideOptions) }) as any)
}

/**
By default the option `exact` is set to `true`.

@throws `ParseError`
@category validation
@since 3.10.0
/
export const asserts = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => {
  const parser = goMemo(AST.typeAST(schema.ast), true)
  return (u: unknown, overrideOptions?: AST.ParseOptions): asserts u is A => {
    const result: Either.Either<any, ParseIssue> = parser(u, {
      exact: true,
      ...mergeInternalOptions(options, overrideOptions)
    }) as any
    if (Either.isLeft(result)) {
      throw parseError(result.left)
    }
  }
}

/**
@category encoding
@since 3.10.0
/
export const encodeSync: <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => (a: A, overrideOptions?: AST.ParseOptions) => I = encodeUnknownSync

/**
@category encoding
@since 3.10.0
/
export const encodeOption: <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => (input: A, overrideOptions?: AST.ParseOptions) => Option.Option<I> = encodeUnknownOption

/**
@category encoding
@since 3.10.0
/
export const encodeEither: <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => (a: A, overrideOptions?: AST.ParseOptions) => Either.Either<I, ParseIssue> = encodeUnknownEither

/**
@category encoding
@since 3.10.0
/
export const encodePromise: <A, I>(
  schema: Schema.Schema<A, I, never>,
  options?: AST.ParseOptions
) => (a: A, overrideOptions?: AST.ParseOptions) => Promise<I> = encodeUnknownPromise

/**
@category encoding
@since 3.10.0
/
export const encode: <A, I, R>(
  schema: Schema.Schema<A, I, R>,
  options?: AST.ParseOptions
) => (a: A, overrideOptions?: AST.ParseOptions) => Effect.Effect<I, ParseIssue, R> = encodeUnknown

interface InternalOptions extends AST.ParseOptions {
  readonly isEffectAllowed?: boolean
}

interface Parser {
  (i: any, options?: InternalOptions): Effect.Effect<any, ParseIssue, any>
}

const decodeMemoMap = globalValue(
  Symbol.for("effect/ParseResult/decodeMemoMap"),
  () => new WeakMap<AST.AST, Parser>()
)
const encodeMemoMap = globalValue(
  Symbol.for("effect/ParseResult/encodeMemoMap"),
  () => new WeakMap<AST.AST, Parser>()
)

const goMemo = (ast: AST.AST, isDecoding: boolean): Parser => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap
  const memo = memoMap.get(ast)
  if (memo) {
    return memo
  }
  const raw = go(ast, isDecoding)
  const parseOptionsAnnotation = AST.getParseOptionsAnnotation(ast)
  const parserWithOptions: Parser = Option.isSome(parseOptionsAnnotation)
    ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value))
    : raw
  const decodingFallbackAnnotation = AST.getDecodingFallbackAnnotation(ast)
  const parser: Parser = isDecoding && Option.isSome(decodingFallbackAnnotation)
    ? (i, options) =>
      handleForbidden(orElse(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options)
    : parserWithOptions
  memoMap.set(ast, parser)
  return parser
}

const getConcurrency = (ast: AST.AST): Concurrency | undefined =>
  Option.getOrUndefined(AST.getConcurrencyAnnotation(ast))

const getBatching = (ast: AST.AST): boolean | "inherit" | undefined =>
  Option.getOrUndefined(AST.getBatchingAnnotation(ast))

const go = (ast: AST.AST, isDecoding: boolean): Parser => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true)
        return (i, options) => {
          options = options ?? AST.defaultParseOption
          const allErrors = options?.errors === "all"
          const result = flatMap(
            orElse(from(i, options), (ef) => {
              const issue = new Refinement(ast, i, "From", ef)
              if (allErrors && AST.hasStableFilter(ast) && isComposite(ef)) {
                return Option.match(
                  ast.filter(i, options, ast),
                  {
                    onNone: () => Either.left<ParseIssue>(issue),
                    onSome: (ep) => Either.left(new Composite(ast, i, [issue, new Refinement(ast, i, "Predicate", ep)]))
                  }
                )
              }
              return Either.left(issue)
            }),
            (a) =>
              Option.match(
                ast.filter(a, options, ast),
                {
                  onNone: () => Either.right(a),
                  onSome: (ep) => Either.left(new Refinement(ast, i, "Predicate", ep))
                }
              )
          )
          return handleForbidden(result, ast, i, options)
        }
      } else {
        const from = goMemo(AST.typeAST(ast), true)
        const to = goMemo(dropRightRefinement(ast.from), false)
        return (i, options) => handleForbidden(flatMap(from(i, options), (a) => to(a, options)), ast, i, options)
      }
    }
    case "Transformation": {
      const transform = getFinalTransformation(ast.transformation, isDecoding)
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false)
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false)
      return (i, options) =>
        handleForbidden(
          flatMap(
            mapError(
              from(i, options),
              (e) => new Transformation(ast, i, isDecoding ? "Encoded" : "Type", e)
            ),
            (a) =>
              flatMap(
                mapError(
                  transform(a, options ?? AST.defaultParseOption, ast, i),
                  (e) => new Transformation(ast, i, "Transformation", e)
                ),
                (i2) =>
                  mapError(
                    to(i2, options),
                    (e) => new Transformation(ast, i, isDecoding ? "Type" : "Encoded", e)
                  )
              )
          ),
          ast,
          i,
          options
        )
    }
    case "Declaration": {
      const parse = isDecoding
        ? ast.decodeUnknown(...ast.typeParameters)
        : ast.encodeUnknown(...ast.typeParameters)
      return (i, options) => handleForbidden(parse(i, options ?? AST.defaultParseOption, ast), ast, i, options)
    }
    case "Literal":
      return fromRefinement(ast, (u): u is typeof ast.literal => u === ast.literal)
    case "UniqueSymbol":
      return fromRefinement(ast, (u): u is typeof ast.symbol => u === ast.symbol)
    case "UndefinedKeyword":
      return fromRefinement(ast, Predicate.isUndefined)
    case "NeverKeyword":
      return fromRefinement(ast, Predicate.isNever)
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return Either.right
    case "StringKeyword":
      return fromRefinement(ast, Predicate.isString)
    case "NumberKeyword":
      return fromRefinement(ast, Predicate.isNumber)
    case "BooleanKeyword":
      return fromRefinement(ast, Predicate.isBoolean)
    case "BigIntKeyword":
      return fromRefinement(ast, Predicate.isBigInt)
    case "SymbolKeyword":
      return fromRefinement(ast, Predicate.isSymbol)
    case "ObjectKeyword":
      return fromRefinement(ast, Predicate.isObject)
    case "Enums":
      return fromRefinement(ast, (u): u is any => ast.enums.some(([_, value]) => value === u))
    case "TemplateLiteral": {
      const regex = AST.getTemplateLiteralRegExp(ast)
      return fromRefinement(ast, (u): u is any => Predicate.isString(u) && regex.test(u))
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding))
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding))
      let requiredTypes: Array<AST.Type> = ast.elements.filter((e) => !e.isOptional)
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1))
      }
      const requiredLen = requiredTypes.length
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never"
      const concurrency = getConcurrency(ast)
      const batching = getBatching(ast)
      return (input: unknown, options) => {
        if (!Arr.isArray(input)) {
          return Either.left(new Type(ast, input))
        }
        const allErrors = options?.errors === "all"
        const es: Array<[number, ParseIssue]> = []
        let stepKey = 0
        const output: Array<[number, any]> = []
        // ---------------------------------------------
        // handle missing indexes
        // ---------------------------------------------
        const len = input.length
        for (let i = len; i <= requiredLen - 1; i++) {
          const e = new Pointer(i, input, new Missing(requiredTypes[i - len]))
          if (allErrors) {
            es.push([stepKey++, e])
            continue
          } else {
            return Either.left(new Composite(ast, input, e, output))
          }
        }

        // ---------------------------------------------
        // handle excess indexes
        // ---------------------------------------------
        if (ast.rest.length === 0) {
          for (let i = ast.elements.length; i <= len - 1; i++) {
            const e = new Pointer(i, input, new Unexpected(input[i], `is unexpected, expected: ${expectedIndexes}`))
            if (allErrors) {
              es.push([stepKey++, e])
              continue
            } else {
              return Either.left(new Composite(ast, input, e, output))
            }
          }
        }

        let i = 0
        type State = {
          es: typeof es
          output: typeof output
        }
        let queue:
          | Array<(_: State) => Effect.Effect<void, ParseIssue, any>>
          | undefined = undefined

        // ---------------------------------------------
        // handle elements
        // ---------------------------------------------
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              // the input element is missing
              continue
            }
          } else {
            const parser = elements[i]
            const te = parser(input[i], options)
            if (isEither(te)) {
              if (Either.isLeft(te)) {
                // the input element is present but is not valid
                const e = new Pointer(i, input, te.left)
                if (allErrors) {
                  es.push([stepKey++, e])
                  continue
                } else {
                  return Either.left(new Composite(ast, input, e, sortByIndex(output)))
                }
              }
              output.push([stepKey++, te.right])
            } else {
              const nk = stepKey++
              const index = i
              if (!queue) {
                queue = []
              }
              queue.push(({ es, output }: State) =>
                Effect.flatMap(Effect.either(te), (t) => {
                  if (Either.isLeft(t)) {
                    // the input element is present but is not valid
                    const e = new Pointer(index, input, t.left)
                    if (allErrors) {
                      es.push([nk, e])
                      return Effect.void
                    } else {
                      return Either.left(new Composite(ast, input, e, sortByIndex(output)))
                    }
                  }
                  output.push([nk, t.right])
                  return Effect.void
                })
              )
            }
          }
        }
        // ---------------------------------------------
        // handle rest element
        // ---------------------------------------------
        if (Arr.isNonEmptyReadonlyArray(rest)) {
          const [head, ...tail] = rest
          for (; i < len - tail.length; i++) {
            const te = head(input[i], options)
            if (isEither(te)) {
              if (Either.isLeft(te)) {
                const e = new Pointer(i, input, te.left)
                if (allErrors) {
                  es.push([stepKey++, e])
                  continue
                } else {
                  return Either.left(new Composite(ast, input, e, sortByIndex(output)))
                }
              } else {
                output.push([stepKey++, te.right])
              }
            } else {
              const nk = stepKey++
              const index = i
              if (!queue) {
                queue = []
              }
              queue.push(
                ({ es, output }: State) =>
                  Effect.flatMap(Effect.either(te), (t) => {
                    if (Either.isLeft(t)) {
                      const e = new Pointer(index, input, t.left)
                      if (allErrors) {
                        es.push([nk, e])
                        return Effect.void
                      } else {
                        return Either.left(new Composite(ast, input, e, sortByIndex(output)))
                      }
                    } else {
                      output.push([nk, t.right])
                      return Effect.void
                    }
                  })
              )
            }
          }
          // ---------------------------------------------
          // handle post rest elements
          // ---------------------------------------------
          for (let j = 0; j < tail.length; j++) {
            i += j
            if (len < i + 1) {
              continue
            } else {
              const te = tail[j](input[i], options)
              if (isEither(te)) {
                if (Either.isLeft(te)) {
                  // the input element is present but is not valid
                  const e = new Pointer(i, input, te.left)
                  if (allErrors) {
                    es.push([stepKey++, e])
                    continue
                  } else {
                    return Either.left(new Composite(ast, input, e, sortByIndex(output)))
                  }
                }
                output.push([stepKey++, te.right])
              } else {
                const nk = stepKey++
                const index = i
                if (!queue) {
                  queue = []
                }
                queue.push(
                  ({ es, output }: State) =>
                    Effect.flatMap(Effect.either(te), (t) => {
                      if (Either.isLeft(t)) {
                        // the input element is present but is not valid
                        const e = new Pointer(index, input, t.left)
                        if (allErrors) {
                          es.push([nk, e])
                          return Effect.void
                        } else {
                          return Either.left(new Composite(ast, input, e, sortByIndex(output)))
                        }
                      }
                      output.push([nk, t.right])
                      return Effect.void
                    })
                )
              }
            }
          }
        }

        // ---------------------------------------------
        // compute result
        // ---------------------------------------------
        const computeResult = ({ es, output }: State) =>
          Arr.isNonEmptyArray(es) ?
            Either.left(new Composite(ast, input, sortByIndex(es), sortByIndex(output))) :
            Either.right(sortByIndex(output))
        if (queue && queue.length > 0) {
          const cqueue = queue
          return Effect.suspend(() => {
            const state: State = {
              es: Arr.copy(es),
              output: Arr.copy(output)
            }
            return Effect.flatMap(
              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),
              () => computeResult(state)
            )
          })
        }
        return computeResult({ output, es })
      }
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, Predicate.isNotNullable)
      }

      const propertySignatures: Array<readonly [Parser, AST.PropertySignature]> = []
      const expectedKeysMap: Record<PropertyKey, null> = {}
      const expectedKeys: Array<PropertyKey> = []
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps])
        expectedKeysMap[ps.name] = null
        expectedKeys.push(ps.name)
      }

      const indexSignatures = ast.indexSignatures.map((is) =>
        [
          goMemo(is.parameter, isDecoding),
          goMemo(is.type, isDecoding),
          is.parameter
        ] as const
      )
      const expectedAST = AST.Union.make(
        ast.indexSignatures.map((is): AST.AST => is.parameter).concat(
          expectedKeys.map((key) => Predicate.isSymbol(key) ? new AST.UniqueSymbol(key) : new AST.Literal(key))
        )
      )
      const expected = goMemo(expectedAST, isDecoding)
      const concurrency = getConcurrency(ast)
      const batching = getBatching(ast)
      return (input: unknown, options) => {
        if (!Predicate.isRecord(input)) {
          return Either.left(new Type(ast, input))
        }
        const allErrors = options?.errors === "all"
        const es: Array<[number, ParseIssue]> = []
        let stepKey = 0

        // ---------------------------------------------
        // handle excess properties
        // ---------------------------------------------
        const onExcessPropertyError = options?.onExcessProperty === "error"
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve"
        const output: Record<PropertyKey, unknown> = {}
        let inputKeys: Array<PropertyKey> | undefined
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = util_.ownKeys(input)
          for (const key of inputKeys) {
            const te = expected(key, options)
            if (isEither(te) && Either.isLeft(te)) {
              // key is unexpected
              if (onExcessPropertyError) {
                const e = new Pointer(
                  key,
                  input,
                  new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`)
                )
                if (allErrors) {
                  es.push([stepKey++, e])
                  continue
                } else {
                  return Either.left(new Composite(ast, input, e, output))
                }
              } else {
                // preserve key
                output[key] = input[key]
              }
            }
          }
        }

        // ---------------------------------------------
        // handle property signatures
        // ---------------------------------------------
        type State = {
          es: typeof es
          output: typeof output
        }
        let queue:
          | Array<(state: State) => Effect.Effect<void, ParseIssue, any>>
          | undefined = undefined

        const isExact = options?.exact === true
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1]
          const name = ps.name
          const hasKey = Object.prototype.hasOwnProperty.call(input, name)
          if (!hasKey) {
            if (ps.isOptional) {
              continue
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps))
              if (allErrors) {
                es.push([stepKey++, e])
                continue
              } else {
                return Either.left(new Composite(ast, input, e, output))
              }
            }
          }
          const parser = propertySignatures[i][0]
          const te = parser(input[name], options)
          if (isEither(te)) {
            if (Either.isLeft(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps))
              if (allErrors) {
                es.push([stepKey++, e])
                continue
              } else {
                return Either.left(new Composite(ast, input, e, output))
              }
            }
            output[name] = te.right
          } else {
            const nk = stepKey++
            const index = name
            if (!queue) {
              queue = []
            }
            queue.push(
              ({ es, output }: State) =>
                Effect.flatMap(Effect.either(te), (t) => {
                  if (Either.isLeft(t)) {
                    const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps))
                    if (allErrors) {
                      es.push([nk, e])
                      return Effect.void
                    } else {
                      return Either.left(new Composite(ast, input, e, output))
                    }
                  }
                  output[index] = t.right
                  return Effect.void
                })
            )
          }
        }

        // ---------------------------------------------
        // handle index signatures
        // ---------------------------------------------
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i]
          const parameter = indexSignature[0]
          const type = indexSignature[1]
          const keys = util_.getKeysForIndexSignature(input, indexSignature[2])
          for (const key of keys) {
            // ---------------------------------------------
            // handle keys
            // ---------------------------------------------
            const keu = parameter(key, options)
            if (isEither(keu) && Either.isRight(keu)) {
              // ---------------------------------------------
              // handle values
              // ---------------------------------------------
              const vpr = type(input[key], options)
              if (isEither(vpr)) {
                if (Either.isLeft(vpr)) {
                  const e = new Pointer(key, input, vpr.left)
                  if (allErrors) {
                    es.push([stepKey++, e])
                    continue
                  } else {
                    return Either.left(new Composite(ast, input, e, output))
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right
                  }
                }
              } else {
                const nk = stepKey++
                const index = key
                if (!queue) {
                  queue = []
                }
                queue.push(
                  ({ es, output }: State) =>
                    Effect.flatMap(
                      Effect.either(vpr),
                      (tv) => {
                        if (Either.isLeft(tv)) {
                          const e = new Pointer(index, input, tv.left)
                          if (allErrors) {
                            es.push([nk, e])
                            return Effect.void
                          } else {
                            return Either.left(new Composite(ast, input, e, output))
                          }
                        } else {
                          if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                            output[key] = tv.right
                          }
                          return Effect.void
                        }
                      }
                    )
                )
              }
            }
          }
        }
        // ---------------------------------------------
        // compute result
        // ---------------------------------------------
        const computeResult = ({ es, output }: State) => {
          if (Arr.isNonEmptyArray(es)) {
            return Either.left(new Composite(ast, input, sortByIndex(es), output))
          }
          if (options?.propertyOrder === "original") {
            // preserve input keys order
            const keys = inputKeys || util_.ownKeys(input)
            for (const name of expectedKeys) {
              if (keys.indexOf(name) === -1) {
                keys.push(name)
              }
            }
            const out: any = {}
            for (const key of keys) {
              if (Object.prototype.hasOwnProperty.call(output, key)) {
                out[key] = output[key]
              }
            }
            return Either.right(out)
          }
          return Either.right(output)
        }
        if (queue && queue.length > 0) {
          const cqueue = queue
          return Effect.suspend(() => {
            const state: State = {
              es: Arr.copy(es),
              output: Object.assign({}, output)
            }
            return Effect.flatMap(
              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),
              () => computeResult(state)
            )
          })
        }
        return computeResult({ es, output })
      }
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding)
      const ownKeys = util_.ownKeys(searchTree.keys)
      const ownKeysLen = ownKeys.length
      const astTypesLen = ast.types.length
      const map = new Map<any, Parser>()
      for (let i = 0; i < astTypesLen; i++) {
        map.set(ast.types[i], goMemo(ast.types[i], isDecoding))
      }
      const concurrency = getConcurrency(ast) ?? 1
      const batching = getBatching(ast)
      return (input, options) => {
        const es: Array<[number, ParseIssue]> = []
        let stepKey = 0
        let candidates: Array<AST.AST> = []
        if (ownKeysLen > 0) {
          if (Predicate.isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name = ownKeys[i]
              const buckets = searchTree.keys[name].buckets
              // for each property that should contain a literal, check if the input contains that property
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal = String(input[name])
                // check that the value obtained from the input for the property corresponds to an existing bucket
                if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                  // retrive the minimal set of candidates for decoding
                  candidates = candidates.concat(buckets[literal])
                } else {
                  const { candidates, literals } = searchTree.keys[name]
                  const literalsUnion = AST.Union.make(literals)
                  const errorAst = candidates.length === astTypesLen
                    ? new AST.TypeLiteral([new AST.PropertySignature(name, literalsUnion, false, true)], [])
                    : AST.Union.make(candidates)
                  es.push([
                    stepKey++,
                    new Composite(errorAst, input, new Pointer(name, input, new Type(literalsUnion, input[name])))
                  ])
                }
              } else {
                const { candidates, literals } = searchTree.keys[name]
                const fakePropertySignature = new AST.PropertySignature(name, AST.Union.make(literals), false, true)
                const errorAst = candidates.length === astTypesLen
                  ? new AST.TypeLiteral([fakePropertySignature], [])
                  : AST.Union.make(candidates)
                es.push([
                  stepKey++,
                  new Composite(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))
                ])
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen
              ? ast
              : AST.Union.make(searchTree.candidates)
            es.push([stepKey++, new Type(errorAst, input)])
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise)
        }

        let queue:
          | Array<(state: State) => Effect.Effect<unknown, ParseIssue, any>>
          | undefined = undefined

        type State = {
          finalResult?: any
          es: typeof es
        }

        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i]
          const pr = map.get(candidate)!(input, options)
          // the members of a union are ordered based on which one should be decoded first,
          // therefore if one member has added a task, all subsequent members must
          // also add a task to the queue even if they are synchronous
          if (isEither(pr) && (!queue || queue.length === 0)) {
            if (Either.isRight(pr)) {
              return pr
            } else {
              es.push([stepKey++, pr.left])
            }
          } else {
            const nk = stepKey++
            if (!queue) {
              queue = []
            }
            queue.push(
              (state) =>
                Effect.suspend(() => {
                  if ("finalResult" in state) {
                    return Effect.void
                  } else {
                    return Effect.flatMap(Effect.either(pr), (t) => {
                      if (Either.isRight(t)) {
                        state.finalResult = t
                      } else {
                        state.es.push([nk, t.left])
                      }
                      return Effect.void
                    })
                  }
                })
            )
          }
        }

        // ---------------------------------------------
        // compute result
        // ---------------------------------------------
        const computeResult = (es: State["es"]) =>
          Arr.isNonEmptyArray(es) ?
            es.length === 1 && es[0][1]._tag === "Type" ?
              Either.left(es[0][1]) :
              Either.left(new Composite(ast, input, sortByIndex(es))) :
            // this should never happen
            Either.left(new Type(ast, input))

        if (queue && queue.length > 0) {
          const cqueue = queue
          return Effect.suspend(() => {
            const state: State = { es: Arr.copy(es) }
            return Effect.flatMap(
              Effect.forEach(cqueue, (f) => f(state), { concurrency, batching, discard: true }),
              () => {
                if ("finalResult" in state) {
                  return state.finalResult
                }
                return computeResult(state.es)
              }
            )
          })
        }
        return computeResult(es)
      }
    }
    case "Suspend": {
      const get = util_.memoizeThunk(() => goMemo(AST.annotations(ast.f(), ast.annotations), isDecoding))
      return (a, options) => get()(a, options)
    }
  }
}

const fromRefinement = <A>(ast: AST.AST, refinement: (u: unknown) => u is A): Parser => (u) =>
  refinement(u) ? Either.right(u) : Either.left(new Type(ast, u))

/** @internal */
export const getLiterals = (
  ast: AST.AST,
  isDecoding: boolean
): ReadonlyArray<[PropertyKey, AST.Literal]> => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = AST.getSurrogateAnnotation(ast)
      if (Option.isSome(annotation)) {
        return getLiterals(annotation.value, isDecoding)
      }
      break
    }
    case "TypeLiteral": {
      const out: Array<[PropertyKey, AST.Literal]> = []
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature = ast.propertySignatures[i]
        const type = isDecoding ? AST.encodedAST(propertySignature.type) : AST.typeAST(propertySignature.type)
        if (AST.isLiteral(type) && !propertySignature.isOptional) {
          out.push([propertySignature.name, type])
        }
      }
      return out
    }
    case "TupleType": {
      const out: Array<[PropertyKey, AST.Literal]> = []
      for (let i = 0; i < ast.elements.length; i++) {
        const element = ast.elements[i]
        const type = isDecoding ? AST.encodedAST(element.type) : AST.typeAST(element.type)
        if (AST.isLiteral(type) && !element.isOptional) {
          out.push([i, type])
        }
      }
      return out
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding)
    case "Suspend":
      return getLiterals(ast.f(), isDecoding)
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding)
  }
  return []
}

/**
The purpose of the algorithm is to narrow down the pool of possible
candidates for decoding as much as possible.

This function separates the schemas into two groups, `keys` and `otherwise`:

- `keys`: the schema has at least one property with a literal value
- `otherwise`: the schema has no properties with a literal value

If a schema has at least one property with a literal value, so it ends up in
`keys`, first a namespace is created for the name of the property containing
the literal, and then within this namespace a "bucket" is created for the
literal value in which to store all the schemas that have the same property
and literal value.

@internal
/
export const getSearchTree = (
  members: ReadonlyArray<AST.AST>,
  isDecoding: boolean
): {
  keys: {
    readonly [key: PropertyKey]: {
      buckets: { [literal: string]: ReadonlyArray<AST.AST> }
      literals: ReadonlyArray<AST.Literal> // this is for error messages
      candidates: ReadonlyArray<AST.AST>
    }
  }
  otherwise: ReadonlyArray<AST.AST>
  candidates: ReadonlyArray<AST.AST>
} => {
  const keys: {
    [key: PropertyKey]: {
      buckets: { [literal: string]: Array<AST.AST> }
      literals: Array<AST.Literal>
      candidates: Array<AST.AST>
    }
  } = {}
  const otherwise: Array<AST.AST> = []
  const candidates: Array<AST.AST> = []
  for (let i = 0; i < members.length; i++) {
    const member = members[i]
    const tags = getLiterals(member, isDecoding)
    if (tags.length > 0) {
      candidates.push(member)
      for (let j = 0; j < tags.length; j++) {
        const [key, literal] = tags[j]
        const hash = String(literal.literal)
        keys[key] = keys[key] || { buckets: {}, literals: [], candidates: [] }
        const buckets = keys[key].buckets
        if (Object.prototype.hasOwnProperty.call(buckets, hash)) {
          if (j < tags.length - 1) {
            continue
          }
          buckets[hash].push(member)
          keys[key].literals.push(literal)
          keys[key].candidates.push(member)
        } else {
          buckets[hash] = [member]
          keys[key].literals.push(literal)
          keys[key].candidates.push(member)
          break
        }
      }
    } else {
      otherwise.push(member)
    }
  }
  return { keys, otherwise, candidates }
}

const dropRightRefinement = (ast: AST.AST): AST.AST => AST.isRefinement(ast) ? dropRightRefinement(ast.from) : ast

const handleForbidden = <A, R>(
  effect: Effect.Effect<A, ParseIssue, R>,
  ast: AST.AST,
  actual: unknown,
  options: InternalOptions | undefined
): Effect.Effect<A, ParseIssue, R> => {
  // If effects are allowed, return the original effect
  if (options?.isEffectAllowed === true) {
    return effect
  }

  // If the effect is already an Either, return it directly
  if (isEither(effect)) {
    return effect
  }

  // Otherwise, attempt to execute the effect synchronously
  const scheduler = new Scheduler.SyncScheduler()
  const fiber = Effect.runFork(effect as Effect.Effect<A, ParseIssue>, { scheduler })
  scheduler.flush()
  const exit = fiber.unsafePoll()

  if (exit) {
    if (Exit.isSuccess(exit)) {
      // If the effect successfully resolves, wrap the value in a Right
      return Either.right(exit.value)
    }
    const cause = exit.cause
    if (Cause.isFailType(cause)) {
      // The effect executed synchronously but failed due to a ParseIssue
      return Either.left(cause.error)
    }
    // The effect executed synchronously but failed due to a defect (e.g., a missing dependency)
    return Either.left(new Forbidden(ast, actual, Cause.pretty(cause)))
  }

  // The effect could not be resolved synchronously, meaning it performs async work
  return Either.left(
    new Forbidden(
      ast,
      actual,
      "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"
    )
  )
}

const compare = ([a]: [number, ...Array<unknown>], [b]: [number, ...Array<unknown>]) => a > b ? 1 : a < b ? -1 : 0

function sortByIndex<T>(
  es: Arr.NonEmptyArray<[number, T]>
): Arr.NonEmptyArray<T>
function sortByIndex<T>(es: Array<[number, T]>): Array<T>
function sortByIndex(es: Array<[number, any]>) {
  return es.sort(compare).map((t) => t[1])
}

// -------------------------------------------------------------------------------------
// transformations interpreter
// -------------------------------------------------------------------------------------

/** @internal */
export const getFinalTransformation = (
  transformation: AST.TransformationKind,
  isDecoding: boolean
): (
  fromA: any,
  options: AST.ParseOptions,
  self: AST.Transformation,
  fromI: any
) => Effect.Effect<any, ParseIssue, any> => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode
    case "ComposeTransformation":
      return Either.right
    case "TypeLiteralTransformation":
      return (input) => {
        let out: Effect.Effect<any, ParseIssue, any> = Either.right(input)

        // ---------------------------------------------
        // handle property signature transformations
        // ---------------------------------------------
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ?
            [pst.from, pst.to] :
            [pst.to, pst.from]
          const transformation = isDecoding ? pst.decode : pst.encode
          const f = (input: any) => {
            const o = transformation(
              Object.prototype.hasOwnProperty.call(input, from) ?
                Option.some(input[from]) :
                Option.none()
            )
            delete input[from]
            if (Option.isSome(o)) {
              input[to] = o.value
            }
            return input
          }
          out = map(out, f)
        }
        return out
      }
  }
}

// ----------------
// Formatters
// ----------------

interface Forest<A> extends ReadonlyArray<Tree<A>> {}

interface Tree<A> {
  readonly value: A
  readonly forest: Forest<A>
}

const makeTree = <A>(value: A, forest: Forest<A> = []): Tree<A> => ({
  value,
  forest
})

/**
@category formatting
@since 3.10.0
/
export interface ParseResultFormatter<A> {
  readonly formatIssue: (issue: ParseIssue) => Effect.Effect<A>
  readonly formatIssueSync: (issue: ParseIssue) => A
  readonly formatError: (error: ParseError) => Effect.Effect<A>
  readonly formatErrorSync: (error: ParseError) => A
}

/**
@category formatting
@since 3.10.0
/
export const TreeFormatter: ParseResultFormatter<string> = {
  formatIssue: (issue) => map(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue)
    return isEither(e) ? Either.getOrThrow(e) : Effect.runSync(e)
  },
  formatError: (error) => TreeFormatter.formatIssue(error.issue),
  formatErrorSync: (error) => TreeFormatter.formatIssueSync(error.issue)
}

const drawTree = (tree: Tree<string>): string => tree.value + draw("\n", tree.forest)

const draw = (indentation: string, forest: Forest<string>): string => {
  let r = ""
  const len = forest.length
  let tree: Tree<string>
  for (let i = 0; i < len; i++) {
    tree = forest[i]
    const isLast = i === len - 1
    r += indentation + (isLast ? "" : "") + " " + tree.value
    r += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest)
  }
  return r
}

const formatTransformationKind = (kind: Transformation["kind"]): string => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure"
    case "Transformation":
      return "Transformation process failure"
    case "Type":
      return "Type side transformation failure"
  }
}

const formatRefinementKind = (kind: Refinement["kind"]): string => {
  switch (kind) {
    case "From":
      return "From side refinement failure"
    case "Predicate":
      return "Predicate refinement failure"
  }
}

const getAnnotated = (issue: ParseIssue): Option.Option<AST.Annotated> =>
  "ast" in issue ? Option.some(issue.ast) : Option.none()

interface CurrentMessage {
  readonly message: string
  readonly override: boolean
}

// TODO: replace with Either.void when 3.13 lands
const Either_void = Either.right(undefined)

const getCurrentMessage = (issue: ParseIssue): Effect.Effect<CurrentMessage | undefined> =>
  getAnnotated(issue).pipe(
    Option.flatMap(AST.getMessageAnnotation),
    Option.match({
      onNone: () => Either_void,
      onSome: (messageAnnotation) => {
        const union = messageAnnotation(issue)
        if (Predicate.isString(union)) {
          return Either.right({ message: union, override: false })
        }
        if (Effect.isEffect(union)) {
          return Effect.map(union, (message) => ({ message, override: false }))
        }
        if (Predicate.isString(union.message)) {
          return Either.right({ message: union.message, override: union.override })
        }
        return Effect.map(union.message, (message) => ({ message, override: union.override }))
      }
    })
  )

const createParseIssueGuard =
  <T extends ParseIssue["_tag"]>(tag: T) => (issue: ParseIssue): issue is Extract<ParseIssue, { _tag: T }> =>
    issue._tag === tag

/**
Returns `true` if the value is a `Composite`.

@category guards
@since 3.10.0
/
export const isComposite = createParseIssueGuard("Composite")

const isRefinement = createParseIssueGuard("Refinement")
const isTransformation = createParseIssueGuard("Transformation")

const getMessage = (issue: ParseIssue): Effect.Effect<string | undefined> =>
  flatMap(getCurrentMessage(issue), (currentMessage) => {
    if (currentMessage !== undefined) {
      const useInnerMessage = !currentMessage.override && (
        isComposite(issue) ||
        (isRefinement(issue) && issue.kind === "From") ||
        (isTransformation(issue) && issue.kind !== "Transformation")
      )
      return useInnerMessage
        ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : Either_void
        : Either.right(currentMessage.message)
    }
    return Either_void
  })

const getParseIssueTitleAnnotation = (issue: ParseIssue): string | undefined =>
  getAnnotated(issue).pipe(
    Option.flatMap(AST.getParseIssueTitleAnnotation),
    Option.flatMapNullable((annotation) => annotation(issue)),
    Option.getOrUndefined
  )

/** @internal

## make

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `make(<A, I = A, R = never>(ast: AST.AST)`

JSDoc:

@since 3.10.0
/

import type { StandardSchemaV1 } from "@standard-schema/spec"
import type { ArbitraryAnnotation, ArbitraryGenerationContext, LazyArbitrary } from "./Arbitrary.js"
import * as array_ from "./Array.js"
import * as bigDecimal_ from "./BigDecimal.js"
import * as bigInt_ from "./BigInt.js"
import * as boolean_ from "./Boolean.js"
import type { Brand } from "./Brand.js"
import * as cause_ from "./Cause.js"
import * as chunk_ from "./Chunk.js"
import * as config_ from "./Config.js"
import * as configError_ from "./ConfigError.js"
import * as data_ from "./Data.js"
import * as dateTime from "./DateTime.js"
import * as duration_ from "./Duration.js"
import * as Effect from "./Effect.js"
import * as either_ from "./Either.js"
import * as Encoding from "./Encoding.js"
import * as Equal from "./Equal.js"
import * as Equivalence from "./Equivalence.js"
import * as exit_ from "./Exit.js"
import * as fastCheck_ from "./FastCheck.js"
import * as fiberId_ from "./FiberId.js"
import type { LazyArg } from "./Function.js"
import { dual, identity } from "./Function.js"
import { globalValue } from "./GlobalValue.js"
import * as hashMap_ from "./HashMap.js"
import * as hashSet_ from "./HashSet.js"
import * as internalCause_ from "./internal/cause.js"
import * as errors_ from "./internal/schema/errors.js"
import * as schemaId_ from "./internal/schema/schemaId.js"
import * as util_ from "./internal/schema/util.js"
import * as list_ from "./List.js"
import * as number_ from "./Number.js"
import * as option_ from "./Option.js"
import type * as Order from "./Order.js"
import * as ParseResult from "./ParseResult.js"
import type { Pipeable } from "./Pipeable.js"
import { pipeArguments } from "./Pipeable.js"
import * as Predicate from "./Predicate.js"
import type * as pretty_ from "./Pretty.js"
import * as redacted_ from "./Redacted.js"
import * as Request from "./Request.js"
import * as scheduler_ from "./Scheduler.js"
import type { ParseOptions } from "./SchemaAST.js"
import * as AST from "./SchemaAST.js"
import * as sortedSet_ from "./SortedSet.js"
import * as string_ from "./String.js"
import * as struct_ from "./Struct.js"
import type * as Types from "./Types.js"

/**
@since 3.10.0
/
export type Simplify<A> = { [K in keyof A]: A[K] } & {}

/**
@since 3.10.0
/
export type SimplifyMutable<A> = {
  -readonly [K in keyof A]: A[K]
} extends infer B ? B : never

/**
@since 3.10.0
@category symbol
/
export const TypeId: unique symbol = Symbol.for("effect/Schema")

/**
@since 3.10.0
@category symbol
/
export type TypeId = typeof TypeId

/**
@category model
@since 3.10.0
/
export interface Schema<in out A, in out I = A, out R = never> extends Schema.Variance<A, I, R>, Pipeable {
  readonly Type: A
  readonly Encoded: I
  readonly Context: R
  readonly ast: AST.AST
  /**
Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.
/
  annotations(annotations: Annotations.GenericSchema<A>): Schema<A, I, R>
}

/**
@category annotations
@since 3.10.0
/
export interface Annotable<Self extends Schema<A, I, R>, A, I = A, R = never> extends Schema<A, I, R> {
  annotations(annotations: Annotations.GenericSchema<A>): Self
}

/**
@category annotations
@since 3.10.0
/
export interface AnnotableClass<Self extends Schema<A, I, R>, A, I = A, R = never> extends Annotable<Self, A, I, R> {
  new(_: never): Schema.Variance<A, I, R>
}

/**
@category model
@since 3.10.0
/
export interface SchemaClass<A, I = A, R = never> extends AnnotableClass<SchemaClass<A, I, R>, A, I, R> {}

/**
@category constructors
@since 3.10.0

## asSchema

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `asSchema(<S extends Schema.All>(
  schema: S
)`

JSDoc:

Returns a "Standard Schema" object conforming to the [Standard Schema
v1](https://standardschema.dev/) specification.

This function creates a schema whose `validate` method attempts to decode and
validate the provided input synchronously. If the underlying `Schema`
includes any asynchronous components (e.g., asynchronous message resolutions
or checks), then validation will necessarily return a `Promise` instead.

Any detected defects will be reported via a single issue containing no
`path`.

@example
```ts
import { Schema } from "effect"

const schema = Schema.Struct({
  name: Schema.String
})

//       StandardSchemaV1<{ readonly name: string; }>
//      
const standardSchema = Schema.standardSchemaV1(schema)
```

@category Standard Schema
@since 3.13.0
/
export const standardSchemaV1 = <A, I>(
  schema: Schema<A, I, never>,
  overrideOptions?: AST.ParseOptions
): StandardSchemaV1<I, A> & SchemaClass<A, I, never> => {
  const decodeUnknown = ParseResult.decodeUnknown(schema, { errors: "all" })
  return class StandardSchemaV1Class extends make<A, I, never>(schema.ast) {
    static "~standard" = {
      version: 1,
      vendor: "effect",
      validate(value) {
        const scheduler = new scheduler_.SyncScheduler()
        const fiber = Effect.runFork(
          Effect.matchEffect(decodeUnknown(value, overrideOptions), {
            onFailure: makeStandardFailureFromParseIssue,
            onSuccess: (value) => Effect.succeed({ value })
          }),
          { scheduler }
        )
        scheduler.flush()
        const exit = fiber.unsafePoll()
        if (exit) {
          return makeStandardResult(exit)
        }
        return new Promise((resolve) => {
          fiber.addObserver((exit) => {
            resolve(makeStandardResult(exit))
          })
        })
      }
    }
  }
}

interface AllAnnotations<A, TypeParameters extends ReadonlyArray<any>>
  extends Annotations.Schema<A, TypeParameters>, PropertySignature.Annotations<A>
{}

const builtInAnnotations = {
  schemaId: AST.SchemaIdAnnotationId,
  message: AST.MessageAnnotationId,
  missingMessage: AST.MissingMessageAnnotationId,
  identifier: AST.IdentifierAnnotationId,
  title: AST.TitleAnnotationId,
  description: AST.DescriptionAnnotationId,
  examples: AST.ExamplesAnnotationId,
  default: AST.DefaultAnnotationId,
  documentation: AST.DocumentationAnnotationId,
  jsonSchema: AST.JSONSchemaAnnotationId,
  arbitrary: AST.ArbitraryAnnotationId,
  pretty: AST.PrettyAnnotationId,
  equivalence: AST.EquivalenceAnnotationId,
  concurrency: AST.ConcurrencyAnnotationId,
  batching: AST.BatchingAnnotationId,
  parseIssueTitle: AST.ParseIssueTitleAnnotationId,
  parseOptions: AST.ParseOptionsAnnotationId,
  decodingFallback: AST.DecodingFallbackAnnotationId
}

const toASTAnnotations = <A, TypeParameters extends ReadonlyArray<any>>(
  annotations?: AllAnnotations<A, TypeParameters>
): AST.Annotations => {
  if (!annotations) {
    return {}
  }
  const out: Types.Mutable<AST.Annotations> = { ...annotations }

  for (const key in builtInAnnotations) {
    if (key in annotations) {
      const id = builtInAnnotations[key as keyof typeof builtInAnnotations]
      out[id] = annotations[key as keyof typeof annotations]
      delete out[key]
    }
  }

  return out
}

const mergeSchemaAnnotations = <A>(ast: AST.AST, annotations: Annotations.Schema<A>): AST.AST =>
  AST.annotations(ast, toASTAnnotations(annotations))

/**
@category annotations
@since 3.10.0
/
export declare namespace Annotable {
  /**
@since 3.10.0
/
  export type Self<S extends All> = ReturnType<S["annotations"]>

  /**
@since 3.10.0
/
  export type Any = Annotable<any, any, any, unknown>

  /**
@since 3.10.0
/
  export type All =
    | Any
    | Annotable<any, any, never, unknown>
    | Annotable<any, never, any, unknown>
    | Annotable<any, never, never, unknown>
}

/**
@since 3.10.0

## Literal

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `Literal(<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(
  ...literals: Literals
)`

JSDoc:

@category formatting
@since 3.10.0
/
export const format = <S extends Schema.All>(schema: S): string => String(schema.ast)

/**
@since 3.10.0
/
export declare namespace Schema {
  /**
@since 3.10.0
/
  export interface Variance<A, I, R> {
    readonly [TypeId]: {
      readonly _A: Types.Invariant<A>
      readonly _I: Types.Invariant<I>
      readonly _R: Types.Covariant<R>
    }
  }

  /**
@since 3.10.0
/
  export type Type<S> = S extends Schema.Variance<infer A, infer _I, infer _R> ? A : never

  /**
@since 3.10.0
/
  export type Encoded<S> = S extends Schema.Variance<infer _A, infer I, infer _R> ? I : never

  /**
@since 3.10.0
/
  export type Context<S> = S extends Schema.Variance<infer _A, infer _I, infer R> ? R : never

  /**
@since 3.10.0
/
  export type ToAsserts<S extends AnyNoContext> = (
    input: unknown,
    options?: AST.ParseOptions
  ) => asserts input is Schema.Type<S>

  /**
Any schema, except for `never`.

@since 3.10.0
/
  export type Any = Schema<any, any, unknown>

  /**
Any schema with `Context = never`, except for `never`.

@since 3.10.0
/
  export type AnyNoContext = Schema<any, any, never>

  /**
Any schema, including `never`.

@since 3.10.0
/
  export type All =
    | Any
    | Schema<any, never, unknown>
    | Schema<never, any, unknown>
    | Schema<never, never, unknown>

  /**
Type-level counterpart of `Schema.asSchema` function.

@since 3.10.0
/
  export type AsSchema<S extends All> = Schema<Type<S>, Encoded<S>, Context<S>>
}

/**
The `encodedSchema` function allows you to extract the `Encoded` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without retaining any refinements or transformations that
were applied previously.

@since 3.10.0
/
export const encodedSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> => make(AST.encodedAST(schema.ast))

/**
The `encodedBoundSchema` function is similar to `encodedSchema` but preserves
the refinements up to the first transformation point in the original schema.

@since 3.10.0
/
export const encodedBoundSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<I> =>
  make(AST.encodedBoundAST(schema.ast))

/**
The `typeSchema` function allows you to extract the `Type` portion of a
schema, creating a new schema that conforms to the properties defined in the
original schema without considering the initial encoding or transformation
processes.

@since 3.10.0
/
export const typeSchema = <A, I, R>(schema: Schema<A, I, R>): SchemaClass<A> => make(AST.typeAST(schema.ast))

/* c8 ignore start */
export {
  /**
By default the option `exact` is set to `true`.

@throws `ParseError`
@category validation
@since 3.10.0
/
  asserts,
  /**
@category decoding
@since 3.10.0
/
  decodeOption,
  /**
@throws `ParseError`
@category decoding
@since 3.10.0
/
  decodeSync,
  /**
@category decoding
@since 3.10.0
/
  decodeUnknownOption,
  /**
@throws `ParseError`
@category decoding
@since 3.10.0
/
  decodeUnknownSync,
  /**
@category encoding
@since 3.10.0
/
  encodeOption,
  /**
@throws `ParseError`
@category encoding
@since 3.10.0
/
  encodeSync,
  /**
@category encoding
@since 3.10.0
/
  encodeUnknownOption,
  /**
@throws `ParseError`
@category encoding
@since 3.10.0
/
  encodeUnknownSync,
  /**
By default the option `exact` is set to `true`.

@category validation
@since 3.10.0
/
  is,
  /**
@category validation
@since 3.10.0
/
  validateOption,
  /**
@throws `ParseError`
@category validation
@since 3.10.0
/
  validateSync
} from "./ParseResult.js"
/* c8 ignore end */

/**
@category encoding
@since 3.10.0
/
export const encodeUnknown = <A, I, R>(
  schema: Schema<A, I, R>,
  options?: ParseOptions
) => {
  const encodeUnknown = ParseResult.encodeUnknown(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<I, ParseResult.ParseError, R> =>
    ParseResult.mapError(encodeUnknown(u, overrideOptions), ParseResult.parseError)
}

/**
@category encoding
@since 3.10.0
/
export const encodeUnknownEither = <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => {
  const encodeUnknownEither = ParseResult.encodeUnknownEither(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<I, ParseResult.ParseError> =>
    either_.mapLeft(encodeUnknownEither(u, overrideOptions), ParseResult.parseError)
}

/**
@category encoding
@since 3.10.0
/
export const encodeUnknownPromise = <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => {
  const parser = encodeUnknown(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): Promise<I> => Effect.runPromise(parser(u, overrideOptions))
}

/**
@category encoding
@since 3.10.0
/
export const encode: <A, I, R>(
  schema: Schema<A, I, R>,
  options?: ParseOptions
) => (a: A, overrideOptions?: ParseOptions) => Effect.Effect<I, ParseResult.ParseError, R> = encodeUnknown

/**
@category encoding
@since 3.10.0
/
export const encodeEither: <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => (a: A, overrideOptions?: ParseOptions) => either_.Either<I, ParseResult.ParseError> = encodeUnknownEither

/**
@category encoding
@since 3.10.0
/
export const encodePromise: <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => (a: A, overrideOptions?: ParseOptions) => Promise<I> = encodeUnknownPromise

/**
@category decoding
@since 3.10.0
/
export const decodeUnknown = <A, I, R>(
  schema: Schema<A, I, R>,
  options?: ParseOptions
) => {
  const decodeUnknown = ParseResult.decodeUnknown(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>
    ParseResult.mapError(decodeUnknown(u, overrideOptions), ParseResult.parseError)
}

/**
@category decoding
@since 3.10.0
/
export const decodeUnknownEither = <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => {
  const decodeUnknownEither = ParseResult.decodeUnknownEither(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>
    either_.mapLeft(decodeUnknownEither(u, overrideOptions), ParseResult.parseError)
}

/**
@category decoding
@since 3.10.0
/
export const decodeUnknownPromise = <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => {
  const parser = decodeUnknown(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))
}

/**
@category decoding
@since 3.10.0
/
export const decode: <A, I, R>(
  schema: Schema<A, I, R>,
  options?: ParseOptions
) => (i: I, overrideOptions?: ParseOptions) => Effect.Effect<A, ParseResult.ParseError, R> = decodeUnknown

/**
@category decoding
@since 3.10.0
/
export const decodeEither: <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => (i: I, overrideOptions?: ParseOptions) => either_.Either<A, ParseResult.ParseError> = decodeUnknownEither

/**
@category decoding
@since 3.10.0
/
export const decodePromise: <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => (i: I, overrideOptions?: ParseOptions) => Promise<A> = decodeUnknownPromise

/**
@category validation
@since 3.10.0
/
export const validate = <A, I, R>(
  schema: Schema<A, I, R>,
  options?: ParseOptions
) => {
  const validate = ParseResult.validate(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): Effect.Effect<A, ParseResult.ParseError, R> =>
    ParseResult.mapError(validate(u, overrideOptions), ParseResult.parseError)
}

/**
@category validation
@since 3.10.0
/
export const validateEither = <A, I, R>(
  schema: Schema<A, I, R>,
  options?: ParseOptions
) => {
  const validateEither = ParseResult.validateEither(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): either_.Either<A, ParseResult.ParseError> =>
    either_.mapLeft(validateEither(u, overrideOptions), ParseResult.parseError)
}

/**
@category validation
@since 3.10.0
/
export const validatePromise = <A, I>(
  schema: Schema<A, I, never>,
  options?: ParseOptions
) => {
  const parser = validate(schema, options)
  return (u: unknown, overrideOptions?: ParseOptions): Promise<A> => Effect.runPromise(parser(u, overrideOptions))
}

/**
Tests if a value is a `Schema`.

@category guards
@since 3.10.0
/
export const isSchema = (u: unknown): u is Schema.Any =>
  Predicate.hasProperty(u, TypeId) && Predicate.isObject(u[TypeId])

/**
@category api interface
@since 3.10.0
/
export interface Literal<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>
  extends AnnotableClass<Literal<Literals>, Literals[number]>
{
  readonly literals: Readonly<Literals>
}

function getDefaultLiteralAST<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(
  literals: Literals
): AST.AST {
  return AST.isMembers(literals)
    ? AST.Union.make(AST.mapMembers(literals, (literal) => new AST.Literal(literal)))
    : new AST.Literal(literals[0])
}

function makeLiteralClass<Literals extends array_.NonEmptyReadonlyArray<AST.LiteralValue>>(
  literals: Literals,
  ast: AST.AST = getDefaultLiteralAST(literals)
): Literal<Literals> {
  return class LiteralClass extends make<Literals[number]>(ast) {
    static override annotations(annotations: Annotations.Schema<Literals[number]>): Literal<Literals> {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations))
    }
    static literals = [...literals] as Literals
  }
}

/**
@category constructors
@since 3.10.0

## Union

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `Union(<Members extends AST.Members<Schema.All>>(...members: Members)`

JSDoc:

Creates a new `Schema` from a literal schema.

@example
```ts
import * as assert from "node:assert"
import { Either, Schema } from "effect"

const schema = Schema.Literal("a", "b", "c").pipe(Schema.pickLiteral("a", "b"))

assert.deepStrictEqual(Schema.decodeSync(schema)("a"), "a")
assert.deepStrictEqual(Schema.decodeSync(schema)("b"), "b")
assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)("c")), true)
```

@category constructors
@since 3.10.0
/
export const pickLiteral =
  <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) =>
  <I, R>(_schema: Schema<A, I, R>): Literal<[...L]> => Literal(...literals)

/**
@category constructors
@since 3.10.0
/
export const UniqueSymbolFromSelf = <S extends symbol>(symbol: S): SchemaClass<S> => make(new AST.UniqueSymbol(symbol))

/**
@category api interface
@since 3.10.0
/
export interface Enums<A extends EnumsDefinition> extends AnnotableClass<Enums<A>, A[keyof A]> {
  readonly enums: A
}

/**
@since 3.10.0
/
export type EnumsDefinition = { [x: string]: string | number }

const getDefaultEnumsAST = <A extends EnumsDefinition>(enums: A) =>
  new AST.Enums(
    Object.keys(enums).filter(
      (key) => typeof enums[enums[key]] !== "number"
    ).map((key) => [key, enums[key]])
  )

const makeEnumsClass = <A extends EnumsDefinition>(
  enums: A,
  ast: AST.AST = getDefaultEnumsAST(enums)
): Enums<A> => (class EnumsClass extends make<A[keyof A]>(ast) {
  static override annotations(annotations: Annotations.Schema<A[keyof A]>) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations))
  }

  static enums = { ...enums }
})

/**
@category constructors
@since 3.10.0
/
export const Enums = <A extends EnumsDefinition>(enums: A): Enums<A> => makeEnumsClass(enums)

type AppendType<
  Template extends string,
  Next
> = Next extends AST.LiteralValue ? `${Template}${Next}`
  : Next extends Schema<infer A extends AST.LiteralValue, infer _I, infer _R> ? `${Template}${A}`
  : never

type GetTemplateLiteralType<Params> = Params extends [...infer Init, infer Last] ?
  AppendType<GetTemplateLiteralType<Init>, Last>
  : ``

/**
@category API interface
@since 3.10.0
/
export interface TemplateLiteral<A> extends SchemaClass<A> {}

type TemplateLiteralParameter = Schema.AnyNoContext | AST.LiteralValue

/**
@category template literal
@since 3.10.0
/
export const TemplateLiteral = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParameter>>(
  ...[head, ...tail]: Params
): TemplateLiteral<GetTemplateLiteralType<Params>> => {
  const spans: Array<AST.TemplateLiteralSpan> = []
  let h = ""
  let ts = tail

  if (isSchema(head)) {
    if (AST.isLiteral(head.ast)) {
      h = String(head.ast.literal)
    } else {
      ts = [head, ...ts]
    }
  } else {
    h = String(head)
  }

  for (let i = 0; i < ts.length; i++) {
    const item = ts[i]
    if (isSchema(item)) {
      if (i < ts.length - 1) {
        const next = ts[i + 1]
        if (isSchema(next)) {
          if (AST.isLiteral(next.ast)) {
            spans.push(new AST.TemplateLiteralSpan(item.ast, String(next.ast.literal)))
            i++
            continue
          }
        } else {
          spans.push(new AST.TemplateLiteralSpan(item.ast, String(next)))
          i++
          continue
        }
      }
      spans.push(new AST.TemplateLiteralSpan(item.ast, ""))
    } else {
      spans.push(new AST.TemplateLiteralSpan(new AST.Literal(item), ""))
    }
  }

  if (array_.isNonEmptyArray(spans)) {
    return make(new AST.TemplateLiteral(h, spans))
  } else {
    return make(new AST.TemplateLiteral("", [new AST.TemplateLiteralSpan(new AST.Literal(h), "")]))
  }
}

type TemplateLiteralParserParameters = Schema.Any | AST.LiteralValue

type GetTemplateLiteralParserType<Params> = Params extends [infer Head, ...infer Tail] ? readonly [
    Head extends Schema<infer A, infer _I, infer _R> ? A : Head,
    ...GetTemplateLiteralParserType<Tail>
  ]
  : []

type AppendEncoded<
  Template extends string,
  Next
> = Next extends AST.LiteralValue ? `${Template}${Next}`
  : Next extends Schema<infer _A, infer I extends AST.LiteralValue, infer _R> ? `${Template}${I}`
  : never

type GetTemplateLiteralParserEncoded<Params> = Params extends [...infer Init, infer Last] ?
  AppendEncoded<GetTemplateLiteralParserEncoded<Init>, Last>
  : ``

/**
@category API interface
@since 3.10.0
/
export interface TemplateLiteralParser<Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>
  extends
    Schema<
      GetTemplateLiteralParserType<Params>,
      GetTemplateLiteralParserEncoded<Params>,
      Schema.Context<Params[number]>
    >
{
  readonly params: Params
}

function getTemplateLiteralParserCoercedElement(encoded: Schema.Any, schema: Schema.Any): Schema.Any | undefined {
  const ast = encoded.ast
  switch (ast._tag) {
    case "Literal": {
      const literal = ast.literal
      if (!Predicate.isString(literal)) {
        const s = String(literal)
        return transform(Literal(s), schema, {
          strict: true,
          decode: () => literal,
          encode: () => s
        })
      }
      break
    }
    case "NumberKeyword":
      return compose(NumberFromString, schema)
    case "Union": {
      const members: Array<Schema.Any> = []
      let hasCoercions = false
      for (const member of ast.types) {
        const schema = make(member)
        const encoded = encodedSchema(schema)
        const coerced = getTemplateLiteralParserCoercedElement(encoded, schema)
        if (coerced) {
          hasCoercions = true
        }
        members.push(coerced ?? schema)
      }
      return hasCoercions ? compose(Union(...members), schema) : schema
    }
  }
}

/**
@category template literal
@since 3.10.0
/
export const TemplateLiteralParser = <Params extends array_.NonEmptyReadonlyArray<TemplateLiteralParserParameters>>(
  ...params: Params
): TemplateLiteralParser<Params> => {
  const encodedSchemas: Array<Schema.Any> = []
  const elements: Array<Schema.Any> = []
  const schemas: Array<Schema.Any> = []
  let coerced = false
  for (let i = 0; i < params.length; i++) {
    const param = params[i]
    const schema = isSchema(param) ? param : Literal(param)
    schemas.push(schema)
    const encoded = encodedSchema(schema)
    encodedSchemas.push(encoded)
    const element = getTemplateLiteralParserCoercedElement(encoded, schema)
    if (element) {
      elements.push(element)
      coerced = true
    } else {
      elements.push(schema)
    }
  }
  const from = TemplateLiteral(...encodedSchemas as any)
  const re = AST.getTemplateLiteralCapturingRegExp(from.ast as AST.TemplateLiteral)
  let to = Tuple(...elements)
  if (coerced) {
    to = to.annotations({ [AST.AutoTitleAnnotationId]: format(Tuple(...schemas)) })
  }
  return class TemplateLiteralParserClass extends transformOrFail(from, to, {
    strict: false,
    decode: (i, _, ast) => {
      const match = re.exec(i)
      return match
        ? ParseResult.succeed(match.slice(1, params.length + 1))
        : ParseResult.fail(new ParseResult.Type(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`))
    },
    encode: (tuple) => ParseResult.succeed(tuple.join(""))
  }) {
    static params = params.slice()
  } as any
}

const declareConstructor = <
  const TypeParameters extends ReadonlyArray<Schema.Any>,
  I,
  A
>(
  typeParameters: TypeParameters,
  options: {
    readonly decode: (
      ...typeParameters: {
        readonly [K in keyof TypeParameters]: Schema<
          Schema.Type<TypeParameters[K]>,
          Schema.Encoded<TypeParameters[K]>,
          never
        >
      }
    ) => (
      input: unknown,
      options: ParseOptions,
      ast: AST.Declaration
    ) => Effect.Effect<A, ParseResult.ParseIssue, never>
    readonly encode: (
      ...typeParameters: {
        readonly [K in keyof TypeParameters]: Schema<
          Schema.Type<TypeParameters[K]>,
          Schema.Encoded<TypeParameters[K]>,
          never
        >
      }
    ) => (
      input: unknown,
      options: ParseOptions,
      ast: AST.Declaration
    ) => Effect.Effect<I, ParseResult.ParseIssue, never>
  },
  annotations?: Annotations.Schema<A, TypeParameters>
): SchemaClass<A, I, Schema.Context<TypeParameters[number]>> =>
  makeDeclareClass(
    typeParameters,
    new AST.Declaration(
      typeParameters.map((tp) => tp.ast),
      (...typeParameters) => options.decode(...typeParameters.map(make) as any),
      (...typeParameters) => options.encode(...typeParameters.map(make) as any),
      toASTAnnotations(annotations)
    )
  )

const declarePrimitive = <A>(
  is: (input: unknown) => input is A,
  annotations?: Annotations.Schema<A>
): SchemaClass<A> => {
  const decodeUnknown = () => (input: unknown, _: ParseOptions, ast: AST.Declaration) =>
    is(input) ? ParseResult.succeed(input) : ParseResult.fail(new ParseResult.Type(ast, input))
  const encodeUnknown = decodeUnknown
  return makeDeclareClass([], new AST.Declaration([], decodeUnknown, encodeUnknown, toASTAnnotations(annotations)))
}

/**
@category api interface
@since 3.13.3
/
export interface declare<
  A,
  I = A,
  P extends ReadonlyArray<Schema.All> = readonly [],
  R = Schema.Context<P[number]>
> extends AnnotableClass<declare<A, I, P, R>, A, I, R> {
  readonly typeParameters: Readonly<P>
}

/**
@category api interface
@since 3.13.3
/
export interface AnnotableDeclare<
  Self extends declare<A, I, P, R>,
  A,
  I = A,
  P extends ReadonlyArray<Schema.All> = readonly [],
  R = Schema.Context<P[number]>
> extends declare<A, I, P, R> {
  annotations(annotations: Annotations.Schema<A>): Self
}

function makeDeclareClass<P extends ReadonlyArray<Schema.All>, A, I, R>(
  typeParameters: P,
  ast: AST.AST
): declare<A, I, P, R> {
  return class DeclareClass extends make<A, I, R>(ast) {
    static override annotations(annotations: Annotations.Schema<A>): declare<A, I, P, R> {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations))
    }
    static typeParameters = [...typeParameters] as any as P
  }
}

/**
The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.

@category constructors
@since 3.10.0
/
export const declare: {
  /**
The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.

@category constructors
@since 3.10.0
/
  <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): declare<A>
  /**
The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.

@category constructors
@since 3.10.0
/
  <A, I, const P extends ReadonlyArray<Schema.All>>(
    typeParameters: P,
    options: {
      readonly decode: (
        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }
      ) => (
        input: unknown,
        options: ParseOptions,
        ast: AST.Declaration
      ) => Effect.Effect<A, ParseResult.ParseIssue, never>
      readonly encode: (
        ...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never> }
      ) => (
        input: unknown,
        options: ParseOptions,
        ast: AST.Declaration
      ) => Effect.Effect<I, ParseResult.ParseIssue, never>
    },
    annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]> }>
  ): declare<A, I, P>
} = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0]
    const options = arguments[1]
    const annotations = arguments[2]
    return declareConstructor(typeParameters, options, annotations)
  }
  const is = arguments[0]
  const annotations = arguments[1]
  return declarePrimitive(is, annotations)
} as any

/**
@category schema id
@since 3.10.0
/
export const BrandSchemaId: unique symbol = Symbol.for("effect/SchemaId/Brand")

/**
@category constructors
@since 3.10.0
/
export const fromBrand = <C extends Brand<string | symbol>, A extends Brand.Unbranded<C>>(
  constructor: Brand.Constructor<C>,
  annotations?: Annotations.Filter<C, A>
) =>
<I, R>(self: Schema<A, I, R>): BrandSchema<A & C, I, R> => {
  const out = makeBrandClass(
    self,
    new AST.Refinement(
      self.ast,
      function predicate(a: A, _: ParseOptions, ast: AST.AST): option_.Option<ParseResult.ParseIssue> {
        const either = constructor.either(a)
        return either_.isLeft(either) ?
          option_.some(new ParseResult.Type(ast, a, either.left.map((v) => v.message).join(", "))) :
          option_.none()
      },
      toASTAnnotations({
        schemaId: BrandSchemaId,
        [BrandSchemaId]: { constructor },
        ...annotations
      })
    )
  )
  return out as any
}

/**
@category schema id
@since 3.10.0
/
export const InstanceOfSchemaId: unique symbol = Symbol.for("effect/SchemaId/InstanceOf")

/**
@category api interface
@since 3.10.0
/
export interface instanceOf<A> extends AnnotableDeclare<instanceOf<A>, A> {}

/**
@category constructors
@since 3.10.0
/
export const instanceOf = <A extends abstract new(...args: any) => any>(
  constructor: A,
  annotations?: Annotations.Schema<InstanceType<A>>
): instanceOf<InstanceType<A>> =>
  declare(
    (u): u is InstanceType<A> => u instanceof constructor,
    {
      title: constructor.name,
      description: `an instance of ${constructor.name}`,
      pretty: (): pretty_.Pretty<InstanceType<A>> => String,
      schemaId: InstanceOfSchemaId,
      [InstanceOfSchemaId]: { constructor },
      ...annotations
    }
  )

/**
@category primitives
@since 3.10.0
/
export class Undefined extends make<undefined>(AST.undefinedKeyword) {}

/**
@category primitives
@since 3.10.0
/
export class Void extends make<void>(AST.voidKeyword) {}

/**
@category primitives
@since 3.10.0
/
export class Null extends make<null>(AST.null) {}

/**
@category primitives
@since 3.10.0
/
export class Never extends make<never>(AST.neverKeyword) {}

/**
@category primitives
@since 3.10.0
/
export class Unknown extends make<unknown>(AST.unknownKeyword) {}

/**
@category primitives
@since 3.10.0
/
export class Any extends make<any>(AST.anyKeyword) {}

/**
@category primitives
@since 3.10.0
/
export class BigIntFromSelf extends make<bigint>(AST.bigIntKeyword) {}

/**
@category primitives
@since 3.10.0
/
export class SymbolFromSelf extends make<symbol>(AST.symbolKeyword) {}

/** @ignore */
class String$ extends make<string>(AST.stringKeyword) {}

/** @ignore */
class Number$ extends make<number>(AST.numberKeyword) {}

/** @ignore */
class Boolean$ extends make<boolean>(AST.booleanKeyword) {}

/** @ignore */
class Object$ extends make<object>(AST.objectKeyword) {}

export {
  /**
@category primitives
@since 3.10.0
/
  Boolean$ as Boolean,
  /**
@category primitives
@since 3.10.0
/
  Number$ as Number,
  /**
@category primitives
@since 3.10.0
/
  Object$ as Object,
  /**
@category primitives
@since 3.10.0
/
  String$ as String
}

/**
@category api interface
@since 3.10.0
/
export interface Union<Members extends ReadonlyArray<Schema.All>> extends
  AnnotableClass<
    Union<Members>,
    Schema.Type<Members[number]>,
    Schema.Encoded<Members[number]>,
    Schema.Context<Members[number]>
  >
{
  readonly members: Readonly<Members>
}

const getDefaultUnionAST = <Members extends AST.Members<Schema.All>>(members: Members): AST.AST =>
  AST.Union.make(members.map((m) => m.ast))

function makeUnionClass<Members extends AST.Members<Schema.All>>(
  members: Members,
  ast: AST.AST = getDefaultUnionAST(members)
): Union<Members> {
  return class UnionClass extends make<
    Schema.Type<Members[number]>,
    Schema.Encoded<Members[number]>,
    Schema.Context<Members[number]>
  >(ast) {
    static override annotations(annotations: Annotations.Schema<Schema.Type<Members[number]>>): Union<Members> {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations))
    }

    static members = [...members]
  }
}

/**
@category combinators
@since 3.10.0

## Tuple

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `Tuple(<
  const Elements extends TupleType.Elements,
  Rest extends array_.NonEmptyReadonlyArray<TupleType.Rest[number]>
>(elements: Elements, ...rest: Rest)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface NullOr<S extends Schema.All> extends Union<[S, typeof Null]> {
  annotations(annotations: Annotations.Schema<Schema.Type<S> | null>): NullOr<S>
}

/**
@category combinators
@since 3.10.0
/
export const NullOr = <S extends Schema.All>(self: S): NullOr<S> => Union(self, Null)

/**
@category api interface
@since 3.10.0
/
export interface UndefinedOr<S extends Schema.All> extends Union<[S, typeof Undefined]> {
  annotations(annotations: Annotations.Schema<Schema.Type<S> | undefined>): UndefinedOr<S>
}

/**
@category combinators
@since 3.10.0
/
export const UndefinedOr = <S extends Schema.All>(self: S): UndefinedOr<S> => Union(self, Undefined)

/**
@category api interface
@since 3.10.0
/
export interface NullishOr<S extends Schema.All> extends Union<[S, typeof Null, typeof Undefined]> {
  annotations(annotations: Annotations.Schema<Schema.Type<S> | null | undefined>): NullishOr<S>
}

/**
@category combinators
@since 3.10.0
/
export const NullishOr = <S extends Schema.All>(self: S): NullishOr<S> => Union(self, Null, Undefined)

/**
@category combinators
@since 3.10.0
/
export const keyof = <A, I, R>(self: Schema<A, I, R>): SchemaClass<keyof A> => make<keyof A>(AST.keyof(self.ast))

/**
@since 3.10.0
/
export declare namespace Element {
  /**
@since 3.10.0
/
  export interface Annotations<A> extends Annotations.Doc<A> {
    readonly missingMessage?: AST.MissingMessageAnnotation
  }

  /**
@since 3.10.0
/
  export type Token = "" | "?"
}

/**
@category API interface
@since 3.10.0
/
export interface Element<S extends Schema.Any, Token extends Element.Token>
  extends Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>
{
  readonly _Token: Token
  readonly ast: AST.OptionalType
  readonly from: S
  annotations(annotations: Element.Annotations<Schema.Type<S>>): Element<S, Token>
}

/**
@since 3.10.0
/
export const element = <S extends Schema.Any>(self: S): Element<S, ""> =>
  new ElementImpl(new AST.OptionalType(self.ast, false), self)

/**
@since 3.10.0
/
export const optionalElement = <S extends Schema.Any>(self: S): Element<S, "?"> =>
  new ElementImpl(new AST.OptionalType(self.ast, true), self)

class ElementImpl<S extends Schema.Any, Token extends Element.Token> implements Element<S, Token> {
  readonly [TypeId]!: Schema.Variance<Schema.Type<S>, Schema.Encoded<S>, Schema.Context<S>>[TypeId]
  readonly _Token!: Token
  constructor(
    readonly ast: AST.OptionalType,
    readonly from: S
  ) {}
  annotations(
    annotations: Annotations.Schema<Schema.Type<S>>
  ): ElementImpl<S, Token> {
    return new ElementImpl(
      new AST.OptionalType(
        this.ast.type,
        this.ast.isOptional,
        { ...this.ast.annotations, ...toASTAnnotations(annotations) }
      ),
      this.from
    )
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`
  }
}

/**
@since 3.10.0
/
export declare namespace TupleType {
  type ElementsType<
    Elements,
    Out extends ReadonlyArray<any> = readonly []
  > = Elements extends readonly [infer Head, ...infer Tail] ?
    Head extends Element<infer T, "?"> ? ElementsType<Tail, readonly [...Out, Schema.Type<T>?]>
    : ElementsType<Tail, readonly [...Out, Schema.Type<Head>]>
    : Out

  type ElementsEncoded<
    Elements,
    Out extends ReadonlyArray<any> = readonly []
  > = Elements extends readonly [infer Head, ...infer Tail] ?
    Head extends Element<infer T, "?"> ? ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<T>?]>
    : ElementsEncoded<Tail, readonly [...Out, Schema.Encoded<Head>]>
    : Out

  /**
@since 3.10.0
/
  export type Elements = ReadonlyArray<Schema.Any | Element<Schema.Any, Element.Token>>

  /**
@since 3.10.0
/
  export type Rest = ReadonlyArray<Schema.Any | Element<Schema.Any, "">>

  /**
@since 3.10.0
/
  export type Type<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends
    [infer Head, ...infer Tail] ? Readonly<[
      ...ElementsType<Elements>,
      ...ReadonlyArray<Schema.Type<Head>>,
      ...{ readonly [K in keyof Tail]: Schema.Type<Tail[K]> }
    ]> :
    ElementsType<Elements>

  /**
@since 3.10.0
/
  export type Encoded<Elements extends TupleType.Elements, Rest extends TupleType.Rest> = Rest extends
    [infer Head, ...infer Tail] ? Readonly<[
      ...ElementsEncoded<Elements>,
      ...ReadonlyArray<Schema.Encoded<Head>>,
      ...{ readonly [K in keyof Tail]: Schema.Encoded<Tail[K]> }
    ]> :
    ElementsEncoded<Elements>
}

/**
@category api interface
@since 3.10.0
/
export interface TupleType<Elements extends TupleType.Elements, Rest extends TupleType.Rest> extends
  AnnotableClass<
    TupleType<Elements, Rest>,
    TupleType.Type<Elements, Rest>,
    TupleType.Encoded<Elements, Rest>,
    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>
  >
{
  readonly elements: Readonly<Elements>
  readonly rest: Readonly<Rest>
}

const getDefaultTupleTypeAST = <Elements extends TupleType.Elements, Rest extends TupleType.Rest>(
  elements: Elements,
  rest: Rest
) =>
  new AST.TupleType(
    elements.map((el) => isSchema(el) ? new AST.OptionalType(el.ast, false) : el.ast),
    rest.map((el) => isSchema(el) ? new AST.Type(el.ast) : el.ast),
    true
  )

function makeTupleTypeClass<Elements extends TupleType.Elements, Rest extends TupleType.Rest>(
  elements: Elements,
  rest: Rest,
  ast: AST.AST = getDefaultTupleTypeAST(elements, rest)
) {
  return class TupleTypeClass extends make<
    TupleType.Type<Elements, Rest>,
    TupleType.Encoded<Elements, Rest>,
    Schema.Context<Elements[number]> | Schema.Context<Rest[number]>
  >(ast) {
    static override annotations(
      annotations: Annotations.Schema<TupleType.Type<Elements, Rest>>
    ): TupleType<Elements, Rest> {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations))
    }

    static elements = [...elements] as any as Elements

    static rest = [...rest] as any as Rest
  }
}

/**
@category api interface
@since 3.10.0
/
export interface Tuple<Elements extends TupleType.Elements> extends TupleType<Elements, []> {
  annotations(annotations: Annotations.Schema<TupleType.Type<Elements, []>>): Tuple<Elements>
}

/**
@category api interface
@since 3.13.3
/
export interface Tuple2<Fst extends Schema.Any, Snd extends Schema.Any> extends
  AnnotableClass<
    Tuple2<Fst, Snd>,
    readonly [Schema.Type<Fst>, Schema.Type<Snd>],
    readonly [Schema.Encoded<Fst>, Schema.Encoded<Snd>],
    Schema.Context<Fst> | Schema.Context<Snd>
  >
{
  readonly elements: readonly [Fst, Snd]
  readonly rest: readonly []
}

/**
@category constructors
@since 3.10.0

## ArrayEnsure

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `ArrayEnsure(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface Array$<Value extends Schema.Any> extends TupleType<[], [Value]> {
  readonly value: Value
  annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>): Array$<Value>
}

function makeArrayClass<Value extends Schema.Any>(
  value: Value,
  ast?: AST.AST
): Array$<Value> {
  return class ArrayClass extends makeTupleTypeClass<[], [Value]>([], [value], ast) {
    static override annotations(annotations: Annotations.Schema<TupleType.Type<[], [Value]>>) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))
    }

    static value = value
  }
}

const Array$ = <Value extends Schema.Any>(value: Value): Array$<Value> => makeArrayClass(value)

export {
  /**
@category constructors
@since 3.10.0
/
  Array$ as Array
}

/**
@category api interface
@since 3.10.0
/
export interface NonEmptyArray<Value extends Schema.Any> extends
  AnnotableClass<
    NonEmptyArray<Value>,
    array_.NonEmptyReadonlyArray<Schema.Type<Value>>,
    array_.NonEmptyReadonlyArray<Schema.Encoded<Value>>,
    Schema.Context<Value>
  >
{
  readonly elements: readonly [Value]
  readonly rest: readonly [Value]
  readonly value: Value
}

function makeNonEmptyArrayClass<Value extends Schema.Any>(
  value: Value,
  ast?: AST.AST
) {
  return class NonEmptyArrayClass extends makeTupleTypeClass<[Value], [Value]>([value], [value], ast) {
    static override annotations(annotations: Annotations.Schema<TupleType.Type<[Value], [Value]>>) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations))
    }

    static value = value
  }
}

/**
@category constructors
@since 3.10.0
/
export const NonEmptyArray = <Value extends Schema.Any>(value: Value): NonEmptyArray<Value> =>
  makeNonEmptyArrayClass(value) as any

/**
@category api interface
@since 3.10.0
/
export interface ArrayEnsure<Value extends Schema.Any>
  extends transform<Union<[Value, Array$<Value>]>, Array$<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category constructors
@since 3.10.0

## NonEmptyArrayEnsure

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `NonEmptyArrayEnsure(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface NonEmptyArrayEnsure<Value extends Schema.Any>
  extends transform<Union<[Value, NonEmptyArray<Value>]>, NonEmptyArray<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category constructors
@since 3.10.0

## Struct

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `Struct(<Fields extends Struct.Fields, const Records extends IndexSignature.NonEmptyRecords>(
  fields: Fields,
  ...records: Records
)`

JSDoc:

@since 3.10.0
/
export declare namespace PropertySignature {
  /**
@since 3.10.0
/
  export type Token = "?:" | ":"

  /**
@since 3.10.0
/
  export type Any<Key extends PropertyKey = PropertyKey> = PropertySignature<
    Token,
    any,
    Key,
    Token,
    any,
    boolean,
    unknown
  >

  /**
@since 3.10.0
/
  export type All<Key extends PropertyKey = PropertyKey> =
    | Any<Key>
    | PropertySignature<Token, never, Key, Token, any, boolean, unknown>
    | PropertySignature<Token, any, Key, Token, never, boolean, unknown>
    | PropertySignature<Token, never, Key, Token, never, boolean, unknown>

  /**
@since 3.10.0
/
  export type AST =
    | PropertySignatureDeclaration
    | PropertySignatureTransformation

  /**
@since 3.10.0
/
  export interface Annotations<A> extends Annotations.Doc<A> {
    readonly missingMessage?: AST.MissingMessageAnnotation
  }
}

const formatPropertySignatureToken = (isOptional: boolean): string => isOptional ? "\"?:\"" : "\":\""

/**
@category PropertySignature
@since 3.10.0
/
export class PropertySignatureDeclaration extends AST.OptionalType {
  /**
@since 3.10.0
/
  readonly _tag = "PropertySignatureDeclaration"
  constructor(
    type: AST.AST,
    isOptional: boolean,
    readonly isReadonly: boolean,
    annotations: AST.Annotations,
    readonly defaultValue: (() => unknown) | undefined
  ) {
    super(type, isOptional, annotations)
  }
  /**
@since 3.10.0
/
  toString() {
    const token = formatPropertySignatureToken(this.isOptional)
    const type = String(this.type)
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`
  }
}

/**
@category PropertySignature
@since 3.10.0
/
export class FromPropertySignature extends AST.OptionalType {
  constructor(
    type: AST.AST,
    isOptional: boolean,
    readonly isReadonly: boolean,
    annotations: AST.Annotations,
    readonly fromKey?: PropertyKey | undefined
  ) {
    super(type, isOptional, annotations)
  }
}

/**
@category PropertySignature
@since 3.10.0
/
export class ToPropertySignature extends AST.OptionalType {
  constructor(
    type: AST.AST,
    isOptional: boolean,
    readonly isReadonly: boolean,
    annotations: AST.Annotations,
    readonly defaultValue: (() => unknown) | undefined
  ) {
    super(type, isOptional, annotations)
  }
}

const formatPropertyKey = (p: PropertyKey | undefined): string => {
  if (p === undefined) {
    return "never"
  }
  if (Predicate.isString(p)) {
    return JSON.stringify(p)
  }
  return String(p)
}

/**
@category PropertySignature
@since 3.10.0
/
export class PropertySignatureTransformation {
  /**
@since 3.10.0
/
  readonly _tag = "PropertySignatureTransformation"
  constructor(
    readonly from: FromPropertySignature,
    readonly to: ToPropertySignature,
    readonly decode: AST.PropertySignatureTransformation["decode"],
    readonly encode: AST.PropertySignatureTransformation["encode"]
  ) {}
  /**
@since 3.10.0
/
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${
      formatPropertyKey(this.from.fromKey)
    }, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`
  }
}

const mergeSignatureAnnotations = (
  ast: PropertySignature.AST,
  annotations: AST.Annotations
): PropertySignature.AST => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(
        ast.type,
        ast.isOptional,
        ast.isReadonly,
        { ...ast.annotations, ...annotations },
        ast.defaultValue
      )
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation(
        ast.from,
        new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations
        }, ast.to.defaultValue),
        ast.decode,
        ast.encode
      )
    }
  }
}

/**
@since 3.10.0
@category symbol
/
export const PropertySignatureTypeId: unique symbol = Symbol.for("effect/PropertySignature")

/**
@since 3.10.0
@category symbol
/
export type PropertySignatureTypeId = typeof PropertySignatureTypeId

/**
@since 3.10.0
@category guards
/
export const isPropertySignature = (u: unknown): u is PropertySignature.All =>
  Predicate.hasProperty(u, PropertySignatureTypeId)

/**
@category PropertySignature
@since 3.10.0
/
export interface PropertySignature<
  TypeToken extends PropertySignature.Token,
  Type,
  Key extends PropertyKey,
  EncodedToken extends PropertySignature.Token,
  Encoded,
  HasDefault extends boolean = false,
  R = never
> extends Schema.Variance<Type, Encoded, R>, Pipeable {
  readonly [PropertySignatureTypeId]: null
  readonly _TypeToken: TypeToken
  readonly _EncodedToken: EncodedToken
  readonly _HasDefault: HasDefault
  readonly _Key: Key
  readonly ast: PropertySignature.AST

  annotations(
    annotations: PropertySignature.Annotations<Type>
  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>
}

class PropertySignatureImpl<
  TypeToken extends PropertySignature.Token,
  Type,
  Key extends PropertyKey,
  EncodedToken extends PropertySignature.Token,
  Encoded,
  HasDefault extends boolean = false,
  R = never
> implements PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {
  readonly [TypeId]!: Schema.Variance<Type, Encoded, R>[TypeId]
  readonly [PropertySignatureTypeId] = null
  readonly _TypeToken!: TypeToken
  readonly _Key!: Key
  readonly _EncodedToken!: EncodedToken
  readonly _HasDefault!: HasDefault

  constructor(
    readonly ast: PropertySignature.AST
  ) {}

  pipe() {
    return pipeArguments(this, arguments)
  }

  annotations(
    annotations: PropertySignature.Annotations<Type>
  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)))
  }

  toString() {
    return String(this.ast)
  }
}

/**
@category PropertySignature
@since 3.10.0
/
export const makePropertySignature = <
  TypeToken extends PropertySignature.Token,
  Type,
  Key extends PropertyKey,
  EncodedToken extends PropertySignature.Token,
  Encoded,
  HasDefault extends boolean = false,
  R = never
>(ast: PropertySignature.AST) =>
  new PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>(ast)

class PropertySignatureWithFromImpl<
  From extends Schema.All,
  TypeToken extends PropertySignature.Token,
  Type,
  Key extends PropertyKey,
  EncodedToken extends PropertySignature.Token,
  Encoded,
  HasDefault extends boolean = false,
  R = never
> extends PropertySignatureImpl<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {
  constructor(ast: PropertySignature.AST, readonly from: From) {
    super(ast)
  }
  annotations(
    annotations: PropertySignature.Annotations<Type>
  ): PropertySignatureWithFromImpl<From, TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> {
    return new PropertySignatureWithFromImpl(
      mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations)),
      this.from
    )
  }
}

/**
@category API interface
@since 1.0.0
/
export interface propertySignature<S extends Schema.All>
  extends PropertySignature<":", Schema.Type<S>, never, ":", Schema.Encoded<S>, false, Schema.Context<S>>
{
  readonly from: S
  annotations(annotations: PropertySignature.Annotations<Schema.Type<S>>): propertySignature<S>
}

/**
Lifts a `Schema` into a `PropertySignature`.

@category PropertySignature
@since 3.10.0
/
export const propertySignature = <S extends Schema.All>(
  self: S
): propertySignature<S> =>
  new PropertySignatureWithFromImpl(
    new PropertySignatureDeclaration(self.ast, false, true, {}, undefined),
    self
  )

/**
Enhances a property signature with a default constructor value.

@category PropertySignature
@since 3.10.0
/
export const withConstructorDefault: {
  /**
Enhances a property signature with a default constructor value.

@category PropertySignature
@since 3.10.0
/
  <Type>(defaultValue: () => Types.NoInfer<Type>): <
    TypeToken extends PropertySignature.Token,
    Key extends PropertyKey,
    EncodedToken extends PropertySignature.Token,
    Encoded,
    R
  >(
    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>
  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>
  /**
Enhances a property signature with a default constructor value.

@category PropertySignature
@since 3.10.0
/
  <
    TypeToken extends PropertySignature.Token,
    Type,
    Key extends PropertyKey,
    EncodedToken extends PropertySignature.Token,
    Encoded,
    R
  >(
    self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,
    defaultValue: () => Types.NoInfer<Type>
  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>
} = dual(2, <
  TypeToken extends PropertySignature.Token,
  Type,
  Key extends PropertyKey,
  EncodedToken extends PropertySignature.Token,
  Encoded,
  R
>(
  self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>,
  defaultValue: () => Types.NoInfer<Type>
): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R> => {
  const ast = self.ast
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(
        new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue)
      )
    case "PropertySignatureTransformation":
      return makePropertySignature(
        new PropertySignatureTransformation(
          ast.from,
          new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue),
          ast.decode,
          ast.encode
        )
      )
  }
})

const applyDefaultValue = <A>(o: option_.Option<A>, defaultValue: () => A) =>
  option_.match(o, {
    onNone: () => option_.some(defaultValue()),
    onSome: (value) => option_.some(value === undefined ? defaultValue() : value)
  })

const pruneUndefined = (ast: AST.AST): AST.AST | undefined =>
  AST.pruneUndefined(ast, pruneUndefined, (ast) => {
    const pruned = pruneUndefined(ast.to)
    if (pruned) {
      return new AST.Transformation(ast.from, pruned, ast.transformation)
    }
  })

/**
Enhances a property signature with a default decoding value.

@category PropertySignature
@since 3.10.0
/
export const withDecodingDefault: {
  /**
Enhances a property signature with a default decoding value.

@category PropertySignature
@since 3.10.0
/
  <Type>(defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>): <
    Key extends PropertyKey,
    Encoded,
    R
  >(
    self: PropertySignature<"?:", Type, Key, "?:", Encoded, false, R>
  ) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, false, R>
  /**
Enhances a property signature with a default decoding value.

@category PropertySignature
@since 3.10.0
/
  <
    Type,
    Key extends PropertyKey,
    Encoded,
    R
  >(
    self: PropertySignature<"?:", Type, Key, "?:", Encoded, false, R>,
    defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>
  ): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, false, R>
} = dual(2, <
  Type,
  Key extends PropertyKey,
  Encoded,
  R
>(
  self: PropertySignature<"?:", Type, Key, "?:", Encoded, false, R>,
  defaultValue: () => Types.NoInfer<Exclude<Type, undefined>>
): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, false, R> => {
  const ast = self.ast
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      const to = AST.typeAST(ast.type)
      return makePropertySignature(
        new PropertySignatureTransformation(
          new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations),
          new ToPropertySignature(pruneUndefined(to) ?? to, false, true, {}, ast.defaultValue),
          (o) => applyDefaultValue(o, defaultValue),
          identity
        )
      )
    }
    case "PropertySignatureTransformation": {
      const to = ast.to.type
      return makePropertySignature(
        new PropertySignatureTransformation(
          ast.from,
          new ToPropertySignature(
            pruneUndefined(to) ?? to,
            false,
            ast.to.isReadonly,
            ast.to.annotations,
            ast.to.defaultValue
          ),
          (o) => applyDefaultValue(ast.decode(o), defaultValue),
          ast.encode
        )
      )
    }
  }
})

/**
Enhances a property signature with a default decoding value and a default constructor value.

@category PropertySignature
@since 3.10.0
/
export const withDefaults: {
  /**
Enhances a property signature with a default decoding value and a default constructor value.

@category PropertySignature
@since 3.10.0
/
  <Type>(
    defaults: {
      constructor: () => Types.NoInfer<Exclude<Type, undefined>>
      decoding: () => Types.NoInfer<Exclude<Type, undefined>>
    }
  ): <
    Key extends PropertyKey,
    Encoded,
    R
  >(
    self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>
  ) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>
  /**
Enhances a property signature with a default decoding value and a default constructor value.

@category PropertySignature
@since 3.10.0
/
  <
    Type,
    Key extends PropertyKey,
    Encoded,
    R
  >(
    self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>,
    defaults: {
      constructor: () => Types.NoInfer<Exclude<Type, undefined>>
      decoding: () => Types.NoInfer<Exclude<Type, undefined>>
    }
  ): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>
} = dual(2, <
  Type,
  Key extends PropertyKey,
  Encoded,
  R
>(
  self: PropertySignature<"?:", Type, Key, "?:", Encoded, false, R>,
  defaults: {
    constructor: () => Types.NoInfer<Exclude<Type, undefined>>
    decoding: () => Types.NoInfer<Exclude<Type, undefined>>
  }
): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R> =>
  self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)))

/**
Enhances a property signature by specifying a different key for it in the Encoded type.

@category PropertySignature
@since 3.10.0
/
export const fromKey: {
  /**
Enhances a property signature by specifying a different key for it in the Encoded type.

@category PropertySignature
@since 3.10.0
/
  <Key extends PropertyKey>(key: Key): <
    TypeToken extends PropertySignature.Token,
    Type,
    EncodedToken extends PropertySignature.Token,
    Encoded,
    HasDefault extends boolean,
    R
  >(
    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>
  ) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>
  /**
Enhances a property signature by specifying a different key for it in the Encoded type.

@category PropertySignature
@since 3.10.0
/
  <
    Type,
    TypeToken extends PropertySignature.Token,
    Encoded,
    EncodedToken extends PropertySignature.Token,
    HasDefault extends boolean,
    R,
    Key extends PropertyKey
  >(
    self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,
    key: Key
  ): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>
} = dual(2, <
  Type,
  TypeToken extends PropertySignature.Token,
  Encoded,
  EncodedToken extends PropertySignature.Token,
  HasDefault extends boolean,
  R,
  Key extends PropertyKey
>(
  self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>,
  key: Key
): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R> => {
  const ast = self.ast
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(
        new PropertySignatureTransformation(
          new FromPropertySignature(
            ast.type,
            ast.isOptional,
            ast.isReadonly,
            ast.annotations,
            key
          ),
          new ToPropertySignature(AST.typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue),
          identity,
          identity
        )
      )
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(
        new PropertySignatureTransformation(
          new FromPropertySignature(
            ast.from.type,
            ast.from.isOptional,
            ast.from.isReadonly,
            ast.from.annotations,
            key
          ),
          ast.to,
          ast.decode,
          ast.encode
        )
      )
  }
})

/**
Converts an optional property to a required one through a transformation `Option -> Type`.

- `decode`: `none` as argument means the value is missing in the input.
- `encode`: `none` as return value means the value will be missing in the output.

@category PropertySignature
@since 3.10.0
/
export const optionalToRequired = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: option_.Option<FA>) => TI
    readonly encode: (ti: TI) => option_.Option<FA>
  }
): PropertySignature<":", TA, never, "?:", FI, false, FR | TR> =>
  makePropertySignature(
    new PropertySignatureTransformation(
      new FromPropertySignature(from.ast, true, true, {}, undefined),
      new ToPropertySignature(to.ast, false, true, {}, undefined),
      (o) => option_.some(options.decode(o)),
      option_.flatMap(options.encode)
    )
  )

/**
Converts an optional property to a required one through a transformation `Type -> Option`.

- `decode`: `none` as return value means the value will be missing in the output.
- `encode`: `none` as argument means the value is missing in the input.

@category PropertySignature
@since 3.10.0
/
export const requiredToOptional = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (fa: FA) => option_.Option<TI>
    readonly encode: (o: option_.Option<TI>) => FA
  }
): PropertySignature<"?:", TA, never, ":", FI, false, FR | TR> =>
  makePropertySignature(
    new PropertySignatureTransformation(
      new FromPropertySignature(from.ast, false, true, {}, undefined),
      new ToPropertySignature(to.ast, true, true, {}, undefined),
      option_.flatMap(options.decode),
      (o) => option_.some(options.encode(o))
    )
  )

/**
Converts an optional property to another optional property through a transformation `Option -> Option`.

- `decode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.
- `encode`:
  - `none` as argument means the value is missing in the input.
  - `none` as return value means the value will be missing in the output.

@category PropertySignature
@since 3.10.0
/
export const optionalToOptional = <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>
    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>
  }
): PropertySignature<"?:", TA, never, "?:", FI, false, FR | TR> =>
  makePropertySignature(
    new PropertySignatureTransformation(
      new FromPropertySignature(from.ast, true, true, {}, undefined),
      new ToPropertySignature(to.ast, true, true, {}, undefined),
      options.decode,
      options.encode
    )
  )

/**
@since 3.10.0
/
export type OptionalOptions<A> = {
  readonly default?: never
  readonly as?: never
  readonly exact?: true
  readonly nullable?: true
} | {
  readonly default: LazyArg<A>
  readonly as?: never
  readonly exact?: true
  readonly nullable?: true
} | {
  readonly as: "Option"
  readonly default?: never
  readonly exact?: never
  readonly nullable?: never
  readonly onNoneEncoding?: LazyArg<option_.Option<undefined>>
} | {
  readonly as: "Option"
  readonly default?: never
  readonly exact?: never
  readonly nullable: true
  readonly onNoneEncoding?: LazyArg<option_.Option<null | undefined>>
} | {
  readonly as: "Option"
  readonly default?: never
  readonly exact: true
  readonly nullable?: never
  readonly onNoneEncoding?: never
} | {
  readonly as: "Option"
  readonly default?: never
  readonly exact: true
  readonly nullable: true
  readonly onNoneEncoding?: LazyArg<option_.Option<null>>
} | undefined

/**
@category api interface
@since 3.10.0
/
export interface optional<S extends Schema.All> extends
  PropertySignature<
    "?:",
    Schema.Type<S> | undefined,
    never,
    "?:",
    Schema.Encoded<S> | undefined,
    false,
    Schema.Context<S>
  >
{
  readonly from: S
  annotations(annotations: PropertySignature.Annotations<Schema.Type<S> | undefined>): optional<S>
}

/**
@category api interface
@since 3.10.0
/
export interface optionalWith<S extends Schema.All, Options> extends
  PropertySignature<
    Types.Has<Options, "as" | "default"> extends true ? ":" : "?:",
    | (Types.Has<Options, "as"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)
    | (Types.Has<Options, "as" | "default" | "exact"> extends true ? never : undefined),
    never,
    "?:",
    | Schema.Encoded<S>
    | (Types.Has<Options, "nullable"> extends true ? null : never)
    | (Types.Has<Options, "exact"> extends true ? never : undefined),
    Types.Has<Options, "default">,
    Schema.Context<S>
  >
{
  readonly from: S
  annotations(
    annotations: PropertySignature.Annotations<
      | (Types.Has<Options, "as"> extends true ? option_.Option<Schema.Type<S>> : Schema.Type<S>)
      | (Types.Has<Options, "as" | "default" | "exact"> extends true ? never : undefined)
    >
  ): optionalWith<S, Options>
}

const optionalPropertySignatureAST = <A, I, R>(
  self: Schema<A, I, R>,
  options?: {
    readonly exact?: true
    readonly default?: () => A
    readonly nullable?: true
    readonly as?: "Option"
    readonly onNoneEncoding?: () => option_.Option<never>
  }
): PropertySignature.AST => {
  const isExact = options?.exact
  const defaultValue = options?.default
  const isNullable = options?.nullable
  const asOption = options?.as == "Option"
  const asOptionEncode = options?.onNoneEncoding ? option_.orElse(options.onNoneEncoding) : identity

  if (isExact) {
    if (defaultValue) {
      if (isNullable) {
        return withConstructorDefault(
          optionalToRequired(
            NullOr(self),
            typeSchema(self),
            {
              decode: option_.match({ onNone: defaultValue, onSome: (a) => a === null ? defaultValue() : a }),
              encode: option_.some
            }
          ),
          defaultValue
        ).ast
      } else {
        return withConstructorDefault(
          optionalToRequired(
            self,
            typeSchema(self),
            { decode: option_.match({ onNone: defaultValue, onSome: identity }), encode: option_.some }
          ),
          defaultValue
        ).ast
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(
          NullOr(self),
          OptionFromSelf(typeSchema(self)),
          {
            decode: option_.filter(Predicate.isNotNull<A | null>),
            encode: asOptionEncode
          }
        ).ast
      } else {
        return optionalToRequired(
          self,
          OptionFromSelf(typeSchema(self)),
          { decode: identity, encode: identity }
        ).ast
      }
    } else {
      if (isNullable) {
        return optionalToOptional(
          NullOr(self),
          typeSchema(self),
          { decode: option_.filter(Predicate.isNotNull<A | null>), encode: identity }
        ).ast
      } else {
        return new PropertySignatureDeclaration(self.ast, true, true, {}, undefined)
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable) {
        return withConstructorDefault(
          optionalToRequired(
            NullishOr(self),
            typeSchema(self),
            {
              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a == null ? defaultValue() : a) }),
              encode: option_.some
            }
          ),
          defaultValue
        ).ast
      } else {
        return withConstructorDefault(
          optionalToRequired(
            UndefinedOr(self),
            typeSchema(self),
            {
              decode: option_.match({ onNone: defaultValue, onSome: (a) => (a === undefined ? defaultValue() : a) }),
              encode: option_.some
            }
          ),
          defaultValue
        ).ast
      }
    } else if (asOption) {
      if (isNullable) {
        return optionalToRequired(
          NullishOr(self),
          OptionFromSelf(typeSchema(self)),
          {
            decode: option_.filter<A | null | undefined, A>((a): a is A => a != null),
            encode: asOptionEncode
          }
        ).ast
      } else {
        return optionalToRequired(
          UndefinedOr(self),
          OptionFromSelf(typeSchema(self)),
          {
            decode: option_.filter(Predicate.isNotUndefined<A | undefined>),
            encode: asOptionEncode
          }
        ).ast
      }
    } else {
      if (isNullable) {
        return optionalToOptional(
          NullishOr(self),
          UndefinedOr(typeSchema(self)),
          { decode: option_.filter(Predicate.isNotNull<A | null | undefined>), encode: identity }
        ).ast
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, undefined)
      }
    }
  }
}

/**
@category PropertySignature
@since 3.10.0
/
export const optional = <S extends Schema.All>(self: S): optional<S> => {
  const ast = self.ast === AST.undefinedKeyword || self.ast === AST.neverKeyword
    ? AST.undefinedKeyword
    : UndefinedOr(self).ast
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self)
}

/**
@category PropertySignature
@since 3.10.0
/
export const optionalWith: {
  /**
@category PropertySignature
@since 3.10.0
/
  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(options: Options): (self: S) => optionalWith<S, Options>
  /**
@category PropertySignature
@since 3.10.0
/
  <S extends Schema.All, Options extends OptionalOptions<Schema.Type<S>>>(self: S, options: Options): optionalWith<S, Options>
} = dual((args) => isSchema(args[0]), (self, options) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self)
})

/**
@since 3.10.0
/
export declare namespace Struct {
  /**
Useful for creating a type that can be used to add custom constraints to the fields of a struct.

```ts
import { Schema } from "effect"

const f = <Fields extends Record<"a" | "b", Schema.Struct.Field>>(
  schema: Schema.Struct<Fields>
) => {
  return schema.omit("a")
}

//       Schema.Struct<{ b: typeof Schema.Number; }>
//      
const result = f(Schema.Struct({ a: Schema.String, b: Schema.Number }))
```
@since 3.13.11
/
  export type Field =
    | Schema.All
    | PropertySignature.All

  /**
@since 3.10.0
/
  export type Fields = { readonly [x: PropertyKey]: Field }

  type OptionalEncodedPropertySignature =
    | PropertySignature<PropertySignature.Token, any, PropertyKey, "?:", any, boolean, unknown>
    | PropertySignature<PropertySignature.Token, any, PropertyKey, "?:", never, boolean, unknown>
    | PropertySignature<PropertySignature.Token, never, PropertyKey, "?:", any, boolean, unknown>
    | PropertySignature<PropertySignature.Token, never, PropertyKey, "?:", never, boolean, unknown>

  type EncodedOptionalKeys<Fields extends Struct.Fields> = {
    [K in keyof Fields]: Fields[K] extends OptionalEncodedPropertySignature ? K
      : never
  }[keyof Fields]

  type OptionalTypePropertySignature =
    | PropertySignature<"?:", any, PropertyKey, PropertySignature.Token, any, boolean, unknown>
    | PropertySignature<"?:", any, PropertyKey, PropertySignature.Token, never, boolean, unknown>
    | PropertySignature<"?:", never, PropertyKey, PropertySignature.Token, any, boolean, unknown>
    | PropertySignature<"?:", never, PropertyKey, PropertySignature.Token, never, boolean, unknown>

  // type TypeOptionalKeys<Fields extends Struct.Fields> = {
  //   [K in keyof Fields]: Fields[K] extends OptionalTypePropertySignature ? K : never
  // }[keyof Fields]

  /**
@since 3.10.0
/
  export type Type<F extends Fields> = Types.UnionToIntersection<
    {
      [K in keyof F]: F[K] extends OptionalTypePropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :
        { readonly [h in K]: Schema.Type<F[h]> }
    }[keyof F]
  > extends infer Q ? Q : never

  type Key<F extends Fields, K extends keyof F> = [K] extends [never] ? never :
    F[K] extends PropertySignature.All<infer Key> ? [Key] extends [never] ? K : Key :
    K

  /**
@since 3.10.0
/
  export type Encoded<F extends Fields> =
    & { readonly [K in Exclude<keyof F, EncodedOptionalKeys<F>> as Key<F, K>]: Schema.Encoded<F[K]> }
    & { readonly [K in EncodedOptionalKeys<F> as Key<F, K>]?: Schema.Encoded<F[K]> }

  /**
@since 3.10.0
/
  export type Context<F extends Fields> = Schema.Context<F[keyof F]>

  type PropertySignatureWithDefault =
    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, any, true, unknown>
    | PropertySignature<PropertySignature.Token, any, PropertyKey, PropertySignature.Token, never, true, unknown>
    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, any, true, unknown>
    | PropertySignature<PropertySignature.Token, never, PropertyKey, PropertySignature.Token, never, true, unknown>

  /**
@since 3.10.0
/
  export type Constructor<F extends Fields> = Types.UnionToIntersection<
    {
      [K in keyof F]: F[K] extends OptionalTypePropertySignature ? { readonly [H in K]?: Schema.Type<F[H]> } :
        F[K] extends PropertySignatureWithDefault ? { readonly [H in K]?: Schema.Type<F[H]> } :
        { readonly [h in K]: Schema.Type<F[h]> }
    }[keyof F]
  > extends infer Q ? Q : never
}

/**
@since 3.10.0
/
export declare namespace IndexSignature {
  /**
@since 3.10.0
/
  export type Record = { readonly key: Schema.All; readonly value: Schema.All }

  /**
@since 3.10.0
/
  export type Records = ReadonlyArray<Record>

  /**
@since 3.10.0
/
  export type NonEmptyRecords = array_.NonEmptyReadonlyArray<Record>

  type MergeTuple<T extends ReadonlyArray<unknown>> = T extends readonly [infer Head, ...infer Tail] ?
    Head & MergeTuple<Tail>
    : {}

  /**
@since 3.10.0
/
  export type Type<Records extends IndexSignature.Records> = MergeTuple<
    {
      readonly [K in keyof Records]: {
        readonly [P in Schema.Type<Records[K]["key"]>]: Schema.Type<Records[K]["value"]>
      }
    }
  >

  /**
@since 3.10.0
/
  export type Encoded<Records extends IndexSignature.Records> = MergeTuple<
    {
      readonly [K in keyof Records]: {
        readonly [P in Schema.Encoded<Records[K]["key"]>]: Schema.Encoded<Records[K]["value"]>
      }
    }
  >

  /**
@since 3.10.0
/
  export type Context<Records extends IndexSignature.Records> = {
    [K in keyof Records]: Schema.Context<Records[K]["key"]> | Schema.Context<Records[K]["value"]>
  }[number]
}

/**
@since 3.10.0
/
export declare namespace TypeLiteral {
  /**
@since 3.10.0
/
  export type Type<Fields extends Struct.Fields, Records extends IndexSignature.Records> =
    & Struct.Type<Fields>
    & IndexSignature.Type<Records>

  /**
@since 3.10.0
/
  export type Encoded<Fields extends Struct.Fields, Records extends IndexSignature.Records> =
    & Struct.Encoded<Fields>
    & IndexSignature.Encoded<Records>

  /**
@since 3.10.0
/
  export type Constructor<Fields extends Struct.Fields, Records extends IndexSignature.Records> =
    & Struct.Constructor<Fields>
    & IndexSignature.Type<Records>
}

/**
@category api interface
@since 3.10.0
/
export interface TypeLiteral<
  Fields extends Struct.Fields,
  Records extends IndexSignature.Records
> extends
  AnnotableClass<
    TypeLiteral<Fields, Records>,
    Simplify<TypeLiteral.Type<Fields, Records>>,
    Simplify<TypeLiteral.Encoded<Fields, Records>>,
    | Struct.Context<Fields>
    | IndexSignature.Context<Records>
  >
{
  readonly fields: Readonly<Fields>
  readonly records: Readonly<Records>
  annotations(
    annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>
  ): TypeLiteral<Fields, Records>
  make(
    props: RequiredKeys<TypeLiteral.Constructor<Fields, Records>> extends never
      ? void | Simplify<TypeLiteral.Constructor<Fields, Records>>
      : Simplify<TypeLiteral.Constructor<Fields, Records>>,
    options?: MakeOptions
  ): Simplify<TypeLiteral.Type<Fields, Records>>
}

const preserveMissingMessageAnnotation = AST.pickAnnotations([AST.MissingMessageAnnotationId])

const getDefaultTypeLiteralAST = <
  Fields extends Struct.Fields,
  const Records extends IndexSignature.Records
>(fields: Fields, records: Records) => {
  const ownKeys = util_.ownKeys(fields)
  const pss: Array<AST.PropertySignature> = []
  if (ownKeys.length > 0) {
    const from: Array<AST.PropertySignature> = []
    const to: Array<AST.PropertySignature> = []
    const transformations: Array<AST.PropertySignatureTransformation> = []
    for (let i = 0; i < ownKeys.length; i++) {
      const key = ownKeys[i]
      const field = fields[key]
      if (isPropertySignature(field)) {
        const ast: PropertySignature.AST = field.ast
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type = ast.type
            const isOptional = ast.isOptional
            const toAnnotations = ast.annotations
            from.push(new AST.PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)))
            to.push(new AST.PropertySignature(key, AST.typeAST(type), isOptional, true, toAnnotations))
            pss.push(
              new AST.PropertySignature(key, type, isOptional, true, toAnnotations)
            )
            break
          }
          case "PropertySignatureTransformation": {
            const fromKey = ast.from.fromKey ?? key
            from.push(
              new AST.PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations)
            )
            to.push(
              new AST.PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations)
            )
            transformations.push(new AST.PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode))
            break
          }
        }
      } else {
        from.push(new AST.PropertySignature(key, field.ast, false, true))
        to.push(new AST.PropertySignature(key, AST.typeAST(field.ast), false, true))
        pss.push(new AST.PropertySignature(key, field.ast, false, true))
      }
    }
    if (array_.isNonEmptyReadonlyArray(transformations)) {
      const issFrom: Array<AST.IndexSignature> = []
      const issTo: Array<AST.IndexSignature> = []
      for (const r of records) {
        const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)
        propertySignatures.forEach((ps) => {
          from.push(ps)
          to.push(
            new AST.PropertySignature(ps.name, AST.typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations)
          )
        })
        indexSignatures.forEach((is) => {
          issFrom.push(is)
          issTo.push(new AST.IndexSignature(is.parameter, AST.typeAST(is.type), is.isReadonly))
        })
      }
      return new AST.Transformation(
        new AST.TypeLiteral(from, issFrom, { [AST.AutoTitleAnnotationId]: "Struct (Encoded side)" }),
        new AST.TypeLiteral(to, issTo, { [AST.AutoTitleAnnotationId]: "Struct (Type side)" }),
        new AST.TypeLiteralTransformation(transformations)
      )
    }
  }
  const iss: Array<AST.IndexSignature> = []
  for (const r of records) {
    const { indexSignatures, propertySignatures } = AST.record(r.key.ast, r.value.ast)
    propertySignatures.forEach((ps) => pss.push(ps))
    indexSignatures.forEach((is) => iss.push(is))
  }
  return new AST.TypeLiteral(pss, iss)
}

const lazilyMergeDefaults = (
  fields: Struct.Fields,
  out: Record<PropertyKey, unknown>
): { [x: string | symbol]: unknown } => {
  const ownKeys = util_.ownKeys(fields)
  for (const key of ownKeys) {
    const field = fields[key]
    if (out[key] === undefined && isPropertySignature(field)) {
      const ast = field.ast
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue
      if (defaultValue !== undefined) {
        out[key] = defaultValue()
      }
    }
  }
  return out
}

function makeTypeLiteralClass<Fields extends Struct.Fields, const Records extends IndexSignature.Records>(
  fields: Fields,
  records: Records,
  ast: AST.AST = getDefaultTypeLiteralAST(fields, records)
): TypeLiteral<Fields, Records> {
  return class TypeLiteralClass extends make<
    Simplify<TypeLiteral.Type<Fields, Records>>,
    Simplify<TypeLiteral.Encoded<Fields, Records>>,
    | Struct.Context<Fields>
    | IndexSignature.Context<Records>
  >(ast) {
    static override annotations(
      annotations: Annotations.Schema<Simplify<TypeLiteral.Type<Fields, Records>>>
    ): TypeLiteral<Fields, Records> {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations))
    }

    static fields = { ...fields }

    static records = [...records] as Records

    static make = (
      props: Simplify<TypeLiteral.Constructor<Fields, Records>>,
      options?: MakeOptions
    ): Simplify<TypeLiteral.Type<Fields, Records>> => {
      const propsWithDefaults: any = lazilyMergeDefaults(fields, { ...props as any })
      return getDisableValidationMakeOption(options)
        ? propsWithDefaults
        : ParseResult.validateSync(this)(propsWithDefaults)
    }

    static pick(...keys: Array<keyof Fields>): Struct<Simplify<Pick<Fields, typeof keys[number]>>> {
      return Struct(struct_.pick(fields, ...keys) as any)
    }

    static omit(...keys: Array<keyof Fields>): Struct<Simplify<Omit<Fields, typeof keys[number]>>> {
      return Struct(struct_.omit(fields, ...keys) as any)
    }
  }
}

/**
@category api interface
@since 3.10.0
/
export interface Struct<Fields extends Struct.Fields> extends
  AnnotableClass<
    Struct<Fields>,
    Simplify<Struct.Type<Fields>>,
    Simplify<Struct.Encoded<Fields>>,
    Struct.Context<Fields>
  >
{
  readonly fields: Readonly<Fields>
  readonly records: readonly []
  make(
    props: RequiredKeys<Struct.Constructor<Fields>> extends never ? void | Simplify<Struct.Constructor<Fields>>
      : Simplify<Struct.Constructor<Fields>>,
    options?: MakeOptions
  ): Simplify<Struct.Type<Fields>>

  annotations(annotations: Annotations.Schema<Simplify<Struct.Type<Fields>>>): Struct<Fields>
  pick<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Pick<Fields, Keys[number]>>>
  omit<Keys extends ReadonlyArray<keyof Fields>>(...keys: Keys): Struct<Simplify<Omit<Fields, Keys[number]>>>
}

/**
@category constructors
@since 3.10.0

## filter

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `filter(<C extends A, B extends A, A = C>(
  refinement: (a: A, options: ParseOptions, self: AST.Refinement)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface tag<Tag extends AST.LiteralValue> extends PropertySignature<":", Tag, never, ":", Tag, true, never> {}

/**
Returns a property signature that represents a tag.
A tag is a literal value that is used to distinguish between different types of objects.
The tag is optional when using the `make` method.

@example
```ts
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.Struct({
  _tag: Schema.tag("User"),
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

@see {@link TaggedStruct}

@since 3.10.0
/
export const tag = <Tag extends AST.LiteralValue>(tag: Tag): tag<Tag> =>
  Literal(tag).pipe(propertySignature, withConstructorDefault(() => tag))

/**
@category api interface
@since 3.10.0
/
export type TaggedStruct<Tag extends AST.LiteralValue, Fields extends Struct.Fields> = Struct<
  { _tag: tag<Tag> } & Fields
>

/**
A tagged struct is a struct that has a tag property that is used to distinguish between different types of objects.

The tag is optional when using the `make` method.

@example
```ts
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.TaggedStruct("User", {
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })
```

@category constructors
@since 3.10.0
/
export const TaggedStruct = <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(
  value: Tag,
  fields: Fields
): TaggedStruct<Tag, Fields> => Struct({ _tag: tag(value), ...fields })

/**
@category api interface
@since 3.10.0
/
export interface Record$<K extends Schema.All, V extends Schema.All> extends
  AnnotableClass<
    Record$<K, V>,
    { readonly [P in Schema.Type<K>]: Schema.Type<V> },
    { readonly [P in Schema.Encoded<K>]: Schema.Encoded<V> },
    | Schema.Context<K>
    | Schema.Context<V>
  >
{
  readonly fields: {}
  readonly records: readonly [{ readonly key: K; readonly value: V }]
  readonly key: K
  readonly value: V
  make(
    props: void | { readonly [P in Schema.Type<K>]: Schema.Type<V> },
    options?: MakeOptions
  ): { readonly [P in Schema.Type<K>]: Schema.Type<V> }
  annotations(annotations: Annotations.Schema<{ readonly [P in Schema.Type<K>]: Schema.Type<V> }>): Record$<K, V>
}

function makeRecordClass<K extends Schema.All, V extends Schema.All>(
  key: K,
  value: V,
  ast?: AST.AST
): Record$<K, V> {
  return class RecordClass extends makeTypeLiteralClass({}, [{ key, value }], ast) {
    static override annotations(
      annotations: Annotations.Schema<{ readonly [P in Schema.Type<K>]: Schema.Type<V> }>
    ): Record$<K, V> {
      return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations))
    }

    static key = key

    static value = value
  }
}

/**
@category constructors
@since 3.10.0
/
export const Record = <K extends Schema.All, V extends Schema.All>(
  options: { readonly key: K; readonly value: V }
): Record$<K, V> => makeRecordClass(options.key, options.value)

/**
@category struct transformations
@since 3.10.0
/
export const pick = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>
<R>(
  self: Schema<A, I, R>
): SchemaClass<Simplify<Pick<A, Keys[number]>>, Simplify<Pick<I, Keys[number]>>, R> => make(AST.pick(self.ast, keys))

/**
@category struct transformations
@since 3.10.0
/
export const omit = <A, I, Keys extends ReadonlyArray<keyof A & keyof I>>(...keys: Keys) =>
<R>(
  self: Schema<A, I, R>
): SchemaClass<Simplify<Omit<A, Keys[number]>>, Simplify<Omit<I, Keys[number]>>, R> => make(AST.omit(self.ast, keys))

/**
Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

@example
```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

@category struct transformations
@since 3.10.0
/
export const pluck: {
  /**
Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

@example
```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

@category struct transformations
@since 3.10.0
/
  <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => SchemaClass<A[K], Simplify<Pick<I, K>>, R>
  /**
Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

@example
```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

@category struct transformations
@since 3.10.0
/
  <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): SchemaClass<A[K], Simplify<Pick<I, K>>, R>
} = dual(
  2,
  <A, I, R, K extends keyof A & keyof I>(
    schema: Schema<A, I, R>,
    key: K
  ): Schema<A[K], Pick<I, K>, R> => {
    const ps = AST.getPropertyKeyIndexedAccess(AST.typeAST(schema.ast), key)
    const value = make</**
Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

@example
```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

@category struct transformations
@since 3.10.0
/
    A[K], /**
Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

@example
```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

@category struct transformations
@since 3.10.0
/
    A[K], /**
Given a schema `Schema<A, I, R>` and a key `key: K`, this function extracts a specific field from the `A` type,
producing a new schema that represents a transformation from the `{ readonly [key]: I[K] }` type to `A[K]`.

@example
```ts
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }
```

@category struct transformations
@since 3.10.0
/
    R>(ps.isOptional ? AST.orUndefined(ps.type) : ps.type)
    const out = transform(
      schema.pipe(pick(key)),
      value,
      {
        strict: true,
        decode: (i) => i[key],
        encode: (a) => ps.isOptional && a === undefined ? {} : { [key]: a } as any
      }
    )
    return out
  }
)

/**
@category branding
@since 3.10.0
/
export interface BrandSchema<A extends Brand<any>, I = A, R = never>
  extends AnnotableClass<BrandSchema<A, I, R>, A, I, R>
{
  make(a: Brand.Unbranded<A>, options?: MakeOptions): A
}

/**
@category api interface
@since 3.10.0
/
export interface brand<S extends Schema.Any, B extends string | symbol>
  extends BrandSchema<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>
{
  readonly from: S
  annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B>
}

function makeBrandClass<S extends Schema.Any, B extends string | symbol>(
  from: S,
  ast: AST.AST
): brand<S, B> {
  return class BrandClass extends make<Schema.Type<S> & Brand<B>, Schema.Encoded<S>, Schema.Context<S>>(ast) {
    static override annotations(annotations: Annotations.Schema<Schema.Type<S> & Brand<B>>): brand<S, B> {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations))
    }

    static make = (a: Brand.Unbranded<Schema.Type<S> & Brand<B>>, options?: MakeOptions): Schema.Type<S> & Brand<B> => {
      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)
    }

    static from = from
  }
}

/**
Returns a nominal branded schema by applying a brand to a given schema.

```
Schema<A> + B -> Schema<A & Brand<B>>
```

@example
```ts
import * as Schema from "effect/Schema"

const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">
```

@category branding
@since 3.10.0
/
export const brand = <S extends Schema.Any, B extends string | symbol>(
  brand: B,
  annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>
) =>
(self: S): brand<S, B> => {
  const annotation: AST.BrandAnnotation = option_.match(AST.getBrandAnnotation(self.ast), {
    onNone: () => [brand],
    onSome: (brands) => [...brands, brand]
  })
  const ast = AST.annotations(
    self.ast,
    toASTAnnotations({
      [AST.BrandAnnotationId]: annotation,
      ...annotations
    })
  )
  return makeBrandClass(self, ast)
}

/**
@category combinators
@since 3.10.0
/
export const partial = <A, I, R>(
  self: Schema<A, I, R>
): SchemaClass<{ [K in keyof A]?: A[K] | undefined }, { [K in keyof I]?: I[K] | undefined }, R> =>
  make(AST.partial(self.ast))

/**
@category combinators
@since 3.10.0
/
export const partialWith: {
  /**
@category combinators
@since 3.10.0
/
  <const Options extends { readonly exact: true }>(options: Options): <A, I, R>(
    self: Schema<A, I, R>
  ) => SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>
  /**
@category combinators
@since 3.10.0
/
  <A, I, R, const Options extends { readonly exact: true } | undefined>(self: Schema<A, I, R>, options: Options): SchemaClass<{ [K in keyof A]?: A[K] }, { [K in keyof I]?: I[K] }, R>
} = dual((args) => isSchema(args[0]), <A, I, R>(
  self: Schema<A, I, R>,
  options: { readonly exact: true }
): SchemaClass<Partial<A>, Partial<I>, R> => make(AST.partial(self.ast, options)))

/**
@category combinators
@since 3.10.0
/
export const required = <A, I, R>(
  self: Schema<A, I, R>
): SchemaClass<{ [K in keyof A]-?: A[K] }, { [K in keyof I]-?: I[K] }, R> => make(AST.required(self.ast))

/**
@category api interface
@since 3.10.0
/
export interface mutable<S extends Schema.Any> extends
  AnnotableClass<
    mutable<S>,
    SimplifyMutable<Schema.Type<S>>,
    SimplifyMutable<Schema.Encoded<S>>,
    Schema.Context<S>
  >
{}

/**
Creates a new schema with shallow mutability applied to its properties.

@category combinators
@since 3.10.0
/
export const mutable = <S extends Schema.Any>(schema: S): mutable<S> => make(AST.mutable(schema.ast))

const intersectTypeLiterals = (
  x: AST.AST,
  y: AST.AST,
  path: ReadonlyArray<PropertyKey>
): AST.TypeLiteral => {
  if (AST.isTypeLiteral(x) && AST.isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures]
    for (const ps of y.propertySignatures) {
      const name = ps.name
      const i = propertySignatures.findIndex((ps) => ps.name === name)
      if (i === -1) {
        propertySignatures.push(ps)
      } else {
        const { isOptional, type } = propertySignatures[i]
        propertySignatures[i] = new AST.PropertySignature(
          name,
          extendAST(type, ps.type, path.concat(name)),
          isOptional,
          true
        )
      }
    }
    return new AST.TypeLiteral(
      propertySignatures,
      x.indexSignatures.concat(y.indexSignatures)
    )
  }
  throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))
}

const preserveRefinementAnnotations = AST.omitAnnotations([AST.IdentifierAnnotationId])

const addRefinementToMembers = (refinement: AST.Refinement, asts: ReadonlyArray<AST.AST>): Array<AST.Refinement> =>
  asts.map((ast) => new AST.Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)))

const extendAST = (x: AST.AST, y: AST.AST, path: ReadonlyArray<PropertyKey>): AST.AST =>
  AST.Union.make(intersectUnionMembers([x], [y], path))

const getTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => AST.isUnion(ast) ? ast.types : [ast]

const intersectUnionMembers = (
  xs: ReadonlyArray<AST.AST>,
  ys: ReadonlyArray<AST.AST>,
  path: ReadonlyArray<PropertyKey>
): Array<AST.AST> =>
  array_.flatMap(xs, (x) =>
    array_.flatMap(ys, (y) => {
      switch (y._tag) {
        case "Literal": {
          if (
            (Predicate.isString(y.literal) && AST.isStringKeyword(x) ||
              (Predicate.isNumber(y.literal) && AST.isNumberKeyword(x)) ||
              (Predicate.isBoolean(y.literal) && AST.isBooleanKeyword(x)))
          ) {
            return [y]
          }
          break
        }
        case "StringKeyword": {
          if (y === AST.stringKeyword) {
            if (AST.isStringKeyword(x) || (AST.isLiteral(x) && Predicate.isString(x.literal))) {
              return [x]
            } else if (AST.isRefinement(x)) {
              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))
            }
          } else if (x === AST.stringKeyword) {
            return [y]
          }
          break
        }
        case "NumberKeyword": {
          if (y === AST.numberKeyword) {
            if (AST.isNumberKeyword(x) || (AST.isLiteral(x) && Predicate.isNumber(x.literal))) {
              return [x]
            } else if (AST.isRefinement(x)) {
              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))
            }
          } else if (x === AST.numberKeyword) {
            return [y]
          }
          break
        }
        case "BooleanKeyword": {
          if (y === AST.booleanKeyword) {
            if (AST.isBooleanKeyword(x) || (AST.isLiteral(x) && Predicate.isBoolean(x.literal))) {
              return [x]
            } else if (AST.isRefinement(x)) {
              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))
            }
          } else if (x === AST.booleanKeyword) {
            return [y]
          }
          break
        }
        case "Union":
          return intersectUnionMembers(getTypes(x), y.types, path)
        case "Suspend":
          return [new AST.Suspend(() => extendAST(x, y.f(), path))]
        case "Refinement":
          return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path))
        case "TypeLiteral": {
          switch (x._tag) {
            case "Union":
              return intersectUnionMembers(x.types, [y], path)
            case "Suspend":
              return [new AST.Suspend(() => extendAST(x.f(), y, path))]
            case "Refinement":
              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path))
            case "TypeLiteral":
              return [intersectTypeLiterals(x, y, path)]
            case "Transformation": {
              const transformation = x.transformation
              const from = intersectTypeLiterals(x.from, y, path)
              const to = intersectTypeLiterals(x.to, AST.typeAST(y), path)
              switch (transformation._tag) {
                case "TypeLiteralTransformation":
                  return [
                    new AST.Transformation(
                      from,
                      to,
                      new AST.TypeLiteralTransformation(transformation.propertySignatureTransformations)
                    )
                  ]
                case "ComposeTransformation":
                  return [new AST.Transformation(from, to, AST.composeTransformation)]
                case "FinalTransformation":
                  return [
                    new AST.Transformation(
                      from,
                      to,
                      new AST.FinalTransformation(
                        (fromA, options, ast, fromI) =>
                          ParseResult.map(
                            transformation.decode(fromA, options, ast, fromI),
                            (partial) => ({ ...fromA, ...partial })
                          ),
                        (toI, options, ast, toA) =>
                          ParseResult.map(
                            transformation.encode(toI, options, ast, toA),
                            (partial) => ({ ...toI, ...partial })
                          )
                      )
                    )
                  ]
              }
            }
          }
          break
        }
        case "Transformation": {
          if (AST.isTransformation(x)) {
            if (
              AST.isTypeLiteralTransformation(y.transformation) && AST.isTypeLiteralTransformation(x.transformation)
            ) {
              return [
                new AST.Transformation(
                  intersectTypeLiterals(x.from, y.from, path),
                  intersectTypeLiterals(x.to, y.to, path),
                  new AST.TypeLiteralTransformation(
                    y.transformation.propertySignatureTransformations.concat(
                      x.transformation.propertySignatureTransformations
                    )
                  )
                )
              ]
            }
          } else {
            return intersectUnionMembers([y], [x], path)
          }
          break
        }
      }
      throw new Error(errors_.getSchemaExtendErrorMessage(x, y, path))
    }))

/**
@category api interface
@since 3.10.0
/
export interface extend<Self extends Schema.Any, That extends Schema.Any> extends
  AnnotableClass<
    extend<Self, That>,
    Schema.Type<Self> & Schema.Type<That>,
    Schema.Encoded<Self> & Schema.Encoded<That>,
    Schema.Context<Self> | Schema.Context<That>
  >
{}

/**
Extends a schema with another schema.

Not all extensions are supported, and their support depends on the nature of
the involved schemas.

Possible extensions include:
- `Schema.String` with another `Schema.String` refinement or a string literal
- `Schema.Number` with another `Schema.Number` refinement or a number literal
- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean
  literal
- A struct with another struct where overlapping fields support extension
- A struct with in index signature
- A struct with a union of supported schemas
- A refinement of a struct with a supported schema
- A suspend of a struct with a supported schema
- A transformation between structs where the from and to sides have no
  overlapping fields with the target struct

@example
```ts
import * as Schema from "effect/Schema"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

// const extended: Schema<
//   {
//     readonly a: string
//     readonly b: string
//   } & {
//     readonly c: string
//   } & {
//     readonly [x: string]: string
//   }
// >
const extended = Schema.asSchema(schema.pipe(
  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures
))
```

@category combinators
@since 3.10.0
/
export const extend: {
  /**
Extends a schema with another schema.

Not all extensions are supported, and their support depends on the nature of
the involved schemas.

Possible extensions include:
- `Schema.String` with another `Schema.String` refinement or a string literal
- `Schema.Number` with another `Schema.Number` refinement or a number literal
- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean
  literal
- A struct with another struct where overlapping fields support extension
- A struct with in index signature
- A struct with a union of supported schemas
- A refinement of a struct with a supported schema
- A suspend of a struct with a supported schema
- A transformation between structs where the from and to sides have no
  overlapping fields with the target struct

@example
```ts
import * as Schema from "effect/Schema"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

// const extended: Schema<
//   {
//     readonly a: string
//     readonly b: string
//   } & {
//     readonly c: string
//   } & {
//     readonly [x: string]: string
//   }
// >
const extended = Schema.asSchema(schema.pipe(
  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures
))
```

@category combinators
@since 3.10.0
/
  <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>
  /**
Extends a schema with another schema.

Not all extensions are supported, and their support depends on the nature of
the involved schemas.

Possible extensions include:
- `Schema.String` with another `Schema.String` refinement or a string literal
- `Schema.Number` with another `Schema.Number` refinement or a number literal
- `Schema.Boolean` with another `Schema.Boolean` refinement or a boolean
  literal
- A struct with another struct where overlapping fields support extension
- A struct with in index signature
- A struct with a union of supported schemas
- A refinement of a struct with a supported schema
- A suspend of a struct with a supported schema
- A transformation between structs where the from and to sides have no
  overlapping fields with the target struct

@example
```ts
import * as Schema from "effect/Schema"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

// const extended: Schema<
//   {
//     readonly a: string
//     readonly b: string
//   } & {
//     readonly c: string
//   } & {
//     readonly [x: string]: string
//   }
// >
const extended = Schema.asSchema(schema.pipe(
  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures
))
```

@category combinators
@since 3.10.0
/
  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>
} = dual(
  2,
  <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That) => make(extendAST(self.ast, that.ast, []))
)

/**
@category combinators
@since 3.10.0
/
export const compose: {
  /**
@category combinators
@since 3.10.0
/
  <To extends Schema.Any, From extends Schema.Any, C extends Schema.Type<From>>(to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): (from: From) => transform<From, To>
  /**
@category combinators
@since 3.10.0
/
  <To extends Schema.Any>(to: To): <From extends Schema.Any, B extends Schema.Encoded<To>>(
    from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>
  ) => transform<From, To>
  /**
@category combinators
@since 3.10.0
/
  <To extends Schema.Any>(to: To, options?: { readonly strict: true }): <From extends Schema.Any>(
    from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>
  ) => transform<From, To>
  /**
@category combinators
@since 3.10.0
/
  <To extends Schema.Any>(to: To, options: { readonly strict: false }): <From extends Schema.Any>(from: From) => transform<From, To>

  /**
@category combinators
@since 3.10.0
/
  <From extends Schema.Any, To extends Schema.Any, C extends Schema.Type<From>>(from: From, to: To & Schema<Schema.Type<To>, C, Schema.Context<To>>): transform<From, To>
  /**
@category combinators
@since 3.10.0
/
  <From extends Schema.Any, B extends Schema.Encoded<To>, To extends Schema.Any>(from: From & Schema<B, Schema.Encoded<From>, Schema.Context<From>>, to: To): transform<From, To>
  /**
@category combinators
@since 3.10.0
/
  <From extends Schema.Any, To extends Schema.Any>(
    from: From & Schema<Schema.Encoded<To>, Schema.Encoded<From>, Schema.Context<From>>,
    to: To,
    options?: { readonly strict: true }
  ): transform<From, To>
  /**
@category combinators
@since 3.10.0
/
  <From extends Schema.Any, To extends Schema.Any>(from: From, to: To, options: { readonly strict: false }): transform<From, To>
} = dual(
  (args) => isSchema(args[1]),
  <B, A, R1, D, C, R2>(from: Schema<B, A, R1>, to: Schema<D, C, R2>): SchemaClass<D, A, R1 | R2> =>
    makeTransformationClass(from, to, AST.compose(from.ast, to.ast))
)

/**
@category api interface
@since 3.10.0
/
export interface suspend<A, I, R> extends AnnotableClass<suspend<A, I, R>, A, I, R> {}

/**
@category constructors
@since 3.10.0
/
export const suspend = <A, I, R>(f: () => Schema<A, I, R>): suspend<A, I, R> => make(new AST.Suspend(() => f().ast))

/**
@since 3.10.0
@category symbol
/
export const RefineSchemaId: unique symbol = Symbol.for("effect/SchemaId/Refine")

/**
@since 3.10.0
@category symbol
/
export type RefineSchemaId = typeof RefineSchemaId

/**
@category api interface
@since 3.10.0
/
export interface refine<A, From extends Schema.Any>
  extends AnnotableClass<refine<A, From>, A, Schema.Encoded<From>, Schema.Context<From>>
{
  /** The following is required for {@link HasFields} to work */
  readonly [RefineSchemaId]: From
  readonly from: From
  readonly filter: (
    a: Schema.Type<From>,
    options: ParseOptions,
    self: AST.Refinement
  ) => option_.Option<ParseResult.ParseIssue>
  make(a: Schema.Type<From>, options?: MakeOptions): A
}

function makeRefineClass<From extends Schema.Any, A>(
  from: From,
  filter: (a: Schema.Type<From>, options: ParseOptions, self: AST.Refinement) => option_.Option<ParseResult.ParseIssue>,
  ast: AST.AST
): refine<A, From> {
  return class RefineClass extends make<A, Schema.Encoded<From>, Schema.Context<From>>(ast) {
    static override annotations(annotations: Annotations.Schema<A>): refine<A, From> {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations))
    }

    static [RefineSchemaId] = from

    static from = from

    static filter = filter

    static make = (a: Schema.Type<From>, options?: MakeOptions): A => {
      return getDisableValidationMakeOption(options) ? a : ParseResult.validateSync(this)(a)
    }
  }
}

/**
@category api interface
@since 3.10.0
/
export interface filter<From extends Schema.Any> extends refine<Schema.Type<From>, From> {}

const fromFilterPredicateReturnTypeItem = (
  item: FilterOutput,
  ast: AST.Refinement | AST.Transformation,
  input: unknown
): option_.Option<ParseResult.ParseIssue> => {
  if (Predicate.isBoolean(item)) {
    return item
      ? option_.none()
      : option_.some(new ParseResult.Type(ast, input))
  }
  if (Predicate.isString(item)) {
    return option_.some(new ParseResult.Type(ast, input, item))
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return option_.some(item)
    }
    const issue = new ParseResult.Type(ast, input, item.message)
    return option_.some(
      array_.isNonEmptyReadonlyArray(item.path) ? new ParseResult.Pointer(item.path, input, issue) : issue
    )
  }
  return option_.none()
}

const toFilterParseIssue = (
  out: FilterReturnType,
  ast: AST.Refinement | AST.Transformation,
  input: unknown
): option_.Option<ParseResult.ParseIssue> => {
  if (util_.isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input)
  }
  if (array_.isNonEmptyReadonlyArray(out)) {
    const issues = array_.filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input))
    if (array_.isNonEmptyReadonlyArray(issues)) {
      return option_.some(issues.length === 1 ? issues[0] : new ParseResult.Composite(ast, input, issues))
    }
  }
  return option_.none()
}

/**
@category filtering
@since 3.10.0
/
export interface FilterIssue {
  readonly path: ReadonlyArray<PropertyKey>
  readonly message: string
}

/**
@category filtering
@since 3.10.0
/
export type FilterOutput = undefined | boolean | string | ParseResult.ParseIssue | FilterIssue

type FilterReturnType = FilterOutput | ReadonlyArray<FilterOutput>

/**
@category filtering
@since 3.10.0

## transformLiteral

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `transformLiteral(<Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(
  from: Encoded,
  to: Type
)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface filterEffect<S extends Schema.Any, FD = never>
  extends transformOrFail<S, SchemaClass<Schema.Type<S>>, FD>
{}

/**
@category transformations
@since 3.10.0
/
export const filterEffect: {
  /**
@category transformations
@since 3.10.0
/
  <S extends Schema.Any, FD>(
    f: (
      a: Types.NoInfer<Schema.Type<S>>,
      options: ParseOptions,
      self: AST.Transformation
    ) => Effect.Effect<FilterReturnType, never, FD>
  ): (self: S) => filterEffect<S, FD>
  /**
@category transformations
@since 3.10.0
/
  <S extends Schema.Any, RD>(
    self: S,
    f: (
      a: Types.NoInfer<Schema.Type<S>>,
      options: ParseOptions,
      self: AST.Transformation
    ) => Effect.Effect<FilterReturnType, never, RD>
  ): filterEffect<S, RD>
} = dual(2, <S extends Schema.Any, FD>(
  self: S,
  f: (
    a: Types.NoInfer<Schema.Type<S>>,
    options: ParseOptions,
    self: AST.Transformation
  ) => Effect.Effect<FilterReturnType, never, FD>
): filterEffect<S, FD> =>
  transformOrFail(
    self,
    typeSchema(self),
    {
      strict: true,
      decode: (i, options, ast) =>
        ParseResult.flatMap(
          f(i, options, ast),
          (filterReturnType) =>
            option_.match(toFilterParseIssue(filterReturnType, ast, i), {
              onNone: () => ParseResult.succeed(i),
              onSome: ParseResult.fail
            })
        ),
      encode: (a) => ParseResult.succeed(a)
    }
  ))

/**
@category api interface
@since 3.10.0
/
export interface transformOrFail<From extends Schema.All, To extends Schema.All, R = never> extends
  AnnotableClass<
    transformOrFail<From, To, R>,
    Schema.Type<To>,
    Schema.Encoded<From>,
    Schema.Context<From> | Schema.Context<To> | R
  >
{
  readonly from: From
  readonly to: To
}

function makeTransformationClass<From extends Schema.Any, To extends Schema.Any, R>(
  from: From,
  to: To,
  ast: AST.AST
): transformOrFail<From, To, R> {
  return class TransformationClass
    extends make<Schema.Type<To>, Schema.Encoded<From>, Schema.Context<From> | Schema.Context<To> | R>(ast)
  {
    static override annotations(annotations: Annotations.Schema<Schema.Type<To>>) {
      return makeTransformationClass<From, To, R>(
        this.from,
        this.to,
        mergeSchemaAnnotations(this.ast, annotations)
      )
    }

    static from = from

    static to = to
  }
}

/**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided decoding functions.

@category transformations
@since 3.10.0
/
export const transformOrFail: {
  /**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided decoding functions.

@category transformations
@since 3.10.0
/
  <To extends Schema.Any, From extends Schema.Any, RD, RE>(
    to: To,
    options: {
      readonly decode: (
        fromA: Schema.Type<From>,
        options: ParseOptions,
        ast: AST.Transformation,
        fromI: Schema.Encoded<From>
      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>
      readonly encode: (
        toI: Schema.Encoded<To>,
        options: ParseOptions,
        ast: AST.Transformation,
        toA: Schema.Type<To>
      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>
      readonly strict?: true
    } | {
      readonly decode: (
        fromA: Schema.Type<From>,
        options: ParseOptions,
        ast: AST.Transformation,
        fromI: Schema.Encoded<From>
      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>
      readonly encode: (
        toI: Schema.Encoded<To>,
        options: ParseOptions,
        ast: AST.Transformation,
        toA: Schema.Type<To>
      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>
      readonly strict: false
    }
  ): (from: From) => transformOrFail<From, To, RD | RE>
  /**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided decoding functions.

@category transformations
@since 3.10.0
/
  <To extends Schema.Any, From extends Schema.Any, RD, RE>(
    from: From,
    to: To,
    options: {
      readonly decode: (
        fromA: Schema.Type<From>,
        options: ParseOptions,
        ast: AST.Transformation,
        fromI: Schema.Encoded<From>
      ) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>
      readonly encode: (
        toI: Schema.Encoded<To>,
        options: ParseOptions,
        ast: AST.Transformation,
        toA: Schema.Type<To>
      ) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>
      readonly strict?: true
    } | {
      readonly decode: (
        fromA: Schema.Type<From>,
        options: ParseOptions,
        ast: AST.Transformation,
        fromI: Schema.Encoded<From>
      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>
      readonly encode: (
        toI: Schema.Encoded<To>,
        options: ParseOptions,
        ast: AST.Transformation,
        toA: Schema.Type<To>
      ) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>
      readonly strict: false
    }
  ): transformOrFail<From, To, RD | RE>
} = dual((args) => isSchema(args[0]) && isSchema(args[1]), <FromA, FromI, FromR, ToA, ToI, ToR, RD, RE>(
  from: Schema<FromA, FromI, FromR>,
  to: Schema<ToA, ToI, ToR>,
  options: {
    readonly decode: (
      fromA: FromA,
      options: ParseOptions,
      ast: AST.Transformation,
      fromI: FromI
    ) => Effect.Effect<ToI, ParseResult.ParseIssue, RD>
    readonly encode: (
      toI: ToI,
      options: ParseOptions,
      ast: AST.Transformation,
      toA: ToA
    ) => Effect.Effect<FromA, ParseResult.ParseIssue, RE>
  }
): Schema<ToA, FromI, FromR | ToR | RD | RE> =>
  makeTransformationClass(
    from,
    to,
    new AST.Transformation(
      from.ast,
      to.ast,
      new AST.FinalTransformation(options.decode, options.encode)
    )
  ))

/**
@category api interface
@since 3.10.0
/
export interface transform<From extends Schema.All, To extends Schema.All> extends transformOrFail<From, To> {
  annotations(annotations: Annotations.Schema<Schema.Type<To>>): transform<From, To>
}

/**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided mapping functions.

@category transformations
@since 3.10.0
/
export const transform: {
  /**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided mapping functions.

@category transformations
@since 3.10.0
/
  <To extends Schema.Any, From extends Schema.Any>(
    to: To,
    options: {
      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>
      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>
      readonly strict?: true
    } | {
      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown
      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown
      readonly strict: false
    }
  ): (from: From) => transform<From, To>
  /**
Create a new `Schema` by transforming the input and output of an existing `Schema`
using the provided mapping functions.

@category transformations
@since 3.10.0
/
  <To extends Schema.Any, From extends Schema.Any>(
    from: From,
    to: To,
    options: {
      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>
      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>
      readonly strict?: true
    } | {
      readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown
      readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown
      readonly strict: false
    }
  ): transform<From, To>
} = dual(
  (args) => isSchema(args[0]) && isSchema(args[1]),
  <FromA, FromI, FromR, ToA, ToI, ToR>(
    from: Schema<FromA, FromI, FromR>,
    to: Schema<ToA, ToI, ToR>,
    options: {
      readonly decode: (fromA: FromA, fromI: FromI) => ToI
      readonly encode: (toI: ToI, toA: ToA) => FromA
    }
  ): Schema<ToA, FromI, FromR | ToR> =>
    transformOrFail(
      from,
      to,
      {
        strict: true,
        decode: (fromA, _options, _ast, toA) => ParseResult.succeed(options.decode(fromA, toA)),
        encode: (toI, _options, _ast, toA) => ParseResult.succeed(options.encode(toI, toA))
      }
    )
)

/**
@category api interface
@since 3.10.0
/
export interface transformLiteral<Type extends AST.LiteralValue, Encoded extends AST.LiteralValue>
  extends transform<Literal<[Encoded]>, Literal<[Type]>>
{
  annotations(annotations: Annotations.Schema<Type>): transformLiteral<Type, Encoded>
}

/**
Creates a new `Schema` which transforms literal values.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"

const schema = S.transformLiteral(0, "a")

assert.deepStrictEqual(S.decodeSync(schema)(0), "a")
```

@category constructors
@since 3.10.0

## transformLiterals

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `transformLiterals(<const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(
  ...pairs: A
)`

JSDoc:

Creates a new `Schema` which maps between corresponding literal values.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"

const Animal = S.transformLiterals(
  [0, "cat"],
  [1, "dog"],
  [2, "cow"]
)

assert.deepStrictEqual(S.decodeSync(Animal)(1), "dog")
```

@category constructors
@since 3.10.0

## parseNumber

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `parseNumber(<S extends Schema.Any, A extends string>(
  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>
)`

JSDoc:

Attaches a property signature with the specified key and value to the schema.
This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
but rather maps to another schema, for example when you want to add a discriminant to a simple union.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"
import { pipe } from "effect/Function"

const Circle = S.Struct({ radius: S.Number })
const Square = S.Struct({ sideLength: S.Number })
const Shape = S.Union(
  Circle.pipe(S.attachPropertySignature("kind", "circle")),
  Square.pipe(S.attachPropertySignature("kind", "square"))
)

assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
  kind: "circle",
  radius: 10
})
```

@category combinators
@since 3.10.0
/
export const attachPropertySignature: {
  /**
Attaches a property signature with the specified key and value to the schema.
This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
but rather maps to another schema, for example when you want to add a discriminant to a simple union.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"
import { pipe } from "effect/Function"

const Circle = S.Struct({ radius: S.Number })
const Square = S.Struct({ sideLength: S.Number })
const Shape = S.Union(
  Circle.pipe(S.attachPropertySignature("kind", "circle")),
  Square.pipe(S.attachPropertySignature("kind", "square"))
)

assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
  kind: "circle",
  radius: 10
})
```

@category combinators
@since 3.10.0
/
  <K extends PropertyKey, V extends AST.LiteralValue | symbol, A>(
    key: K,
    value: V,
    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>
  ): <I, R>(
    schema: SchemaClass<A, I, R>
  ) => SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>
  /**
Attaches a property signature with the specified key and value to the schema.
This API is useful when you want to add a property to your schema which doesn't describe the shape of the input,
but rather maps to another schema, for example when you want to add a discriminant to a simple union.

@example
```ts
import * as assert from "node:assert"
import * as S from "effect/Schema"
import { pipe } from "effect/Function"

const Circle = S.Struct({ radius: S.Number })
const Square = S.Struct({ sideLength: S.Number })
const Shape = S.Union(
  Circle.pipe(S.attachPropertySignature("kind", "circle")),
  Square.pipe(S.attachPropertySignature("kind", "square"))
)

assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
  kind: "circle",
  radius: 10
})
```

@category combinators
@since 3.10.0
/
  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(
    schema: Schema<A, I, R>,
    key: K,
    value: V,
    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>
  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R>
} = dual(
  (args) => isSchema(args[0]),
  <A, I, R, K extends PropertyKey, V extends AST.LiteralValue | symbol>(
    schema: Schema<A, I, R>,
    key: K,
    value: V,
    annotations?: Annotations.Schema<Simplify<A & { readonly [k in K]: V }>>
  ): SchemaClass<Simplify<A & { readonly [k in K]: V }>, I, R> => {
    const ast = extend(
      typeSchema(schema),
      Struct({ [key]: Predicate.isSymbol(value) ? UniqueSymbolFromSelf(value) : Literal(value) })
    ).ast
    return make(
      new AST.Transformation(
        schema.ast,
        annotations ? mergeSchemaAnnotations(ast, annotations) : ast,
        new AST.TypeLiteralTransformation(
          [
            new AST.PropertySignatureTransformation(
              key,
              key,
              () => option_.some(value),
              () => option_.none()
            )
          ]
        )
      )
    )
  }
)

/**
@category annotations
@since 3.10.0
/
export declare namespace Annotations {
  /**
@category annotations
@since 3.10.0
/
  export interface Doc<A> extends AST.Annotations {
    readonly title?: AST.TitleAnnotation
    readonly description?: AST.DescriptionAnnotation
    readonly documentation?: AST.DocumentationAnnotation
    readonly examples?: AST.ExamplesAnnotation<A>
    readonly default?: AST.DefaultAnnotation<A>
  }

  /**
@since 3.10.0
/
  export interface Schema<A, TypeParameters extends ReadonlyArray<any> = readonly []> extends Doc<A> {
    readonly identifier?: AST.IdentifierAnnotation
    readonly message?: AST.MessageAnnotation
    readonly schemaId?: AST.SchemaIdAnnotation
    readonly jsonSchema?: AST.JSONSchemaAnnotation
    readonly arbitrary?: ArbitraryAnnotation<A, TypeParameters>
    readonly pretty?: pretty_.PrettyAnnotation<A, TypeParameters>
    readonly equivalence?: AST.EquivalenceAnnotation<A, TypeParameters>
    readonly concurrency?: AST.ConcurrencyAnnotation
    readonly batching?: AST.BatchingAnnotation
    readonly parseIssueTitle?: AST.ParseIssueTitleAnnotation
    readonly parseOptions?: AST.ParseOptions
    readonly decodingFallback?: AST.DecodingFallbackAnnotation<A>
  }

  /**
@since 3.11.6
/
  export interface GenericSchema<A> extends Schema<A> {
    readonly arbitrary?: (..._: any) => LazyArbitrary<A>
    readonly pretty?: (..._: any) => pretty_.Pretty<A>
    readonly equivalence?: (..._: any) => Equivalence.Equivalence<A>
  }

  // TODO(4.0): replace `readonly [P]` with `readonly []`
  /**
@since 3.10.0
/
  export interface Filter<A, P = A> extends Schema<A, readonly [P]> {}
}

/**
Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

@category annotations
@since 3.10.0
/
export const annotations: {
  /**
Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

@category annotations
@since 3.10.0
/
  <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>
  /**
Merges a set of new annotations with existing ones, potentially overwriting
any duplicates.

@category annotations
@since 3.10.0
/
  <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>
} = dual(
  2,
  <A, I, R>(self: Schema<A, I, R>, annotations: Annotations.GenericSchema<A>): Schema<A, I, R> =>
    self.annotations(annotations)
)

type Rename<A, M> = {
  [
    K in keyof A as K extends keyof M ? M[K] extends PropertyKey ? M[K]
      : never
      : K
  ]: A[K]
}

/**
@category renaming
@since 3.10.0
/
export const rename: {
  /**
@category renaming
@since 3.10.0
/
  <
    A,
    const M extends
      & { readonly [K in keyof A]?: PropertyKey }
      & { readonly [K in Exclude<keyof M, keyof A>]: never }
  >(mapping: M): <I, R>(self: Schema<A, I, R>) => SchemaClass<Simplify<Rename<A, M>>, I, R>
  /**
@category renaming
@since 3.10.0
/
  <
    A,
    I,
    R,
    const M extends
      & { readonly [K in keyof A]?: PropertyKey }
      & { readonly [K in Exclude<keyof M, keyof A>]: never }
  >(self: Schema<A, I, R>, mapping: M): SchemaClass<Simplify<Rename<A, M>>, I, R>
} = dual(
  2,
  <
    A,
    I,
    R,
    const M extends
      & { readonly [K in keyof A]?: PropertyKey }
      & { readonly [K in Exclude<keyof M, keyof A>]: never }
  >(
    self: Schema<A, I, R>,
    mapping: M
  ): SchemaClass<Simplify<Rename<A, M>>, I, R> => make(AST.rename(self.ast, mapping))
)

/**
@category schema id
@since 3.10.0
/
export const TrimmedSchemaId: unique symbol = Symbol.for("effect/SchemaId/Trimmed")

/**
Verifies that a string contains no leading or trailing whitespaces.

Note. This combinator does not make any transformations, it only validates.
If what you were looking for was a combinator to trim strings, then check out the `trim` combinator.

@category string filters
@since 3.10.0
/
export const trimmed = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a === a.trim(), {
      schemaId: TrimmedSchemaId,
      title: "trimmed",
      description: "a string with no leading or trailing whitespace",
      jsonSchema: { pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$" },
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const MaxLengthSchemaId: unique symbol = schemaId_.MaxLengthSchemaId

/**
@category schema id
@since 3.10.0
/
export type MaxLengthSchemaId = typeof MaxLengthSchemaId

/**
@category string filters
@since 3.10.0
/
export const maxLength =
  <S extends Schema.Any>(maxLength: number, annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter(
        (a) => a.length <= maxLength,
        {
          schemaId: MaxLengthSchemaId,
          title: `maxLength(${maxLength})`,
          description: `a string at most ${maxLength} character(s) long`,
          jsonSchema: { maxLength },
          ...annotations
        }
      )
    )

/**
@category schema id
@since 3.10.0
/
export const MinLengthSchemaId: unique symbol = schemaId_.MinLengthSchemaId

/**
@category schema id
@since 3.10.0
/
export type MinLengthSchemaId = typeof MinLengthSchemaId

/**
@category string filters
@since 3.10.0
/
export const minLength = <S extends Schema.Any>(
  minLength: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter(
      (a) => a.length >= minLength,
      {
        schemaId: MinLengthSchemaId,
        title: `minLength(${minLength})`,
        description: `a string at least ${minLength} character(s) long`,
        jsonSchema: { minLength },
        ...annotations
      }
    )
  )

/**
@category schema id
@since 3.10.0
/
export const LengthSchemaId: unique symbol = schemaId_.LengthSchemaId

/**
@category schema id
@since 3.10.0
/
export type LengthSchemaId = typeof LengthSchemaId

/**
@category string filters
@since 3.10.0
/
export const length = <S extends Schema.Any>(
  length: number | { readonly min: number; readonly max: number },
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const minLength = Predicate.isObject(length) ? Math.max(0, Math.floor(length.min)) : Math.max(0, Math.floor(length))
  const maxLength = Predicate.isObject(length) ? Math.max(minLength, Math.floor(length.max)) : minLength
  if (minLength !== maxLength) {
    return self.pipe(
      filter((a) => a.length >= minLength && a.length <= maxLength, {
        schemaId: LengthSchemaId,
        title: `length({ min: ${minLength}, max: ${maxLength})`,
        description: `a string at least ${minLength} character(s) and at most ${maxLength} character(s) long`,
        jsonSchema: { minLength, maxLength },
        ...annotations
      })
    )
  }
  return self.pipe(
    filter((a) => a.length === minLength, {
      schemaId: LengthSchemaId,
      title: `length(${minLength})`,
      description: minLength === 1 ? `a single character` : `a string ${minLength} character(s) long`,
      jsonSchema: { minLength, maxLength: minLength },
      ...annotations
    })
  )
}

/**
@category schema id
@since 3.10.0
/
export const PatternSchemaId: unique symbol = Symbol.for("effect/SchemaId/Pattern")

/**
@category string filters
@since 3.10.0
/
export const pattern = <S extends Schema.Any>(
  regex: RegExp,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const source = regex.source
  return self.pipe(
    filter(
      (a) => {
        // The following line ensures that `lastIndex` is reset to `0` in case the user has specified the `g` flag
        regex.lastIndex = 0
        return regex.test(a)
      },
      {
        schemaId: PatternSchemaId,
        [PatternSchemaId]: { regex },
        // title: `pattern(/${source}/)`, // avoiding this because it can be very long
        description: `a string matching the pattern ${source}`,
        jsonSchema: { pattern: source },
        ...annotations
      }
    )
  )
}

/**
@category schema id
@since 3.10.0
/
export const StartsWithSchemaId: unique symbol = Symbol.for("effect/SchemaId/StartsWith")

/**
@category string filters
@since 3.10.0
/
export const startsWith = <S extends Schema.Any>(
  startsWith: string,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const formatted = JSON.stringify(startsWith)
  return self.pipe(
    filter(
      (a) => a.startsWith(startsWith),
      {
        schemaId: StartsWithSchemaId,
        [StartsWithSchemaId]: { startsWith },
        title: `startsWith(${formatted})`,
        description: `a string starting with ${formatted}`,
        jsonSchema: { pattern: `^${startsWith}` },
        ...annotations
      }
    )
  )
}

/**
@category schema id
@since 3.10.0
/
export const EndsWithSchemaId: unique symbol = Symbol.for("effect/SchemaId/EndsWith")

/**
@category string filters
@since 3.10.0
/
export const endsWith = <S extends Schema.Any>(
  endsWith: string,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const formatted = JSON.stringify(endsWith)
  return self.pipe(
    filter(
      (a) => a.endsWith(endsWith),
      {
        schemaId: EndsWithSchemaId,
        [EndsWithSchemaId]: { endsWith },
        title: `endsWith(${formatted})`,
        description: `a string ending with ${formatted}`,
        jsonSchema: { pattern: `^.*${endsWith}$` },
        ...annotations
      }
    )
  )
}

/**
@category schema id
@since 3.10.0
/
export const IncludesSchemaId: unique symbol = Symbol.for("effect/SchemaId/Includes")

/**
@category string filters
@since 3.10.0
/
export const includes = <S extends Schema.Any>(
  searchString: string,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const formatted = JSON.stringify(searchString)
  return self.pipe(
    filter(
      (a) => a.includes(searchString),
      {
        schemaId: IncludesSchemaId,
        [IncludesSchemaId]: { includes: searchString },
        title: `includes(${formatted})`,
        description: `a string including ${formatted}`,
        jsonSchema: { pattern: `.*${searchString}.*` },
        ...annotations
      }
    )
  )
}

/**
@category schema id
@since 3.10.0
/
export const LowercasedSchemaId: unique symbol = Symbol.for("effect/SchemaId/Lowercased")

/**
Verifies that a string is lowercased.

@category string filters
@since 3.10.0
/
export const lowercased =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => a === a.toLowerCase(), {
        schemaId: LowercasedSchemaId,
        title: "lowercased",
        description: "a lowercase string",
        jsonSchema: { pattern: "^[^A-Z]*$" },
        ...annotations
      })
    )

/**
@category string constructors
@since 3.10.0
/
export class Lowercased extends String$.pipe(
  lowercased({ identifier: "Lowercased" })
) {}

/**
@category schema id
@since 3.10.0
/
export const UppercasedSchemaId: unique symbol = Symbol.for("effect/SchemaId/Uppercased")

/**
Verifies that a string is uppercased.

@category string filters
@since 3.10.0
/
export const uppercased =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => a === a.toUpperCase(), {
        schemaId: UppercasedSchemaId,
        title: "uppercased",
        description: "an uppercase string",
        jsonSchema: { pattern: "^[^a-z]*$" },
        ...annotations
      })
    )

/**
@category string constructors
@since 3.10.0
/
export class Uppercased extends String$.pipe(
  uppercased({ identifier: "Uppercased" })
) {}

/**
@category schema id
@since 3.10.0
/
export const CapitalizedSchemaId: unique symbol = Symbol.for("effect/SchemaId/Capitalized")

/**
Verifies that a string is capitalized.

@category string filters
@since 3.10.0
/
export const capitalized =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => a[0]?.toUpperCase() === a[0], {
        schemaId: CapitalizedSchemaId,
        title: "capitalized",
        description: "a capitalized string",
        jsonSchema: { pattern: "^[^a-z]?.*$" },
        ...annotations
      })
    )

/**
@category string constructors
@since 3.10.0
/
export class Capitalized extends String$.pipe(
  capitalized({ identifier: "Capitalized" })
) {}

/**
@category schema id
@since 3.10.0
/
export const UncapitalizedSchemaId: unique symbol = Symbol.for("effect/SchemaId/Uncapitalized")

/**
Verifies that a string is uncapitalized.

@category string filters
@since 3.10.0
/
export const uncapitalized =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => a[0]?.toLowerCase() === a[0], {
        schemaId: UncapitalizedSchemaId,
        title: "uncapitalized",
        description: "a uncapitalized string",
        jsonSchema: { pattern: "^[^A-Z]?.*$" },
        ...annotations
      })
    )

/**
@category string constructors
@since 3.10.0
/
export class Uncapitalized extends String$.pipe(
  uncapitalized({ identifier: "Uncapitalized" })
) {}

/**
A schema representing a single character.

@category string constructors
@since 3.10.0
/
export class Char extends String$.pipe(length(1, { identifier: "Char" })) {}

/**
@category string filters
@since 3.10.0
/
export const nonEmptyString = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  minLength(1, {
    title: "nonEmptyString",
    description: "a non empty string",
    ...annotations
  })

/**
This schema converts a string to lowercase.

@category string transformations
@since 3.10.0
/
export class Lowercase extends transform(
  String$.annotations({ description: "a string that will be converted to lowercase" }),
  Lowercased,
  {
    strict: true,
    decode: (i) => i.toLowerCase(),
    encode: identity
  }
).annotations({ identifier: "Lowercase" }) {}

/**
This schema converts a string to uppercase.

@category string transformations
@since 3.10.0
/
export class Uppercase extends transform(
  String$.annotations({ description: "a string that will be converted to uppercase" }),
  Uppercased,
  {
    strict: true,
    decode: (i) => i.toUpperCase(),
    encode: identity
  }
).annotations({ identifier: "Uppercase" }) {}

/**
This schema converts a string to capitalized one.

@category string transformations
@since 3.10.0
/
export class Capitalize extends transform(
  String$.annotations({ description: "a string that will be converted to a capitalized format" }),
  Capitalized,
  {
    strict: true,
    decode: (i) => string_.capitalize(i),
    encode: identity
  }
).annotations({ identifier: "Capitalize" }) {}

/**
This schema converts a string to uncapitalized one.

@category string transformations
@since 3.10.0
/
export class Uncapitalize extends transform(
  String$.annotations({ description: "a string that will be converted to an uncapitalized format" }),
  Uncapitalized,
  {
    strict: true,
    decode: (i) => string_.uncapitalize(i),
    encode: identity
  }
).annotations({ identifier: "Uncapitalize" }) {}

/**
@category string constructors
@since 3.10.0
/
export class Trimmed extends String$.pipe(
  trimmed({ identifier: "Trimmed" })
) {}

/**
Useful for validating strings that must contain meaningful characters without
leading or trailing whitespace.

@example
```ts
import { Schema } from "effect"

console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(" a ")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("a")) // Option.some("a")
```

@category string constructors
@since 3.10.0
/
export class NonEmptyTrimmedString extends Trimmed.pipe(
  nonEmptyString({ identifier: "NonEmptyTrimmedString" })
) {}

/**
This schema allows removing whitespaces from the beginning and end of a string.

@category string transformations
@since 3.10.0
/
export class Trim extends transform(
  String$.annotations({ description: "a string that will be trimmed" }),
  Trimmed,
  {
    strict: true,
    decode: (i) => i.trim(),
    encode: identity
  }
).annotations({ identifier: "Trim" }) {}

/**
Returns a schema that allows splitting a string into an array of strings.

@category string transformations
@since 3.10.0
/
export const split = (separator: string): transform<SchemaClass<string>, Array$<typeof String$>> =>
  transform(
    String$.annotations({ description: "a string that will be split" }),
    Array$(String$),
    {
      strict: true,
      decode: (i) => i.split(separator),
      encode: (a) => a.join(separator)
    }
  )

/**
@since 3.10.0
/
export type ParseJsonOptions = {
  readonly reviver?: Parameters<typeof JSON.parse>[1]
  readonly replacer?: Parameters<typeof JSON.stringify>[1]
  readonly space?: Parameters<typeof JSON.stringify>[2]
}

const getErrorMessage = (e: unknown): string => e instanceof Error ? e.message : String(e)

const getParseJsonTransformation = (options?: ParseJsonOptions): SchemaClass<unknown, string> =>
  transformOrFail(
    String$.annotations({ description: "a string to be decoded into JSON" }),
    Unknown,
    {
      strict: true,
      decode: (i, _, ast) =>
        ParseResult.try({
          try: () => JSON.parse(i, options?.reviver),
          catch: (e) => new ParseResult.Type(ast, i, getErrorMessage(e))
        }),
      encode: (a, _, ast) =>
        ParseResult.try({
          try: () => JSON.stringify(a, options?.replacer, options?.space),
          catch: (e) => new ParseResult.Type(ast, a, getErrorMessage(e))
        })
    }
  ).annotations({
    title: "parseJson",
    schemaId: AST.ParseJsonSchemaId
  })

/**
The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.

You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.

Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.

@example
```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{"a":"1"}`), { a: "1" })
assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{"a":"1"}`), { a: 1 })
```

@category string transformations
@since 3.10.0
/
export const parseJson: {
  /**
The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.

You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.

Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.

@example
```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{"a":"1"}`), { a: "1" })
assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{"a":"1"}`), { a: 1 })
```

@category string transformations
@since 3.10.0
/
  <S extends Schema.Any>(schema: S, options?: ParseJsonOptions): transform<SchemaClass<unknown, string>, S>
  /**
The `ParseJson` combinator provides a method to convert JSON strings into the `unknown` type using the underlying
functionality of `JSON.parse`. It also utilizes `JSON.stringify` for encoding.

You can optionally provide a `ParseJsonOptions` to configure both `JSON.parse` and `JSON.stringify` executions.

Optionally, you can pass a schema `Schema<A, I, R>` to obtain an `A` type instead of `unknown`.

@example
```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{"a":"1"}`), { a: "1" })
assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{"a":"1"}`), { a: 1 })
```

@category string transformations
@since 3.10.0
/
  (options?: ParseJsonOptions): SchemaClass<unknown, string>
} = <A, I, R>(schemaOrOptions?: Schema<A, I, R> | ParseJsonOptions, o?: ParseJsonOptions) =>
  isSchema(schemaOrOptions)
    ? compose(parseJson(o), schemaOrOptions) as any
    : getParseJsonTransformation(schemaOrOptions as ParseJsonOptions | undefined)

/**
@category string constructors
@since 3.10.0
/
export class NonEmptyString extends String$.pipe(
  nonEmptyString({ identifier: "NonEmptyString" })
) {}

/**
@category schema id
@since 3.10.0
/
export const UUIDSchemaId: unique symbol = Symbol.for("effect/SchemaId/UUID")

const uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i

/**
Represents a Universally Unique Identifier (UUID).

This schema ensures that the provided string adheres to the standard UUID format.

@category string constructors
@since 3.10.0
/
export class UUID extends String$.pipe(
  pattern(uuidRegexp, {
    schemaId: UUIDSchemaId,
    identifier: "UUID",
    jsonSchema: {
      format: "uuid",
      pattern: uuidRegexp.source
    },
    description: "a Universally Unique Identifier",
    arbitrary: (): LazyArbitrary<string> => (fc) => fc.uuid()
  })
) {}

/**
@category schema id
@since 3.10.0
/
export const ULIDSchemaId: unique symbol = Symbol.for("effect/SchemaId/ULID")

const ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i

/**
Represents a Universally Unique Lexicographically Sortable Identifier (ULID).

ULIDs are designed to be compact, URL-safe, and ordered, making them suitable for use as identifiers.
This schema ensures that the provided string adheres to the standard ULID format.

@category string constructors
@since 3.10.0
/
export class ULID extends String$.pipe(
  pattern(ulidRegexp, {
    schemaId: ULIDSchemaId,
    identifier: "ULID",
    description: "a Universally Unique Lexicographically Sortable Identifier",
    arbitrary: (): LazyArbitrary<string> => (fc) => fc.ulid()
  })
) {}

/**
Defines a schema that represents a `URL` object.

@category URL constructors
@since 3.11.0
/
export class URLFromSelf extends instanceOf(URL, {
  identifier: "URLFromSelf",
  arbitrary: (): LazyArbitrary<URL> => (fc) => fc.webUrl().map((s) => new URL(s)),
  pretty: () => (url) => url.toString()
}) {}

/** @ignore */
class URL$ extends transformOrFail(
  String$.annotations({ description: "a string to be decoded into a URL" }),
  URLFromSelf,
  {
    strict: true,
    decode: (i, _, ast) =>
      ParseResult.try({
        try: () => new URL(i),
        catch: (e) =>
          new ParseResult.Type(
            ast,
            i,
            `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage(e)}`
          )
      }),
    encode: (a) => ParseResult.succeed(a.toString())
  }
).annotations({
  identifier: "URL",
  pretty: () => (url) => url.toString()
}) {}

export {
  /**
Defines a schema that attempts to convert a `string` to a `URL` object using
the `new URL` constructor.

@category URL transformations
@since 3.11.0
/
  URL$ as URL
}

/**
@category schema id
@since 3.10.0
/
export const FiniteSchemaId: unique symbol = schemaId_.FiniteSchemaId

/**
@category schema id
@since 3.10.0
/
export type FiniteSchemaId = typeof FiniteSchemaId

/**
Ensures that the provided value is a finite number (excluding NaN, +Infinity, and -Infinity).

@category number filters
@since 3.10.0
/
export const finite =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter(Number.isFinite, {
        schemaId: FiniteSchemaId,
        title: "finite",
        description: "a finite number",
        jsonSchema: { "type": "number" },
        ...annotations
      })
    )

/**
@category schema id
@since 3.10.0
/
export const GreaterThanSchemaId: unique symbol = schemaId_.GreaterThanSchemaId

/**
@category schema id
@since 3.10.0
/
export type GreaterThanSchemaId = typeof GreaterThanSchemaId

/**
This filter checks whether the provided number is greater than the specified minimum.

@category number filters
@since 3.10.0
/
export const greaterThan = <S extends Schema.Any>(
  exclusiveMinimum: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a > exclusiveMinimum, {
      schemaId: GreaterThanSchemaId,
      title: `greaterThan(${exclusiveMinimum})`,
      description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
      jsonSchema: { exclusiveMinimum },
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToSchemaId: unique symbol = schemaId_.GreaterThanOrEqualToSchemaId

/**
@category schema id
@since 3.10.0
/
export type GreaterThanOrEqualToSchemaId = typeof GreaterThanOrEqualToSchemaId

/**
This filter checks whether the provided number is greater than or equal to the specified minimum.

@category number filters
@since 3.10.0
/
export const greaterThanOrEqualTo = <S extends Schema.Any>(
  minimum: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a >= minimum, {
      schemaId: GreaterThanOrEqualToSchemaId,
      title: `greaterThanOrEqualTo(${minimum})`,
      description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
      jsonSchema: { minimum },
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const MultipleOfSchemaId: unique symbol = Symbol.for("effect/SchemaId/MultipleOf")

/**
@category number filters
@since 3.10.0
/
export const multipleOf = <S extends Schema.Any>(
  divisor: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const positiveDivisor = Math.abs(divisor) // spec requires positive divisor
  return self.pipe(
    filter((a) => number_.remainder(a, divisor) === 0, {
      schemaId: MultipleOfSchemaId,
      title: `multipleOf(${positiveDivisor})`,
      description: `a number divisible by ${positiveDivisor}`,
      jsonSchema: { multipleOf: positiveDivisor },
      ...annotations
    })
  )
}

/**
@category schema id
@since 3.10.0
/
export const IntSchemaId: unique symbol = schemaId_.IntSchemaId

/**
@category schema id
@since 3.10.0
/
export type IntSchemaId = typeof IntSchemaId

/**
Ensures that the provided value is an integer number (excluding NaN, +Infinity, and -Infinity).

@category number filters
@since 3.10.0
/
export const int =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => Number.isSafeInteger(a), {
        schemaId: IntSchemaId,
        title: "int",
        description: "an integer",
        jsonSchema: { type: "integer" },
        ...annotations
      })
    )

/**
@category schema id
@since 3.10.0
/
export const LessThanSchemaId: unique symbol = schemaId_.LessThanSchemaId

/**
@category schema id
@since 3.10.0
/
export type LessThanSchemaId = typeof LessThanSchemaId

/**
This filter checks whether the provided number is less than the specified maximum.

@category number filters
@since 3.10.0
/
export const lessThan =
  <S extends Schema.Any>(exclusiveMaximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => a < exclusiveMaximum, {
        schemaId: LessThanSchemaId,
        title: `lessThan(${exclusiveMaximum})`,
        description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
        jsonSchema: { exclusiveMaximum },
        ...annotations
      })
    )

/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToSchemaId: unique symbol = schemaId_.LessThanOrEqualToSchemaId

/**
@category schema id
@since 3.10.0
/
export type LessThanOrEqualToSchemaId = typeof LessThanOrEqualToSchemaId

/**
This schema checks whether the provided number is less than or equal to the specified maximum.

@category number filters
@since 3.10.0
/
export const lessThanOrEqualTo = <S extends Schema.Any>(
  maximum: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a <= maximum, {
      schemaId: LessThanOrEqualToSchemaId,
      title: `lessThanOrEqualTo(${maximum})`,
      description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
      jsonSchema: { maximum },
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const BetweenSchemaId: unique symbol = schemaId_.BetweenSchemaId

/**
@category schema id
@since 3.10.0
/
export type BetweenSchemaId = typeof BetweenSchemaId

/**
This filter checks whether the provided number falls within the specified minimum and maximum values.

@category number filters
@since 3.10.0
/
export const between = <S extends Schema.Any>(
  minimum: number,
  maximum: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a >= minimum && a <= maximum, {
      schemaId: BetweenSchemaId,
      title: `between(${minimum}, ${maximum})`,
      description: `a number between ${minimum} and ${maximum}`,
      jsonSchema: { minimum, maximum },
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const NonNaNSchemaId: unique symbol = schemaId_.NonNaNSchemaId

/**
@category schema id
@since 3.10.0
/
export type NonNaNSchemaId = typeof NonNaNSchemaId

/**
@category number filters
@since 3.10.0
/
export const nonNaN =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => !Number.isNaN(a), {
        schemaId: NonNaNSchemaId,
        title: "nonNaN",
        description: "a number excluding NaN",
        ...annotations
      })
    )

/**
@category number filters
@since 3.10.0
/
export const positive = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  greaterThan(0, { title: "positive", ...annotations })

/**
@category number filters
@since 3.10.0
/
export const negative = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  lessThan(0, { title: "negative", ...annotations })

/**
@category number filters
@since 3.10.0
/
export const nonPositive = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  lessThanOrEqualTo(0, { title: "nonPositive", ...annotations })

/**
@category number filters
@since 3.10.0
/
export const nonNegative = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  greaterThanOrEqualTo(0, { title: "nonNegative", ...annotations })

/**
Clamps a number between a minimum and a maximum value.

@category number transformations
@since 3.10.0
/
export const clamp = (minimum: number, maximum: number) =>
<S extends Schema.Any, A extends number>(
  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>
): transform<S, filter<SchemaClass<A>>> => {
  return transform(
    self,
    typeSchema(self).pipe(between(minimum, maximum)),
    {
      strict: false,
      decode: (i) => number_.clamp(i, { minimum, maximum }),
      encode: identity
    }
  )
}

/**
Transforms a `string` into a `number` by parsing the string using the `parse`
function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when
non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity",
"-Infinity".

@category number transformations
@since 3.10.0

## Redacted

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `Redacted(<Value extends Schema.Any>(value: Value)`

JSDoc:

This schema transforms a `string` into a `number` by parsing the string using the `parse` function of the `effect/Number` module.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

The following special string values are supported: "NaN", "Infinity", "-Infinity".

@category number transformations
@since 3.10.0
/
export class NumberFromString extends parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({ identifier: "NumberFromString" }) {}

/**
@category number constructors
@since 3.10.0
/
export class Finite extends Number$.pipe(finite({ identifier: "Finite" })) {}

/**
@category number constructors
@since 3.10.0
/
export class Int extends Number$.pipe(int({ identifier: "Int" })) {}

/**
@category number constructors
@since 3.10.0
/
export class NonNaN extends Number$.pipe(nonNaN({ identifier: "NonNaN" })) {}

/**
@category number constructors
@since 3.10.0
/
export class Positive extends Number$.pipe(
  positive({ identifier: "Positive" })
) {}

/**
@category number constructors
@since 3.10.0
/
export class Negative extends Number$.pipe(
  negative({ identifier: "Negative" })
) {}

/**
@category number constructors
@since 3.10.0
/
export class NonPositive extends Number$.pipe(
  nonPositive({ identifier: "NonPositive" })
) {}

/**
@category number constructors
@since 3.10.0
/
export class NonNegative extends Number$.pipe(
  nonNegative({ identifier: "NonNegative" })
) {}

/**
@category schema id
@since 3.10.0
/
export const JsonNumberSchemaId: unique symbol = schemaId_.JsonNumberSchemaId

/**
@category schema id
@since 3.10.0
/
export type JsonNumberSchemaId = typeof JsonNumberSchemaId

/**
The `JsonNumber` is a schema for representing JSON numbers. It ensures that the provided value is a valid
number by filtering out `NaN` and `(+/-) Infinity`. This is useful when you want to validate and represent numbers in JSON
format.

@example
```ts
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

const is = Schema.is(S.JsonNumber)

assert.deepStrictEqual(is(42), true)
assert.deepStrictEqual(is(Number.NaN), false)
assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)
```

@category number constructors
@since 3.10.0
/
export class JsonNumber extends Number$.pipe(
  finite({
    schemaId: JsonNumberSchemaId,
    identifier: "JsonNumber"
  })
) {}

/**
@category boolean transformations
@since 3.10.0
/
export class Not extends transform(Boolean$.annotations({ description: "a boolean that will be negated" }), Boolean$, {
  strict: true,
  decode: (i) => boolean_.not(i),
  encode: (a) => boolean_.not(a)
}) {}

const encodeSymbol = (sym: symbol, ast: AST.AST) => {
  const key = Symbol.keyFor(sym)
  return key === undefined
    ? ParseResult.fail(
      new ParseResult.Type(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)
    )
    : ParseResult.succeed(key)
}

const decodeSymbol = (s: string) => ParseResult.succeed(Symbol.for(s))

/** @ignore */
class Symbol$ extends transformOrFail(
  String$.annotations({ description: "a string to be decoded into a globally shared symbol" }),
  SymbolFromSelf,
  {
    strict: false,
    decode: (i) => decodeSymbol(i),
    encode: (a, _, ast) => encodeSymbol(a, ast)
  }
).annotations({ identifier: "Symbol" }) {}

export {
  /**
Converts a string key into a globally shared symbol.

@category symbol transformations
@since 3.10.0
/
  Symbol$ as Symbol
}

/**
@category schema id
@since 3.10.0
/
export const GreaterThanBigIntSchemaId: unique symbol = schemaId_.GreaterThanBigintSchemaId

/**
@category schema id
@since 3.10.0
/
export type GreaterThanBigIntSchemaId = typeof GreaterThanBigIntSchemaId

/**
@category bigint filters
@since 3.10.0
/
export const greaterThanBigInt = <S extends Schema.Any>(
  min: bigint,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a > min, {
      schemaId: GreaterThanBigIntSchemaId,
      [GreaterThanBigIntSchemaId]: { min },
      title: `greaterThanBigInt(${min})`,
      description: min === 0n ? "a positive bigint" : `a bigint greater than ${min}n`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToBigIntSchemaId: unique symbol = schemaId_.GreaterThanOrEqualToBigIntSchemaId

/**
@category schema id
@since 3.10.0
/
export type GreaterThanOrEqualToBigIntSchemaId = typeof GreaterThanOrEqualToBigIntSchemaId

/**
@category bigint filters
@since 3.10.0
/
export const greaterThanOrEqualToBigInt = <S extends Schema.Any>(
  min: bigint,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a >= min, {
      schemaId: GreaterThanOrEqualToBigIntSchemaId,
      [GreaterThanOrEqualToBigIntSchemaId]: { min },
      title: `greaterThanOrEqualToBigInt(${min})`,
      description: min === 0n
        ? "a non-negative bigint"
        : `a bigint greater than or equal to ${min}n`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const LessThanBigIntSchemaId: unique symbol = schemaId_.LessThanBigIntSchemaId

/**
@category schema id
@since 3.10.0
/
export type LessThanBigIntSchemaId = typeof LessThanBigIntSchemaId

/**
@category bigint filters
@since 3.10.0
/
export const lessThanBigInt = <S extends Schema.Any>(
  max: bigint,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a < max, {
      schemaId: LessThanBigIntSchemaId,
      [LessThanBigIntSchemaId]: { max },
      title: `lessThanBigInt(${max})`,
      description: max === 0n ? "a negative bigint" : `a bigint less than ${max}n`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToBigIntSchemaId: unique symbol = schemaId_.LessThanOrEqualToBigIntSchemaId

/**
@category schema id
@since 3.10.0
/
export type LessThanOrEqualToBigIntSchemaId = typeof LessThanOrEqualToBigIntSchemaId

/**
@category bigint filters
@since 3.10.0
/
export const lessThanOrEqualToBigInt = <S extends Schema.Any>(
  max: bigint,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a <= max, {
      schemaId: LessThanOrEqualToBigIntSchemaId,
      [LessThanOrEqualToBigIntSchemaId]: { max },
      title: `lessThanOrEqualToBigInt(${max})`,
      description: max === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max}n`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const BetweenBigIntSchemaId: unique symbol = schemaId_.BetweenBigintSchemaId

/**
@category schema id
@since 3.10.0
/
export type BetweenBigIntSchemaId = typeof BetweenBigIntSchemaId

/**
@category bigint filters
@since 3.10.0
/
export const betweenBigInt = <S extends Schema.Any>(
  min: bigint,
  max: bigint,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => a >= min && a <= max, {
      schemaId: BetweenBigIntSchemaId,
      [BetweenBigIntSchemaId]: { min, max },
      title: `betweenBigInt(${min}, ${max})`,
      description: `a bigint between ${min}n and ${max}n`,
      ...annotations
    })
  )

/**
@category bigint filters
@since 3.10.0
/
export const positiveBigInt = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  greaterThanBigInt(0n, { title: "positiveBigInt", ...annotations })

/**
@category bigint filters
@since 3.10.0
/
export const negativeBigInt = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  lessThanBigInt(0n, { title: "negativeBigInt", ...annotations })

/**
@category bigint filters
@since 3.10.0
/
export const nonNegativeBigInt = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  greaterThanOrEqualToBigInt(0n, { title: "nonNegativeBigInt", ...annotations })

/**
@category bigint filters
@since 3.10.0
/
export const nonPositiveBigInt = <S extends Schema.Any>(
  annotations?: Annotations.Filter<Schema.Type<S>>
): <A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S> =>
  lessThanOrEqualToBigInt(0n, { title: "nonPositiveBigInt", ...annotations })

/**
Clamps a bigint between a minimum and a maximum value.

@category bigint transformations
@since 3.10.0
/
export const clampBigInt = (minimum: bigint, maximum: bigint) =>
<S extends Schema.Any, A extends bigint>(
  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>
): transform<S, filter<SchemaClass<A>>> =>
  transform(
    self,
    self.pipe(typeSchema, betweenBigInt(minimum, maximum)),
    {
      strict: false,
      decode: (i) => bigInt_.clamp(i, { minimum, maximum }),
      encode: identity
    }
  )

/** @ignore */
class BigInt$ extends transformOrFail(
  String$.annotations({ description: "a string to be decoded into a bigint" }),
  BigIntFromSelf,
  {
    strict: true,
    decode: (i, _, ast) =>
      ParseResult.fromOption(
        bigInt_.fromString(i),
        () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)
      ),
    encode: (a) => ParseResult.succeed(String(a))
  }
).annotations({ identifier: "BigInt" }) {}

export {
  /**
This schema transforms a `string` into a `bigint` by parsing the string using the `BigInt` function.

It returns an error if the value can't be converted (for example when non-numeric characters are provided).

@category bigint transformations
@since 3.10.0
/
  BigInt$ as BigInt
}

/**
@category bigint constructors
@since 3.10.0
/
export const PositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(
  positiveBigInt({ identifier: "PositiveBigintFromSelf" })
)

/**
@category bigint constructors
@since 3.10.0
/
export const PositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(
  positiveBigInt({ identifier: "PositiveBigint" })
)

/**
@category bigint constructors
@since 3.10.0
/
export const NegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(
  negativeBigInt({ identifier: "NegativeBigintFromSelf" })
)

/**
@category bigint constructors
@since 3.10.0
/
export const NegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(
  negativeBigInt({ identifier: "NegativeBigint" })
)

/**
@category bigint constructors
@since 3.10.0
/
export const NonPositiveBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(
  nonPositiveBigInt({ identifier: "NonPositiveBigintFromSelf" })
)

/**
@category bigint constructors
@since 3.10.0
/
export const NonPositiveBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(
  nonPositiveBigInt({ identifier: "NonPositiveBigint" })
)

/**
@category bigint constructors
@since 3.10.0
/
export const NonNegativeBigIntFromSelf: filter<Schema<bigint>> = BigIntFromSelf.pipe(
  nonNegativeBigInt({ identifier: "NonNegativeBigintFromSelf" })
)

/**
@category bigint constructors
@since 3.10.0
/
export const NonNegativeBigInt: filter<Schema<bigint, string>> = BigInt$.pipe(
  nonNegativeBigInt({ identifier: "NonNegativeBigint" })
)

/**
This schema transforms a `number` into a `bigint` by parsing the number using the `BigInt` function.

It returns an error if the value can't be safely encoded as a `number` due to being out of range.

@category bigint transformations
@since 3.10.0
/
export class BigIntFromNumber extends transformOrFail(
  Number$.annotations({ description: "a number to be decoded into a bigint" }),
  BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))),
  {
    strict: true,
    decode: (i, _, ast) =>
      ParseResult.fromOption(
        bigInt_.fromNumber(i),
        () => new ParseResult.Type(ast, i, `Unable to decode ${i} into a bigint`)
      ),
    encode: (a, _, ast) =>
      ParseResult.fromOption(
        bigInt_.toNumber(a),
        () => new ParseResult.Type(ast, a, `Unable to encode ${a}n into a number`)
      )
  }
).annotations({ identifier: "BigIntFromNumber" }) {}

const redactedArbitrary = <A>(value: LazyArbitrary<A>): LazyArbitrary<redacted_.Redacted<A>> => (fc) =>
  value(fc).map(redacted_.make)

const toComposite = <A, R, B>(
  eff: Effect.Effect<A, ParseResult.ParseIssue, R>,
  onSuccess: (a: A) => B,
  ast: AST.AST,
  actual: unknown
): Effect.Effect<B, ParseResult.Composite, R> =>
  ParseResult.mapBoth(eff, {
    onFailure: (e) => new ParseResult.Composite(ast, actual, e),
    onSuccess
  })

const redactedParse = <A, R>(
  decodeUnknown: ParseResult.DecodeUnknown<A, R>
): ParseResult.DeclarationDecodeUnknown<redacted_.Redacted<A>, R> =>
(u, options, ast) =>
  redacted_.isRedacted(u) ?
    toComposite(decodeUnknown(redacted_.value(u), options), redacted_.make, ast, u) :
    ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface RedactedFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    RedactedFromSelf<Value>,
    redacted_.Redacted<Schema.Type<Value>>,
    redacted_.Redacted<Schema.Encoded<Value>>,
    [Value]
  >
{}

/**
@category Redacted constructors
@since 3.10.0
/
export const RedactedFromSelf = <Value extends Schema.Any>(value: Value): RedactedFromSelf<Value> =>
  declare(
    [value],
    {
      decode: (value) => redactedParse(ParseResult.decodeUnknown(value)),
      encode: (value) => redactedParse(ParseResult.encodeUnknown(value))
    },
    {
      description: "Redacted(<redacted>)",
      pretty: () => () => "Redacted(<redacted>)",
      arbitrary: redactedArbitrary,
      equivalence: redacted_.getEquivalence
    }
  )

/**
@category api interface
@since 3.10.0
/
export interface Redacted<Value extends Schema.Any>
  extends transform<Value, RedactedFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
A transformation that transform a `Schema<A, I, R>` into a
`RedactedFromSelf<A>`.

@category Redacted transformations
@since 3.10.0

## head

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `head(<S extends Schema.Any, A extends ReadonlyArray<unknown>>(
  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>
)`

JSDoc:

@category Duration constructors
@since 3.10.0
/
export class DurationFromSelf extends declare(
  duration_.isDuration,
  {
    identifier: "DurationFromSelf",
    pretty: (): pretty_.Pretty<duration_.Duration> => String,
    arbitrary: (): LazyArbitrary<duration_.Duration> => (fc) =>
      fc.oneof(
        fc.constant(duration_.infinity),
        fc.bigInt({ min: 0n }).map((_) => duration_.nanos(_)),
        fc.maxSafeNat().map((_) => duration_.millis(_))
      ),
    equivalence: (): Equivalence.Equivalence<duration_.Duration> => duration_.Equivalence
  }
) {}

/**
A schema that transforms a non negative `bigint` into a `Duration`. Treats
the value as the number of nanoseconds.

@category Duration transformations
@since 3.10.0
/
export class DurationFromNanos extends transformOrFail(
  NonNegativeBigIntFromSelf.annotations({ description: "a bigint to be decoded into a Duration" }),
  DurationFromSelf.pipe(filter((duration) => duration_.isFinite(duration), { description: "a finite duration" })),
  {
    strict: true,
    decode: (i) => ParseResult.succeed(duration_.nanos(i)),
    encode: (a, _, ast) =>
      option_.match(duration_.toNanos(a), {
        onNone: () => ParseResult.fail(new ParseResult.Type(ast, a, `Unable to encode ${a} into a bigint`)),
        onSome: (nanos) => ParseResult.succeed(nanos)
      })
  }
).annotations({ identifier: "DurationFromNanos" }) {}

/**
A non-negative integer. +Infinity is excluded.

@category number constructors
@since 3.11.10
/
export const NonNegativeInt = NonNegative.pipe(int()).annotations({ identifier: "NonNegativeInt" })

/**
A schema that transforms a (possibly Infinite) non negative number into a
`Duration`. Treats the value as the number of milliseconds.

@category Duration transformations
@since 3.10.0
/
export class DurationFromMillis extends transform(
  NonNegative.annotations({
    description: "a non-negative number to be decoded into a Duration"
  }),
  DurationFromSelf,
  {
    strict: true,
    decode: (i) => duration_.millis(i),
    encode: (a) => duration_.toMillis(a)
  }
).annotations({ identifier: "DurationFromMillis" }) {}

const DurationValueMillis = TaggedStruct("Millis", { millis: NonNegativeInt })
const DurationValueNanos = TaggedStruct("Nanos", { nanos: BigInt$ })
const DurationValueInfinity = TaggedStruct("Infinity", {})
const durationValueInfinity = DurationValueInfinity.make({})

/**
@category Duration utils
@since 3.12.8
/
export type DurationEncoded =
  | {
    readonly _tag: "Millis"
    readonly millis: number
  }
  | {
    readonly _tag: "Nanos"
    readonly nanos: string
  }
  | {
    readonly _tag: "Infinity"
  }

const DurationValue: Schema<duration_.DurationValue, DurationEncoded> = Union(
  DurationValueMillis,
  DurationValueNanos,
  DurationValueInfinity
).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
})

const FiniteHRTime = Tuple(
  element(NonNegativeInt).annotations({ title: "seconds" }),
  element(NonNegativeInt).annotations({ title: "nanos" })
).annotations({ identifier: "FiniteHRTime" })

const InfiniteHRTime = Tuple(Literal(-1), Literal(0)).annotations({ identifier: "InfiniteHRTime" })

const HRTime: Schema<readonly [seconds: number, nanos: number]> = Union(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
})

const isDurationValue = (u: duration_.DurationValue | typeof HRTime.Type): u is duration_.DurationValue =>
  typeof u === "object"

// TODO(4.0): remove HRTime union member
/**
A schema that converts a JSON-compatible tagged union into a `Duration`.

@category Duration transformations
@since 3.10.0
/
export class Duration extends transform(
  Union(DurationValue, HRTime),
  DurationFromSelf,
  {
    strict: true,
    decode: (i) => {
      if (isDurationValue(i)) {
        switch (i._tag) {
          case "Millis":
            return duration_.millis(i.millis)
          case "Nanos":
            return duration_.nanos(i.nanos)
          case "Infinity":
            return duration_.infinity
        }
      }
      const [seconds, nanos] = i
      return seconds === -1 ? duration_.infinity : duration_.nanos(BigInt(seconds) * BigInt(1e9) + BigInt(nanos))
    },
    encode: (a) => {
      switch (a.value._tag) {
        case "Millis":
          return DurationValueMillis.make({ millis: a.value.millis })
        case "Nanos":
          return DurationValueNanos.make({ nanos: a.value.nanos })
        case "Infinity":
          return durationValueInfinity
      }
    }
  }
).annotations({ identifier: "Duration" }) {}

/**
Clamps a `Duration` between a minimum and a maximum value.

@category Duration transformations
@since 3.10.0
/
export const clampDuration =
  (minimum: duration_.DurationInput, maximum: duration_.DurationInput) =>
  <S extends Schema.Any, A extends duration_.Duration>(
    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>
  ): transform<S, filter<SchemaClass<A>>> =>
    transform(
      self,
      self.pipe(typeSchema, betweenDuration(minimum, maximum)),
      {
        strict: false,
        decode: (i) => duration_.clamp(i, { minimum, maximum }),
        encode: identity
      }
    )

/**
@category schema id
@since 3.10.0
/
export const LessThanDurationSchemaId: unique symbol = Symbol.for("effect/SchemaId/LessThanDuration")

/**
@category Duration filters
@since 3.10.0
/
export const lessThanDuration = <S extends Schema.Any>(
  max: duration_.DurationInput,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => duration_.lessThan(a, max), {
      schemaId: LessThanDurationSchemaId,
      [LessThanDurationSchemaId]: { max },
      title: `lessThanDuration(${max})`,
      description: `a Duration less than ${duration_.decode(max)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(
  "effect/schema/LessThanOrEqualToDuration"
)

/**
@category Duration filters
@since 3.10.0
/
export const lessThanOrEqualToDuration = <S extends Schema.Any>(
  max: duration_.DurationInput,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => duration_.lessThanOrEqualTo(a, max), {
      schemaId: LessThanDurationSchemaId,
      [LessThanDurationSchemaId]: { max },
      title: `lessThanOrEqualToDuration(${max})`,
      description: `a Duration less than or equal to ${duration_.decode(max)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const GreaterThanDurationSchemaId: unique symbol = Symbol.for("effect/SchemaId/GreaterThanDuration")

/**
@category Duration filters
@since 3.10.0
/
export const greaterThanDuration = <S extends Schema.Any>(
  min: duration_.DurationInput,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => duration_.greaterThan(a, min), {
      schemaId: GreaterThanDurationSchemaId,
      [GreaterThanDurationSchemaId]: { min },
      title: `greaterThanDuration(${min})`,
      description: `a Duration greater than ${duration_.decode(min)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToDurationSchemaId: unique symbol = Symbol.for(
  "effect/schema/GreaterThanOrEqualToDuration"
)

/**
@category Duration filters
@since 3.10.0
/
export const greaterThanOrEqualToDuration = <S extends Schema.Any>(
  min: duration_.DurationInput,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => duration_.greaterThanOrEqualTo(a, min), {
      schemaId: GreaterThanOrEqualToDurationSchemaId,
      [GreaterThanOrEqualToDurationSchemaId]: { min },
      title: `greaterThanOrEqualToDuration(${min})`,
      description: `a Duration greater than or equal to ${duration_.decode(min)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const BetweenDurationSchemaId: unique symbol = Symbol.for("effect/SchemaId/BetweenDuration")

/**
@category Duration filters
@since 3.10.0
/
export const betweenDuration = <S extends Schema.Any>(
  minimum: duration_.DurationInput,
  maximum: duration_.DurationInput,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a) => duration_.between(a, { minimum, maximum }), {
      schemaId: BetweenDurationSchemaId,
      [BetweenDurationSchemaId]: { maximum, minimum },
      title: `betweenDuration(${minimum}, ${maximum})`,
      description: `a Duration between ${duration_.decode(minimum)} and ${duration_.decode(maximum)}`,
      ...annotations
    })
  )

/**
@category Uint8Array constructors
@since 3.10.0
/
export class Uint8ArrayFromSelf extends declare(
  Predicate.isUint8Array,
  {
    identifier: "Uint8ArrayFromSelf",
    pretty: (): pretty_.Pretty<Uint8Array> => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
    arbitrary: (): LazyArbitrary<Uint8Array> => (fc) => fc.uint8Array(),
    equivalence: (): Equivalence.Equivalence<Uint8Array> => array_.getEquivalence(Equal.equals) as any
  }
) {}

/**
@category number constructors
@since 3.11.10
/
export class Uint8 extends Number$.pipe(
  between(0, 255, {
    identifier: "Uint8",
    description: "a 8-bit unsigned integer"
  })
) {}

/** @ignore */
class Uint8Array$ extends transform(
  Array$(Uint8).annotations({
    description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
  }),
  Uint8ArrayFromSelf,
  {
    strict: true,
    decode: (i) => Uint8Array.from(i),
    encode: (a) => Array.from(a)
  }
).annotations({ identifier: "Uint8Array" }) {}

export {
  /**
A schema that transforms an array of numbers into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
  Uint8Array$ as Uint8Array
}

const makeUint8ArrayTransformation = (
  id: string,
  decode: (s: string) => either_.Either<Uint8Array, Encoding.DecodeException>,
  encode: (u: Uint8Array) => string
) =>
  transformOrFail(
    String$.annotations({ description: "a string to be decoded into a Uint8Array" }),
    Uint8ArrayFromSelf,
    {
      strict: true,
      decode: (i, _, ast) =>
        either_.mapLeft(
          decode(i),
          (decodeException) => new ParseResult.Type(ast, i, decodeException.message)
        ),
      encode: (a) => ParseResult.succeed(encode(a))
    }
  ).annotations({ identifier: id })

/**
Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
export const Uint8ArrayFromBase64: Schema<Uint8Array, string> = makeUint8ArrayTransformation(
  "Uint8ArrayFromBase64",
  Encoding.decodeBase64,
  Encoding.encodeBase64
)

/**
Decodes a base64 (URL) encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
export const Uint8ArrayFromBase64Url: Schema<Uint8Array, string> = makeUint8ArrayTransformation(
  "Uint8ArrayFromBase64Url",
  Encoding.decodeBase64Url,
  Encoding.encodeBase64Url
)

/**
Decodes a hex encoded string into a `Uint8Array`.

@category Uint8Array transformations
@since 3.10.0
/
export const Uint8ArrayFromHex: Schema<Uint8Array, string> = makeUint8ArrayTransformation(
  "Uint8ArrayFromHex",
  Encoding.decodeHex,
  Encoding.encodeHex
)

const makeEncodingTransformation = (
  id: string,
  decode: (s: string) => either_.Either<string, Encoding.DecodeException>,
  encode: (u: string) => string
) =>
  transformOrFail(
    String$.annotations({
      description: `A string that is interpreted as being ${id}-encoded and will be decoded into a UTF-8 string`
    }),
    String$,
    {
      strict: true,
      decode: (i, _, ast) =>
        either_.mapLeft(
          decode(i),
          (decodeException) => new ParseResult.Type(ast, i, decodeException.message)
        ),
      encode: (a) => ParseResult.succeed(encode(a))
    }
  ).annotations({ identifier: `StringFrom${id}` })

/**
Decodes a base64 (RFC4648) encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
export const StringFromBase64: Schema<string> = makeEncodingTransformation(
  "Base64",
  Encoding.decodeBase64String,
  Encoding.encodeBase64
)

/**
Decodes a base64 (URL) encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
export const StringFromBase64Url: Schema<string> = makeEncodingTransformation(
  "Base64Url",
  Encoding.decodeBase64UrlString,
  Encoding.encodeBase64Url
)

/**
Decodes a hex encoded string into a UTF-8 string.

@category string transformations
@since 3.10.0
/
export const StringFromHex: Schema<string> = makeEncodingTransformation(
  "Hex",
  Encoding.decodeHexString,
  Encoding.encodeHex
)

/**
Decodes a URI component encoded string into a UTF-8 string.
Can be used to store data in a URL.

@example
```ts
import { Schema } from "effect"

const PaginationSchema = Schema.Struct({
  maxItemPerPage: Schema.Number,
  page: Schema.Number
})

const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))

console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))
// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D
```

@category string transformations
@since 3.12.0
/
export const StringFromUriComponent = transformOrFail(
  String$.annotations({
    description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
  }),
  String$,
  {
    strict: true,
    decode: (i, _, ast) =>
      either_.mapLeft(
        Encoding.decodeUriComponent(i),
        (decodeException) => new ParseResult.Type(ast, i, decodeException.message)
      ),
    encode: (a, _, ast) =>
      either_.mapLeft(
        Encoding.encodeUriComponent(a),
        (encodeException) => new ParseResult.Type(ast, a, encodeException.message)
      )
  }
).annotations({ identifier: `StringFromUriComponent` })

/**
@category schema id
@since 3.10.0
/
export const MinItemsSchemaId: unique symbol = schemaId_.MinItemsSchemaId

/**
@category schema id
@since 3.10.0
/
export type MinItemsSchemaId = typeof MinItemsSchemaId

/**
@category ReadonlyArray filters
@since 3.10.0
/
export const minItems = <S extends Schema.Any>(
  n: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const minItems = Math.floor(n)
  if (minItems < 1) {
    throw new Error(
      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)
    )
  }
  return self.pipe(
    filter(
      (a) => a.length >= minItems,
      {
        schemaId: MinItemsSchemaId,
        title: `minItems(${minItems})`,
        description: `an array of at least ${minItems} item(s)`,
        jsonSchema: { minItems },
        [AST.StableFilterAnnotationId]: true,
        ...annotations
      }
    )
  )
}

/**
@category schema id
@since 3.10.0
/
export const MaxItemsSchemaId: unique symbol = schemaId_.MaxItemsSchemaId

/**
@category schema id
@since 3.10.0
/
export type MaxItemsSchemaId = typeof MaxItemsSchemaId

/**
@category ReadonlyArray filters
@since 3.10.0
/
export const maxItems = <S extends Schema.Any>(
  n: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const maxItems = Math.floor(n)
  if (maxItems < 1) {
    throw new Error(
      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`)
    )
  }
  return self.pipe(
    filter((a) => a.length <= maxItems, {
      schemaId: MaxItemsSchemaId,
      title: `maxItems(${maxItems})`,
      description: `an array of at most ${maxItems} item(s)`,
      jsonSchema: { maxItems },
      [AST.StableFilterAnnotationId]: true,
      ...annotations
    })
  )
}

/**
@category schema id
@since 3.10.0
/
export const ItemsCountSchemaId: unique symbol = schemaId_.ItemsCountSchemaId

/**
@category schema id
@since 3.10.0
/
export type ItemsCountSchemaId = typeof ItemsCountSchemaId

/**
@category ReadonlyArray filters
@since 3.10.0
/
export const itemsCount = <S extends Schema.Any>(
  n: number,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends ReadonlyArray<any>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const itemsCount = Math.floor(n)
  if (itemsCount < 0) {
    throw new Error(
      errors_.getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`)
    )
  }
  return self.pipe(
    filter((a) => a.length === itemsCount, {
      schemaId: ItemsCountSchemaId,
      title: `itemsCount(${itemsCount})`,
      description: `an array of exactly ${itemsCount} item(s)`,
      jsonSchema: { minItems: itemsCount, maxItems: itemsCount },
      [AST.StableFilterAnnotationId]: true,
      ...annotations
    })
  )
}

/**
@category ReadonlyArray transformations
@since 3.10.0
/
export const getNumberIndexedAccess = <A extends ReadonlyArray<any>, I extends ReadonlyArray<any>, R>(
  self: Schema<A, I, R>
): SchemaClass<A[number], I[number], R> => make(AST.getNumberIndexedAccess(self.ast))

/**
Get the first element of a `ReadonlyArray`, or `None` if the array is empty.

@category ReadonlyArray transformations
@since 3.10.0

## headNonEmpty

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `headNonEmpty(<S extends Schema.Any, A extends array_.NonEmptyReadonlyArray<unknown>>(
  self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>
)`

JSDoc:

Get the first element of a `NonEmptyReadonlyArray`.

@category NonEmptyReadonlyArray transformations
@since 3.12.0

## Option

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `Option(<Value extends Schema.Any>(value: Value)`

JSDoc:

Retrieves the first element of a `ReadonlyArray`.

If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.

@category ReadonlyArray transformations
@since 3.10.0
/
export const headOrElse: {
  /**
Retrieves the first element of a `ReadonlyArray`.

If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.

@category ReadonlyArray transformations
@since 3.10.0
/
  <S extends Schema.Any, A extends ReadonlyArray<unknown>>(fallback?: LazyArg<A[number]>): (
    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>
  ) => transform<S, SchemaClass<A[number]>>
  /**
Retrieves the first element of a `ReadonlyArray`.

If the array is empty, it returns the `fallback` argument if provided; otherwise, it fails.

@category ReadonlyArray transformations
@since 3.10.0
/
  <S extends Schema.Any, A extends ReadonlyArray<unknown>>(
    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>,
    fallback?: LazyArg<A[number]>
  ): transform<S, SchemaClass<A[number]>>
} = dual(
  (args) => isSchema(args[0]),
  <A, I, R>(
    self: Schema<ReadonlyArray<A>, I, R>,
    fallback?: LazyArg<A>
  ): transform<Schema<ReadonlyArray<A>, I, R>, SchemaClass<A>> =>
    transformOrFail(
      self,
      getNumberIndexedAccess(typeSchema(self)),
      {
        strict: true,
        decode: (i, _, ast) =>
          i.length > 0
            ? ParseResult.succeed(i[0])
            : fallback
            ? ParseResult.succeed(fallback())
            : ParseResult.fail(new ParseResult.Type(ast, i, "Unable to retrieve the first element of an empty array")),
        encode: (a) => ParseResult.succeed(array_.of(a))
      }
    )
)

/**
@category schema id
@since 3.10.0
/
export const ValidDateSchemaId: unique symbol = Symbol.for("effect/SchemaId/ValidDate")

/**
Defines a filter that specifically rejects invalid dates, such as `new
Date("Invalid Date")`. This filter ensures that only properly formatted and
valid date objects are accepted, enhancing data integrity by preventing
erroneous date values from being processed.

@category Date filters
@since 3.10.0
/
export const validDate =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => !Number.isNaN(a.getTime()), {
        schemaId: ValidDateSchemaId,
        [ValidDateSchemaId]: { noInvalidDate: true },
        title: "validDate",
        description: "a valid Date",
        ...annotations
      })
    )

/**
@category schema id
@since 3.10.0
/
export const LessThanDateSchemaId: unique symbol = Symbol.for("effect/SchemaId/LessThanDate")

/**
@category Date filters
@since 3.10.0
/
export const lessThanDate = <S extends Schema.Any>(
  max: Date,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a: Date) => a < max, {
      schemaId: LessThanDateSchemaId,
      [LessThanDateSchemaId]: { max },
      title: `lessThanDate(${util_.formatDate(max)})`,
      description: `a date before ${util_.formatDate(max)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToDateSchemaId: unique symbol = Symbol.for(
  "effect/schema/LessThanOrEqualToDate"
)

/**
@category Date filters
@since 3.10.0
/
export const lessThanOrEqualToDate = <S extends Schema.Any>(
  max: Date,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a: Date) => a <= max, {
      schemaId: LessThanDateSchemaId,
      [LessThanDateSchemaId]: { max },
      title: `lessThanOrEqualToDate(${util_.formatDate(max)})`,
      description: `a date before or equal to ${util_.formatDate(max)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const GreaterThanDateSchemaId: unique symbol = Symbol.for("effect/SchemaId/GreaterThanDate")

/**
@category Date filters
@since 3.10.0
/
export const greaterThanDate = <S extends Schema.Any>(
  min: Date,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a: Date) => a > min, {
      schemaId: GreaterThanDateSchemaId,
      [GreaterThanDateSchemaId]: { min },
      title: `greaterThanDate(${util_.formatDate(min)})`,
      description: `a date after ${util_.formatDate(min)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToDateSchemaId: unique symbol = Symbol.for(
  "effect/schema/GreaterThanOrEqualToDate"
)

/**
@category Date filters
@since 3.10.0
/
export const greaterThanOrEqualToDate = <S extends Schema.Any>(
  min: Date,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a: Date) => a >= min, {
      schemaId: GreaterThanOrEqualToDateSchemaId,
      [GreaterThanOrEqualToDateSchemaId]: { min },
      title: `greaterThanOrEqualToDate(${util_.formatDate(min)})`,
      description: `a date after or equal to ${util_.formatDate(min)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.10.0
/
export const BetweenDateSchemaId: unique symbol = Symbol.for("effect/SchemaId/BetweenDate")

/**
@category Date filters
@since 3.10.0
/
export const betweenDate = <S extends Schema.Any>(
  min: Date,
  max: Date,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
  self.pipe(
    filter((a: Date) => a <= max && a >= min, {
      schemaId: BetweenDateSchemaId,
      [BetweenDateSchemaId]: { max, min },
      title: `betweenDate(${util_.formatDate(min)}, ${util_.formatDate(max)})`,
      description: `a date between ${util_.formatDate(min)} and ${util_.formatDate(max)}`,
      ...annotations
    })
  )

/**
@category schema id
@since 3.11.8
/
export const DateFromSelfSchemaId: unique symbol = schemaId_.DateFromSelfSchemaId

/**
@category schema id
@since 3.11.8
/
export type DateFromSelfSchemaId = typeof DateFromSelfSchemaId

/**
Describes a schema that accommodates potentially invalid `Date` instances,
such as `new Date("Invalid Date")`, without rejection.

@category Date constructors
@since 3.10.0
/
export class DateFromSelf extends declare(
  Predicate.isDate,
  {
    identifier: "DateFromSelf",
    schemaId: DateFromSelfSchemaId,
    [DateFromSelfSchemaId]: { noInvalidDate: false },
    description: "a potentially invalid Date instance",
    pretty: () => (date) => `new Date(${JSON.stringify(date)})`,
    arbitrary: () => (fc) => fc.date({ noInvalidDate: false }),
    equivalence: () => Equivalence.Date
  }
) {}

/**
Defines a schema that ensures only valid dates are accepted. This schema
rejects values like `new Date("Invalid Date")`, which, despite being a `Date`
instance, represents an invalid date. Such stringent validation ensures that
all date objects processed through this schema are properly formed and
represent real dates.

@category Date constructors
@since 3.10.0
/
export class ValidDateFromSelf extends DateFromSelf.pipe(
  validDate({
    identifier: "ValidDateFromSelf",
    description: "a valid Date instance"
  })
) {}

/**
Defines a schema that attempts to convert a `string` to a `Date` object using
the `new Date` constructor. This conversion is lenient, meaning it does not
reject strings that do not form valid dates (e.g., using `new Date("Invalid
Date")` results in a `Date` object, despite being invalid).

@category Date transformations
@since 3.10.0
/
export class DateFromString extends transform(
  String$.annotations({ description: "a string to be decoded into a Date" }),
  DateFromSelf,
  {
    strict: true,
    decode: (i) => new Date(i),
    encode: (a) => util_.formatDate(a)
  }
).annotations({ identifier: "DateFromString" }) {}

/** @ignore */
class Date$ extends DateFromString.pipe(
  validDate({ identifier: "Date" })
) {}

export {
  /**
This schema converts a `string` into a `Date` object using the `new Date`
constructor. It ensures that only valid date strings are accepted,
rejecting any strings that would result in an invalid date, such as `new
Date("Invalid Date")`.

@category Date transformations
@since 3.10.0
/
  Date$ as Date
}

/**
Defines a schema that converts a `number` into a `Date` object using the `new
Date` constructor. This schema does not validate the numerical input,
allowing potentially invalid values such as `NaN`, `Infinity`, and
`-Infinity` to be converted into `Date` objects. During the encoding process,
any invalid `Date` object will be encoded to `NaN`.

@category Date transformations
@since 3.10.0
/
export class DateFromNumber extends transform(
  Number$.annotations({ description: "a number to be decoded into a Date" }),
  DateFromSelf,
  {
    strict: true,
    decode: (i) => new Date(i),
    encode: (a) => a.getTime()
  }
).annotations({ identifier: "DateFromNumber" }) {}

/**
Describes a schema that represents a `DateTime.Utc` instance.

@category DateTime.Utc constructors
@since 3.10.0
/
export class DateTimeUtcFromSelf extends declare(
  (u) => dateTime.isDateTime(u) && dateTime.isUtc(u),
  {
    identifier: "DateTimeUtcFromSelf",
    description: "a DateTime.Utc instance",
    pretty: (): pretty_.Pretty<dateTime.Utc> => (dateTime) => dateTime.toString(),
    arbitrary: (): LazyArbitrary<dateTime.Utc> => (fc) =>
      fc.date({ noInvalidDate: true }).map((date) => dateTime.unsafeFromDate(date)),
    equivalence: () => dateTime.Equivalence
  }
) {}

const decodeDateTimeUtc = <A extends dateTime.DateTime.Input>(input: A, ast: AST.AST) =>
  ParseResult.try({
    try: () => dateTime.unsafeMake(input),
    catch: () => new ParseResult.Type(ast, input, `Unable to decode ${util_.formatUnknown(input)} into a DateTime.Utc`)
  })

/**
Defines a schema that attempts to convert a `number` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.10.0
/
export class DateTimeUtcFromNumber extends transformOrFail(
  Number$.annotations({ description: "a number to be decoded into a DateTime.Utc" }),
  DateTimeUtcFromSelf,
  {
    strict: true,
    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
    encode: (a) => ParseResult.succeed(dateTime.toEpochMillis(a))
  }
).annotations({ identifier: "DateTimeUtcFromNumber" }) {}

/**
Defines a schema that attempts to convert a `Date` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.12.0
/
export class DateTimeUtcFromDate extends transformOrFail(
  DateFromSelf.annotations({ description: "a Date to be decoded into a DateTime.Utc" }),
  DateTimeUtcFromSelf,
  {
    strict: true,
    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
    encode: (a) => ParseResult.succeed(dateTime.toDateUtc(a))
  }
).annotations({ identifier: "DateTimeUtcFromDate" }) {}

/**
Defines a schema that attempts to convert a `string` to a `DateTime.Utc` instance using the `DateTime.unsafeMake` constructor.

@category DateTime.Utc transformations
@since 3.10.0
/
export class DateTimeUtc extends transformOrFail(
  String$.annotations({ description: "a string to be decoded into a DateTime.Utc" }),
  DateTimeUtcFromSelf,
  {
    strict: true,
    decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
    encode: (a) => ParseResult.succeed(dateTime.formatIso(a))
  }
).annotations({ identifier: "DateTimeUtc" }) {}

const timeZoneOffsetArbitrary = (): LazyArbitrary<dateTime.TimeZone.Offset> => (fc) =>
  fc.integer({ min: -12 * 60 * 60 * 1000, max: 14 * 60 * 60 * 1000 }).map(dateTime.zoneMakeOffset)

/**
Describes a schema that represents a `TimeZone.Offset` instance.

@category TimeZone constructors
@since 3.10.0
/
export class TimeZoneOffsetFromSelf extends declare(
  dateTime.isTimeZoneOffset,
  {
    identifier: "TimeZoneOffsetFromSelf",
    description: "a TimeZone.Offset instance",
    pretty: (): pretty_.Pretty<dateTime.TimeZone.Offset> => (zone) => zone.toString(),
    arbitrary: timeZoneOffsetArbitrary
  }
) {}

/**
Defines a schema that converts a `number` to a `TimeZone.Offset` instance using the `DateTime.zoneMakeOffset` constructor.

@category TimeZone transformations
@since 3.10.0
/
export class TimeZoneOffset extends transform(
  Number$.annotations({ description: "a number to be decoded into a TimeZone.Offset" }),
  TimeZoneOffsetFromSelf,
  {
    strict: true,
    decode: (i) => dateTime.zoneMakeOffset(i),
    encode: (a) => a.offset
  }
).annotations({ identifier: "TimeZoneOffset" }) {}

const timeZoneNamedArbitrary = (): LazyArbitrary<dateTime.TimeZone.Named> => (fc) =>
  fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(dateTime.zoneUnsafeMakeNamed)

/**
Describes a schema that represents a `TimeZone.Named` instance.

@category TimeZone constructors
@since 3.10.0
/
export class TimeZoneNamedFromSelf extends declare(
  dateTime.isTimeZoneNamed,
  {
    identifier: "TimeZoneNamedFromSelf",
    description: "a TimeZone.Named instance",
    pretty: (): pretty_.Pretty<dateTime.TimeZone.Named> => (zone) => zone.toString(),
    arbitrary: timeZoneNamedArbitrary
  }
) {}

/**
Defines a schema that attempts to convert a `string` to a `TimeZone.Named` instance using the `DateTime.zoneUnsafeMakeNamed` constructor.

@category TimeZone transformations
@since 3.10.0
/
export class TimeZoneNamed extends transformOrFail(
  String$.annotations({ description: "a string to be decoded into a TimeZone.Named" }),
  TimeZoneNamedFromSelf,
  {
    strict: true,
    decode: (i, _, ast) =>
      ParseResult.try({
        try: () => dateTime.zoneUnsafeMakeNamed(i),
        catch: () => new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)
      }),
    encode: (a) => ParseResult.succeed(a.id)
  }
).annotations({ identifier: "TimeZoneNamed" }) {}

/**
@category TimeZone constructors
@since 3.10.0
/
export class TimeZoneFromSelf extends Union(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf) {}

/**
Defines a schema that attempts to convert a `string` to a `TimeZone` using the `DateTime.zoneFromString` constructor.

@category TimeZone transformations
@since 3.10.0
/
export class TimeZone extends transformOrFail(
  String$.annotations({ description: "a string to be decoded into a TimeZone" }),
  TimeZoneFromSelf,
  {
    strict: true,
    decode: (i, _, ast) =>
      option_.match(dateTime.zoneFromString(i), {
        onNone: () =>
          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),
        onSome: ParseResult.succeed
      }),
    encode: (a) => ParseResult.succeed(dateTime.zoneToString(a))
  }
).annotations({ identifier: "TimeZone" }) {}

const timeZoneArbitrary: LazyArbitrary<dateTime.TimeZone> = (fc) =>
  fc.oneof(
    timeZoneOffsetArbitrary()(fc),
    timeZoneNamedArbitrary()(fc)
  )

/**
Describes a schema that represents a `DateTime.Zoned` instance.

@category DateTime.Zoned constructors
@since 3.10.0
/
export class DateTimeZonedFromSelf extends declare(
  (u) => dateTime.isDateTime(u) && dateTime.isZoned(u),
  {
    identifier: "DateTimeZonedFromSelf",
    description: "a DateTime.Zoned instance",
    pretty: (): pretty_.Pretty<dateTime.Zoned> => (dateTime) => dateTime.toString(),
    arbitrary: (): LazyArbitrary<dateTime.Zoned> => (fc) =>
      fc.tuple(
        fc.integer({
          // time zone db supports +/- 1000 years or so
          min: -31536000000000,
          max: 31536000000000
        }),
        timeZoneArbitrary(fc)
      ).map(([millis, timeZone]) => dateTime.unsafeMakeZoned(millis, { timeZone })),
    equivalence: () => dateTime.Equivalence
  }
) {}

/**
Defines a schema that attempts to convert a `string` to a `DateTime.Zoned` instance.

@category DateTime.Zoned transformations
@since 3.10.0
/
export class DateTimeZoned extends transformOrFail(
  String$.annotations({ description: "a string to be decoded into a DateTime.Zoned" }),
  DateTimeZonedFromSelf,
  {
    strict: true,
    decode: (i, _, ast) =>
      option_.match(dateTime.makeZonedFromString(i), {
        onNone: () =>
          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),
        onSome: ParseResult.succeed
      }),
    encode: (a) => ParseResult.succeed(dateTime.formatIsoZoned(a))
  }
).annotations({ identifier: "DateTimeZoned" }) {}

/**
@category Option utils
@since 3.10.0
/
export type OptionEncoded<I> =
  | {
    readonly _tag: "None"
  }
  | {
    readonly _tag: "Some"
    readonly value: I
  }

const OptionNoneEncoded = Struct({
  _tag: Literal("None")
}).annotations({ description: "NoneEncoded" })

const optionSomeEncoded = <Value extends Schema.Any>(value: Value) =>
  Struct({
    _tag: Literal("Some"),
    value
  }).annotations({ description: `SomeEncoded<${format(value)}>` })

const optionEncoded = <Value extends Schema.Any>(value: Value) =>
  Union(
    OptionNoneEncoded,
    optionSomeEncoded(value)
  ).annotations({
    description: `OptionEncoded<${format(value)}>`
  })

const optionDecode = <A>(input: OptionEncoded<A>): option_.Option<A> =>
  input._tag === "None" ? option_.none() : option_.some(input.value)

const optionArbitrary =
  <A>(value: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<option_.Option<A>> => (fc) =>
    fc.oneof(
      ctx,
      fc.record({ _tag: fc.constant("None" as const) }),
      fc.record({ _tag: fc.constant("Some" as const), value: value(fc) })
    ).map(optionDecode)

const optionPretty = <A>(value: pretty_.Pretty<A>): pretty_.Pretty<option_.Option<A>> =>
  option_.match({
    onNone: () => "none()",
    onSome: (a) => `some(${value(a)})`
  })

const optionParse =
  <A, R>(decodeUnknown: ParseResult.DecodeUnknown<A, R>): ParseResult.DeclarationDecodeUnknown<option_.Option<A>, R> =>
  (u, options, ast) =>
    option_.isOption(u) ?
      option_.isNone(u) ?
        ParseResult.succeed(option_.none())
        : toComposite(decodeUnknown(u.value, options), option_.some, ast, u)
      : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface OptionFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    OptionFromSelf<Value>,
    option_.Option<Schema.Type<Value>>,
    option_.Option<Schema.Encoded<Value>>,
    [Value]
  >
{}

/**
@category Option transformations
@since 3.10.0
/
export const OptionFromSelf = <Value extends Schema.Any>(value: Value): OptionFromSelf<Value> => {
  return declare(
    [value],
    {
      decode: (value) => optionParse(ParseResult.decodeUnknown(value)),
      encode: (value) => optionParse(ParseResult.encodeUnknown(value))
    },
    {
      description: `Option<${format(value)}>`,
      pretty: optionPretty,
      arbitrary: optionArbitrary,
      equivalence: option_.getEquivalence
    }
  )
}

/**
@category api interface
@since 3.10.0
/
export interface Option<Value extends Schema.Any> extends
  transform<
    Union<[
      Struct<{ _tag: Literal<["None"]> }>,
      Struct<{ _tag: Literal<["Some"]>; value: Value }>
    ]>,
    OptionFromSelf<SchemaClass<Schema.Type<Value>>>
  >
{}

const makeNoneEncoded = {
  _tag: "None"
} as const

const makeSomeEncoded = <A>(value: A) => ({
  _tag: "Some",
  value
} as const)

/**
@category Option transformations
@since 3.10.0

## OptionFromNullOr

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `OptionFromNullOr(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface OptionFromNullOr<Value extends Schema.Any>
  extends transform<NullOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category Option transformations
@since 3.10.0

## OptionFromNullishOr

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `OptionFromNullishOr(<Value extends Schema.Any>(
  value: Value,
  onNoneEncoding: null | undefined
)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface OptionFromNullishOr<Value extends Schema.Any>
  extends transform<NullishOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category Option transformations
@since 3.10.0

## OptionFromUndefinedOr

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `OptionFromUndefinedOr(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface OptionFromUndefinedOr<Value extends Schema.Any>
  extends transform<UndefinedOr<Value>, OptionFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category Option transformations
@since 3.10.0

## ReadonlyMap

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `ReadonlyMap(<K extends Schema.Any, V extends Schema.Any>({ key, value }: {
  readonly key: K
  readonly value: V
})`

JSDoc:

Transforms strings into an Option type, effectively filtering out empty or
whitespace-only strings by trimming them and checking their length. Returns
`none` for invalid inputs and `some` for valid non-empty strings.

@example
```ts
import { Schema } from "effect"

console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(" a ")) // Option.some("a")
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("a")) // Option.some("a")
```

@category Option transformations
@since 3.10.0
/
export class OptionFromNonEmptyTrimmedString extends transform(String$, OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: (i) => option_.filter(option_.some(i.trim()), string_.isNonEmpty),
  encode: (a) => option_.getOrElse(a, () => "")
}) {}

/**
@category Either utils
@since 3.10.0
/
export type RightEncoded<IA> = {
  readonly _tag: "Right"
  readonly right: IA
}

/**
@category Either utils
@since 3.10.0
/
export type LeftEncoded<IE> = {
  readonly _tag: "Left"
  readonly left: IE
}

/**
@category Either utils
@since 3.10.0
/
export type EitherEncoded<IR, IL> = RightEncoded<IR> | LeftEncoded<IL>

const rightEncoded = <Right extends Schema.All>(right: Right) =>
  Struct({
    _tag: Literal("Right"),
    right
  }).annotations({ description: `RightEncoded<${format(right)}>` })

const leftEncoded = <Left extends Schema.All>(left: Left) =>
  Struct({
    _tag: Literal("Left"),
    left
  }).annotations({ description: `LeftEncoded<${format(left)}>` })

const eitherEncoded = <Right extends Schema.All, Left extends Schema.All>(
  right: Right,
  left: Left
) =>
  Union(rightEncoded(right), leftEncoded(left)).annotations({
    description: `EitherEncoded<${format(left)}, ${format(right)}>`
  })

const eitherDecode = <R, L>(input: EitherEncoded<R, L>): either_.Either<R, L> =>
  input._tag === "Left" ? either_.left(input.left) : either_.right(input.right)

const eitherArbitrary = <R, L>(
  right: LazyArbitrary<R>,
  left: LazyArbitrary<L>
): LazyArbitrary<either_.Either<R, L>> =>
(fc) =>
  fc.oneof(
    fc.record({ _tag: fc.constant("Left" as const), left: left(fc) }),
    fc.record({ _tag: fc.constant("Right" as const), right: right(fc) })
  ).map(eitherDecode)

const eitherPretty = <R, L>(
  right: pretty_.Pretty<R>,
  left: pretty_.Pretty<L>
): pretty_.Pretty<either_.Either<R, L>> =>
  either_.match({
    onLeft: (e) => `left(${left(e)})`,
    onRight: (a) => `right(${right(a)})`
  })

const eitherParse = <RR, R, LR, L>(
  parseRight: ParseResult.DecodeUnknown<R, RR>,
  decodeUnknownLeft: ParseResult.DecodeUnknown<L, LR>
): ParseResult.DeclarationDecodeUnknown<either_.Either<R, L>, LR | RR> =>
(u, options, ast) =>
  either_.isEither(u) ?
    either_.match(u, {
      onLeft: (left) => toComposite(decodeUnknownLeft(left, options), either_.left, ast, u),
      onRight: (right) => toComposite(parseRight(right, options), either_.right, ast, u)
    })
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface EitherFromSelf<R extends Schema.All, L extends Schema.All> extends
  AnnotableDeclare<
    EitherFromSelf<R, L>,
    either_.Either<Schema.Type<R>, Schema.Type<L>>,
    either_.Either<Schema.Encoded<R>, Schema.Encoded<L>>,
    [R, L]
  >
{}

/**
@category Either transformations
@since 3.10.0
/
export const EitherFromSelf = <R extends Schema.All, L extends Schema.All>({ left, right }: {
  readonly left: L
  readonly right: R
}): EitherFromSelf<R, L> => {
  return declare(
    [right, left],
    {
      decode: (right, left) => eitherParse(ParseResult.decodeUnknown(right), ParseResult.decodeUnknown(left)),
      encode: (right, left) => eitherParse(ParseResult.encodeUnknown(right), ParseResult.encodeUnknown(left))
    },
    {
      description: `Either<${format(right)}, ${format(left)}>`,
      pretty: eitherPretty,
      arbitrary: eitherArbitrary,
      equivalence: (right, left) => either_.getEquivalence({ left, right })
    }
  )
}

const makeLeftEncoded = <E>(left: E) => (({
  _tag: "Left",
  left
}) as const)
const makeRightEncoded = <A>(right: A) => (({
  _tag: "Right",
  right
}) as const)

/**
@category api interface
@since 3.10.0
/
export interface Either<Right extends Schema.All, Left extends Schema.All> extends
  transform<
    Union<[
      Struct<{
        _tag: Literal<["Right"]>
        right: Right
      }>,
      Struct<{
        _tag: Literal<["Left"]>
        left: Left
      }>
    ]>,
    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>
  >
{}

/**
@category Either transformations
@since 3.10.0
/
export const Either = <R extends Schema.All, L extends Schema.All>({ left, right }: {
  readonly left: L
  readonly right: R
}): Either<R, L> => {
  const right_ = asSchema(right)
  const left_ = asSchema(left)
  const out = transform(
    eitherEncoded(right_, left_),
    EitherFromSelf({ left: typeSchema(left_), right: typeSchema(right_) }),
    {
      strict: true,
      decode: (i) => eitherDecode(i),
      encode: (a) =>
        either_.match(a, {
          onLeft: makeLeftEncoded,
          onRight: makeRightEncoded
        })
    }
  )
  return out as any
}

/**
@category api interface
@since 3.10.0
/
export interface EitherFromUnion<Right extends Schema.All, Left extends Schema.All> extends
  transform<
    Union<[
      transform<Right, Struct<{ _tag: Literal<["Right"]>; right: SchemaClass<Schema.Type<Right>> }>>,
      transform<Left, Struct<{ _tag: Literal<["Left"]>; right: SchemaClass<Schema.Type<Left>> }>>
    ]>,
    EitherFromSelf<SchemaClass<Schema.Type<Right>>, SchemaClass<Schema.Type<Left>>>
  >
{}

/**
@example
```ts
import * as Schema from "effect/Schema"

// Schema<string | number, Either<string, number>>
Schema.EitherFromUnion({ left: Schema.String, right: Schema.Number })
```

@category Either transformations
@since 3.10.0
/
export const EitherFromUnion = <Right extends Schema.All, Left extends Schema.All>({ left, right }: {
  readonly left: Left
  readonly right: Right
}): EitherFromUnion<Right, Left> => {
  const right_ = asSchema(right)
  const left_ = asSchema(left)
  const toright = typeSchema(right_)
  const toleft = typeSchema(left_)
  const fromRight = transform(right_, rightEncoded(toright), {
    strict: true,
    decode: (i) => makeRightEncoded(i),
    encode: (a) => a.right
  })
  const fromLeft = transform(left_, leftEncoded(toleft), {
    strict: true,
    decode: (i) => makeLeftEncoded(i),
    encode: (a) => a.left
  })
  const out = transform(
    Union(fromRight, fromLeft),
    EitherFromSelf({ left: toleft, right: toright }),
    {
      strict: true,
      decode: (i) => i._tag === "Left" ? either_.left(i.left) : either_.right(i.right),
      encode: (a) =>
        either_.match(a, {
          onLeft: makeLeftEncoded,
          onRight: makeRightEncoded
        })
    }
  )
  return out as any
}

const mapArbitrary = <K, V>(
  key: LazyArbitrary<K>,
  value: LazyArbitrary<V>,
  ctx: ArbitraryGenerationContext
): LazyArbitrary<Map<K, V>> => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value(fc)))
    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Map(as))
  }
}

const readonlyMapPretty = <K, V>(
  key: pretty_.Pretty<K>,
  value: pretty_.Pretty<V>
): pretty_.Pretty<ReadonlyMap<K, V>> =>
(map) =>
  `new Map([${
    Array.from(map.entries())
      .map(([k, v]) => `[${key(k)}, ${value(v)}]`)
      .join(", ")
  }])`

const readonlyMapEquivalence = <K, V>(
  key: Equivalence.Equivalence<K>,
  value: Equivalence.Equivalence<V>
): Equivalence.Equivalence<ReadonlyMap<K, V>> => {
  const arrayEquivalence = array_.getEquivalence(
    Equivalence.make<[K, V]>(([ka, va], [kb, vb]) => key(ka, kb) && value(va, vb))
  )
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())))
}

const readonlyMapParse = <R, K, V>(
  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<readonly [K, V]>, R>
): ParseResult.DeclarationDecodeUnknown<ReadonlyMap<K, V>, R> =>
(u, options, ast) =>
  Predicate.isMap(u) ?
    toComposite(decodeUnknown(Array.from(u.entries()), options), (as) => new Map(as), ast, u)
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface ReadonlyMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends
  AnnotableDeclare<
    ReadonlyMapFromSelf<K, V>,
    ReadonlyMap<Schema.Type<K>, Schema.Type<V>>,
    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,
    [K, V]
  >
{}

const mapFromSelf_ = <K extends Schema.Any, V extends Schema.Any>(
  key: K,
  value: V,
  description: string
): ReadonlyMapFromSelf<K, V> =>
  declare(
    [key, value],
    {
      decode: (Key, Value) => readonlyMapParse(ParseResult.decodeUnknown(Array$(Tuple(Key, Value)))),
      encode: (Key, Value) => readonlyMapParse(ParseResult.encodeUnknown(Array$(Tuple(Key, Value))))
    },
    {
      description,
      pretty: readonlyMapPretty,
      arbitrary: mapArbitrary,
      equivalence: readonlyMapEquivalence
    }
  )

/**
@category ReadonlyMap
@since 3.10.0
/
export const ReadonlyMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
  readonly key: K
  readonly value: V
}): ReadonlyMapFromSelf<K, V> => mapFromSelf_(key, value, `ReadonlyMap<${format(key)}, ${format(value)}>`)

/**
@category api interface
@since 3.10.0
/
export interface MapFromSelf<K extends Schema.Any, V extends Schema.Any> extends
  AnnotableDeclare<
    MapFromSelf<K, V>,
    Map<Schema.Type<K>, Schema.Type<V>>,
    ReadonlyMap<Schema.Encoded<K>, Schema.Encoded<V>>,
    [K, V]
  >
{}

/**
@category Map
@since 3.10.0
/
export const MapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
  readonly key: K
  readonly value: V
}): MapFromSelf<K, V> => mapFromSelf_(key, value, `Map<${format(key)}, ${format(value)}>`) as any

/**
@category api interface
@since 3.10.0
/
export interface ReadonlyMap$<K extends Schema.Any, V extends Schema.Any>
  extends transform<Array$<Tuple2<K, V>>, ReadonlyMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>
{}

/**
@category ReadonlyMap transformations
@since 3.10.0

## ReadonlySet

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `ReadonlySet(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface Map$<K extends Schema.Any, V extends Schema.Any>
  extends transform<Array$<Tuple2<K, V>>, MapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>
{}

/** @ignore */
function map<K extends Schema.Any, V extends Schema.Any>({ key, value }: {
  readonly key: K
  readonly value: V
}): Map$<K, V> {
  return transform(
    Array$(Tuple(key, value)),
    MapFromSelf({ key: typeSchema(asSchema(key)), value: typeSchema(asSchema(value)) }),
    {
      strict: true,
      decode: (i) => new Map(i),
      encode: (a) => Array.from(a.entries())
    }
  )
}

export {
  /**
@category Map transformations
@since 3.10.0
/
  map as Map
}

/**
@category ReadonlyMap transformations
@since 3.10.0
/
export const ReadonlyMapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {
  key: Schema<KA, string, KR>
  value: Schema<VA, VI, VR>
}): SchemaClass<ReadonlyMap<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>
  transform(
    Record({ key: encodedBoundSchema(key), value }).annotations({
      description: "a record to be decoded into a ReadonlyMap"
    }),
    ReadonlyMapFromSelf({ key, value: typeSchema(value) }),
    {
      strict: true,
      decode: (i) => new Map(Object.entries(i)),
      encode: (a) => Object.fromEntries(a)
    }
  )

/**
@category Map transformations
@since 3.10.0
/
export const MapFromRecord = <KA, KR, VA, VI, VR>({ key, value }: {
  key: Schema<KA, string, KR>
  value: Schema<VA, VI, VR>
}): SchemaClass<Map<KA, VA>, { readonly [x: string]: VI }, KR | VR> =>
  transform(
    Record({ key: encodedBoundSchema(key), value }).annotations({
      description: "a record to be decoded into a Map"
    }),
    MapFromSelf({ key, value: typeSchema(value) }),
    {
      strict: true,
      decode: (i) => new Map(Object.entries(i)),
      encode: (a) => Object.fromEntries(a)
    }
  )

const setArbitrary =
  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<ReadonlySet<A>> => (fc) => {
    const items = fc.array(item(fc))
    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as) => new Set(as))
  }

const readonlySetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<ReadonlySet<A>> => (set) =>
  `new Set([${Array.from(set.values()).map((a) => item(a)).join(", ")}])`

const readonlySetEquivalence = <A>(
  item: Equivalence.Equivalence<A>
): Equivalence.Equivalence<ReadonlySet<A>> => {
  const arrayEquivalence = array_.getEquivalence(item)
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())))
}

const readonlySetParse = <A, R>(
  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>
): ParseResult.DeclarationDecodeUnknown<ReadonlySet<A>, R> =>
(u, options, ast) =>
  Predicate.isSet(u) ?
    toComposite(decodeUnknown(Array.from(u.values()), options), (as) => new Set(as), ast, u)
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface ReadonlySetFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    ReadonlySetFromSelf<Value>,
    ReadonlySet<Schema.Type<Value>>,
    ReadonlySet<Schema.Encoded<Value>>,
    [Value]
  >
{}

const setFromSelf_ = <Value extends Schema.Any>(value: Value, description: string): ReadonlySetFromSelf<Value> =>
  declare(
    [value],
    {
      decode: (item) => readonlySetParse(ParseResult.decodeUnknown(Array$(item))),
      encode: (item) => readonlySetParse(ParseResult.encodeUnknown(Array$(item)))
    },
    {
      description,
      pretty: readonlySetPretty,
      arbitrary: setArbitrary,
      equivalence: readonlySetEquivalence
    }
  )

/**
@category ReadonlySet
@since 3.10.0
/
export const ReadonlySetFromSelf = <Value extends Schema.Any>(value: Value): ReadonlySetFromSelf<Value> =>
  setFromSelf_(value, `ReadonlySet<${format(value)}>`)

/**
@category api interface
@since 3.10.0
/
export interface SetFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    SetFromSelf<Value>,
    Set<Schema.Type<Value>>,
    ReadonlySet<Schema.Encoded<Value>>,
    [Value]
  >
{}

/**
@category Set
@since 3.10.0
/
export const SetFromSelf = <Value extends Schema.Any>(value: Value): SetFromSelf<Value> =>
  setFromSelf_(value, `Set<${format(value)}>`) as any

/**
@category api interface
@since 3.10.0
/
export interface ReadonlySet$<Value extends Schema.Any>
  extends transform<Array$<Value>, ReadonlySetFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category ReadonlySet transformations
@since 3.10.0

## Chunk

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `Chunk(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface Set$<Value extends Schema.Any>
  extends transform<Array$<Value>, SetFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/** @ignore */
function set<Value extends Schema.Any>(value: Value): Set$<Value> {
  return transform(
    Array$(value),
    SetFromSelf(typeSchema(asSchema(value))),
    {
      strict: true,
      decode: (i) => new Set(i),
      encode: (a) => Array.from(a)
    }
  )
}

export {
  /**
@category Set transformations
@since 3.10.0
/
  set as Set
}

const bigDecimalPretty = (): pretty_.Pretty<bigDecimal_.BigDecimal> => (val) =>
  `BigDecimal(${bigDecimal_.format(bigDecimal_.normalize(val))})`

const bigDecimalArbitrary = (): LazyArbitrary<bigDecimal_.BigDecimal> => (fc) =>
  fc.tuple(fc.bigInt(), fc.integer({ min: 0, max: 18 }))
    .map(([value, scale]) => bigDecimal_.make(value, scale))

/**
@category BigDecimal constructors
@since 3.10.0
/
export class BigDecimalFromSelf extends declare(
  bigDecimal_.isBigDecimal,
  {
    identifier: "BigDecimalFromSelf",
    pretty: bigDecimalPretty,
    arbitrary: bigDecimalArbitrary,
    equivalence: () => bigDecimal_.Equivalence
  }
) {}

/**
@category BigDecimal transformations
@since 3.10.0
/
export class BigDecimal extends transformOrFail(
  String$.annotations({ description: "a string to be decoded into a BigDecimal" }),
  BigDecimalFromSelf,
  {
    strict: true,
    decode: (i, _, ast) =>
      bigDecimal_.fromString(i).pipe(option_.match({
        onNone: () =>
          ParseResult.fail(new ParseResult.Type(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),
        onSome: (val) => ParseResult.succeed(bigDecimal_.normalize(val))
      })),
    encode: (a) => ParseResult.succeed(bigDecimal_.format(bigDecimal_.normalize(a)))
  }
).annotations({ identifier: "BigDecimal" }) {}

/**
A schema that transforms a `number` into a `BigDecimal`.
When encoding, this Schema will produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.

@category BigDecimal transformations
@since 3.10.0
/
export class BigDecimalFromNumber extends transform(
  Number$.annotations({ description: "a number to be decoded into a BigDecimal" }),
  BigDecimalFromSelf,
  {
    strict: true,
    decode: (i) => bigDecimal_.unsafeFromNumber(i),
    encode: (a) => bigDecimal_.unsafeToNumber(a)
  }
).annotations({ identifier: "BigDecimalFromNumber" }) {}

/**
@category schema id
@since 3.10.0
/
export const GreaterThanBigDecimalSchemaId: unique symbol = Symbol.for("effect/SchemaId/GreaterThanBigDecimal")

/**
@category BigDecimal filters
@since 3.10.0
/
export const greaterThanBigDecimal =
  <S extends Schema.Any>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
    const formatted = bigDecimal_.format(min)
    return self.pipe(
      filter((a) => bigDecimal_.greaterThan(a, min), {
        schemaId: GreaterThanBigDecimalSchemaId,
        [GreaterThanBigDecimalSchemaId]: { min },
        title: `greaterThanBigDecimal(${formatted})`,
        description: `a BigDecimal greater than ${formatted}`,
        ...annotations
      })
    )
  }

/**
@category schema id
@since 3.10.0
/
export const GreaterThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(
  "effect/schema/GreaterThanOrEqualToBigDecimal"
)

/**
@category BigDecimal filters
@since 3.10.0
/
export const greaterThanOrEqualToBigDecimal =
  <S extends Schema.Any>(min: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
    const formatted = bigDecimal_.format(min)
    return self.pipe(
      filter((a) => bigDecimal_.greaterThanOrEqualTo(a, min), {
        schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
        [GreaterThanOrEqualToBigDecimalSchemaId]: { min },
        title: `greaterThanOrEqualToBigDecimal(${formatted})`,
        description: `a BigDecimal greater than or equal to ${formatted}`,
        ...annotations
      })
    )
  }

/**
@category schema id
@since 3.10.0
/
export const LessThanBigDecimalSchemaId: unique symbol = Symbol.for("effect/SchemaId/LessThanBigDecimal")

/**
@category BigDecimal filters
@since 3.10.0
/
export const lessThanBigDecimal =
  <S extends Schema.Any>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
    const formatted = bigDecimal_.format(max)
    return self.pipe(
      filter((a) => bigDecimal_.lessThan(a, max), {
        schemaId: LessThanBigDecimalSchemaId,
        [LessThanBigDecimalSchemaId]: { max },
        title: `lessThanBigDecimal(${formatted})`,
        description: `a BigDecimal less than ${formatted}`,
        ...annotations
      })
    )
  }

/**
@category schema id
@since 3.10.0
/
export const LessThanOrEqualToBigDecimalSchemaId: unique symbol = Symbol.for(
  "effect/schema/LessThanOrEqualToBigDecimal"
)

/**
@category BigDecimal filters
@since 3.10.0
/
export const lessThanOrEqualToBigDecimal =
  <S extends Schema.Any>(max: bigDecimal_.BigDecimal, annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
    const formatted = bigDecimal_.format(max)
    return self.pipe(
      filter((a) => bigDecimal_.lessThanOrEqualTo(a, max), {
        schemaId: LessThanOrEqualToBigDecimalSchemaId,
        [LessThanOrEqualToBigDecimalSchemaId]: { max },
        title: `lessThanOrEqualToBigDecimal(${formatted})`,
        description: `a BigDecimal less than or equal to ${formatted}`,
        ...annotations
      })
    )
  }

/**
@category schema id
@since 3.10.0
/
export const PositiveBigDecimalSchemaId: unique symbol = Symbol.for(
  "effect/schema/PositiveBigDecimal"
)

/**
@category BigDecimal filters
@since 3.10.0
/
export const positiveBigDecimal =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => bigDecimal_.isPositive(a), {
        schemaId: PositiveBigDecimalSchemaId,
        title: "positiveBigDecimal",
        description: `a positive BigDecimal`,
        ...annotations
      })
    )

/**
@category BigDecimal constructors
@since 3.10.0
/
export const PositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(
  positiveBigDecimal({ identifier: "PositiveBigDecimalFromSelf" })
)

/**
@category schema id
@since 3.10.0
/
export const NonNegativeBigDecimalSchemaId: unique symbol = Symbol.for(
  "effect/schema/NonNegativeBigDecimal"
)

/**
@category BigDecimal filters
@since 3.10.0
/
export const nonNegativeBigDecimal =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => a.value >= 0n, {
        schemaId: NonNegativeBigDecimalSchemaId,
        title: "nonNegativeBigDecimal",
        description: `a non-negative BigDecimal`,
        ...annotations
      })
    )

/**
@category BigDecimal constructors
@since 3.10.0
/
export const NonNegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(
  nonNegativeBigDecimal({ identifier: "NonNegativeBigDecimalFromSelf" })
)

/**
@category schema id
@since 3.10.0
/
export const NegativeBigDecimalSchemaId: unique symbol = Symbol.for(
  "effect/schema/NegativeBigDecimal"
)

/**
@category BigDecimal filters
@since 3.10.0
/
export const negativeBigDecimal =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => bigDecimal_.isNegative(a), {
        schemaId: NegativeBigDecimalSchemaId,
        title: "negativeBigDecimal",
        description: `a negative BigDecimal`,
        ...annotations
      })
    )

/**
@category BigDecimal constructors
@since 3.10.0
/
export const NegativeBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(
  negativeBigDecimal({ identifier: "NegativeBigDecimalFromSelf" })
)

/**
@category schema id
@since 3.10.0
/
export const NonPositiveBigDecimalSchemaId: unique symbol = Symbol.for(
  "effect/schema/NonPositiveBigDecimal"
)

/**
@category BigDecimal filters
@since 3.10.0
/
export const nonPositiveBigDecimal =
  <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) =>
  <A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> =>
    self.pipe(
      filter((a) => a.value <= 0n, {
        schemaId: NonPositiveBigDecimalSchemaId,
        title: "nonPositiveBigDecimal",
        description: `a non-positive BigDecimal`,
        ...annotations
      })
    )

/**
@category BigDecimal constructors
@since 3.10.0
/
export const NonPositiveBigDecimalFromSelf: filter<Schema<bigDecimal_.BigDecimal>> = BigDecimalFromSelf.pipe(
  nonPositiveBigDecimal({ identifier: "NonPositiveBigDecimalFromSelf" })
)

/**
@category schema id
@since 3.10.0
/
export const BetweenBigDecimalSchemaId: unique symbol = Symbol.for("effect/SchemaId/BetweenBigDecimal")

/**
@category BigDecimal filters
@since 3.10.0
/
export const betweenBigDecimal = <S extends Schema.Any>(
  minimum: bigDecimal_.BigDecimal,
  maximum: bigDecimal_.BigDecimal,
  annotations?: Annotations.Filter<Schema.Type<S>>
) =>
<A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>): filter<S> => {
  const formattedMinimum = bigDecimal_.format(minimum)
  const formattedMaximum = bigDecimal_.format(maximum)
  return self.pipe(
    filter((a) => bigDecimal_.between(a, { minimum, maximum }), {
      schemaId: BetweenBigDecimalSchemaId,
      [BetweenBigDecimalSchemaId]: { maximum, minimum },
      title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
      description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
      ...annotations
    })
  )
}

/**
Clamps a `BigDecimal` between a minimum and a maximum value.

@category BigDecimal transformations
@since 3.10.0
/
export const clampBigDecimal =
  (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) =>
  <S extends Schema.Any, A extends bigDecimal_.BigDecimal>(
    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>
  ): transform<S, filter<SchemaClass<A>>> =>
    transform(
      self,
      self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)),
      {
        strict: false,
        decode: (i) => bigDecimal_.clamp(i, { minimum, maximum }),
        encode: identity
      }
    )

const chunkArbitrary =
  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<chunk_.Chunk<A>> => (fc) => {
    const items = fc.array(item(fc))
    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(chunk_.fromIterable)
  }

const chunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.Chunk<A>> => (c) =>
  `Chunk(${chunk_.toReadonlyArray(c).map(item).join(", ")})`

const chunkParse = <A, R>(
  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>
): ParseResult.DeclarationDecodeUnknown<chunk_.Chunk<A>, R> =>
(u, options, ast) =>
  chunk_.isChunk(u) ?
    chunk_.isEmpty(u) ?
      ParseResult.succeed(chunk_.empty())
      : toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.fromIterable, ast, u)
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface ChunkFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    ChunkFromSelf<Value>,
    chunk_.Chunk<Schema.Type<Value>>,
    chunk_.Chunk<Schema.Encoded<Value>>,
    [Value]
  >
{}

/**
@category Chunk
@since 3.10.0
/
export const ChunkFromSelf = <Value extends Schema.Any>(value: Value): ChunkFromSelf<Value> => {
  return declare(
    [value],
    {
      decode: (item) => chunkParse(ParseResult.decodeUnknown(Array$(item))),
      encode: (item) => chunkParse(ParseResult.encodeUnknown(Array$(item)))
    },
    {
      description: `Chunk<${format(value)}>`,
      pretty: chunkPretty,
      arbitrary: chunkArbitrary,
      equivalence: chunk_.getEquivalence
    }
  )
}

/**
@category api interface
@since 3.10.0
/
export interface Chunk<Value extends Schema.Any>
  extends transform<Array$<Value>, ChunkFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category Chunk transformations
@since 3.10.0

## NonEmptyChunk

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `NonEmptyChunk(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface NonEmptyChunkFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    NonEmptyChunkFromSelf<Value>,
    chunk_.NonEmptyChunk<Schema.Type<Value>>,
    chunk_.NonEmptyChunk<Schema.Encoded<Value>>,
    [Value]
  >
{}

const nonEmptyChunkArbitrary = <A>(item: LazyArbitrary<A>): LazyArbitrary<chunk_.NonEmptyChunk<A>> => (fc) =>
  fastCheck_.array(item(fc), { minLength: 1 }).map((as) => chunk_.unsafeFromNonEmptyArray(as as any))

const nonEmptyChunkPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<chunk_.NonEmptyChunk<A>> => (c) =>
  `NonEmptyChunk(${chunk_.toReadonlyArray(c).map(item).join(", ")})`

const nonEmptyChunkParse = <A, R>(
  decodeUnknown: ParseResult.DecodeUnknown<array_.NonEmptyReadonlyArray<A>, R>
): ParseResult.DeclarationDecodeUnknown<chunk_.NonEmptyChunk<A>, R> =>
(u, options, ast) =>
  chunk_.isChunk(u) && chunk_.isNonEmpty(u)
    ? toComposite(decodeUnknown(chunk_.toReadonlyArray(u), options), chunk_.unsafeFromNonEmptyArray, ast, u)
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category Chunk
@since 3.10.0
/
export const NonEmptyChunkFromSelf = <Value extends Schema.Any>(value: Value): NonEmptyChunkFromSelf<Value> => {
  return declare(
    [value],
    {
      decode: (item) => nonEmptyChunkParse(ParseResult.decodeUnknown(NonEmptyArray(item))),
      encode: (item) => nonEmptyChunkParse(ParseResult.encodeUnknown(NonEmptyArray(item)))
    },
    {
      description: `NonEmptyChunk<${format(value)}>`,
      pretty: nonEmptyChunkPretty,
      arbitrary: nonEmptyChunkArbitrary,
      equivalence: chunk_.getEquivalence
    }
  )
}

/**
@category api interface
@since 3.10.0
/
export interface NonEmptyChunk<Value extends Schema.Any>
  extends transform<NonEmptyArray<Value>, NonEmptyChunkFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category Chunk transformations
@since 3.10.0

## HashSet

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `HashSet(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.13.3
/
export interface DataFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    DataFromSelf<Value>,
    Schema.Type<Value>,
    Schema.Encoded<Value>,
    [Value]
  >
{}

/**
Type and Encoded must extend `Readonly<Record<string, any>> |
ReadonlyArray<any>` to be compatible with this API.

@category Data transformations
@since 3.10.0
/
export const DataFromSelf = <
  S extends Schema.Any,
  A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>,
  I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>
>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>): DataFromSelf<S> => {
  return declare(
    [value],
    {
      decode: (item) => dataParse(ParseResult.decodeUnknown(item)),
      encode: (item) => dataParse(ParseResult.encodeUnknown(item))
    },
    {
      description: `Data<${format(value)}>`,
      pretty: dataPretty,
      arbitrary: dataArbitrary
    }
  )
}

/**
@category api interface
@since 3.13.3
/
export interface Data<Value extends Schema.Any>
  extends transform<Value, DataFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
Type and Encoded must extend `Readonly<Record<string, any>> |
ReadonlyArray<any>` to be compatible with this API.

@category Data transformations
@since 3.10.0
/
export const Data = <
  S extends Schema.Any,
  A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>,
  I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>
>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>): Data<S> => {
  return transform(
    value,
    DataFromSelf(typeSchema(value)),
    {
      strict: false,
      decode: (i) => decodeData(i),
      encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
    }
  )
}

type MissingSelfGeneric<Usage extends string, Params extends string = ""> =
  `Missing \`Self\` generic - use \`class Self extends ${Usage}<Self>()(${Params}{ ... })\``

type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

type ClassAnnotations<Self, A> =
  | Annotations.Schema<Self>
  | readonly [
    Annotations.Schema<Self> | undefined,
    (Annotations.Schema<Self> | undefined)?,
    Annotations.Schema<A>?
  ]

/**
@category api interface
@since 3.10.0
/
export interface Class<Self, Fields extends Struct.Fields, I, R, C, Inherited, Proto>
  extends Schema<Self, Simplify<I>, R>
{
  new(
    props: RequiredKeys<C> extends never ? void | Simplify<C> : Simplify<C>,
    options?: MakeOptions
  ): Struct.Type<Fields> & Inherited & Proto

  /** @since 3.10.0 */
  readonly ast: AST.Transformation

  make<C extends new(...args: Array<any>) => any>(this: C, ...args: ConstructorParameters<C>): InstanceType<C>

  annotations(annotations: Annotations.Schema<Self>): SchemaClass<Self, Simplify<I>, R>

  readonly fields: { readonly [K in keyof Fields]: Fields[K] }

  readonly identifier: string

  /**
@example
```ts
import { Schema } from "effect"

class MyClass extends Schema.Class<MyClass>("MyClass")({
 myField: Schema.String
}) {
 myMethod() {
   return this.myField + "my"
 }
}

class NextClass extends MyClass.extend<NextClass>("NextClass")({
 nextField: Schema.Number
}) {
 nextMethod() {
   return this.myMethod() + this.myField + this.nextField
 }
}
```
/
  extend<Extended = never>(identifier: string): <NewFields extends Struct.Fields>(
    fields: NewFields | HasFields<NewFields>,
    annotations?: ClassAnnotations<Extended, Simplify<Struct.Type<Fields & NewFields>>>
  ) => [Extended] extends [never] ? MissingSelfGeneric<"Base.extend">
    : Class<
      Extended,
      Fields & NewFields,
      I & Struct.Encoded<NewFields>,
      R | Struct.Context<NewFields>,
      C & Struct.Constructor<NewFields>,
      Self,
      Proto
    >

  /**
@example
```ts
import { Effect, Schema } from "effect"

class MyClass extends Schema.Class<MyClass>("MyClass")({
  myField: Schema.String
}) {
  myMethod() {
    return this.myField + "my"
  }
}

class NextClass extends MyClass.transformOrFail<NextClass>("NextClass")({
  nextField: Schema.Number
}, {
  decode: (i) =>
    Effect.succeed({
      myField: i.myField,
      nextField: i.myField.length
    }),
  encode: (a) => Effect.succeed({ myField: a.myField })
}) {
  nextMethod() {
    return this.myMethod() + this.myField + this.nextField
  }
}
```
/
  transformOrFail<Transformed = never>(identifier: string): <
    NewFields extends Struct.Fields,
    R2,
    R3
  >(
    fields: NewFields,
    options: {
      readonly decode: (
        input: Simplify<Struct.Type<Fields>>,
        options: ParseOptions,
        ast: AST.Transformation
      ) => Effect.Effect<Simplify<Struct.Type<Fields & NewFields>>, ParseResult.ParseIssue, R2>
      readonly encode: (
        input: Simplify<Struct.Type<Fields & NewFields>>,
        options: ParseOptions,
        ast: AST.Transformation
      ) => Effect.Effect<Struct.Type<Fields>, ParseResult.ParseIssue, R3>
    },
    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>
  ) => [Transformed] extends [never] ? MissingSelfGeneric<"Base.transformOrFail">
    : Class<
      Transformed,
      Fields & NewFields,
      I,
      R | Struct.Context<NewFields> | R2 | R3,
      C & Struct.Constructor<NewFields>,
      Self,
      Proto
    >

  /**
@example
```ts
import { Effect, Schema } from "effect"

class MyClass extends Schema.Class<MyClass>("MyClass")({
  myField: Schema.String
}) {
  myMethod() {
    return this.myField + "my"
  }
}

class NextClass extends MyClass.transformOrFailFrom<NextClass>("NextClass")({
  nextField: Schema.Number
}, {
  decode: (i) =>
    Effect.succeed({
      myField: i.myField,
      nextField: i.myField.length
    }),
  encode: (a) => Effect.succeed({ myField: a.myField })
}) {
  nextMethod() {
    return this.myMethod() + this.myField + this.nextField
  }
}
```
/
  transformOrFailFrom<Transformed = never>(identifier: string): <
    NewFields extends Struct.Fields,
    R2,
    R3
  >(
    fields: NewFields,
    options: {
      readonly decode: (
        input: Simplify<I>,
        options: ParseOptions,
        ast: AST.Transformation
      ) => Effect.Effect<Simplify<I & Struct.Encoded<NewFields>>, ParseResult.ParseIssue, R2>
      readonly encode: (
        input: Simplify<I & Struct.Encoded<NewFields>>,
        options: ParseOptions,
        ast: AST.Transformation
      ) => Effect.Effect<I, ParseResult.ParseIssue, R3>
    },
    annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>
  ) => [Transformed] extends [never] ? MissingSelfGeneric<"Base.transformOrFailFrom">
    : Class<
      Transformed,
      Fields & NewFields,
      I,
      R | Struct.Context<NewFields> | R2 | R3,
      C & Struct.Constructor<NewFields>,
      Self,
      Proto
    >
}

type HasFields<Fields extends Struct.Fields> = Struct<Fields> | {
  readonly [RefineSchemaId]: HasFields<Fields>
}

const isField = (u: unknown) => isSchema(u) || isPropertySignature(u)

const isFields = <Fields extends Struct.Fields>(fields: object): fields is Fields =>
  util_.ownKeys(fields).every((key) => isField((fields as any)[key]))

const getFields = <Fields extends Struct.Fields>(hasFields: HasFields<Fields>): Fields =>
  "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId])

const getSchemaFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Schema.Any =>
  isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr))

const getFieldsFromFieldsOr = <Fields extends Struct.Fields>(fieldsOr: Fields | HasFields<Fields>): Fields =>
  isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr)

/**
@example
```ts
import { Schema } from "effect"

class MyClass extends Schema.Class<MyClass>("MyClass")({
 someField: Schema.String
}) {
 someMethod() {
   return this.someField + "bar"
 }
}
```

@category classes
@since 3.10.0
/
export const Class = <Self = never>(identifier: string) =>
<Fields extends Struct.Fields>(
  fieldsOr: Fields | HasFields<Fields>,
  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<Fields>>>
): [Self] extends [never] ? MissingSelfGeneric<"Class">
  : Class<
    Self,
    Fields,
    Struct.Encoded<Fields>,
    Struct.Context<Fields>,
    Struct.Constructor<Fields>,
    {},
    {}
  > =>
  makeClass({
    kind: "Class",
    identifier,
    schema: getSchemaFromFieldsOr(fieldsOr),
    fields: getFieldsFromFieldsOr(fieldsOr),
    Base: data_.Class,
    annotations
  })

/** @internal */
export const getClassTag = <Tag extends string>(tag: Tag) =>
  withConstructorDefault(propertySignature(Literal(tag)), () => tag)

/**
@category api interface
@since 3.10.0
/
export interface TaggedClass<Self, Tag extends string, Fields extends Struct.Fields> extends
  Class<
    Self,
    Fields,
    Struct.Encoded<Fields>,
    Struct.Context<Fields>,
    Struct.Constructor<Omit<Fields, "_tag">>,
    {},
    {}
  >
{
  readonly _tag: Tag
}

/**
@example
```ts
import { Schema } from "effect"

class MyClass extends Schema.TaggedClass<MyClass>("MyClass")("MyClass", {
 a: Schema.String
}) {}
```

@category classes
@since 3.10.0
/
export const TaggedClass = <Self = never>(identifier?: string) =>
<Tag extends string, Fields extends Struct.Fields>(
  tag: Tag,
  fieldsOr: Fields | HasFields<Fields>,
  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag> } & Fields>>>
): [Self] extends [never] ? MissingSelfGeneric<"TaggedClass", `"Tag", `>
  : TaggedClass<Self, Tag, { readonly _tag: tag<Tag> } & Fields> =>
{
  const fields = getFieldsFromFieldsOr(fieldsOr)
  const schema = getSchemaFromFieldsOr(fieldsOr)
  const newFields = { _tag: getClassTag(tag) }
  const taggedFields = extendFields(newFields, fields)
  return class TaggedClass extends makeClass({
    kind: "TaggedClass",
    identifier: identifier ?? tag,
    schema: extend(schema, Struct(newFields)),
    fields: taggedFields,
    Base: data_.Class,
    annotations
  }) {
    static _tag = tag
  } as any
}

/**
@category api interface
@since 3.10.0
/
export interface TaggedErrorClass<Self, Tag extends string, Fields extends Struct.Fields> extends
  Class<
    Self,
    Fields,
    Struct.Encoded<Fields>,
    Struct.Context<Fields>,
    Struct.Constructor<Omit<Fields, "_tag">>,
    {},
    cause_.YieldableError
  >
{
  readonly _tag: Tag
}

/**
@example
```ts
import { Schema } from "effect"

class MyError extends Schema.TaggedError<MyError>("MyError")(
  "MyError",
  {
    module: Schema.String,
    method: Schema.String,
    description: Schema.String
  }
) {
  get message(): string {
    return `${this.module}.${this.method}: ${this.description}`
  }
}
```
@category classes
@since 3.10.0
/
export const TaggedError = <Self = never>(identifier?: string) =>
<Tag extends string, Fields extends Struct.Fields>(
  tag: Tag,
  fieldsOr: Fields | HasFields<Fields>,
  annotations?: ClassAnnotations<Self, Simplify<Struct.Type<{ readonly _tag: tag<Tag> } & Fields>>>
): [Self] extends [never] ? MissingSelfGeneric<"TaggedError", `"Tag", `>
  : TaggedErrorClass<
    Self,
    Tag,
    { readonly _tag: tag<Tag> } & Fields
  > =>
{
  class Base extends data_.Error {}
  ;(Base.prototype as any).name = tag
  const fields = getFieldsFromFieldsOr(fieldsOr)
  const schema = getSchemaFromFieldsOr(fieldsOr)
  const newFields = { _tag: getClassTag(tag) }
  const taggedFields = extendFields(newFields, fields)
  const hasMessageField = "message" in taggedFields
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier ?? tag,
    schema: extend(schema, Struct(newFields)),
    fields: taggedFields,
    Base,
    annotations,
    disableToString: true
  }) {
    static _tag = tag
  }

  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${
          util_.ownKeys(fields)
            .map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown((this)[p])}`)
            .join(", ")
        } }`
      },
      enumerable: false, // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    })
  }

  return TaggedErrorClass as any
}

const extendFields = (a: Struct.Fields, b: Struct.Fields): Struct.Fields => {
  const out = { ...a }
  for (const key of util_.ownKeys(b)) {
    if (key in a) {
      throw new Error(errors_.getASTDuplicatePropertySignatureErrorMessage(key))
    }
    out[key] = b[key]
  }
  return out
}

/**
@category Constructor utils
@since 3.13.4
/
export type MakeOptions = boolean | {
  readonly disableValidation?: boolean | undefined
}

function getDisableValidationMakeOption(options: MakeOptions | undefined): boolean {
  return Predicate.isBoolean(options) ? options : options?.disableValidation ?? false
}

const astCache = globalValue("effect/Schema/astCache", () => new WeakMap<any, AST.AST>())

const getClassAnnotations = <Self, A>(
  annotations: ClassAnnotations<Self, A> | undefined
): [Annotations.Schema<Self>?, Annotations.Schema<Self>?, Annotations.Schema<A>?] => {
  if (annotations === undefined) {
    return []
  } else if (Array.isArray(annotations)) {
    return annotations as any
  } else {
    return [annotations] as any
  }
}

const makeClass = <Fields extends Struct.Fields>(
  { Base, annotations, disableToString, fields, identifier, kind, schema }: {
    kind: "Class" | "TaggedClass" | "TaggedError" | "TaggedRequest"
    identifier: string
    schema: Schema.Any
    fields: Fields
    Base: new(...args: ReadonlyArray<any>) => any
    annotations?: ClassAnnotations<any, any> | undefined
    disableToString?: boolean | undefined
  }
): any => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier}`)

  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations)

  const typeSchema_ = typeSchema(schema)

  const declarationSurrogate = typeSchema_.annotations({
    identifier,
    ...typeAnnotations
  })

  const typeSide = typeSchema_.annotations({
    [AST.AutoTitleAnnotationId]: `${identifier} (Type side)`,
    ...typeAnnotations
  })

  const constructorSchema = schema.annotations({
    [AST.AutoTitleAnnotationId]: `${identifier} (Constructor)`,
    ...typeAnnotations
  })

  const encodedSide = schema.annotations({
    [AST.AutoTitleAnnotationId]: `${identifier} (Encoded side)`,
    ...encodedAnnotations
  })

  const transformationSurrogate = schema.annotations({
    [AST.JSONIdentifierAnnotationId]: identifier,
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  })

  const fallbackInstanceOf = (u: unknown) => Predicate.hasProperty(u, classSymbol) && ParseResult.is(typeSide)(u)

  const klass = class extends Base {
    constructor(
      props: { [x: string | symbol]: unknown } = {},
      options: MakeOptions = false
    ) {
      props = { ...props }
      if (kind !== "Class") {
        delete props["_tag"]
      }
      props = lazilyMergeDefaults(fields, props)
      if (!getDisableValidationMakeOption(options)) {
        props = ParseResult.validateSync(constructorSchema)(props)
      }
      super(props, true)
    }

    // ----------------
    // Schema interface
    // ----------------

    static [TypeId] = variance

    static get ast(): AST.AST {
      let out = astCache.get(this)
      if (out) {
        return out
      }

      const declaration: Schema.Any = declare(
        [schema],
        {
          decode: () => (input, _, ast) =>
            input instanceof this || fallbackInstanceOf(input)
              ? ParseResult.succeed(input)
              : ParseResult.fail(new ParseResult.Type(ast, input)),
          encode: () => (input, options) =>
            input instanceof this
              ? ParseResult.succeed(input)
              : ParseResult.map(
                ParseResult.encodeUnknown(typeSide)(input, options),
                (props) => new this(props, true)
              )
        },
        {
          identifier,
          pretty: (pretty) => (self: any) => `${identifier}(${pretty(self)})`,
          // @ts-expect-error
          arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
          equivalence: identity,
          [AST.SurrogateAnnotationId]: declarationSurrogate.ast,
          ...typeAnnotations
        }
      )

      out = transform(
        encodedSide,
        declaration,
        {
          strict: true,
          decode: (i) => new this(i, true),
          encode: identity
        }
      ).annotations({
        [AST.SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast

      astCache.set(this, out)

      return out
    }

    static pipe() {
      return pipeArguments(this, arguments)
    }

    static annotations(annotations: Annotations.Schema<any>) {
      return make(this.ast).annotations(annotations)
    }

    static toString() {
      return `(${String(encodedSide)} <-> ${identifier})`
    }

    // ----------------
    // Class interface
    // ----------------

    static make(...args: Array<any>) {
      return new this(...args)
    }

    static fields = { ...fields }

    static identifier = identifier

    static extend<Extended, NewFields extends Struct.Fields>(identifier: string) {
      return (
        newFieldsOr: NewFields | HasFields<NewFields>,
        annotations?: ClassAnnotations<Extended, Simplify<Struct.Type<Fields & NewFields>>>
      ) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr)
        const newSchema = getSchemaFromFieldsOr(newFieldsOr)
        const extendedFields = extendFields(fields, newFields)
        return makeClass({
          kind,
          identifier,
          schema: extend(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations
        })
      }
    }

    static transformOrFail<Transformed, NewFields extends Struct.Fields>(identifier: string) {
      return (
        newFieldsOr: NewFields,
        options: any,
        annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>
      ) => {
        const transformedFields: Struct.Fields = extendFields(fields, newFieldsOr)
        return makeClass({
          kind,
          identifier,
          schema: transformOrFail(
            schema,
            typeSchema(Struct(transformedFields)),
            options
          ),
          fields: transformedFields,
          Base: this,
          annotations
        })
      }
    }

    static transformOrFailFrom<Transformed, NewFields extends Struct.Fields>(identifier: string) {
      return (
        newFields: NewFields,
        options: any,
        annotations?: ClassAnnotations<Transformed, Simplify<Struct.Type<Fields & NewFields>>>
      ) => {
        const transformedFields: Struct.Fields = extendFields(fields, newFields)
        return makeClass({
          kind,
          identifier,
          schema: transformOrFail(
            encodedSchema(schema),
            Struct(transformedFields),
            options
          ),
          fields: transformedFields,
          Base: this,
          annotations
        })
      }
    }

    // ----------------
    // other
    // ----------------

    get [classSymbol]() {
      return classSymbol
    }
  }
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier}({ ${
          util_.ownKeys(fields).map((p: any) => `${util_.formatPropertyKey(p)}: ${util_.formatUnknown(this[p])}`)
            .join(", ")
        } })`
      },
      configurable: true,
      writable: true
    })
  }
  return klass
}

/**
@category FiberId
@since 3.10.0
/
export type FiberIdEncoded =
  | {
    readonly _tag: "Composite"
    readonly left: FiberIdEncoded
    readonly right: FiberIdEncoded
  }
  | {
    readonly _tag: "None"
  }
  | {
    readonly _tag: "Runtime"
    readonly id: number
    readonly startTimeMillis: number
  }

const FiberIdNoneEncoded = Struct({
  _tag: Literal("None")
}).annotations({ identifier: "FiberIdNoneEncoded" })

const FiberIdRuntimeEncoded = Struct({
  _tag: Literal("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({ identifier: "FiberIdRuntimeEncoded" })

const FiberIdCompositeEncoded = Struct({
  _tag: Literal("Composite"),
  left: suspend(() => FiberIdEncoded),
  right: suspend(() => FiberIdEncoded)
}).annotations({ identifier: "FiberIdCompositeEncoded" })

const FiberIdEncoded: Schema<FiberIdEncoded> = Union(
  FiberIdNoneEncoded,
  FiberIdRuntimeEncoded,
  FiberIdCompositeEncoded
).annotations({ identifier: "FiberIdEncoded" })

const fiberIdArbitrary: LazyArbitrary<fiberId_.FiberId> = (fc) =>
  fc.letrec((tie) => ({
    None: fc.record({ _tag: fc.constant("None" as const) }),
    Runtime: fc.record({ _tag: fc.constant("Runtime" as const), id: fc.integer(), startTimeMillis: fc.integer() }),
    Composite: fc.record({ _tag: fc.constant("Composite" as const), left: tie("FiberId"), right: tie("FiberId") }),
    FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite")) as any as fastCheck_.Arbitrary<fiberId_.FiberId>
  })).FiberId.map(fiberIdDecode)

const fiberIdPretty: pretty_.Pretty<fiberId_.FiberId> = (fiberId) => {
  switch (fiberId._tag) {
    case "None":
      return "FiberId.none"
    case "Runtime":
      return `FiberId.runtime(${fiberId.id}, ${fiberId.startTimeMillis})`
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId.right)}, ${fiberIdPretty(fiberId.left)})`
  }
}

/**
@category FiberId constructors
@since 3.10.0
/
export class FiberIdFromSelf extends declare(
  fiberId_.isFiberId,
  {
    identifier: "FiberIdFromSelf",
    pretty: () => fiberIdPretty,
    arbitrary: () => fiberIdArbitrary
  }
) {}

const fiberIdDecode = (input: FiberIdEncoded): fiberId_.FiberId => {
  switch (input._tag) {
    case "None":
      return fiberId_.none
    case "Runtime":
      return fiberId_.runtime(input.id, input.startTimeMillis)
    case "Composite":
      return fiberId_.composite(fiberIdDecode(input.left), fiberIdDecode(input.right))
  }
}

const fiberIdEncode = (input: fiberId_.FiberId): FiberIdEncoded => {
  switch (input._tag) {
    case "None":
      return { _tag: "None" }
    case "Runtime":
      return { _tag: "Runtime", id: input.id, startTimeMillis: input.startTimeMillis }
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      }
  }
}

/**
@category FiberId transformations
@since 3.10.0
/
export class FiberId extends transform(
  FiberIdEncoded,
  FiberIdFromSelf,
  {
    strict: true,
    decode: (i) => fiberIdDecode(i),
    encode: (a) => fiberIdEncode(a)
  }
).annotations({ identifier: "FiberId" }) {}

/**
@category Cause utils
@since 3.10.0
/
export type CauseEncoded<E, D> =
  | {
    readonly _tag: "Empty"
  }
  | {
    readonly _tag: "Fail"
    readonly error: E
  }
  | {
    readonly _tag: "Die"
    readonly defect: D
  }
  | {
    readonly _tag: "Interrupt"
    readonly fiberId: FiberIdEncoded
  }
  | {
    readonly _tag: "Sequential"
    readonly left: CauseEncoded<E, D>
    readonly right: CauseEncoded<E, D>
  }
  | {
    readonly _tag: "Parallel"
    readonly left: CauseEncoded<E, D>
    readonly right: CauseEncoded<E, D>
  }

const causeDieEncoded = <Defect extends Schema.Any>(defect: Defect) =>
  Struct({
    _tag: Literal("Die"),
    defect
  })

const CauseEmptyEncoded = Struct({
  _tag: Literal("Empty")
})

const causeFailEncoded = <E extends Schema.Any>(error: E) =>
  Struct({
    _tag: Literal("Fail"),
    error
  })

const CauseInterruptEncoded = Struct({
  _tag: Literal("Interrupt"),
  fiberId: FiberIdEncoded
})

let causeEncodedId = 0

const causeEncoded = <E extends Schema.All, D extends Schema.All>(
  error: E,
  defect: D
): SchemaClass<
  CauseEncoded<Schema.Type<E>, Schema.Type<D>>,
  CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,
  Schema.Context<E> | Schema.Context<D>
> => {
  const error_ = asSchema(error)
  const defect_ = asSchema(defect)
  const suspended = suspend((): Schema<
    CauseEncoded<Schema.Type<E>, Schema.Type<D>>,
    CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,
    Schema.Context<E> | Schema.Context<D>
  > => out)
  const out = Union(
    CauseEmptyEncoded,
    causeFailEncoded(error_),
    causeDieEncoded(defect_),
    CauseInterruptEncoded,
    Struct({
      _tag: Literal("Sequential"),
      left: suspended,
      right: suspended
    }),
    Struct({
      _tag: Literal("Parallel"),
      left: suspended,
      right: suspended
    })
  ).annotations({
    title: `CauseEncoded<${format(error)}>`,
    [AST.JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  })
  return out
}

const causeArbitrary = <E>(
  error: LazyArbitrary<E>,
  defect: LazyArbitrary<unknown>
): LazyArbitrary<cause_.Cause<E>> =>
(fc) =>
  fc.letrec((tie) => ({
    Empty: fc.record({ _tag: fc.constant("Empty" as const) }),
    Fail: fc.record({ _tag: fc.constant("Fail" as const), error: error(fc) }),
    Die: fc.record({ _tag: fc.constant("Die" as const), defect: defect(fc) }),
    Interrupt: fc.record({ _tag: fc.constant("Interrupt" as const), fiberId: fiberIdArbitrary(fc) }),
    Sequential: fc.record({ _tag: fc.constant("Sequential" as const), left: tie("Cause"), right: tie("Cause") }),
    Parallel: fc.record({ _tag: fc.constant("Parallel" as const), left: tie("Cause"), right: tie("Cause") }),
    Cause: fc.oneof(
      tie("Empty"),
      tie("Fail"),
      tie("Die"),
      tie("Interrupt"),
      tie("Sequential"),
      tie("Parallel")
    ) as any as fastCheck_.Arbitrary<cause_.Cause<E>>
  })).Cause.map(causeDecode)

const causePretty = <E>(error: pretty_.Pretty<E>): pretty_.Pretty<cause_.Cause<E>> => (cause) => {
  const f = (cause: cause_.Cause<E>): string => {
    switch (cause._tag) {
      case "Empty":
        return "Cause.empty"
      case "Fail":
        return `Cause.fail(${error(cause.error)})`
      case "Die":
        return `Cause.die(${cause_.pretty(cause)})`
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause.fiberId)})`
      case "Sequential":
        return `Cause.sequential(${f(cause.left)}, ${f(cause.right)})`
      case "Parallel":
        return `Cause.parallel(${f(cause.left)}, ${f(cause.right)})`
    }
  }
  return f(cause)
}

const causeParse = <A, D, R>(
  decodeUnknown: ParseResult.DecodeUnknown<CauseEncoded<A, D>, R>
): ParseResult.DeclarationDecodeUnknown<cause_.Cause<A>, R> =>
(u, options, ast) =>
  cause_.isCause(u) ?
    toComposite(decodeUnknown(causeEncode(u), options), causeDecode, ast, u)
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface CauseFromSelf<E extends Schema.All, D extends Schema.All> extends
  AnnotableDeclare<
    CauseFromSelf<E, D>,
    cause_.Cause<Schema.Type<E>>,
    cause_.Cause<Schema.Encoded<E>>,
    [E, D]
  >
{}

/**
@category Cause transformations
@since 3.10.0
/
export const CauseFromSelf = <E extends Schema.All, D extends Schema.All>({ defect, error }: {
  readonly error: E
  readonly defect: D
}): CauseFromSelf<E, D> => {
  return declare(
    [error, defect],
    {
      decode: (error, defect) => causeParse(ParseResult.decodeUnknown(causeEncoded(error, defect))),
      encode: (error, defect) => causeParse(ParseResult.encodeUnknown(causeEncoded(error, defect)))
    },
    {
      title: `Cause<${error.ast}>`,
      pretty: causePretty,
      arbitrary: causeArbitrary
    }
  )
}

function causeDecode<E>(cause: CauseEncoded<E, unknown>): cause_.Cause<E> {
  switch (cause._tag) {
    case "Empty":
      return cause_.empty
    case "Fail":
      return cause_.fail(cause.error)
    case "Die":
      return cause_.die(cause.defect)
    case "Interrupt":
      return cause_.interrupt(fiberIdDecode(cause.fiberId))
    case "Sequential":
      return cause_.sequential(causeDecode(cause.left), causeDecode(cause.right))
    case "Parallel":
      return cause_.parallel(causeDecode(cause.left), causeDecode(cause.right))
  }
}

function causeEncode<E>(cause: cause_.Cause<E>): CauseEncoded<E, unknown> {
  switch (cause._tag) {
    case "Empty":
      return { _tag: "Empty" }
    case "Fail":
      return { _tag: "Fail", error: cause.error }
    case "Die":
      return { _tag: "Die", defect: cause.defect }
    case "Interrupt":
      return { _tag: "Interrupt", fiberId: cause.fiberId }
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      }
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause.left),
        right: causeEncode(cause.right)
      }
  }
}

/**
@category api interface
@since 3.10.0
/
export interface Cause<E extends Schema.All, D extends Schema.All> extends
  transform<
    SchemaClass<
      CauseEncoded<Schema.Type<E>, Schema.Type<Defect>>,
      CauseEncoded<Schema.Encoded<E>, Schema.Encoded<Defect>>,
      Schema.Context<E> | Schema.Context<D>
    >,
    CauseFromSelf<SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>
  >
{}

/**
@category Cause transformations
@since 3.10.0
/
export const Cause = <E extends Schema.All, D extends Schema.All>({ defect, error }: {
  readonly error: E
  readonly defect: D
}): Cause<E, D> => {
  const error_ = asSchema(error)
  const defect_ = asSchema(defect)
  const out = transform(
    causeEncoded(error_, defect_),
    CauseFromSelf({ error: typeSchema(error_), defect: typeSchema(defect_) }),
    {
      strict: false,
      decode: (i) => causeDecode(i),
      encode: (a) => causeEncode(a)
    }
  )
  return out as any
}

/**
Defines a schema for handling JavaScript errors (`Error` instances) and other types of defects.
It decodes objects into Error instances if they match the expected structure (i.e., have a `message` and optionally a `name` and `stack`),
or converts other values to their string representations.

When encoding, it converts `Error` instances back into plain objects containing only the error's name and message,
or other values into their string forms.

This is useful for serializing and deserializing errors across network boundaries where error objects do not natively serialize.

@category defect
@since 3.10.0
/
export class Defect extends transform(
  Unknown,
  Unknown,
  {
    strict: true,
    decode: (i) => {
      if (Predicate.isObject(i) && "message" in i && typeof i.message === "string") {
        const err = new Error(i.message, { cause: i })
        if ("name" in i && typeof i.name === "string") {
          err.name = i.name
        }
        err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : ""
        return err
      }
      return String(i)
    },
    encode: (a) => {
      if (a instanceof Error) {
        return {
          name: a.name,
          message: a.message
          // no stack because of security reasons
        }
      }
      return internalCause_.prettyErrorMessage(a)
    }
  }
).annotations({ identifier: "Defect" }) {}

/**
@category Exit utils
@since 3.10.0
/
export type ExitEncoded<A, E, D> =
  | {
    readonly _tag: "Failure"
    readonly cause: CauseEncoded<E, D>
  }
  | {
    readonly _tag: "Success"
    readonly value: A
  }

const exitFailureEncoded = <E extends Schema.All, D extends Schema.All>(
  error: E,
  defect: D
) =>
  Struct({
    _tag: Literal("Failure"),
    cause: causeEncoded(error, defect)
  })

const exitSuccessEncoded = <A extends Schema.All>(
  value: A
) =>
  Struct({
    _tag: Literal("Success"),
    value
  })

const exitEncoded = <A extends Schema.All, E extends Schema.All, D extends Schema.Any>(
  value: A,
  error: E,
  defect: D
) => {
  return Union(
    exitFailureEncoded(error, defect),
    exitSuccessEncoded(value)
  ).annotations({
    title: `ExitEncoded<${format(value)}, ${format(error)}, ${format(defect)}>`
  })
}

const exitDecode = <A, E>(input: ExitEncoded<A, E, unknown>): exit_.Exit<A, E> => {
  switch (input._tag) {
    case "Failure":
      return exit_.failCause(causeDecode(input.cause))
    case "Success":
      return exit_.succeed(input.value)
  }
}

const exitArbitrary = <A, E>(
  value: LazyArbitrary<A>,
  error: LazyArbitrary<E>,
  defect: LazyArbitrary<unknown>
): LazyArbitrary<exit_.Exit<A, E>> =>
(fc) =>
  fc.oneof(
    fc.record({ _tag: fc.constant("Failure" as const), cause: causeArbitrary(error, defect)(fc) }),
    fc.record({ _tag: fc.constant("Success" as const), value: value(fc) })
  ).map(exitDecode)

const exitPretty =
  <A, E>(value: pretty_.Pretty<A>, error: pretty_.Pretty<E>): pretty_.Pretty<exit_.Exit<A, E>> => (exit) =>
    exit._tag === "Failure"
      ? `Exit.failCause(${causePretty(error)(exit.cause)})`
      : `Exit.succeed(${value(exit.value)})`

const exitParse = <A, R, E, ER>(
  decodeUnknownValue: ParseResult.DecodeUnknown<A, R>,
  decodeUnknownCause: ParseResult.DecodeUnknown<cause_.Cause<E>, ER>
): ParseResult.DeclarationDecodeUnknown<exit_.Exit<A, E>, ER | R> =>
(u, options, ast) =>
  exit_.isExit(u) ?
    exit_.match(u, {
      onFailure: (cause) => toComposite(decodeUnknownCause(cause, options), exit_.failCause, ast, u),
      onSuccess: (value) => toComposite(decodeUnknownValue(value, options), exit_.succeed, ast, u)
    })
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface ExitFromSelf<A extends Schema.All, E extends Schema.All, D extends Schema.All>
  extends
    AnnotableDeclare<
      ExitFromSelf<A, E, D>,
      exit_.Exit<Schema.Type<A>, Schema.Type<E>>,
      exit_.Exit<Schema.Encoded<A>, Schema.Encoded<E>>,
      [A, E, D]
    >
{}

/**
@category Exit transformations
@since 3.10.0
/
export const ExitFromSelf = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(
  { defect, failure, success }: {
    readonly failure: E
    readonly success: A
    readonly defect: D
  }
): ExitFromSelf<A, E, D> =>
  declare(
    [success, failure, defect],
    {
      decode: (success, failure, defect) =>
        exitParse(
          ParseResult.decodeUnknown(success),
          ParseResult.decodeUnknown(CauseFromSelf({ error: failure, defect }))
        ),
      encode: (success, failure, defect) =>
        exitParse(
          ParseResult.encodeUnknown(success),
          ParseResult.encodeUnknown(CauseFromSelf({ error: failure, defect }))
        )
    },
    {
      title: `Exit<${success.ast}, ${failure.ast}>`,
      pretty: exitPretty,
      arbitrary: exitArbitrary
    }
  )

/**
@category api interface
@since 3.10.0
/
export interface Exit<A extends Schema.All, E extends Schema.All, D extends Schema.All> extends
  transform<
    Union<[
      Struct<{
        _tag: Literal<["Failure"]>
        cause: SchemaClass<
          CauseEncoded<Schema.Type<E>, Schema.Type<D>>,
          CauseEncoded<Schema.Encoded<E>, Schema.Encoded<D>>,
          Schema.Context<E> | Schema.Context<D>
        >
      }>,
      Struct<{
        _tag: Literal<["Success"]>
        value: A
      }>
    ]>,
    ExitFromSelf<SchemaClass<Schema.Type<A>>, SchemaClass<Schema.Type<E>>, SchemaClass<Schema.Type<D>>>
  >
{}

/**
@category Exit transformations
@since 3.10.0
/
export const Exit = <A extends Schema.All, E extends Schema.All, D extends Schema.All>(
  { defect, failure, success }: {
    readonly failure: E
    readonly success: A
    readonly defect: D
  }
): Exit<A, E, D> => {
  const success_ = asSchema(success)
  const failure_ = asSchema(failure)
  const defect_ = asSchema(defect)
  const out = transform(
    exitEncoded(success_, failure_, defect_),
    ExitFromSelf({ failure: typeSchema(failure_), success: typeSchema(success_), defect: typeSchema(defect_) }),
    {
      strict: false,
      decode: (i) => exitDecode(i),
      encode: (a) =>
        a._tag === "Failure"
          ? { _tag: "Failure", cause: a.cause } as const
          : { _tag: "Success", value: a.value } as const
    }
  )
  return out as any
}

const hashSetArbitrary =
  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<hashSet_.HashSet<A>> => (fc) => {
    const items = fc.array(item(fc))
    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(
      hashSet_.fromIterable
    )
  }

const hashSetPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<hashSet_.HashSet<A>> => (set) =>
  `HashSet(${Array.from(set).map((a) => item(a)).join(", ")})`

const hashSetEquivalence = <A>(
  item: Equivalence.Equivalence<A>
): Equivalence.Equivalence<hashSet_.HashSet<A>> => {
  const arrayEquivalence = array_.getEquivalence(item)
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))
}

const hashSetParse = <A, R>(
  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>
): ParseResult.DeclarationDecodeUnknown<hashSet_.HashSet<A>, R> =>
(u, options, ast) =>
  hashSet_.isHashSet(u) ?
    toComposite(decodeUnknown(Array.from(u), options), hashSet_.fromIterable, ast, u)
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface HashSetFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    HashSetFromSelf<Value>,
    hashSet_.HashSet<Schema.Type<Value>>,
    hashSet_.HashSet<Schema.Encoded<Value>>,
    [Value]
  >
{}

/**
@category HashSet transformations
@since 3.10.0
/
export const HashSetFromSelf = <Value extends Schema.Any>(
  value: Value
): HashSetFromSelf<Value> => {
  return declare(
    [value],
    {
      decode: (item) => hashSetParse(ParseResult.decodeUnknown(Array$(item))),
      encode: (item) => hashSetParse(ParseResult.encodeUnknown(Array$(item)))
    },
    {
      description: `HashSet<${format(value)}>`,
      pretty: hashSetPretty,
      arbitrary: hashSetArbitrary,
      equivalence: hashSetEquivalence
    }
  )
}

/**
@category api interface
@since 3.10.0
/
export interface HashSet<Value extends Schema.Any>
  extends transform<Array$<Value>, HashSetFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category HashSet transformations
@since 3.10.0

## List

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `List(<Value extends Schema.Any>(value: Value)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface HashMapFromSelf<K extends Schema.Any, V extends Schema.Any> extends
  AnnotableDeclare<
    HashMapFromSelf<K, V>,
    hashMap_.HashMap<Schema.Type<K>, Schema.Type<V>>,
    hashMap_.HashMap<Schema.Encoded<K>, Schema.Encoded<V>>,
    [K, V]
  >
{}

/**
@category HashMap transformations
@since 3.10.0
/
export const HashMapFromSelf = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
  readonly key: K
  readonly value: V
}): HashMapFromSelf<K, V> => {
  return declare(
    [key, value],
    {
      decode: (key, value) => hashMapParse(ParseResult.decodeUnknown(Array$(Tuple(key, value)))),
      encode: (key, value) => hashMapParse(ParseResult.encodeUnknown(Array$(Tuple(key, value))))
    },
    {
      description: `HashMap<${format(key)}, ${format(value)}>`,
      pretty: hashMapPretty,
      arbitrary: hashMapArbitrary,
      equivalence: hashMapEquivalence
    }
  )
}

/**
@category api interface
@since 3.10.0
/
export interface HashMap<K extends Schema.Any, V extends Schema.Any>
  extends transform<Array$<Tuple2<K, V>>, HashMapFromSelf<SchemaClass<Schema.Type<K>>, SchemaClass<Schema.Type<V>>>>
{}

/**
@category HashMap transformations
@since 3.10.0
/
export const HashMap = <K extends Schema.Any, V extends Schema.Any>({ key, value }: {
  readonly key: K
  readonly value: V
}): HashMap<K, V> => {
  return transform(
    Array$(Tuple(key, value)),
    HashMapFromSelf({ key: typeSchema(asSchema(key)), value: typeSchema(asSchema(value)) }),
    {
      strict: true,
      decode: (i) => hashMap_.fromIterable(i),
      encode: (a) => Array.from(a)
    }
  )
}

const listArbitrary =
  <A>(item: LazyArbitrary<A>, ctx: ArbitraryGenerationContext): LazyArbitrary<list_.List<A>> => (fc) => {
    const items = fc.array(item(fc))
    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(list_.fromIterable)
  }

const listPretty = <A>(item: pretty_.Pretty<A>): pretty_.Pretty<list_.List<A>> => (set) =>
  `List(${Array.from(set).map((a) => item(a)).join(", ")})`

const listEquivalence = <A>(
  item: Equivalence.Equivalence<A>
): Equivalence.Equivalence<list_.List<A>> => {
  const arrayEquivalence = array_.getEquivalence(item)
  return Equivalence.make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)))
}

const listParse = <A, R>(
  decodeUnknown: ParseResult.DecodeUnknown<ReadonlyArray<A>, R>
): ParseResult.DeclarationDecodeUnknown<list_.List<A>, R> =>
(u, options, ast) =>
  list_.isList(u) ?
    toComposite(decodeUnknown(Array.from(u), options), list_.fromIterable, ast, u)
    : ParseResult.fail(new ParseResult.Type(ast, u))

/**
@category api interface
@since 3.10.0
/
export interface ListFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    ListFromSelf<Value>,
    list_.List<Schema.Type<Value>>,
    list_.List<Schema.Encoded<Value>>,
    [Value]
  >
{}

/**
@category List transformations
@since 3.10.0
/
export const ListFromSelf = <Value extends Schema.Any>(
  value: Value
): ListFromSelf<Value> => {
  return declare(
    [value],
    {
      decode: (item) => listParse(ParseResult.decodeUnknown(Array$(item))),
      encode: (item) => listParse(ParseResult.encodeUnknown(Array$(item)))
    },
    {
      description: `List<${format(value)}>`,
      pretty: listPretty,
      arbitrary: listArbitrary,
      equivalence: listEquivalence
    }
  )
}

/**
@category api interface
@since 3.10.0
/
export interface List<Value extends Schema.Any>
  extends transform<Array$<Value>, ListFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category List transformations
@since 3.10.0

## SortedSet

Source: `my-backend/node_modules/effect/src/Schema.ts`

Signature: `SortedSet(<Value extends Schema.Any>(
  value: Value,
  ordA: Order.Order<Schema.Type<Value>>
)`

JSDoc:

@category api interface
@since 3.10.0
/
export interface SortedSetFromSelf<Value extends Schema.Any> extends
  AnnotableDeclare<
    SortedSetFromSelf<Value>,
    sortedSet_.SortedSet<Schema.Type<Value>>,
    sortedSet_.SortedSet<Schema.Encoded<Value>>,
    [Value]
  >
{}

/**
@category SortedSet transformations
@since 3.10.0
/
export const SortedSetFromSelf = <Value extends Schema.Any>(
  value: Value,
  ordA: Order.Order<Schema.Type<Value>>,
  ordI: Order.Order<Schema.Encoded<Value>>
): SortedSetFromSelf<Value> => {
  return declare(
    [value],
    {
      decode: (item) => sortedSetParse(ParseResult.decodeUnknown(Array$(item)), ordA),
      encode: (item) => sortedSetParse(ParseResult.encodeUnknown(Array$(item)), ordI)
    },
    {
      description: `SortedSet<${format(value)}>`,
      pretty: sortedSetPretty,
      arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
      equivalence: () => sortedSet_.getEquivalence<Schema.Type<Value>>()
    }
  )
}

/**
@category api interface
@since 3.10.0
/
export interface SortedSet<Value extends Schema.Any>
  extends transform<Array$<Value>, SortedSetFromSelf<SchemaClass<Schema.Type<Value>>>>
{}

/**
@category SortedSet transformations
@since 3.10.0

## yieldWrapGet

Source: `my-backend/node_modules/effect/src/Utils.ts`

Signature: `yieldWrapGet(<T>(self: YieldWrap<T>)`

JSDoc:

@since 2.0.0
/
import { identity } from "./Function.js"
import { globalValue } from "./GlobalValue.js"
import type { Kind, TypeLambda } from "./HKT.js"
import { getBugErrorMessage } from "./internal/errors.js"
import { isNullable, isObject } from "./Predicate.js"
import type * as Types from "./Types.js"

/*
Copyright 2014 Thom Chiovoloni, released under the MIT license.

A random number generator based on the basic implementation of the PCG algorithm,
as described here: http://www.pcg-random.org/

Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random

forked from https://github.com/frptools

@since 2.0.0
/

/**
@category symbols
@since 2.0.0
/
export const GenKindTypeId: unique symbol = Symbol.for("effect/Gen/GenKind")

/**
@category symbols
@since 2.0.0
/
export type GenKindTypeId = typeof GenKindTypeId

/**
@category models
@since 2.0.0
/
export interface GenKind<F extends TypeLambda, R, O, E, A> extends Variance<F, R, O, E> {
  readonly value: Kind<F, R, O, E, A>

  [Symbol.iterator](): IterableIterator<GenKind<F, R, O, E, A>, A>
}

/**
@category predicates
@since 3.0.6
/
export const isGenKind = (u: unknown): u is GenKind<any, any, any, any, any> => isObject(u) && GenKindTypeId in u

/**
@category constructors
@since 2.0.0
/
export class GenKindImpl<F extends TypeLambda, R, O, E, A> implements GenKind<F, R, O, E, A> {
  constructor(
    /**
@since 2.0.0
/
    readonly value: Kind<F, R, O, E, A>
  ) {}

  /**
@since 2.0.0
/
  get _F() {
    return identity
  }

  /**
@since 2.0.0
/
  get _R() {
    return (_: R) => _
  }

  /**
@since 2.0.0
/
  get _O() {
    return (_: never): O => _
  }

  /**
@since 2.0.0
/
  get _E() {
    return (_: never): E => _
  }

  /**
@since 2.0.0
/
  readonly [GenKindTypeId]: typeof GenKindTypeId = GenKindTypeId;

  /**
@since 2.0.0
/
  [Symbol.iterator](): IterableIterator<GenKind<F, R, O, E, A>, A> {
    return new SingleShotGen<GenKind<F, R, O, E, A>, A>(this as any)
  }
}

/**
@category constructors
@since 2.0.0
/
export class SingleShotGen<T, A> implements IterableIterator<T, A> {
  private called = false

  constructor(readonly self: T) {}

  /**
@since 2.0.0
/
  next(a: A): IteratorResult<T, A> {
    return this.called ?
      ({
        value: a,
        done: true
      }) :
      (this.called = true,
        ({
          value: this.self,
          done: false
        }))
  }

  /**
@since 2.0.0
/
  return(a: A): IteratorResult<T, A> {
    return ({
      value: a,
      done: true
    })
  }

  /**
@since 2.0.0
/
  throw(e: unknown): IteratorResult<T, A> {
    throw e
  }

  /**
@since 2.0.0
/
  [Symbol.iterator](): IterableIterator<T, A> {
    return new SingleShotGen<T, A>(this.self)
  }
}

/**
@category constructors
@since 2.0.0
/
export const makeGenKind = <F extends TypeLambda, R, O, E, A>(
  kind: Kind<F, R, O, E, A>
): GenKind<F, R, O, E, A> => new GenKindImpl(kind)

/**
@category models
@since 2.0.0
/
export interface Variance<in out F extends TypeLambda, in R, out O, out E> {
  readonly [GenKindTypeId]: GenKindTypeId
  readonly _F: Types.Invariant<F>
  readonly _R: Types.Contravariant<R>
  readonly _O: Types.Covariant<O>
  readonly _E: Types.Covariant<E>
}

/**
@category models
@since 2.0.0
/
export interface Gen<F extends TypeLambda, Z> {
  <Self, K extends Variance<F, any, any, any> | YieldWrap<Kind<F, any, any, any, any>>, A>(
    ...args:
      | [
        self: Self,
        body: (this: Self, resume: Z) => Generator<K, A, never>
      ]
      | [
        body: (resume: Z) => Generator<K, A, never>
      ]
  ): Kind<
    F,
    [K] extends [Variance<F, infer R, any, any>] ? R
      : [K] extends [YieldWrap<Kind<F, infer R, any, any, any>>] ? R
      : never,
    [K] extends [Variance<F, any, infer O, any>] ? O
      : [K] extends [YieldWrap<Kind<F, any, infer O, any, any>>] ? O
      : never,
    [K] extends [Variance<F, any, any, infer E>] ? E
      : [K] extends [YieldWrap<Kind<F, any, any, infer E, any>>] ? E
      : never,
    A
  >
}

/**
@category models
@since 2.0.0
/
export interface Adapter<Z extends TypeLambda> {
  <_R, _O, _E, _A>(
    self: Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, _R, _O, _E, _A>(a: A, ab: (a: A) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>
  <A, B, _R, _O, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => Kind<Z, _R, _O, _E, _A>): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: F) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (g: H) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, M, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => M,
    mn: (m: M) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => M,
    mn: (m: M) => N,
    no: (n: N) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => M,
    mn: (m: M) => N,
    no: (n: N) => O,
    op: (o: O) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => M,
    mn: (m: M) => N,
    no: (n: N) => O,
    op: (o: O) => P,
    pq: (p: P) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => M,
    mn: (m: M) => N,
    no: (n: N) => O,
    op: (o: O) => P,
    pq: (p: P) => Q,
    qr: (q: Q) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => M,
    mn: (m: M) => N,
    no: (n: N) => O,
    op: (o: O) => P,
    pq: (p: P) => Q,
    qr: (q: Q) => R,
    rs: (r: R) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => M,
    mn: (m: M) => N,
    no: (n: N) => O,
    op: (o: O) => P,
    pq: (p: P) => Q,
    qr: (q: Q) => R,
    rs: (r: R) => S,
    st: (s: S) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _R, _O, _E, _A>(
    a: A,
    ab: (a: A) => B,
    bc: (b: B) => C,
    cd: (c: C) => D,
    de: (d: D) => E,
    ef: (e: E) => F,
    fg: (f: F) => G,
    gh: (g: G) => H,
    hi: (h: H) => I,
    ij: (i: I) => J,
    jk: (j: J) => K,
    kl: (k: K) => L,
    lm: (l: L) => M,
    mn: (m: M) => N,
    no: (n: N) => O,
    op: (o: O) => P,
    pq: (p: P) => Q,
    qr: (q: Q) => R,
    rs: (r: R) => S,
    st: (s: S) => T,
    tu: (s: T) => Kind<Z, _R, _O, _E, _A>
  ): GenKind<Z, _R, _O, _E, _A>
}

/**
@category adapters
@since 2.0.0
/
export const adapter: <F extends TypeLambda>() => Adapter<F> = () => (function() {
  let x = arguments[0]
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x)
  }
  return new GenKindImpl(x) as any
})

const defaultIncHi = 0x14057b7e
const defaultIncLo = 0xf767814f
const MUL_HI = 0x5851f42d >>> 0
const MUL_LO = 0x4c957f2d >>> 0
const BIT_53 = 9007199254740992.0
const BIT_27 = 134217728.0

/**
@category model
@since 2.0.0
/
export type PCGRandomState = [number, number, number, number]

/**
@category model
@since 2.0.0
/
export type OptionalNumber = number | null | undefined

/**
PCG is a family of simple fast space-efficient statistically good algorithms
for random number generation. Unlike many general-purpose RNGs, they are also
hard to predict.

@category model
@since 2.0.0
/
export class PCGRandom {
  private _state!: Int32Array

  /**
Creates an instance of PCGRandom.

- `seed` - The low 32 bits of the seed (0 is used for high 32 bits).

@memberOf PCGRandom
/
  constructor(seed?: OptionalNumber)
  /**
Creates an instance of PCGRandom.

- `seedHi` - The high 32 bits of the seed.
- `seedLo` - The low 32 bits of the seed.
- `inc` - The low 32 bits of the incrementer (0 is used for high 32 bits).

@memberOf PCGRandom
/
  constructor(seedHi: OptionalNumber, seedLo: OptionalNumber, inc?: OptionalNumber)
  /**
Creates an instance of PCGRandom.

- `seedHi` - The high 32 bits of the seed.
- `seedLo` - The low 32 bits of the seed.
- `incHi` - The high 32 bits of the incrementer.
- `incLo` - The low 32 bits of the incrementer.

@memberOf PCGRandom
/
  constructor(
    seedHi: OptionalNumber,
    seedLo: OptionalNumber,
    incHi: OptionalNumber,
    incLo: OptionalNumber
  )
  constructor(
    seedHi?: OptionalNumber,
    seedLo?: OptionalNumber,
    incHi?: OptionalNumber,
    incLo?: OptionalNumber
  ) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = (Math.random() * 0xffffffff) >>> 0
      seedHi = 0
    } else if (isNullable(seedLo)) {
      seedLo = seedHi
      seedHi = 0
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo
      incHi = this._state ? this._state[2] : defaultIncHi
    } else if (isNullable(incLo)) {
      incLo = <number> incHi
      incHi = 0
    }

    this._state = new Int32Array([0, 0, (<number> incHi) >>> 0, ((incLo || 0) | 1) >>> 0])
    this._next()
    add64(
      this._state,
      this._state[0]!,
      this._state[1]!,
      (<number> seedHi) >>> 0,
      (<number> seedLo) >>> 0
    )
    this._next()
    return this
  }

  /**
Returns a copy of the internal state of this random number generator as a
JavaScript Array.

@category getters
@since 2.0.0
/
  getState(): PCGRandomState {
    return [this._state[0]!, this._state[1]!, this._state[2]!, this._state[3]!]
  }

  /**
Restore state previously retrieved using `getState()`.

@since 2.0.0
/
  setState(state: PCGRandomState) {
    this._state[0] = state[0]
    this._state[1] = state[1]
    this._state[2] = state[2]
    this._state[3] = state[3] | 1
  }

  /**
Get a uniformly distributed 32 bit integer between [0, max).

@category getter
@since 2.0.0
/
  integer(max: number) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max
  }

  /**
Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
53 bits of precision (every bit of the mantissa is randomized).

@category getters
@since 2.0.0
/
  number() {
    const hi = (this._next() & 0x03ffffff) * 1.0
    const lo = (this._next() & 0x07ffffff) * 1.0
    return (hi * BIT_27 + lo) / BIT_53
  }

  /** @internal */
  private _next() {
    // save current state (what we'll use for this number)
    const oldHi = this._state[0]! >>> 0
    const oldLo = this._state[1]! >>> 0

    // churn LCG.
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO)
    add64(this._state, this._state[0]!, this._state[1]!, this._state[2]!, this._state[3]!)

    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27
    let xsHi = oldHi >>> 18
    let xsLo = ((oldLo >>> 18) | (oldHi << 14)) >>> 0
    xsHi = (xsHi ^ oldHi) >>> 0
    xsLo = (xsLo ^ oldLo) >>> 0
    const xorshifted = ((xsLo >>> 27) | (xsHi << 5)) >>> 0
    // rotate xorshifted right a random amount, based on the most sig. 5 bits
    // bits of the old state.
    const rot = oldHi >>> 27
    const rot2 = ((-rot >>> 0) & 31) >>> 0
    return ((xorshifted >>> rot) | (xorshifted << rot2)) >>> 0
  }
}

function mul64(
  out: Int32Array,
  aHi: number,
  aLo: number,
  bHi: number,
  bLo: number
): void {
  let c1 = ((aLo >>> 16) * (bLo & 0xffff)) >>> 0
  let c0 = ((aLo & 0xffff) * (bLo >>> 16)) >>> 0

  let lo = ((aLo & 0xffff) * (bLo & 0xffff)) >>> 0
  let hi = ((aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16))) >>> 0

  c0 = (c0 << 16) >>> 0
  lo = (lo + c0) >>> 0
  if ((lo >>> 0) < (c0 >>> 0)) {
    hi = (hi + 1) >>> 0
  }

  c1 = (c1 << 16) >>> 0
  lo = (lo + c1) >>> 0
  if ((lo >>> 0) < (c1 >>> 0)) {
    hi = (hi + 1) >>> 0
  }

  hi = (hi + Math.imul(aLo, bHi)) >>> 0
  hi = (hi + Math.imul(aHi, bLo)) >>> 0

  out[0] = hi
  out[1] = lo
}

// add two 64 bit numbers (given in parts), and store the result in `out`.
function add64(
  out: Int32Array,
  aHi: number,
  aLo: number,
  bHi: number,
  bLo: number
): void {
  let hi = (aHi + bHi) >>> 0
  const lo = (aLo + bLo) >>> 0
  if ((lo >>> 0) < (aLo >>> 0)) {
    hi = (hi + 1) | 0
  }
  out[0] = hi
  out[1] = lo
}

/**
@since 3.0.6
/
export const YieldWrapTypeId: unique symbol = Symbol.for("effect/Utils/YieldWrap")

/**
@since 3.0.6
/
export class YieldWrap<T> {
  /**
@since 3.0.6
/
  readonly #value: T
  constructor(value: T) {
    this.#value = value
  }
  /**
@since 3.0.6
/
  [YieldWrapTypeId](): T {
    return this.#value
  }
}

/**
@since 3.0.6

## unsafeMake

Source: `my-backend/node_modules/effect/src/internal/fiberRefs.ts`

Signature: `unsafeMake(
  fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>
)`

JSDoc:

@internal

## empty

Source: `my-backend/node_modules/effect/src/internal/fiberRefs.ts`

Signature: `empty()`

JSDoc:

@internal

## arrayUpdate

Source: `my-backend/node_modules/effect/src/internal/hashMap/array.ts`

Signature: `arrayUpdate(<A>(mutate: boolean, at: number, v: A, arr: Array<A>)`

JSDoc:

@internal

## arraySpliceOut

Source: `my-backend/node_modules/effect/src/internal/hashMap/array.ts`

Signature: `arraySpliceOut(<A>(mutate: boolean, at: number, arr: Array<A>)`

JSDoc:

@internal

## arraySpliceIn

Source: `my-backend/node_modules/effect/src/internal/hashMap/array.ts`

Signature: `arraySpliceIn(<A>(mutate: boolean, at: number, v: A, arr: Array<A>)`

JSDoc:

@internal

## popcount

Source: `my-backend/node_modules/effect/src/internal/hashMap/bitwise.ts`

Signature: `popcount(x: number)`

JSDoc:

Hamming weight.

Taken from: http://jsperf.com/hamming-weight

@internal

## hashFragment

Source: `my-backend/node_modules/effect/src/internal/hashMap/bitwise.ts`

Signature: `hashFragment(shift: number, h: number)`

JSDoc:

@internal

## toBitmap

Source: `my-backend/node_modules/effect/src/internal/hashMap/bitwise.ts`

Signature: `toBitmap(x: number)`

JSDoc:

@internal

## fromBitmap

Source: `my-backend/node_modules/effect/src/internal/hashMap/bitwise.ts`

Signature: `fromBitmap(bitmap: number, bit: number)`

JSDoc:

@internal

## keySet

Source: `my-backend/node_modules/effect/src/internal/hashMap/keySet.ts`

Signature: `keySet(<K, V>(self: HashMap<K, V>)`

JSDoc:

@internal

## isEmptyNode

Source: `my-backend/node_modules/effect/src/internal/hashMap/node.ts`

Signature: `isEmptyNode(a: unknown)`

JSDoc:

@internal */
export type Node<K, V> =
  | EmptyNode<K, V>
  | LeafNode<K, V>
  | CollisionNode<K, V>
  | IndexedNode<K, V>
  | ArrayNode<K, V>

/** @internal */
export interface SizeRef {
  value: number // mutable by design
}

/** @internal */
export class EmptyNode<out K, out V> {
  readonly _tag = "EmptyNode"

  modify(
    edit: number,
    _shift: number,
    f: HashMap.UpdateFn<V>,
    hash: number,
    key: K,
    size: SizeRef
  ): Node<K, V> {
    const v = f(O.none())
    if (O.isNone(v)) return new EmptyNode()
    ;++size.value
    return new LeafNode(edit, hash, key, v)
  }
}

/** @internal

## isLeafNode

Source: `my-backend/node_modules/effect/src/internal/hashMap/node.ts`

Signature: `isLeafNode(<K, V>(
  node: Node<K, V>
)`

JSDoc:

@internal

## canEditNode

Source: `my-backend/node_modules/effect/src/internal/hashMap/node.ts`

Signature: `canEditNode(<K, V>(node: Node<K, V>, edit: number)`

JSDoc:

@internal

## fromEffectContext

Source: `my-backend/node_modules/effect/src/internal/layer.ts`

Signature: `fromEffectContext(<A, E, R>(
  effect: Effect.Effect<Context.Context<A>, E, R>
)`

JSDoc:

@internal */
const LayerSymbolKey = "effect/Layer"

/** @internal */
export const LayerTypeId: Layer.LayerTypeId = Symbol.for(
  LayerSymbolKey
) as Layer.LayerTypeId

const layerVariance = {
  /* c8 ignore next */
  _RIn: (_: never) => _,
  /* c8 ignore next */
  _E: (_: never) => _,
  /* c8 ignore next */
  _ROut: (_: unknown) => _
}

/** @internal */
export const proto = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments)
  }
}

/** @internal */
const MemoMapTypeIdKey = "effect/Layer/MemoMap"

/** @internal */
export const MemoMapTypeId: Layer.MemoMapTypeId = Symbol.for(
  MemoMapTypeIdKey
) as Layer.MemoMapTypeId

/** @internal */
export const CurrentMemoMap = Context.Reference<Layer.CurrentMemoMap>()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
})

/** @internal */
export type Primitive =
  | ExtendScope
  | Fold
  | Fresh
  | FromEffect
  | Scoped
  | Suspend
  | Locally
  | ProvideTo
  | ZipWith
  | ZipWithPar

/** @internal */
export type Op<Tag extends string, Body = {}> = Layer.Layer<unknown, unknown, unknown> & Body & {
  readonly _op_layer: Tag
}

/** @internal */
export interface ExtendScope extends
  Op<OpCodes.OP_EXTEND_SCOPE, {
    readonly layer: Layer.Layer<unknown>
  }>
{}

/** @internal */
export interface Fold extends
  Op<OpCodes.OP_FOLD, {
    readonly layer: Layer.Layer<unknown>
    failureK(cause: Cause.Cause<unknown>): Layer.Layer<unknown>
    successK(context: Context.Context<unknown>): Layer.Layer<unknown>
  }>
{}

/** @internal */
export interface Fresh extends
  Op<OpCodes.OP_FRESH, {
    readonly layer: Layer.Layer<unknown>
  }>
{}

/** @internal */
export interface FromEffect extends
  Op<OpCodes.OP_FROM_EFFECT, {
    readonly effect: Effect.Effect<unknown, unknown, Context.Context<unknown>>
  }>
{}

/** @internal */
export interface Scoped extends
  Op<OpCodes.OP_SCOPED, {
    readonly effect: Effect.Effect<unknown, unknown, Context.Context<unknown>>
  }>
{}

/** @internal */
export interface Suspend extends
  Op<OpCodes.OP_SUSPEND, {
    evaluate(): Layer.Layer<unknown>
  }>
{}

/** @internal */
export interface Locally extends
  Op<"Locally", {
    readonly self: Layer.Layer<unknown>
    f(_: Effect.Effect<any, any, any>): Effect.Effect<any, any, any>
  }>
{}

/** @internal */
export interface ProvideTo extends
  Op<OpCodes.OP_PROVIDE, {
    readonly first: Layer.Layer<unknown>
    readonly second: Layer.Layer<unknown>
  }>
{}

/** @internal */
export interface ZipWith extends
  Op<OpCodes.OP_PROVIDE_MERGE, {
    readonly first: Layer.Layer<unknown>
    readonly second: Layer.Layer<unknown>
    zipK(left: Context.Context<unknown>, right: Context.Context<unknown>): Context.Context<unknown>
  }>
{}

/** @internal */
export interface ZipWithPar extends
  Op<OpCodes.OP_ZIP_WITH, {
    readonly first: Layer.Layer<unknown>
    readonly second: Layer.Layer<unknown>
    zipK(left: Context.Context<unknown>, right: Context.Context<unknown>): Context.Context<unknown>
  }>
{}

/** @internal */
export const isLayer = (u: unknown): u is Layer.Layer<unknown, unknown, unknown> => hasProperty(u, LayerTypeId)

/** @internal */
export const isFresh = <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>): boolean => {
  return (self as Primitive)._op_layer === OpCodes.OP_FRESH
}

// -----------------------------------------------------------------------------
// MemoMap
// -----------------------------------------------------------------------------

/** @internal */
class MemoMapImpl implements Layer.MemoMap {
  readonly [MemoMapTypeId]: Layer.MemoMapTypeId
  constructor(
    readonly ref: Synchronized.SynchronizedRef<
      Map<
        Layer.Layer<any, any, any>,
        readonly [Effect.Effect<any, any>, Scope.Scope.Finalizer]
      >
    >
  ) {
    this[MemoMapTypeId] = MemoMapTypeId
  }

  /**
Checks the memo map to see if a layer exists. If it is, immediately
returns it. Otherwise, obtains the layer, stores it in the memo map,
and adds a finalizer to the `Scope`.
/
  getOrElseMemoize<RIn, E, ROut>(
    layer: Layer.Layer<ROut, E, RIn>,
    scope: Scope.Scope
  ): Effect.Effect<Context.Context<ROut>, E, RIn> {
    return pipe(
      synchronized.modifyEffect(this.ref, (map) => {
        const inMap = map.get(layer)
        if (inMap !== undefined) {
          const [acquire, release] = inMap
          const cached: Effect.Effect<Context.Context<ROut>, E> = pipe(
            acquire as Effect.Effect<readonly [FiberRefsPatch.FiberRefsPatch, Context.Context<ROut>], E>,
            core.flatMap(([patch, b]) => pipe(effect.patchFiberRefs(patch), core.as(b))),
            core.onExit(core.exitMatch({
              onFailure: () => core.void,
              onSuccess: () => core.scopeAddFinalizerExit(scope, release)
            }))
          )
          return core.succeed([cached, map] as const)
        }
        return pipe(
          ref.make(0),
          core.flatMap((observers) =>
            pipe(
              core.deferredMake<readonly [FiberRefsPatch.FiberRefsPatch, Context.Context<ROut>], E>(),
              core.flatMap((deferred) =>
                pipe(
                  ref.make<Scope.Scope.Finalizer>(() => core.void),
                  core.map((finalizerRef) => {
                    const resource = core.uninterruptibleMask((restore) =>
                      pipe(
                        fiberRuntime.scopeMake(),
                        core.flatMap((innerScope) =>
                          pipe(
                            restore(core.flatMap(
                              makeBuilder(layer, innerScope, true),
                              (f) => effect.diffFiberRefs(f(this))
                            )),
                            core.exit,
                            core.flatMap((exit) => {
                              switch (exit._tag) {
                                case EffectOpCodes.OP_FAILURE: {
                                  return pipe(
                                    core.deferredFailCause(deferred, exit.effect_instruction_i0),
                                    core.zipRight(core.scopeClose(innerScope, exit)),
                                    core.zipRight(core.failCause(exit.effect_instruction_i0))
                                  )
                                }
                                case EffectOpCodes.OP_SUCCESS: {
                                  return pipe(
                                    ref.set(finalizerRef, (exit) =>
                                      pipe(
                                        core.scopeClose(innerScope, exit),
                                        core.whenEffect(
                                          ref.modify(observers, (n) => [n === 1, n - 1] as const)
                                        ),
                                        core.asVoid
                                      )),
                                    core.zipRight(ref.update(observers, (n) => n + 1)),
                                    core.zipRight(
                                      core.scopeAddFinalizerExit(scope, (exit) =>
                                        pipe(
                                          core.sync(() => map.delete(layer)),
                                          core.zipRight(ref.get(finalizerRef)),
                                          core.flatMap((finalizer) => finalizer(exit))
                                        ))
                                    ),
                                    core.zipRight(core.deferredSucceed(deferred, exit.effect_instruction_i0)),
                                    core.as(exit.effect_instruction_i0[1])
                                  )
                                }
                              }
                            })
                          )
                        )
                      )
                    )
                    const memoized = [
                      pipe(
                        core.deferredAwait(deferred),
                        core.onExit(core.exitMatchEffect({
                          onFailure: () => core.void,
                          onSuccess: () => ref.update(observers, (n) => n + 1)
                        }))
                      ),
                      (exit: Exit.Exit<unknown, unknown>) =>
                        pipe(
                          ref.get(finalizerRef),
                          core.flatMap((finalizer) => finalizer(exit))
                        )
                    ] as const
                    return [
                      resource,
                      isFresh(layer) ? map : map.set(layer, memoized)
                    ] as const
                  })
                )
              )
            )
          )
        )
      }),
      core.flatten
    )
  }
}

/** @internal */
export const makeMemoMap: Effect.Effect<Layer.MemoMap> = core.suspend(() =>
  core.map(
    circular.makeSynchronized<
      Map<
        Layer.Layer<any, any, any>,
        readonly [
          Effect.Effect<any, any>,
          Scope.Scope.Finalizer
        ]
      >
    >(new Map()),
    (ref) => new MemoMapImpl(ref)
  )
)

/** @internal */
export const unsafeMakeMemoMap = (): Layer.MemoMap => new MemoMapImpl(circular.unsafeMakeSynchronized(new Map()))

/** @internal */
export const build = <RIn, E, ROut>(
  self: Layer.Layer<ROut, E, RIn>
): Effect.Effect<Context.Context<ROut>, E, RIn | Scope.Scope> =>
  fiberRuntime.scopeWith((scope) => buildWithScope(self, scope))

/** @internal */
export const buildWithScope = dual<
  (
    scope: Scope.Scope
  ) => <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>,
  <RIn, E, ROut>(
    self: Layer.Layer<ROut, E, RIn>,
    scope: Scope.Scope
  ) => Effect.Effect<Context.Context<ROut>, E, RIn>
>(2, (self, scope) =>
  core.flatMap(
    makeMemoMap,
    (memoMap) => buildWithMemoMap(self, memoMap, scope)
  ))

/** @internal */
export const buildWithMemoMap = dual<
  (
    memoMap: Layer.MemoMap,
    scope: Scope.Scope
  ) => <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>,
  <RIn, E, ROut>(
    self: Layer.Layer<ROut, E, RIn>,
    memoMap: Layer.MemoMap,
    scope: Scope.Scope
  ) => Effect.Effect<Context.Context<ROut>, E, RIn>
>(
  3,
  (self, memoMap, scope) =>
    core.flatMap(
      makeBuilder(self, scope),
      (run) => effect.provideService(run(memoMap), CurrentMemoMap, memoMap)
    )
)

const makeBuilder = <RIn, E, ROut>(
  self: Layer.Layer<ROut, E, RIn>,
  scope: Scope.Scope,
  inMemoMap = false
): Effect.Effect<(memoMap: Layer.MemoMap) => Effect.Effect<Context.Context<ROut>, E, RIn>> => {
  const op = self as Primitive
  switch (op._op_layer) {
    case "Locally": {
      return core.sync(() => (memoMap: Layer.MemoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope)))
    }
    case "ExtendScope": {
      return core.sync(() => (memoMap: Layer.MemoMap) =>
        fiberRuntime.scopeWith(
          (scope) => memoMap.getOrElseMemoize(op.layer, scope)
        ) as unknown as Effect.Effect<Context.Context<ROut>, E, RIn>
      )
    }
    case "Fold": {
      return core.sync(() => (memoMap: Layer.MemoMap) =>
        pipe(
          memoMap.getOrElseMemoize(op.layer, scope),
          core.matchCauseEffect({
            onFailure: (cause) => memoMap.getOrElseMemoize(op.failureK(cause), scope),
            onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope)
          })
        )
      )
    }
    case "Fresh": {
      return core.sync(() => (_: Layer.MemoMap) => pipe(op.layer, buildWithScope(scope)))
    }
    case "FromEffect": {
      return inMemoMap
        ? core.sync(() => (_: Layer.MemoMap) => op.effect as Effect.Effect<Context.Context<ROut>, E, RIn>)
        : core.sync(() => (memoMap: Layer.MemoMap) => memoMap.getOrElseMemoize(self, scope))
    }
    case "Provide": {
      return core.sync(() => (memoMap: Layer.MemoMap) =>
        pipe(
          memoMap.getOrElseMemoize(op.first, scope),
          core.flatMap((env) =>
            pipe(
              memoMap.getOrElseMemoize(op.second, scope),
              core.provideContext(env)
            )
          )
        )
      )
    }
    case "Scoped": {
      return inMemoMap
        ? core.sync(() => (_: Layer.MemoMap) =>
          fiberRuntime.scopeExtend(
            op.effect as Effect.Effect<Context.Context<ROut>, E, RIn>,
            scope
          )
        )
        : core.sync(() => (memoMap: Layer.MemoMap) => memoMap.getOrElseMemoize(self, scope))
    }
    case "Suspend": {
      return core.sync(() => (memoMap: Layer.MemoMap) =>
        memoMap.getOrElseMemoize(
          op.evaluate(),
          scope
        )
      )
    }
    case "ProvideMerge": {
      return core.sync(() => (memoMap: Layer.MemoMap) =>
        pipe(
          memoMap.getOrElseMemoize(op.first, scope),
          core.zipWith(
            memoMap.getOrElseMemoize(op.second, scope),
            op.zipK
          )
        )
      )
    }
    case "ZipWith": {
      return core.sync(() => (memoMap: Layer.MemoMap) =>
        pipe(
          memoMap.getOrElseMemoize(op.first, scope),
          fiberRuntime.zipWithOptions(
            memoMap.getOrElseMemoize(op.second, scope),
            op.zipK,
            { concurrent: true }
          )
        )
      )
    }
  }
}

// -----------------------------------------------------------------------------
// Layer
// -----------------------------------------------------------------------------

/** @internal */
export const catchAll = dual<
  <E, RIn2, E2, ROut2>(
    onError: (error: E) => Layer.Layer<ROut2, E2, RIn2>
  ) => <RIn, ROut>(self: Layer.Layer<ROut, E, RIn>) => Layer.Layer<ROut & ROut2, E2, RIn | RIn2>,
  <RIn, E, ROut, RIn2, E2, ROut2>(
    self: Layer.Layer<ROut, E, RIn>,
    onError: (error: E) => Layer.Layer<ROut2, E2, RIn2>
  ) => Layer.Layer<ROut & ROut2, E2, RIn | RIn2>
>(2, (self, onFailure) => match(self, { onFailure, onSuccess: succeedContext }))

/** @internal */
export const catchAllCause = dual<
  <E, RIn2, E2, ROut2>(
    onError: (cause: Cause.Cause<E>) => Layer.Layer<ROut2, E2, RIn2>
  ) => <RIn, ROut>(self: Layer.Layer<ROut, E, RIn>) => Layer.Layer<ROut & ROut2, E2, RIn | RIn2>,
  <RIn, E, ROut, RIn2, E2, ROut22>(
    self: Layer.Layer<ROut, E, RIn>,
    onError: (cause: Cause.Cause<E>) => Layer.Layer<ROut22, E2, RIn2>
  ) => Layer.Layer<ROut & ROut22, E2, RIn | RIn2>
>(2, (self, onFailure) => matchCause(self, { onFailure, onSuccess: succeedContext }))

/** @internal */
export const die = (defect: unknown): Layer.Layer<unknown> => failCause(Cause.die(defect))

/** @internal */
export const dieSync = (evaluate: LazyArg<unknown>): Layer.Layer<unknown> => failCauseSync(() => Cause.die(evaluate()))

/** @internal */
export const discard = <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>): Layer.Layer<never, E, RIn> =>
  map(self, () => Context.empty())

/** @internal */
export const context = <R>(): Layer.Layer<R, never, R> => fromEffectContext(core.context<R>())

/** @internal */
export const extendScope = <RIn, E, ROut>(
  self: Layer.Layer<ROut, E, RIn>
): Layer.Layer<ROut, E, RIn | Scope.Scope> => {
  const extendScope = Object.create(proto)
  extendScope._op_layer = OpCodes.OP_EXTEND_SCOPE
  extendScope.layer = self
  return extendScope
}

/** @internal */
export const fail = <E>(error: E): Layer.Layer<unknown, E> => failCause(Cause.fail(error))

/** @internal */
export const failSync = <E>(evaluate: LazyArg<E>): Layer.Layer<unknown, E> =>
  failCauseSync(() => Cause.fail(evaluate()))

/** @internal */
export const failCause = <E>(cause: Cause.Cause<E>): Layer.Layer<unknown, E> => fromEffectContext(core.failCause(cause))

/** @internal */
export const failCauseSync = <E>(evaluate: LazyArg<Cause.Cause<E>>): Layer.Layer<unknown, E> =>
  fromEffectContext(core.failCauseSync(evaluate))

/** @internal */
export const flatMap = dual<
  <A, A2, E2, R2>(
    f: (context: Context.Context<A>) => Layer.Layer<A2, E2, R2>
  ) => <E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A2, E | E2, R | R2>,
  <A, E, R, A2, E2, R2>(
    self: Layer.Layer<A, E, R>,
    f: (context: Context.Context<A>) => Layer.Layer<A2, E2, R2>
  ) => Layer.Layer<A2, E | E2, R | R2>
>(2, (self, f) => match(self, { onFailure: fail, onSuccess: f }))

/** @internal */
export const flatten = dual<
  <I, A, E2, R2>(
    tag: Context.Tag<I, Layer.Layer<A, E2, R2>>
  ) => <E, R>(
    self: Layer.Layer<I, E, R>
  ) => Layer.Layer<A, E | E2, R | R2>,
  <I, E, R, A, E2, R2>(
    self: Layer.Layer<I, E, R>,
    tag: Context.Tag<I, Layer.Layer<A, E2, R2>>
  ) => Layer.Layer<A, E | E2, R | R2>
>(2, (self, tag) => flatMap(self, Context.get(tag as any) as any))

/** @internal */
export const fresh = <A, E, R>(self: Layer.Layer<A, E, R>): Layer.Layer<A, E, R> => {
  const fresh = Object.create(proto)
  fresh._op_layer = OpCodes.OP_FRESH
  fresh.layer = self
  return fresh
}

/** @internal */
export const fromEffect = dual<
  <I, S>(
    tag: Context.Tag<I, S>
  ) => <E, R>(
    effect: Effect.Effect<Types.NoInfer<S>, E, R>
  ) => Layer.Layer<I, E, R>,
  <I, S, E, R>(
    tag: Context.Tag<I, S>,
    effect: Effect.Effect<Types.NoInfer<S>, E, R>
  ) => Layer.Layer<I, E, R>
>(2, (a, b) => {
  const tagFirst = Context.isTag(a)
  const tag = (tagFirst ? a : b) as Context.Tag<unknown, unknown>
  const effect = tagFirst ? b : a
  return fromEffectContext(core.map(effect, (service) => Context.make(tag, service)))
})

/** @internal */
export const fromEffectDiscard = <X, E, R>(effect: Effect.Effect<X, E, R>) =>
  fromEffectContext(core.map(effect, () => Context.empty()))

/** @internal

## swap

Source: `my-backend/node_modules/effect/src/internal/redBlackTree/node.ts`

Signature: `swap(<K, V>(n: Node<K, V>, v: Node<K, V>)`

JSDoc:

@internal */
export const Color = {
  Red: 0 as Node.Color,
  Black: 1 << 0 as Node.Color
} as const

export declare namespace Node {
  export type Color = number & {
    readonly Color: unique symbol
  }
}

export interface Node<out K, out V> {
  color: Node.Color
  key: K
  value: V
  left: Node<K, V> | undefined
  right: Node<K, V> | undefined
  count: number
}

/** @internal */
export const clone = <K, V>({
  color,
  count,
  key,
  left,
  right,
  value
}: Node<K, V>) => ({
  color,
  key,
  value,
  left,
  right,
  count
})

/** @internal

## application

Source: `my-backend/node_modules/express/lib/express.js`

Signature: `application(= proto;
exports.request = req;
exports.response = res;

/**
 * Expose constructors.
 */

exports.Route = Route;
exports.Router = Router;

/**
 * Expose middleware
 */

exports.json = bodyParser.json
exports.query = require('./middleware/query')`

JSDoc:

Module dependencies.
/

var bodyParser = require('body-parser')
var EventEmitter = require('events').EventEmitter;
var mixin = require('merge-descriptors');
var proto = require('./application');
var Route = require('./router/route');
var Router = require('./router');
var req = require('./request');
var res = require('./response');

/**
Expose `createApplication()`.
/

exports = module.exports = createApplication;

/**
Create an express application.

@return {Function}
@api public
/

function createApplication() {
  var app = function(req, res, next) {
    app.handle(req, res, next);
  };

  mixin(app, EventEmitter.prototype, false);
  mixin(app, proto, false);

  // expose the prototype that will get set on requests
  app.request = Object.create(req, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  // expose the prototype that will get set on responses
  app.response = Object.create(res, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  })

  app.init();
  return app;
}

/**
Expose the prototypes.

## init

Source: `my-backend/node_modules/express/lib/middleware/init.js`

Signature: `init(= function(app)`

JSDoc:

Module dependencies.
@private
/

var setPrototypeOf = require('setprototypeof')

/**
Initialization middleware, exposing the
request and response to each other, as well
as defaulting the X-Powered-By header field.

@param {Function} app
@return {Function}
@api private

## etag

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `etag(= createETagGenerator({ weak: false })`

JSDoc:

Module dependencies.
@api private
/

var Buffer = require('safe-buffer').Buffer
var contentDisposition = require('content-disposition');
var contentType = require('content-type');
var deprecate = require('depd')('express');
var flatten = require('array-flatten');
var mime = require('send').mime;
var etag = require('etag');
var proxyaddr = require('proxy-addr');
var qs = require('qs');
var querystring = require('querystring');

/**
Return strong ETag for `body`.

@param {String|Buffer} body
@param {String} [encoding]
@return {String}
@api private

## wetag

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `wetag(= createETagGenerator({ weak: true })`

JSDoc:

Return weak ETag for `body`.

@param {String|Buffer} body
@param {String} [encoding]
@return {String}
@api private

## isAbsolute

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `isAbsolute(= function(path)`

JSDoc:

Check if `path` looks absolute.

@param {String} path
@return {Boolean}
@api private

## flatten

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `flatten(= deprecate.function(flatten,
  'utils.flatten: use array-flatten npm module instead')`

JSDoc:

Flatten the given `arr`.

@param {Array} arr
@return {Array}
@api private

## normalizeType

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `normalizeType(= function(type)`

JSDoc:

Normalize the given `type`, for example "html" becomes "text/html".

@param {String} type
@return {Object}
@api private

## normalizeTypes

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `normalizeTypes(= function(types)`

JSDoc:

Normalize `types`, for example "html" becomes "text/html".

@param {Array} types
@return {Array}
@api private

## contentDisposition

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `contentDisposition(= deprecate.function(contentDisposition,
  'utils.contentDisposition: use content-disposition npm module instead')`

JSDoc:

Generate Content-Disposition header appropriate for the filename.
non-ascii filenames are urlencoded and a filename* parameter is added

@param {String} filename
@return {String}
@api private

## compileETag

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `compileETag(= function(val)`

JSDoc:

Parse accept params `str` returning an
object with `.value`, `.quality` and `.params`.

@param {String} str
@return {Object}
@api private
/

function acceptParams (str) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {} }

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' === pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
Compile "etag" value to function.

@param  {Boolean|String|Function} val
@return {Function}
@api private

## compileQueryParser

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `compileQueryParser(= function compileQueryParser(val)`

JSDoc:

Compile "query parser" value to function.

@param  {String|Function} val
@return {Function}
@api private

## compileTrust

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `compileTrust(= function(val)`

JSDoc:

Compile "proxy trust" value to function.

@param  {Boolean|String|Number|Array|Function} val
@return {Function}
@api private

## setCharset

Source: `my-backend/node_modules/express/lib/utils.js`

Signature: `setCharset(= function setCharset(type, charset)`

JSDoc:

Set the charset in a given Content-Type string.

@param {String} type
@param {String} charset
@return {String}
@api private

## checkSchema

Source: `my-backend/node_modules/express-validator/lib/middlewares/schema.js`

Signature: `checkSchema(= createCheckSchema(check_1.check)`

JSDoc:

Factory for a {@link checkSchema()} function which can have extension validators and sanitizers.

@see {@link checkSchema()}
/
function createCheckSchema(createChain, extraValidators = [], extraSanitizers = []) {
    /** Type guard for an object entry for a standard validator. */
    function isStandardValidator(entry) {
        return (
        // #664 - explicitly exclude properties which should be set per validator
        !['not', 'withMessage'].includes(entry[0]) &&
            (entry[0] in chain_1.ValidatorsImpl.prototype || extraValidators.includes(entry[0])) &&
            entry[1]);
    }
    /** Type guard for an object entry for a standard sanitizer. */
    function isStandardSanitizer(entry) {
        return ((entry[0] in chain_1.SanitizersImpl.prototype || extraSanitizers.includes(entry[0])) &&
            entry[1]);
    }
    /** Type guard for an object entry for a custom validator. */
    function isCustomValidator(entry) {
        return (!isStandardValidator(entry) &&
            !isStandardSanitizer(entry) &&
            typeof entry[1] === 'object' &&
            entry[1] &&
            typeof entry[1].custom === 'function');
    }
    /** Type guard for an object entry for a custom sanitizer. */
    function isCustomSanitizer(entry) {
        return (!isStandardValidator(entry) &&
            !isStandardSanitizer(entry) &&
            typeof entry[1] === 'object' &&
            entry[1] &&
            typeof entry[1].customSanitizer === 'function');
    }
    return (schema, defaultLocations = validLocations) => {
        const chains = Object.keys(schema).map(field => {
            const config = schema[field];
            const chain = createChain(field, ensureLocations(config, defaultLocations), config.errorMessage);
            // optional doesn't matter where it happens in the chain
            if (config.optional) {
                chain.optional(config.optional === true ? true : config.optional.options);
            }
            for (const entry of Object.entries(config)) {
                if (protectedNames.includes(entry[0]) || !entry[1]) {
                    continue;
                }
                if (!isStandardValidator(entry) &&
                    !isStandardSanitizer(entry) &&
                    !isCustomValidator(entry) &&
                    !isCustomSanitizer(entry)) {
                    console.warn(`express-validator: schema of "${field}" has unknown validator/sanitizer "${entry[0]}"`);
                    continue;
                }
                // For validators, stuff that must come _before_ the validator itself in the chain.
                if ((isStandardValidator(entry) || isCustomValidator(entry)) && entry[1] !== true) {
                    const [, validatorConfig] = entry;
                    validatorConfig.if && chain.if(validatorConfig.if);
                    validatorConfig.negated && chain.not();
                }
                if (isStandardValidator(entry) || isStandardSanitizer(entry)) {
                    const options = entry[1] ? (entry[1] === true ? [] : _.castArray(entry[1].options)) : [];
                    chain[entry[0]](...options);
                }
                if (isCustomValidator(entry)) {
                    chain.custom(entry[1].custom);
                }
                if (isCustomSanitizer(entry)) {
                    chain.customSanitizer(entry[1].customSanitizer);
                }
                // For validators, stuff that must come _after_ the validator itself in the chain.
                if ((isStandardValidator(entry) || isCustomValidator(entry)) && entry[1] !== true) {
                    const [, validatorConfig] = entry;
                    validatorConfig.bail &&
                        chain.bail(validatorConfig.bail === true ? {} : validatorConfig.bail);
                    validatorConfig.errorMessage && chain.withMessage(validatorConfig.errorMessage);
                }
            }
            return chain;
        });
        const run = async (req) => (0, utils_1.runAllChains)(req, chains);
        return Object.assign(chains, { run });
    };
}
/**
Creates an express middleware with validations for multiple fields at once in the form of
a schema object.

@param schema the schema to validate.
@param defaultLocations
@returns

## check

Source: `my-backend/node_modules/express-validator/lib/middlewares/validation-chain-builders.js`

Signature: `check(= buildCheckFunction(['body', 'cookies', 'headers', 'params', 'query'])`

JSDoc:

Creates a variant of `check()` that checks the given request locations.

@example
 const checkBodyAndQuery = buildCheckFunction(['body', 'query']);
/
function buildCheckFunction(locations) {
    return (fields, message) => (0, check_1.check)(fields, locations, message);
}
/**
Creates a middleware/validation chain for one or more fields that may be located in
any of the following:

- `req.body`
- `req.cookies`
- `req.headers`
- `req.params`
- `req.query`

@param fields  a string or array of field names to validate/sanitize
@param message an error message to use when failed validations don't specify a custom message.
               Defaults to `Invalid Value`.

## body

Source: `my-backend/node_modules/express-validator/lib/middlewares/validation-chain-builders.js`

Signature: `body(= buildCheckFunction(['body'])`

JSDoc:

Same as {@link check()}, but only validates `req.body`.

## cookie

Source: `my-backend/node_modules/express-validator/lib/middlewares/validation-chain-builders.js`

Signature: `cookie(= buildCheckFunction(['cookies'])`

JSDoc:

Same as {@link check()}, but only validates `req.cookies`.

## header

Source: `my-backend/node_modules/express-validator/lib/middlewares/validation-chain-builders.js`

Signature: `header(= buildCheckFunction(['headers'])`

JSDoc:

Same as {@link check()}, but only validates `req.headers`.

## param

Source: `my-backend/node_modules/express-validator/lib/middlewares/validation-chain-builders.js`

Signature: `param(= buildCheckFunction(['params'])`

JSDoc:

Same as {@link check()}, but only validates `req.params`.

## query

Source: `my-backend/node_modules/express-validator/lib/middlewares/validation-chain-builders.js`

Signature: `query(= buildCheckFunction(['query'])`

JSDoc:

Same as {@link check()}, but only validates `req.query`.

## validationResult

Source: `my-backend/node_modules/express-validator/lib/validation-result.js`

Signature: `validationResult(= Object.assign(withDefaults()`

JSDoc:

Extracts the validation errors of an express request

## SCOPES

Source: `my-backend/node_modules/ip-address/dist/v6/constants.js`

Signature: `SCOPES(= {
    0: 'Reserved',
    1: 'Interface local',
    2: 'Link local',
    4: 'Admin local',
    5: 'Site local',
    8: 'Organization local',
    14: 'Global',
    15: 'Reserved',
};
/**
 * Represents IPv6 address types
 * @memberof Address6
 * @static
 */
exports.TYPES = {
    'ff01::1/128': 'Multicast (All nodes on this interface)`

JSDoc:

Represents IPv6 address scopes
@memberof Address6
@static

## RE_BAD_CHARACTERS

Source: `my-backend/node_modules/ip-address/dist/v6/constants.js`

Signature: `RE_BAD_CHARACTERS(= /([^0-9a-f:/%])`

JSDoc:

A regular expression that matches bad characters in an IPv6 address
@memberof Address6
@static

## RE_BAD_ADDRESS

Source: `my-backend/node_modules/ip-address/dist/v6/constants.js`

Signature: `RE_BAD_ADDRESS(= /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)`

JSDoc:

A regular expression that matches an incorrect IPv6 address
@memberof Address6
@static

## RE_SUBNET_STRING

Source: `my-backend/node_modules/ip-address/dist/v6/constants.js`

Signature: `RE_SUBNET_STRING(= /\/\d{1,3}(?=%|$)`

JSDoc:

A regular expression that matches an IPv6 subnet
@memberof Address6
@static

## RE_ZONE_STRING

Source: `my-backend/node_modules/ip-address/dist/v6/constants.js`

Signature: `RE_ZONE_STRING(= /%.*$/;
exports.RE_URL = /^\[{0,1}([0-9a-f:]+)`

JSDoc:

A regular expression that matches an IPv6 zone
@memberof Address6
@static

## testBit

Source: `my-backend/node_modules/ip-address/src/common.ts`

Signature: `testBit(binaryValue: string, position: number)`

JSDoc:

@param binaryValue Binary representation of a value (e.g. `10`)
@param position Byte position, where 0 is the least significant bit

## spanAllZeroes

Source: `my-backend/node_modules/ip-address/src/v6/helpers.ts`

Signature: `spanAllZeroes(s: string)`

JSDoc:

@returns {String} the string with all zeroes contained in a <span>

## spanAll

Source: `my-backend/node_modules/ip-address/src/v6/helpers.ts`

Signature: `spanAll(s: string, offset: number = 0)`

JSDoc:

@returns {String} the string with each character contained in a <span>

## spanLeadingZeroes

Source: `my-backend/node_modules/ip-address/src/v6/helpers.ts`

Signature: `spanLeadingZeroes(address: string)`

JSDoc:

@returns {String} the string with leading zeroes contained in a <span>

## simpleGroup

Source: `my-backend/node_modules/ip-address/src/v6/helpers.ts`

Signature: `simpleGroup(addressString: string, offset: number = 0)`

JSDoc:

Groups an address
@returns {String} a grouped address

## classes

Source: `my-backend/node_modules/istanbul-lib-coverage/index.js`

Signature: `classes(= {
    /**
     * the file coverage constructor
     */
    FileCoverage
};
)`

JSDoc:

istanbul-lib-coverage exports an API that allows you to create and manipulate
file coverage, coverage maps (a set of file coverage objects) and summary
coverage objects. File coverage for the same file can be merged as can
entire coverage maps.

@module Exports
/
const { FileCoverage } = require('./lib/file-coverage');
const { CoverageMap } = require('./lib/coverage-map');
const { CoverageSummary } = require('./lib/coverage-summary');

module.exports = {
    /**
creates a coverage summary object
@param {Object} obj an argument with the same semantics
 as the one passed to the `CoverageSummary` constructor
@returns {CoverageSummary}
/
    createCoverageSummary(obj) {
        if (obj && obj instanceof CoverageSummary) {
            return obj;
        }
        return new CoverageSummary(obj);
    },
    /**
creates a CoverageMap object
@param {Object} obj optional - an argument with the same semantics
 as the one passed to the CoverageMap constructor.
@returns {CoverageMap}
/
    createCoverageMap(obj) {
        if (obj && obj instanceof CoverageMap) {
            return obj;
        }
        return new CoverageMap(obj);
    },
    /**
creates a FileCoverage object
@param {Object} obj optional - an argument with the same semantics
 as the one passed to the FileCoverage constructor.
@returns {FileCoverage}
/
    createFileCoverage(obj) {
        if (obj && obj instanceof FileCoverage) {
            return obj;
        }
        return new FileCoverage(obj);
    }
};

/** classes exported for reuse

## formatArgs

Source: `my-backend/node_modules/istanbul-lib-source-maps/node_modules/debug/src/browser.js`

Signature: `formatArgs(= formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage()`

JSDoc:

This is the web browser implementation of `debug()`.

## colors

Source: `my-backend/node_modules/istanbul-lib-source-maps/node_modules/debug/src/browser.js`

Signature: `colors(= [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version)`

JSDoc:

Colors.

## log

Source: `my-backend/node_modules/istanbul-lib-source-maps/node_modules/debug/src/browser.js`

Signature: `log(= console.debug || console.log || (()`

JSDoc:

Colorize log arguments if enabled.

@api public
/

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
Invokes `console.debug()` when available.
No-op when `console.debug` is not a "function".
If `console.debug` is not available, falls back
to `console.log`.

@api public

## init

Source: `my-backend/node_modules/istanbul-lib-source-maps/node_modules/debug/src/node.js`

Signature: `init(= init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	()`

JSDoc:

Module dependencies.
/

const tty = require('tty');
const util = require('util');

/**
This is the Node.js implementation of `debug()`.

## colors

Source: `my-backend/node_modules/istanbul-lib-source-maps/node_modules/debug/src/node.js`

Signature: `colors(= [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)`

JSDoc:

Colors.

## inspectOpts

Source: `my-backend/node_modules/istanbul-lib-source-maps/node_modules/debug/src/node.js`

Signature: `inspectOpts(= Object.keys(process.env)`

JSDoc:

Build up the default `inspectOpts` object from the environment variables.

  $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js

## setState

Source: `my-backend/node_modules/jest-circus/build/state.js`

Signature: `setState(= setState;
const dispatch = async event => {
  for (const handler of eventHandlers)`

JSDoc:

Copyright (c) Meta Platforms, Inc. and affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
/

const eventHandlers = [_eventHandler.default, _formatNodeAssertErrors.default];
const ROOT_DESCRIBE_BLOCK_NAME = 'ROOT_DESCRIBE_BLOCK';
exports.ROOT_DESCRIBE_BLOCK_NAME = ROOT_DESCRIBE_BLOCK_NAME;
const createState = () => {
  const ROOT_DESCRIBE_BLOCK = (0, _utils.makeDescribe)(
    ROOT_DESCRIBE_BLOCK_NAME
  );
  return {
    currentDescribeBlock: ROOT_DESCRIBE_BLOCK,
    currentlyRunningTest: null,
    expand: undefined,
    hasFocusedTests: false,
    hasStarted: false,
    includeTestLocationInResult: false,
    maxConcurrency: 5,
    parentProcess: null,
    rootDescribeBlock: ROOT_DESCRIBE_BLOCK,
    seed: 0,
    testNamePattern: null,
    testTimeout: 5000,
    unhandledErrors: []
  };
};

/* eslint-disable no-restricted-globals */
const resetState = () => {
  global[_types.STATE_SYM] = createState();
};
exports.resetState = resetState;
resetState();
const getState = () => global[_types.STATE_SYM];
exports.getState = getState;
const setState = state => (global[_types.STATE_SYM] = state);
/* eslint-enable

## DIFF_EQUAL

Source: `my-backend/node_modules/jest-diff/build/cleanupSemantic.js`

Signature: `DIFF_EQUAL(= DIFF_EQUAL;
class Diff {
  0;
  1;
  constructor(op, text)`

JSDoc:

Diff Match and Patch
Copyright 2018 The diff-match-patch Authors.
https://github.com/google/diff-match-patch

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
/

/**
@fileoverview Computes the difference between two texts to create a patch.
Applies the patch onto another text, allowing for errors.
@author fraser@google.com (Neil Fraser)
/

/**
CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:

1. Delete anything not needed to use diff_cleanupSemantic method
2. Convert from prototype properties to var declarations
3. Convert Diff to class from constructor and prototype
4. Add type annotations for arguments and return values
5. Add exports
/

/**
The data structure representing a diff is an array of tuples:
[[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
which means: delete 'Hello', add 'Goodbye' and keep ' world.'
/
var DIFF_DELETE = -1;
exports.DIFF_DELETE = DIFF_DELETE;
var DIFF_INSERT = 1;
exports.DIFF_INSERT = DIFF_INSERT;
var DIFF_EQUAL = 0;

/**
Class representing one diff tuple.
Attempts to look like a two-element array (which is what this used to be).
@param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
@param {string} text Text to be deleted, inserted, or retained.
@constructor

## Diff

Source: `my-backend/node_modules/jest-diff/build/cleanupSemantic.js`

Signature: `Diff(= Diff;
var diff_commonPrefix = function (text1, text2)`

JSDoc:

Determine the common prefix of two strings.
@param {string} text1 First string.
@param {string} text2 Second string.
@return {number} The number of characters common to the start of each
    string.

## cleanupSemantic

Source: `my-backend/node_modules/jest-diff/build/cleanupSemantic.js`

Signature: `cleanupSemantic(= diff_cleanupSemantic;
var diff_cleanupSemanticLossless = function (diffs)`

JSDoc:

Determine the common suffix of two strings.
@param {string} text1 First string.
@param {string} text2 Second string.
@return {number} The number of characters common to the end of each string.
/
var diff_commonSuffix = function (text1, text2) {
  // Quick check for common null cases.
  if (
    !text1 ||
    !text2 ||
    text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)
  ) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (
      text1.substring(text1.length - pointermid, text1.length - pointerend) ==
      text2.substring(text2.length - pointermid, text2.length - pointerend)
    ) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};

/**
Determine if the suffix of one string is the prefix of another.
@param {string} text1 First string.
@param {string} text2 Second string.
@return {number} The number of characters common to the end of the first
    string and the start of the second string.
@private
/
var diff_commonOverlap_ = function (text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: https://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (
      found == 0 ||
      text1.substring(text_length - length) == text2.substring(0, length)
    ) {
      best = length;
      length++;
    }
  }
};

/**
Reduce the number of edits by eliminating semantically trivial equalities.
@param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
/
var diff_cleanupSemantic = function (diffs) {
  var changes = false;
  var equalities = []; // Stack of indices where equalities are found.
  var equalitiesLength = 0; // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastEquality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0; // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {
      // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (
        lastEquality &&
        lastEquality.length <=
          Math.max(length_insertions1, length_deletions1) &&
        lastEquality.length <= Math.max(length_insertions2, length_deletions2)
      ) {
        // Duplicate record.
        diffs.splice(
          equalities[equalitiesLength - 1],
          0,
          new Diff(DIFF_DELETE, lastEquality)
        );
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0; // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    diff_cleanupMerge(diffs);
  }
  diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (
      diffs[pointer - 1][0] == DIFF_DELETE &&
      diffs[pointer][0] == DIFF_INSERT
    ) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (
          overlap_length1 >= deletion.length / 2 ||
          overlap_length1 >= insertion.length / 2
        ) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(
            pointer,
            0,
            new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))
          );
          diffs[pointer - 1][1] = deletion.substring(
            0,
            deletion.length - overlap_length1
          );
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (
          overlap_length2 >= deletion.length / 2 ||
          overlap_length2 >= insertion.length / 2
        ) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(
            pointer,
            0,
            new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))
          );
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(
            0,
            insertion.length - overlap_length2
          );
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};

/**
Look for single edits surrounded on both sides by equalities
which can be shifted sideways to align the edit to a word boundary.
e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
@param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.

## interpolateVariables

Source: `my-backend/node_modules/jest-each/build/table/interpolation.js`

Signature: `interpolateVariables(= interpolateVariables;
function getPath(template, [head, ...tail])`

JSDoc:

Copyright (c) Meta Platforms, Inc. and affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.

/

const interpolateVariables = (title, template, index) =>
  title
    .replace(
      new RegExp(`\\$(${Object.keys(template).join('|')})[.\\w]*`, 'g'),
      match => {
        const keyPath = match.slice(1).split('.');
        const value = getPath(template, keyPath);
        return (0, _jestGetType().isPrimitive)(value)
          ? String(value)
          : (0, _prettyFormat().format)(value, {
              maxDepth: 1,
              min: true
            });
      }
    )
    .replace('$#', `${index}`);

/* eslint import/export: 0

## DEFAULT_DELAY

Source: `my-backend/node_modules/jest-haste-map/build/watchers/common.js`

Signature: `DEFAULT_DELAY(= 100;
exports.CHANGE_EVENT = 'change';
exports.DELETE_EVENT = 'delete';
exports.ADD_EVENT = 'add';
exports.ALL_EVENT = 'all';

/**
 * Assigns options to the watcher.
 *
 * @param {NodeWatcher|PollWatcher|WatchmanWatcher} watcher
 * @param {?object} opts
 * @return {boolean}
 * @public
 */

exports.assignOptions = function (watcher, opts)`

JSDoc:

Constants

## isFileIncluded

Source: `my-backend/node_modules/jest-haste-map/build/watchers/common.js`

Signature: `isFileIncluded(= function (globs, dot, doIgnore, relativePath)`

JSDoc:

Checks a file relative path against the globs array.

@param {array} globs
@param {string} relativePath
@return {boolean}
@public

## recReaddir

Source: `my-backend/node_modules/jest-haste-map/build/watchers/common.js`

Signature: `recReaddir(= function (
  dir,
  dirCallback,
  fileCallback,
  endCallback,
  errorCallback,
  ignored
)`

JSDoc:

Traverse a directory recursively calling `callback` on every directory.

@param {string} dir
@param {function} dirCallback
@param {function} fileCallback
@param {function} endCallback
@param {*} ignored
@public

## default

Source: `my-backend/node_modules/jest-matcher-utils/build/Replaceable.js`

Signature: `default(= Replaceable;
)`

JSDoc:

Copyright (c) Meta Platforms, Inc. and affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
/

const supportTypes = ['map', 'array', 'object'];
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
class Replaceable {
  object;
  type;
  constructor(object) {
    this.object = object;
    this.type = (0, _jestGetType.getType)(object);
    if (!supportTypes.includes(this.type)) {
      throw new Error(`Type ${this.type} is not support in Replaceable!`);
    }
  }
  static isReplaceable(obj1, obj2) {
    const obj1Type = (0, _jestGetType.getType)(obj1);
    const obj2Type = (0, _jestGetType.getType)(obj2);
    return obj1Type === obj2Type && supportTypes.includes(obj1Type);
  }
  forEach(cb) {
    if (this.type === 'object') {
      const descriptors = Object.getOwnPropertyDescriptors(this.object);
      [
        ...Object.keys(descriptors),
        ...Object.getOwnPropertySymbols(descriptors)
      ]
        //@ts-expect-error because typescript do not support symbol key in object
        //https://github.com/microsoft/TypeScript/issues/1863
        .filter(key => descriptors[key].enumerable)
        .forEach(key => {
          cb(this.object[key], key, this.object);
        });
    } else {
      this.object.forEach(cb);
    }
  }
  get(key) {
    if (this.type === 'map') {
      return this.object.get(key);
    }
    return this.object[key];
  }
  set(key, value) {
    if (this.type === 'map') {
      this.object.set(key, value);
    } else {
      this.object[key] = value;
    }
  }
}
/* eslint-enable

## ensureNoExpected

Source: `my-backend/node_modules/jest-matcher-utils/build/index.js`

Signature: `ensureNoExpected(= ensureNoExpected;
const ensureActualIsNumber = (actual, matcherName, options)`

JSDoc:

Copyright (c) Meta Platforms, Inc. and affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
/

/* eslint-disable local/ban-types-eventually */

const {
  AsymmetricMatcher,
  DOMCollection,
  DOMElement,
  Immutable,
  ReactElement,
  ReactTestComponent
} = _prettyFormat.plugins;
const PLUGINS = [
  ReactTestComponent,
  ReactElement,
  DOMElement,
  DOMCollection,
  Immutable,
  AsymmetricMatcher
];

// subset of Chalk type

const EXPECTED_COLOR = _chalk.default.green;
exports.EXPECTED_COLOR = EXPECTED_COLOR;
const RECEIVED_COLOR = _chalk.default.red;
exports.RECEIVED_COLOR = RECEIVED_COLOR;
const INVERTED_COLOR = _chalk.default.inverse;
exports.INVERTED_COLOR = INVERTED_COLOR;
const BOLD_WEIGHT = _chalk.default.bold;
exports.BOLD_WEIGHT = BOLD_WEIGHT;
const DIM_COLOR = _chalk.default.dim;
exports.DIM_COLOR = DIM_COLOR;
const MULTILINE_REGEXP = /\n/;
const SPACE_SYMBOL = '\u{00B7}'; // middle dot

const NUMBERS = [
  'zero',
  'one',
  'two',
  'three',
  'four',
  'five',
  'six',
  'seven',
  'eight',
  'nine',
  'ten',
  'eleven',
  'twelve',
  'thirteen'
];
const SUGGEST_TO_CONTAIN_EQUAL = _chalk.default.dim(
  'Looks like you wanted to test for object/array equality with the stricter `toContain` matcher. You probably need to use `toContainEqual` instead.'
);
exports.SUGGEST_TO_CONTAIN_EQUAL = SUGGEST_TO_CONTAIN_EQUAL;
const stringify = (object, maxDepth = 10, maxWidth = 10) => {
  const MAX_LENGTH = 10000;
  let result;
  try {
    result = (0, _prettyFormat.format)(object, {
      maxDepth,
      maxWidth,
      min: true,
      plugins: PLUGINS
    });
  } catch {
    result = (0, _prettyFormat.format)(object, {
      callToJSON: false,
      maxDepth,
      maxWidth,
      min: true,
      plugins: PLUGINS
    });
  }
  if (result.length >= MAX_LENGTH && maxDepth > 1) {
    return stringify(object, Math.floor(maxDepth / 2), maxWidth);
  } else if (result.length >= MAX_LENGTH && maxWidth > 1) {
    return stringify(object, maxDepth, Math.floor(maxWidth / 2));
  } else {
    return result;
  }
};
exports.stringify = stringify;
const highlightTrailingWhitespace = text =>
  text.replace(/\s+$/gm, _chalk.default.inverse('$&'));

// Instead of inverse highlight which now implies a change,
// replace common spaces with middle dot at the end of any line.
exports.highlightTrailingWhitespace = highlightTrailingWhitespace;
const replaceTrailingSpaces = text =>
  text.replace(/\s+$/gm, spaces => SPACE_SYMBOL.repeat(spaces.length));
const printReceived = object =>
  RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));
exports.printReceived = printReceived;
const printExpected = value =>
  EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));
exports.printExpected = printExpected;
function printWithType(name, value, print) {
  const type = (0, _jestGetType.getType)(value);
  const hasType =
    type !== 'null' && type !== 'undefined'
      ? `${name} has type:  ${type}\n`
      : '';
  const hasValue = `${name} has value: ${print(value)}`;
  return hasType + hasValue;
}
const ensureNoExpected = (expected, matcherName, options) => {
  if (typeof expected !== 'undefined') {
    // Prepend maybe not only for backward compatibility.
    const matcherString = (options ? '' : '[.not]') + matcherName;
    throw new Error(
      matcherErrorMessage(
        matcherHint(matcherString, undefined, '', options),
        // Because expected is omitted in hint above,
        // expected is black instead of green in message below.
        'this matcher must not have an expected argument',
        printWithType('Expected', expected, printExpected)
      )
    );
  }
};

/**
Ensures that `actual` is of type `number | bigint`

## ensureActualIsNumber

Source: `my-backend/node_modules/jest-matcher-utils/build/index.js`

Signature: `ensureActualIsNumber(= ensureActualIsNumber;
const ensureExpectedIsNumber = (expected, matcherName, options)`

JSDoc:

Ensures that `expected` is of type `number | bigint`

## ensureExpectedIsNumber

Source: `my-backend/node_modules/jest-matcher-utils/build/index.js`

Signature: `ensureExpectedIsNumber(= ensureExpectedIsNumber;
const ensureNumbers = (actual, expected, matcherName, options)`

JSDoc:

Ensures that `actual` & `expected` are of type `number | bigint`

## default

Source: `my-backend/node_modules/jest-resolve/build/defaultResolver.js`

Signature: `default(= _default;
function readPackageSync(_, file)`

JSDoc:

Copyright (c) Meta Platforms, Inc. and affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
/

/**
Allows transforming parsed `package.json` contents.

@param pkg - Parsed `package.json` contents.
@param file - Path to `package.json` file.
@param dir - Directory that contains the `package.json`.

@returns Transformed `package.json` contents.
/

/**
Allows transforming a path within a package.

@param pkg - Parsed `package.json` contents.
@param path - Path being resolved.
@param relativePath - Path relative from the `package.json` location.

@returns Relative path that will be joined from the `package.json` location.
/

const defaultResolver = (path, options) => {
  // Yarn 2 adds support to `resolve` automatically so the pnpResolver is only
  // needed for Yarn 1 which implements version 1 of the pnp spec
  if (process.versions.pnp === '1') {
    return (0, _jestPnpResolver().default)(path, options);
  }
  const resolveOptions = {
    ...options,
    isDirectory: _fileWalkers.isDirectory,
    isFile: _fileWalkers.isFile,
    preserveSymlinks: false,
    readPackageSync,
    realpathSync: _fileWalkers.realpathSync
  };
  const pathToResolve = getPathInModule(path, resolveOptions);

  // resolveSync dereferences symlinks to ensure we don't create a separate
  // module instance depending on how it was referenced.
  const result = (0, _resolve().sync)(pathToResolve, resolveOptions);
  return result;
};
var _default = defaultResolver;
/*
helper functions

## resolveTestEnvironment

Source: `my-backend/node_modules/jest-resolve/build/utils.js`

Signature: `resolveTestEnvironment(= resolveTestEnvironment;
const resolveWatchPlugin = (
  resolver,
  {filePath, rootDir, requireResolveFunction}
)`

JSDoc:

Copyright (c) Meta Platforms, Inc. and affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
/

const BULLET = _chalk().default.bold('\u25cf ');
const DOCUMENTATION_NOTE = `  ${_chalk().default.bold(
  'Configuration Documentation:'
)}
  https://jestjs.io/docs/configuration
`;
const createValidationError = message =>
  new (_jestValidate().ValidationError)(
    `${BULLET}Validation Error`,
    message,
    DOCUMENTATION_NOTE
  );
const replaceRootDirInPath = (rootDir, filePath) => {
  if (!/^<rootDir>/.test(filePath)) {
    return filePath;
  }
  return path().resolve(
    rootDir,
    path().normalize(`./${filePath.substr('<rootDir>'.length)}`)
  );
};
const resolveWithPrefix = (
  resolver,
  {
    filePath,
    humanOptionName,
    optionName,
    prefix,
    requireResolveFunction,
    rootDir
  }
) => {
  const fileName = replaceRootDirInPath(rootDir, filePath);
  let module = _resolver.default.findNodeModule(`${prefix}${fileName}`, {
    basedir: rootDir,
    resolver: resolver || undefined
  });
  if (module) {
    return module;
  }
  try {
    return requireResolveFunction(`${prefix}${fileName}`);
  } catch {}
  module = _resolver.default.findNodeModule(fileName, {
    basedir: rootDir,
    resolver: resolver || undefined
  });
  if (module) {
    return module;
  }
  try {
    return requireResolveFunction(fileName);
  } catch {}
  throw createValidationError(
    `  ${humanOptionName} ${_chalk().default.bold(
      fileName
    )} cannot be found. Make sure the ${_chalk().default.bold(
      optionName
    )} configuration option points to an existing node module.`
  );
};

/**
Finds the test environment to use:

1. looks for jest-environment-<name> relative to project.
1. looks for jest-environment-<name> relative to Jest.
1. looks for <name> relative to project.
1. looks for <name> relative to Jest.
/
const resolveTestEnvironment = ({
  rootDir,
  testEnvironment: filePath,
  requireResolveFunction
}) => {
  // we don't want to resolve the actual `jsdom` module if `jest-environment-jsdom` is not installed, but `jsdom` package is
  if (filePath === 'jsdom') {
    filePath = 'jest-environment-jsdom';
  }
  try {
    return resolveWithPrefix(undefined, {
      filePath,
      humanOptionName: 'Test environment',
      optionName: 'testEnvironment',
      prefix: 'jest-environment-',
      requireResolveFunction,
      rootDir
    });
  } catch (error) {
    if (filePath === 'jest-environment-jsdom') {
      error.message +=
        '\n\nAs of Jest 28 "jest-environment-jsdom" is no longer shipped by default, make sure to install it separately.';
    }
    throw error;
  }
};

/**
Finds the watch plugins to use:

1. looks for jest-watch-<name> relative to project.
1. looks for jest-watch-<name> relative to Jest.
1. looks for <name> relative to project.
1. looks for <name> relative to Jest.

## resolveWatchPlugin

Source: `my-backend/node_modules/jest-resolve/build/utils.js`

Signature: `resolveWatchPlugin(= resolveWatchPlugin;
const resolveRunner = (resolver, {filePath, rootDir, requireResolveFunction})`

JSDoc:

Finds the runner to use:

1. looks for jest-runner-<name> relative to project.
1. looks for jest-runner-<name> relative to Jest.
1. looks for <name> relative to project.
1. looks for <name> relative to Jest.

## SIGKILL_DELAY

Source: `my-backend/node_modules/jest-worker/build/workers/ChildProcessWorker.js`

Signature: `SIGKILL_DELAY(= SIGKILL_DELAY;
class ChildProcessWorker extends _WorkerAbstract.default {
  _child;
  _options;
  _request;
  _retries;
  _onProcessEnd;
  _onCustomMessage;
  _stdout;
  _stderr;
  _stderrBuffer = [];
  _memoryUsagePromise;
  _resolveMemoryUsage;
  _childIdleMemoryUsage;
  _childIdleMemoryUsageLimit;
  _memoryUsageCheck = false;
  _childWorkerPath;
  constructor(options)`

JSDoc:

Copyright (c) Meta Platforms, Inc. and affiliates.

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
/

const SIGNAL_BASE_EXIT_CODE = 128;
const SIGKILL_EXIT_CODE = SIGNAL_BASE_EXIT_CODE + 9;
const SIGTERM_EXIT_CODE = SIGNAL_BASE_EXIT_CODE + 15;

// How long to wait after SIGTERM before sending SIGKILL
const SIGKILL_DELAY = 500;

/**
This class wraps the child process and provides a nice interface to
communicate with. It takes care of:

 - Re-spawning the process if it dies.
 - Queues calls while the worker is busy.
 - Re-sends the requests if the worker blew up.

The reason for queueing them here (since childProcess.send also has an
internal queue) is because the worker could be doing asynchronous work, and
this would lead to the child process to read its receiving buffer and start a
second call. By queueing calls here, we don't send the next call to the
children until we receive the result of the previous one.

As soon as a request starts to be processed by a worker, its "processed"
field is changed to "true", so that other workers which might encounter the
same call skip it.

## aliasToReal

Source: `my-backend/node_modules/lodash/fp/_mapping.js`

Signature: `aliasToReal(= {

  // Lodash aliases.
  'each': 'forEach',
  'eachRight': 'forEachRight',
  'entries': 'toPairs',
  'entriesIn': 'toPairsIn',
  'extend': 'assignIn',
  'extendAll': 'assignInAll',
  'extendAllWith': 'assignInAllWith',
  'extendWith': 'assignInWith',
  'first': 'head',

  // Methods that are curried variants of others.
  'conforms': 'conformsTo',
  'matches': 'isMatch',
  'property': 'get',

  // Ramda aliases.
  '__': 'placeholder',
  'F': 'stubFalse',
  'T': 'stubTrue',
  'all': 'every',
  'allPass': 'overEvery',
  'always': 'constant',
  'any': 'some',
  'anyPass': 'overSome',
  'apply': 'spread',
  'assoc': 'set',
  'assocPath': 'set',
  'complement': 'negate',
  'compose': 'flowRight',
  'contains': 'includes',
  'dissoc': 'unset',
  'dissocPath': 'unset',
  'dropLast': 'dropRight',
  'dropLastWhile': 'dropRightWhile',
  'equals': 'isEqual',
  'identical': 'eq',
  'indexBy': 'keyBy',
  'init': 'initial',
  'invertObj': 'invert',
  'juxt': 'over',
  'omitAll': 'omit',
  'nAry': 'ary',
  'path': 'get',
  'pathEq': 'matchesProperty',
  'pathOr': 'getOr',
  'paths': 'at',
  'pickAll': 'pick',
  'pipe': 'flow',
  'pluck': 'map',
  'prop': 'get',
  'propEq': 'matchesProperty',
  'propOr': 'getOr',
  'props': 'at',
  'symmetricDifference': 'xor',
  'symmetricDifferenceBy': 'xorBy',
  'symmetricDifferenceWith': 'xorWith',
  'takeLast': 'takeRight',
  'takeLastWhile': 'takeRightWhile',
  'unapply': 'rest',
  'unnest': 'flatten',
  'useWith': 'overArgs',
  'where': 'conformsTo',
  'whereEq': 'isMatch',
  'zipObj': 'zipObject'
};

/** Used to map ary to method names. */
exports.aryMethod = {
  '1': [
    'assignAll', 'assignInAll', 'attempt', 'castArray', 'ceil', 'create',
    'curry', 'curryRight', 'defaultsAll', 'defaultsDeepAll', 'floor', 'flow',
    'flowRight', 'fromPairs', 'invert', 'iteratee', 'memoize', 'method', 'mergeAll',
    'methodOf', 'mixin', 'nthArg', 'over', 'overEvery', 'overSome','rest', 'reverse',
    'round', 'runInContext', 'spread', 'template', 'trim', 'trimEnd', 'trimStart',
    'uniqueId', 'words', 'zipAll'
  ],
  '2': [
    'add', 'after', 'ary', 'assign', 'assignAllWith', 'assignIn', 'assignInAllWith',
    'at', 'before', 'bind', 'bindAll', 'bindKey', 'chunk', 'cloneDeepWith',
    'cloneWith', 'concat', 'conformsTo', 'countBy', 'curryN', 'curryRightN',
    'debounce', 'defaults', 'defaultsDeep', 'defaultTo', 'delay', 'difference',
    'divide', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'endsWith', 'eq',
    'every', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex',
    'findLastKey', 'flatMap', 'flatMapDeep', 'flattenDepth', 'forEach',
    'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'get',
    'groupBy', 'gt', 'gte', 'has', 'hasIn', 'includes', 'indexOf', 'intersection',
    'invertBy', 'invoke', 'invokeMap', 'isEqual', 'isMatch', 'join', 'keyBy',
    'lastIndexOf', 'lt', 'lte', 'map', 'mapKeys', 'mapValues', 'matchesProperty',
    'maxBy', 'meanBy', 'merge', 'mergeAllWith', 'minBy', 'multiply', 'nth', 'omit',
    'omitBy', 'overArgs', 'pad', 'padEnd', 'padStart', 'parseInt', 'partial',
    'partialRight', 'partition', 'pick', 'pickBy', 'propertyOf', 'pull', 'pullAll',
    'pullAt', 'random', 'range', 'rangeRight', 'rearg', 'reject', 'remove',
    'repeat', 'restFrom', 'result', 'sampleSize', 'some', 'sortBy', 'sortedIndex',
    'sortedIndexOf', 'sortedLastIndex', 'sortedLastIndexOf', 'sortedUniqBy',
    'split', 'spreadFrom', 'startsWith', 'subtract', 'sumBy', 'take', 'takeRight',
    'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'times', 'trimChars',
    'trimCharsEnd', 'trimCharsStart', 'truncate', 'union', 'uniqBy', 'uniqWith',
    'unset', 'unzipWith', 'without', 'wrap', 'xor', 'zip', 'zipObject',
    'zipObjectDeep'
  ],
  '3': [
    'assignInWith', 'assignWith', 'clamp', 'differenceBy', 'differenceWith',
    'findFrom', 'findIndexFrom', 'findLastFrom', 'findLastIndexFrom', 'getOr',
    'includesFrom', 'indexOfFrom', 'inRange', 'intersectionBy', 'intersectionWith',
    'invokeArgs', 'invokeArgsMap', 'isEqualWith', 'isMatchWith', 'flatMapDepth',
    'lastIndexOfFrom', 'mergeWith', 'orderBy', 'padChars', 'padCharsEnd',
    'padCharsStart', 'pullAllBy', 'pullAllWith', 'rangeStep', 'rangeStepRight',
    'reduce', 'reduceRight', 'replace', 'set', 'slice', 'sortedIndexBy',
    'sortedLastIndexBy', 'transform', 'unionBy', 'unionWith', 'update', 'xorBy',
    'xorWith', 'zipWith'
  ],
  '4': [
    'fill', 'setWith', 'updateWith'
  ]
};

/** Used to map ary to rearg configs. */
exports.aryRearg = {
  '2': [1, 0],
  '3': [2, 0, 1],
  '4': [3, 2, 0, 1]
};

/** Used to map method names to their iteratee ary. */
exports.iterateeAry = {
  'dropRightWhile': 1,
  'dropWhile': 1,
  'every': 1,
  'filter': 1,
  'find': 1,
  'findFrom': 1,
  'findIndex': 1,
  'findIndexFrom': 1,
  'findKey': 1,
  'findLast': 1,
  'findLastFrom': 1,
  'findLastIndex': 1,
  'findLastIndexFrom': 1,
  'findLastKey': 1,
  'flatMap': 1,
  'flatMapDeep': 1,
  'flatMapDepth': 1,
  'forEach': 1,
  'forEachRight': 1,
  'forIn': 1,
  'forInRight': 1,
  'forOwn': 1,
  'forOwnRight': 1,
  'map': 1,
  'mapKeys': 1,
  'mapValues': 1,
  'partition': 1,
  'reduce': 2,
  'reduceRight': 2,
  'reject': 1,
  'remove': 1,
  'some': 1,
  'takeRightWhile': 1,
  'takeWhile': 1,
  'times': 1,
  'transform': 2
};

/** Used to map method names to iteratee rearg configs. */
exports.iterateeRearg = {
  'mapKeys': [1],
  'reduceRight': [1, 0]
};

/** Used to map method names to rearg configs. */
exports.methodRearg = {
  'assignInAllWith': [1, 0],
  'assignInWith': [1, 2, 0],
  'assignAllWith': [1, 0],
  'assignWith': [1, 2, 0],
  'differenceBy': [1, 2, 0],
  'differenceWith': [1, 2, 0],
  'getOr': [2, 1, 0],
  'intersectionBy': [1, 2, 0],
  'intersectionWith': [1, 2, 0],
  'isEqualWith': [1, 2, 0],
  'isMatchWith': [2, 1, 0],
  'mergeAllWith': [1, 0],
  'mergeWith': [1, 2, 0],
  'padChars': [2, 1, 0],
  'padCharsEnd': [2, 1, 0],
  'padCharsStart': [2, 1, 0],
  'pullAllBy': [2, 1, 0],
  'pullAllWith': [2, 1, 0],
  'rangeStep': [1, 2, 0],
  'rangeStepRight': [1, 2, 0],
  'setWith': [3, 1, 2, 0],
  'sortedIndexBy': [2, 1, 0],
  'sortedLastIndexBy': [2, 1, 0],
  'unionBy': [1, 2, 0],
  'unionWith': [1, 2, 0],
  'updateWith': [3, 1, 2, 0],
  'xorBy': [1, 2, 0],
  'xorWith': [1, 2, 0],
  'zipWith': [1, 2, 0]
};

/** Used to map method names to spread configs. */
exports.methodSpread = {
  'assignAll': { 'start': 0 },
  'assignAllWith': { 'start': 0 },
  'assignInAll': { 'start': 0 },
  'assignInAllWith': { 'start': 0 },
  'defaultsAll': { 'start': 0 },
  'defaultsDeepAll': { 'start': 0 },
  'invokeArgs': { 'start': 2 },
  'invokeArgsMap': { 'start': 2 },
  'mergeAll': { 'start': 0 },
  'mergeAllWith': { 'start': 0 },
  'partial': { 'start': 1 },
  'partialRight': { 'start': 1 },
  'without': { 'start': 1 },
  'zipAll': { 'start': 0 }
};

/** Used to identify methods which mutate arrays or objects. */
exports.mutate = {
  'array': {
    'fill': true,
    'pull': true,
    'pullAll': true,
    'pullAllBy': true,
    'pullAllWith': true,
    'pullAt': true,
    'remove': true,
    'reverse': true
  },
  'object': {
    'assign': true,
    'assignAll': true,
    'assignAllWith': true,
    'assignIn': true,
    'assignInAll': true,
    'assignInAllWith': true,
    'assignInWith': true,
    'assignWith': true,
    'defaults': true,
    'defaultsAll': true,
    'defaultsDeep': true,
    'defaultsDeepAll': true,
    'merge': true,
    'mergeAll': true,
    'mergeAllWith': true,
    'mergeWith': true,
  },
  'set': {
    'set': true,
    'setWith': true,
    'unset': true,
    'update': true,
    'updateWith': true
  }
};

/** Used to map real names to their aliases. */
exports.realToAlias = (function()`

JSDoc:

Used to map aliases to their real names.

## remap

Source: `my-backend/node_modules/lodash/fp/_mapping.js`

Signature: `remap(= {
  'assignAll': 'assign',
  'assignAllWith': 'assignWith',
  'assignInAll': 'assignIn',
  'assignInAllWith': 'assignInWith',
  'curryN': 'curry',
  'curryRightN': 'curryRight',
  'defaultsAll': 'defaults',
  'defaultsDeepAll': 'defaultsDeep',
  'findFrom': 'find',
  'findIndexFrom': 'findIndex',
  'findLastFrom': 'findLast',
  'findLastIndexFrom': 'findLastIndex',
  'getOr': 'get',
  'includesFrom': 'includes',
  'indexOfFrom': 'indexOf',
  'invokeArgs': 'invoke',
  'invokeArgsMap': 'invokeMap',
  'lastIndexOfFrom': 'lastIndexOf',
  'mergeAll': 'merge',
  'mergeAllWith': 'mergeWith',
  'padChars': 'pad',
  'padCharsEnd': 'padEnd',
  'padCharsStart': 'padStart',
  'propertyOf': 'get',
  'rangeStep': 'range',
  'rangeStepRight': 'rangeRight',
  'restFrom': 'rest',
  'spreadFrom': 'spread',
  'trimChars': 'trim',
  'trimCharsEnd': 'trimEnd',
  'trimCharsStart': 'trimStart',
  'zipAll': 'zip'
};

/** Used to track methods that skip fixing their arity. */
exports.skipFixed = {
  'castArray': true,
  'flow': true,
  'flowRight': true,
  'iteratee': true,
  'mixin': true,
  'rearg': true,
  'runInContext': true
};

/** Used to track methods that skip rearranging arguments. */
exports.skipRearg = {
  'add': true,
  'assign': true,
  'assignIn': true,
  'bind': true,
  'bindKey': true,
  'concat': true,
  'difference': true,
  'divide': true,
  'eq': true,
  'gt': true,
  'gte': true,
  'isEqual': true,
  'lt': true,
  'lte': true,
  'matchesProperty': true,
  'merge': true,
  'multiply': true,
  'overArgs': true,
  'partial': true,
  'partialRight': true,
  'propertyOf': true,
  'random': true,
  'range': true,
  'rangeRight': true,
  'subtract': true,
  'zip': true,
  'zipObject': true,
  'zipObjectDeep': true
};
)`

JSDoc:

Used to map method names to other names.

## format

Source: `my-backend/node_modules/media-typer/index.js`

Signature: `format(= format
exports.parse = parse

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @api public
 */

function format(obj)`

JSDoc:

RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7

parameter     = token "=" ( token | quoted-string )
token         = 1*<any CHAR except CTLs or separators>
separators    = "(" | ")" | "<" | ">" | "@"
              | "," | ";" | ":" | "\" | <">
              | "/" | "[" | "]" | "?" | "="
              | "{" | "}" | SP | HT
quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
qdtext        = <any TEXT except <">>
quoted-pair   = "\" CHAR
CHAR          = <any US-ASCII character (octets 0 - 127)>
TEXT          = <any OCTET except CTLs, but including LWS>
LWS           = [CRLF] 1*( SP | HT )
CRLF          = CR LF
CR            = <US-ASCII CR, carriage return (13)>
LF            = <US-ASCII LF, linefeed (10)>
SP            = <US-ASCII SP, space (32)>
SHT           = <US-ASCII HT, horizontal-tab (9)>
CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
OCTET         = <any 8-bit sequence of data>
/
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

/**
RegExp to match quoted-pair in RFC 2616

quoted-pair = "\" CHAR
CHAR        = <any US-ASCII character (octets 0 - 127)>
/
var qescRegExp = /\\([\u0000-\u007f])/g;

/**
RegExp to match chars that must be quoted-pair in RFC 2616
/
var quoteRegExp = /([\\"])/g;

/**
RegExp to match type in RFC 6838

type-name = restricted-name
subtype-name = restricted-name
restricted-name = restricted-name-first *126restricted-name-chars
restricted-name-first  = ALPHA / DIGIT
restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
                         "$" / "&" / "-" / "^" / "_"
restricted-name-chars =/ "." ; Characters before first dot always
                             ; specify a facet name
restricted-name-chars =/ "+" ; Characters after last plus always
                             ; specify a structured syntax suffix
ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
DIGIT =  %x30-39             ; 0-9
/
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

/**
Module exports.

## charset

Source: `my-backend/node_modules/mime-types/index.js`

Signature: `charset(= charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)`

JSDoc:

Module dependencies.
@private
/

var db = require('mime-db')
var extname = require('path').extname

/**
Module variables.
@private
/

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
Module exports.
@public

## log

Source: `my-backend/node_modules/nodemon/node_modules/debug/src/browser.js`

Signature: `log(= log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage()`

JSDoc:

This is the web browser implementation of `debug()`.

## colors

Source: `my-backend/node_modules/nodemon/node_modules/debug/src/browser.js`

Signature: `colors(= ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version)`

JSDoc:

Colors.

## init

Source: `my-backend/node_modules/nodemon/node_modules/debug/src/node.js`

Signature: `init(= init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)`

JSDoc:

Module dependencies.
/
var tty = require('tty');

var util = require('util');
/**
This is the Node.js implementation of `debug()`.

## inspectOpts

Source: `my-backend/node_modules/nodemon/node_modules/debug/src/node.js`

Signature: `inspectOpts(= Object.keys(process.env)`

JSDoc:

Build up the default `inspectOpts` object from the environment variables.

  $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js

## SourceMapGenerator

Source: `my-backend/node_modules/source-map/dist/source-map.debug.js`

Signature: `SourceMapGenerator(= __webpack_require__(1)`

JSDoc:

***/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/*
Copyright 2009-2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE.txt or:
http://opensource.org/licenses/BSD-3-Clause

## encode

Source: `my-backend/node_modules/source-map/dist/source-map.debug.js`

Signature: `encode(= function base64VLQ_encode(aValue)`

JSDoc:

/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/
	
	var base64VLQ = __webpack_require__(2);
	var util = __webpack_require__(4);
	var ArraySet = __webpack_require__(5).ArraySet;
	var MappingList = __webpack_require__(6).MappingList;
	
	/**
An instance of the SourceMapGenerator represents a source map which is
being built incrementally. You may pass an object with the following
properties:

  - file: The filename of the generated source.
  - sourceRoot: A root for all relative URLs in this source map.
/
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}
	
	SourceMapGenerator.prototype._version = 3;
	
	/**
Creates a new SourceMapGenerator based on a SourceMapConsumer

@param aSourceMapConsumer The SourceMap.
/
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };
	
	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }
	
	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };
	
	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }
	
	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }
	
	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }
	
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };
	
	/**
Add a single mapping from original source line and column to the generated
source's line and column for this source map being created. The mapping
object should have the following properties:

  - generated: An object with the generated line and column positions.
  - original: An object with the original line and column positions.
  - source: The original source file (relative to the sourceRoot).
  - name: An optional original token name for this mapping.
/
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);
	
	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }
	
	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }
	
	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }
	
	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };
	
	/**
Set the source content for a source file.
/
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }
	
	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };
	
	/**
Applies the mappings of a sub-source-map for a specific source file to the
source map being generated. Each mapping to the supplied source file is
rewritten using the supplied source map. Note: The resolution for the
resulting mappings is the minimium of this map and the supplied map.

@param aSourceMapConsumer The source map to be applied.
@param aSourceFile Optional. The filename of the source file.
       If omitted, SourceMapConsumer's file property will be used.
@param aSourceMapPath Optional. The dirname of the path to the source map
       to be applied. If relative, it is relative to the SourceMapConsumer.
       This parameter is needed when the two source maps aren't in the same
       directory, and the source map to be applied contains relative source
       paths. If so, those relative source paths need to be rewritten
       relative to the SourceMapGenerator.
/
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();
	
	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source)
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }
	
	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }
	
	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }
	
	    }, this);
	    this._sources = newSources;
	    this._names = newNames;
	
	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };
	
	/**
A mapping can have one of the three levels of data:

  1. Just the generated position.
  2. The Generated position, original position, and original source.
  3. Generated and original position, original source, as well as a name
     token.

To maintain consistency, we validate that any new mapping being added falls
in to one of these categories.
/
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }
	
	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };
	
	/**
Serialize the accumulated mappings in to the stream of base 64 VLQs
specified by the source map format.
/
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;
	
	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = ''
	
	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }
	
	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;
	
	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;
	
	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;
	
	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;
	
	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }
	
	      result += next;
	    }
	
	    return result;
	  };
	
	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };
	
	/**
Externalize the source map.
/
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }
	
	    return map;
	  };
	
	/**
Render the source map being generated to a string.
/
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };
	
	exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause

Based on the Base 64 VLQ implementation in Closure Compiler:
https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java

Copyright 2011 The Closure Compiler Authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following
   disclaimer in the documentation and/or other materials provided
   with the distribution.
 * Neither the name of Google Inc. nor the names of its
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/
	
	var base64 = __webpack_require__(3);
	
	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011
	
	var VLQ_BASE_SHIFT = 5;
	
	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	/**
Converts from a two-complement value to a value where the sign bit is
placed in the least significant bit.  For example, as decimals:
  1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
  2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
/
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}
	
	/**
Converts to a two-complement value from a value where the sign bit is
placed in the least significant bit.  For example, as decimals:
  2 (10 binary) becomes 1, 3 (11 binary) becomes -1
  4 (100 binary) becomes 2, 5 (101 binary) becomes -2
/
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}
	
	/**
Returns the base 64 VLQ encoded value.

## decode

Source: `my-backend/node_modules/source-map/dist/source-map.debug.js`

Signature: `decode(= function base64VLQ_decode(aStr, aIndex, aOutParam)`

JSDoc:

Decodes the next base 64 VLQ value from the given string and returns the
value and the rest of the string via the out parameter.

## encode

Source: `my-backend/node_modules/source-map/dist/source-map.debug.js`

Signature: `encode(= function (number)`

JSDoc:

/ }),
/* 3 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/
	
	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	/**
Encode an integer in the range of 0 to 63 to a single base 64 digit.

## decode

Source: `my-backend/node_modules/source-map/dist/source-map.debug.js`

Signature: `decode(= function (charCode)`

JSDoc:

Decode a single base 64 character code digit to an integer. Returns -1 on
failure.

## GREATEST_LOWER_BOUND

Source: `my-backend/node_modules/source-map/dist/source-map.debug.js`

Signature: `GREATEST_LOWER_BOUND(= 1;
	exports.LEAST_UPPER_BOUND = 2;
	
	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias)`

JSDoc:

/ }),
/* 4 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/
	
	/**
This is a helper function for getting values from parameter/options
objects.

@param args The object we are extracting values from
@param name The name of the property we are getting.
@param defaultValue An optional value to return if the property is missing
from the object. If this is not specified and the property is missing, an
error will be thrown.
/
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;
	
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	
	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;
	
	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;
	
	/**
Normalizes a path, or the path portion of a URL:

- Replaces consecutive slashes with one slash.
- Removes unnecessary '.' parts.
- Removes unnecessary '<dir>/..' parts.

Based on code in the Node.js 'path' core module.

@param aPath The path or url to normalize.
/
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);
	
	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');
	
	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }
	
	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;
	
	/**
Joins two paths/URLs.

@param aRoot The root path or URL.
@param aPath The path or URL to be joined with the root.

- If aPath is a URL or a data URI, aPath is returned, unless aPath is a
  scheme-relative URL: Then the scheme of aRoot, if any, is prepended
  first.
- Otherwise aPath is a path. If aRoot is a URL, then its path portion
  is updated with the result and aRoot is returned. Otherwise the result
  is returned.
  - If aPath is absolute, the result is aPath.
  - Otherwise the two paths are joined with a slash.
- Joining for example 'http://' and 'www.example.com' is also supported.
/
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }
	
	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }
	
	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }
	
	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }
	
	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;
	
	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};
	
	/**
Make a path relative to a URL or another path.

@param aRoot The root path or URL.
@param aPath The path or URL to be made relative to aRoot.
/
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	
	  aRoot = aRoot.replace(/\/$/, '');
	
	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }
	
	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }
	
	    ++level;
	  }
	
	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;
	
	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());
	
	function identity (s) {
	  return s;
	}
	
	/**
Because behavior goes wacky when you set `__proto__` on objects, we
have to prefix all the strings in our set with an arbitrary character.

See https://github.com/mozilla/source-map/pull/31 and
https://github.com/mozilla/source-map/issues/30

@param String aStr
/
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }
	
	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;
	
	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }
	
	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;
	
	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }
	
	  var length = s.length;
	
	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }
	
	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }
	
	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	/**
Comparator between two mappings where the original positions are compared.

Optionally pass in `true` as `onlyCompareGenerated` to consider two
mappings with the same original source/line/column, but different generated
line and column the same. Useful when searching for a mapping with a
stubbed out mapping.
/
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;
	
	/**
Comparator between two mappings with deflated source and name indices where
the generated positions are compared.

Optionally pass in `true` as `onlyCompareGenerated` to consider two
mappings with the same generated line and column, but different
source/name/original line and column the same. Useful when searching for a
mapping with a stubbed out mapping.
/
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }
	
	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }
	
	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }
	
	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }
	
	  if (aStr1 > aStr2) {
	    return 1;
	  }
	
	  return -1;
	}
	
	/**
Comparator between two mappings with inflated source and name strings where
the generated positions are compared.
/
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	
	/**
Strip any JSON XSSI avoidance prefix from the string (as documented
in the source maps specification), and then parse the string as
JSON.
/
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;
	
	/**
Compute the URL of a source given the the source root, the source's
URL, and the source map's URL.
/
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';
	
	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   sources entry.  This value is prepended to the individual
	    //   entries in the source field.
	    sourceURL = sourceRoot + sourceURL;
	  }
	
	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   sourceRoot, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }
	
	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/
	
	var util = __webpack_require__(4);
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	
	/**
A data structure which is a combination of an array and a set. Adding a new
member is O(1), testing for membership is O(1), and finding the index of an
element is O(1). Removing elements from the set is not supported. Only
strings are supported for membership.
/
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}
	
	/**
Static method for creating ArraySet instances from an existing array.
/
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};
	
	/**
Return how many unique items are in this ArraySet. If duplicates have been
added, than those do not count towards the size.

@returns Number
/
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	
	/**
Add the given string to this set.

@param String aStr
/
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};
	
	/**
Is the given string a member of this set?

@param String aStr
/
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};
	
	/**
What is the index of the given string in the array?

@param String aStr
/
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }
	
	  throw new Error('"' + aStr + '" is not in the set.');
	};
	
	/**
What is the element at the given index?

@param Number aIdx
/
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};
	
	/**
Returns the array representation of this set (which has the proper indices
indicated by indexOf). Note that this is a copy of the internal array used
for storing the members so that no one can mess with internal state.
/
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};
	
	exports.ArraySet = ArraySet;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2014 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/
	
	var util = __webpack_require__(4);
	
	/**
Determine whether mappingB is after mappingA with respect to generated
position.
/
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	
	/**
A data structure to provide a sorted view of accumulated mappings in a
performance conscious manner. It trades a neglibable overhead in general
case for a large speedup in case of mappings being added in order.
/
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}
	
	/**
Iterate through internal items. This method takes the same arguments that
`Array.prototype.forEach` takes.

NOTE: The order of the mappings is NOT guaranteed.
/
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };
	
	/**
Add the given source mapping.

@param Object aMapping
/
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};
	
	/**
Returns the flat, sorted array of mappings. The mappings are sorted by
generated position.

WARNING: This method returns internal data without copying, for
performance. The return value must NOT be mutated, and should be treated as
an immutable borrow. If you want to take ownership, you must make your own
copy.
/
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};
	
	exports.MappingList = MappingList;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/
	
	var util = __webpack_require__(4);
	var binarySearch = __webpack_require__(8);
	var ArraySet = __webpack_require__(5).ArraySet;
	var base64VLQ = __webpack_require__(2);
	var quickSort = __webpack_require__(9).quickSort;
	
	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	
	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}
	
	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	}
	
	/**
The version of the source mapping spec that we are consuming.
/
	SourceMapConsumer.prototype._version = 3;
	
	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.
	
	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	
	    return this.__generatedMappings;
	  }
	});
	
	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	
	    return this.__originalMappings;
	  }
	});
	
	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };
	
	/**
Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the `this.__generatedMappings` and
`this.__originalMappings` properties).
/
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };
	
	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	/**
Iterate over each mapping between an original source/line/column and a
generated line/column in this source map.

@param Function aCallback
       The function that is called with each mapping.
@param Object aContext
       Optional. If specified, this object will be the value of `this` every
       time that `aCallback` is called.
@param aOrder
       Either `SourceMapConsumer.GENERATED_ORDER` or
       `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       iterate over the mappings sorted by the generated file's line/column
       order or the original's source/line/column order, respectively. Defaults to
       `SourceMapConsumer.GENERATED_ORDER`.
/
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }
	
	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };
	
	/**
Returns all generated line and column information for the original source,
line, and column provided. If no column is provided, returns all mappings
corresponding to a either the line we are searching for or the next
closest line that has any mappings. Otherwise, returns all mappings
corresponding to the given line and either the column we are searching for
or the next closest column that has any offsets.

The only argument is an object with the following properties:

  - source: The filename of the original source.
  - line: The line number in the original source.  The line number is 1-based.
  - column: Optional. the column number in the original source.
   The column number is 0-based.

and an array of objects is returned, each with the following properties:

  - line: The line number in the generated source, or null.  The
   line number is 1-based.
  - column: The column number in the generated source, or null.
   The column number is 0-based.
/
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');
	
	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };
	
	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }
	
	    var mappings = [];
	
	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	
	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;
	
	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	
	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;
	
	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	
	          mapping = this._originalMappings[++index];
	        }
	      }
	    }
	
	    return mappings;
	  };
	
	exports.SourceMapConsumer = SourceMapConsumer;
	
	/**
A BasicSourceMapConsumer instance represents a parsed source map which we can
query for information about the original file positions by giving it a file
position in the generated source.

The first parameter is the raw source map (either as a JSON string, or
already parsed to an object). According to the spec, source maps have the
following attributes:

  - version: Which version of the source map spec this map is following.
  - sources: An array of URLs to the original source files.
  - names: An array of identifiers which can be referrenced by individual mappings.
  - sourceRoot: Optional. The URL root from which all sources are relative.
  - sourcesContent: Optional. An array of contents of the original source files.
  - mappings: A string of base64 VLQs which contain the actual mappings.
  - file: Optional. The generated file this source map is associated with.

Here is an example source map, taken from the source map spec[0]:

    {
      version : 3,
      file: "out.js",
      sourceRoot : "",
      sources: ["foo.js", "bar.js"],
      names: ["src", "maps", "are", "fun"],
      mappings: "AA,AB;;ABCDE;"
    }

The second parameter, if given, is a string whose value is the URL
at which the source map was found.  This URL is used to compute the
sources array.

[0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
/
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	
	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);
	
	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	
	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }
	
	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });
	
	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);
	
	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });
	
	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}
	
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	/**
Utility function to find the index of a source.  Returns -1 if not
found.
/
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }
	
	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }
	
	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }
	
	  return -1;
	};
	
	/**
Create a BasicSourceMapConsumer from a SourceMapGenerator.

@param SourceMapGenerator aSourceMap
       The source map that will be consumed.
@param String aSourceMapURL
       The URL at which the source map can be found (optional)
@returns BasicSourceMapConsumer
/
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });
	
	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.
	
	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];
	
	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;
	
	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;
	
	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }
	
	        destOriginalMappings.push(destMapping);
	      }
	
	      destGeneratedMappings.push(destMapping);
	    }
	
	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	    return smc;
	  };
	
	/**
The version of the source mapping spec that we are consuming.
/
	BasicSourceMapConsumer.prototype._version = 3;
	
	/**
The list of original sources.
/
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});
	
	/**
Provide the JIT with a nice shape / hidden class.
/
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}
	
	/**
Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the `this.__generatedMappings` and
`this.__originalMappings` properties).
/
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;
	
	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;
	
	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);
	
	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }
	
	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }
	
	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }
	
	          cachedSegments[str] = segment;
	        }
	
	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];
	
	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;
	
	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }
	
	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }
	
	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;
	
	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };
	
	/**
Find the mapping that best matches the hypothetical "needle" mapping that
we are searching for in the given "haystack" of mappings.
/
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.
	
	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }
	
	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };
	
	/**
Compute the last column for each generated mapping. The last column is
inclusive.
/
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];
	
	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];
	
	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }
	
	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };
	
	/**
Returns the original source, line, and column information for the generated
source's line and column positions provided. The only argument is an object
with the following properties:

  - line: The line number in the generated source.  The line number
    is 1-based.
  - column: The column number in the generated source.  The column
    number is 0-based.
  - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
    'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
    closest element that is smaller than or greater than the one we are
    searching for, respectively, if the exact element cannot be found.
    Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.

and an object is returned with the following properties:

  - source: The original source file, or null.
  - line: The line number in the original source, or null.  The
    line number is 1-based.
  - column: The column number in the original source, or null.  The
    column number is 0-based.
  - name: The original identifier, or null.
/
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	
	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	
	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];
	
	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }
	
	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };
	
	/**
Return true if we have the source content for every source in the source
map, false otherwise.
/
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };
	
	/**
Returns the original source content. The only argument is the url of the
original source file. Returns null if no original source content is
available.
/
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }
	
	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }
	
	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }
	
	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }
	
	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }
	
	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };
	
	/**
Returns the generated line and column information for the original source,
line, and column positions provided. The only argument is an object with
the following properties:

  - source: The filename of the original source.
  - line: The line number in the original source.  The line number
    is 1-based.
  - column: The column number in the original source.  The column
    number is 0-based.
  - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
    'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
    closest element that is smaller than or greater than the one we are
    searching for, respectively, if the exact element cannot be found.
    Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.

and an object is returned with the following properties:

  - line: The line number in the generated source, or null.  The
    line number is 1-based.
  - column: The column number in the generated source, or null.
    The column number is 0-based.
/
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	
	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };
	
	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	
	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }
	
	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };
	
	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	/**
An IndexedSourceMapConsumer instance represents a parsed source map which
we can query for information. It differs from BasicSourceMapConsumer in
that it takes "indexed" source maps (i.e. ones with a "sections" field) as
input.

The first parameter is a raw source map (either as a JSON string, or already
parsed to an object). According to the spec for indexed source maps, they
have the following attributes:

  - version: Which version of the source map spec this map is following.
  - file: Optional. The generated file this source map is associated with.
  - sections: A list of section definitions.

Each value under the "sections" field has two fields:
  - offset: The offset into the original specified at which this section
      begins to apply, defined as an object with a "line" and "column"
      field.
  - map: A source map definition. This source map could also be indexed,
      but doesn't have to be.

Instead of the "map" field, it's also possible to have a "url" field
specifying a URL to retrieve a source map from, but that's currently
unsupported.

Here's an example source map, taken from the source map spec[0], but
modified to omit a section which uses the "url" field.

 {
   version : 3,
   file: "app.js",
   sections: [{
     offset: {line:100, column:10},
     map: {
       version : 3,
       file: "section.js",
       sources: ["foo.js", "bar.js"],
       names: ["src", "maps", "are", "fun"],
       mappings: "AAAA,E;;ABCDE;"
     }
   }],
 }

The second parameter, if given, is a string whose value is the URL
at which the source map was found.  This URL is used to compute the
sources array.

[0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
/
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }
	
	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');
	
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	
	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');
	
	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;
	
	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}
	
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	/**
The version of the source mapping spec that we are consuming.
/
	IndexedSourceMapConsumer.prototype._version = 3;
	
	/**
The list of original sources.
/
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});
	
	/**
Returns the original source, line, and column information for the generated
source's line and column positions provided. The only argument is an object
with the following properties:

  - line: The line number in the generated source.  The line number
    is 1-based.
  - column: The column number in the generated source.  The column
    number is 0-based.

and an object is returned with the following properties:

  - source: The original source file, or null.
  - line: The line number in the original source, or null.  The
    line number is 1-based.
  - column: The column number in the original source, or null.  The
    column number is 0-based.
  - name: The original identifier, or null.
/
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	
	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }
	
	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];
	
	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }
	
	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };
	
	/**
Return true if we have the source content for every source in the source
map, false otherwise.
/
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };
	
	/**
Returns the original source content. The only argument is the url of the
original source file. Returns null if no original source content is
available.
/
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	
	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };
	
	/**
Returns the generated line and column information for the original source,
line, and column positions provided. The only argument is an object with
the following properties:

  - source: The filename of the original source.
  - line: The line number in the original source.  The line number
    is 1-based.
  - column: The column number in the original source.  The column
    number is 0-based.

and an object is returned with the following properties:

  - line: The line number in the generated source, or null.  The
    line number is 1-based. 
  - column: The column number in the generated source, or null.
    The column number is 0-based.
/
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	
	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }
	
	    return {
	      line: null,
	      column: null
	    };
	  };
	
	/**
Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the `this.__generatedMappings` and
`this.__originalMappings` properties).
/
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];
	
	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);
	
	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }
	
	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };
	
	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }
	
	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };
	
	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause

## search

Source: `my-backend/node_modules/source-map/dist/source-map.debug.js`

Signature: `search(= function search(aNeedle, aHaystack, aCompare, aBias)`

JSDoc:

This is an implementation of binary search which will always try and return
the index of the closest element if there is no exact hit. This is because
mappings between original and generated line/col pairs are single points,
and there is an implicit region between each of them, so a miss just means
that you aren't on the very start of a region.

@param aNeedle The element you are looking for.
@param aHaystack The array that is being searched.
@param aCompare A function which takes the needle and an element in the
    array and returns -1, 0, or 1 depending on whether the needle is less
    than, equal to, or greater than the element, respectively.
@param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
    'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
    closest element that is smaller than or greater than the one we are
    searching for, respectively, if the exact element cannot be found.
    Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.

## quickSort

Source: `my-backend/node_modules/source-map/dist/source-map.debug.js`

Signature: `quickSort(= function (ary, comparator)`

JSDoc:

/ }),
/* 9 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/
	
	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.
	
	/**
Swap the elements indexed by `x` and `y` in the array `ary`.

@param {Array} ary
       The array.
@param {Number} x
       The index of the first item.
@param {Number} y
       The index of the second item.
/
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}
	
	/**
Returns a random integer within the range `low .. high` inclusive.

@param {Number} low
       The lower bound on the range.
@param {Number} high
       The upper bound on the range.
/
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}
	
	/**
The Quick Sort algorithm.

@param {Array} ary
       An array to sort.
@param {function} comparator
       Function to use to compare two items.
@param {Number} p
       Start index of the array
@param {Number} r
       End index of the array
/
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.
	
	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.
	
	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;
	
	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];
	
	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }
	
	    swap(ary, i + 1, j);
	    var q = i + 1;
	
	    // (2) Recurse on each half.
	
	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}
	
	/**
Sort the given array in-place with the given comparator function.

@param {Array} ary
       An array to sort.
@param {function} comparator
       Function to use to compare two items.

## SourceMapGenerator

Source: `my-backend/node_modules/source-map/dist/source-map.js`

Signature: `SourceMapGenerator(= __webpack_require__(1)`

JSDoc:

***/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/*
Copyright 2009-2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE.txt or:
http://opensource.org/licenses/BSD-3-Clause

## encode

Source: `my-backend/node_modules/source-map/dist/source-map.js`

Signature: `encode(= function base64VLQ_encode(aValue)`

JSDoc:

/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/

	var base64VLQ = __webpack_require__(2);
	var util = __webpack_require__(4);
	var ArraySet = __webpack_require__(5).ArraySet;
	var MappingList = __webpack_require__(6).MappingList;

	/**
An instance of the SourceMapGenerator represents a source map which is
being built incrementally. You may pass an object with the following
properties:

  - file: The filename of the generated source.
  - sourceRoot: A root for all relative URLs in this source map.
/
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
Creates a new SourceMapGenerator based on a SourceMapConsumer

@param aSourceMapConsumer The SourceMap.
/
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
Add a single mapping from original source line and column to the generated
source's line and column for this source map being created. The mapping
object should have the following properties:

  - generated: An object with the generated line and column positions.
  - original: An object with the original line and column positions.
  - source: The original source file (relative to the sourceRoot).
  - name: An optional original token name for this mapping.
/
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
Set the source content for a source file.
/
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
Applies the mappings of a sub-source-map for a specific source file to the
source map being generated. Each mapping to the supplied source file is
rewritten using the supplied source map. Note: The resolution for the
resulting mappings is the minimium of this map and the supplied map.

@param aSourceMapConsumer The source map to be applied.
@param aSourceFile Optional. The filename of the source file.
       If omitted, SourceMapConsumer's file property will be used.
@param aSourceMapPath Optional. The dirname of the path to the source map
       to be applied. If relative, it is relative to the SourceMapConsumer.
       This parameter is needed when the two source maps aren't in the same
       directory, and the source map to be applied contains relative source
       paths. If so, those relative source paths need to be rewritten
       relative to the SourceMapGenerator.
/
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source)
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
A mapping can have one of the three levels of data:

  1. Just the generated position.
  2. The Generated position, original position, and original source.
  3. Generated and original position, original source, as well as a name
     token.

To maintain consistency, we validate that any new mapping being added falls
in to one of these categories.
/
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
Serialize the accumulated mappings in to the stream of base 64 VLQs
specified by the source map format.
/
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = ''

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
Externalize the source map.
/
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
Render the source map being generated to a string.
/
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause

Based on the Base 64 VLQ implementation in Closure Compiler:
https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java

Copyright 2011 The Closure Compiler Authors. All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above
   copyright notice, this list of conditions and the following
   disclaimer in the documentation and/or other materials provided
   with the distribution.
 * Neither the name of Google Inc. nor the names of its
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/

	var base64 = __webpack_require__(3);

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
Converts from a two-complement value to a value where the sign bit is
placed in the least significant bit.  For example, as decimals:
  1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
  2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
/
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
Converts to a two-complement value from a value where the sign bit is
placed in the least significant bit.  For example, as decimals:
  2 (10 binary) becomes 1, 3 (11 binary) becomes -1
  4 (100 binary) becomes 2, 5 (101 binary) becomes -2
/
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
Returns the base 64 VLQ encoded value.

## decode

Source: `my-backend/node_modules/source-map/dist/source-map.js`

Signature: `decode(= function base64VLQ_decode(aStr, aIndex, aOutParam)`

JSDoc:

Decodes the next base 64 VLQ value from the given string and returns the
value and the rest of the string via the out parameter.

## encode

Source: `my-backend/node_modules/source-map/dist/source-map.js`

Signature: `encode(= function (number)`

JSDoc:

/ }),
/* 3 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
Encode an integer in the range of 0 to 63 to a single base 64 digit.

## decode

Source: `my-backend/node_modules/source-map/dist/source-map.js`

Signature: `decode(= function (charCode)`

JSDoc:

Decode a single base 64 character code digit to an integer. Returns -1 on
failure.

## GREATEST_LOWER_BOUND

Source: `my-backend/node_modules/source-map/dist/source-map.js`

Signature: `GREATEST_LOWER_BOUND(= 1;
	exports.LEAST_UPPER_BOUND = 2;

	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias)`

JSDoc:

/ }),
/* 4 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/

	/**
This is a helper function for getting values from parameter/options
objects.

@param args The object we are extracting values from
@param name The name of the property we are getting.
@param defaultValue An optional value to return if the property is missing
from the object. If this is not specified and the property is missing, an
error will be thrown.
/
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
Normalizes a path, or the path portion of a URL:

- Replaces consecutive slashes with one slash.
- Removes unnecessary '.' parts.
- Removes unnecessary '<dir>/..' parts.

Based on code in the Node.js 'path' core module.

@param aPath The path or url to normalize.
/
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
Joins two paths/URLs.

@param aRoot The root path or URL.
@param aPath The path or URL to be joined with the root.

- If aPath is a URL or a data URI, aPath is returned, unless aPath is a
  scheme-relative URL: Then the scheme of aRoot, if any, is prepended
  first.
- Otherwise aPath is a path. If aRoot is a URL, then its path portion
  is updated with the result and aRoot is returned. Otherwise the result
  is returned.
  - If aPath is absolute, the result is aPath.
  - Otherwise the two paths are joined with a slash.
- Joining for example 'http://' and 'www.example.com' is also supported.
/
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
Make a path relative to a URL or another path.

@param aRoot The root path or URL.
@param aPath The path or URL to be made relative to aRoot.
/
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
Because behavior goes wacky when you set `__proto__` on objects, we
have to prefix all the strings in our set with an arbitrary character.

See https://github.com/mozilla/source-map/pull/31 and
https://github.com/mozilla/source-map/issues/30

@param String aStr
/
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
Comparator between two mappings where the original positions are compared.

Optionally pass in `true` as `onlyCompareGenerated` to consider two
mappings with the same original source/line/column, but different generated
line and column the same. Useful when searching for a mapping with a
stubbed out mapping.
/
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
Comparator between two mappings with deflated source and name indices where
the generated positions are compared.

Optionally pass in `true` as `onlyCompareGenerated` to consider two
mappings with the same generated line and column, but different
source/name/original line and column the same. Useful when searching for a
mapping with a stubbed out mapping.
/
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
Comparator between two mappings with inflated source and name strings where
the generated positions are compared.
/
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
Strip any JSON XSSI avoidance prefix from the string (as documented
in the source maps specification), and then parse the string as
JSON.
/
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
Compute the URL of a source given the the source root, the source's
URL, and the source map's URL.
/
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   sources entry.  This value is prepended to the individual
	    //   entries in the source field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   sourceRoot, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/

	var util = __webpack_require__(4);
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
A data structure which is a combination of an array and a set. Adding a new
member is O(1), testing for membership is O(1), and finding the index of an
element is O(1). Removing elements from the set is not supported. Only
strings are supported for membership.
/
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
Static method for creating ArraySet instances from an existing array.
/
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
Return how many unique items are in this ArraySet. If duplicates have been
added, than those do not count towards the size.

@returns Number
/
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
Add the given string to this set.

@param String aStr
/
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
Is the given string a member of this set?

@param String aStr
/
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
What is the index of the given string in the array?

@param String aStr
/
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
What is the element at the given index?

@param Number aIdx
/
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
Returns the array representation of this set (which has the proper indices
indicated by indexOf). Note that this is a copy of the internal array used
for storing the members so that no one can mess with internal state.
/
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	exports.ArraySet = ArraySet;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2014 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/

	var util = __webpack_require__(4);

	/**
Determine whether mappingB is after mappingA with respect to generated
position.
/
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
A data structure to provide a sorted view of accumulated mappings in a
performance conscious manner. It trades a neglibable overhead in general
case for a large speedup in case of mappings being added in order.
/
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
Iterate through internal items. This method takes the same arguments that
`Array.prototype.forEach` takes.

NOTE: The order of the mappings is NOT guaranteed.
/
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
Add the given source mapping.

@param Object aMapping
/
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
Returns the flat, sorted array of mappings. The mappings are sorted by
generated position.

WARNING: This method returns internal data without copying, for
performance. The return value must NOT be mutated, and should be treated as
an immutable borrow. If you want to take ownership, you must make your own
copy.
/
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	exports.MappingList = MappingList;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/

	var util = __webpack_require__(4);
	var binarySearch = __webpack_require__(8);
	var ArraySet = __webpack_require__(5).ArraySet;
	var base64VLQ = __webpack_require__(2);
	var quickSort = __webpack_require__(9).quickSort;

	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
	    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	}

	/**
The version of the source mapping spec that we are consuming.
/
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  configurable: true,
	  enumerable: true,
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the `this.__generatedMappings` and
`this.__originalMappings` properties).
/
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
Iterate over each mapping between an original source/line/column and a
generated line/column in this source map.

@param Function aCallback
       The function that is called with each mapping.
@param Object aContext
       Optional. If specified, this object will be the value of `this` every
       time that `aCallback` is called.
@param aOrder
       Either `SourceMapConsumer.GENERATED_ORDER` or
       `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       iterate over the mappings sorted by the generated file's line/column
       order or the original's source/line/column order, respectively. Defaults to
       `SourceMapConsumer.GENERATED_ORDER`.
/
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
Returns all generated line and column information for the original source,
line, and column provided. If no column is provided, returns all mappings
corresponding to a either the line we are searching for or the next
closest line that has any mappings. Otherwise, returns all mappings
corresponding to the given line and either the column we are searching for
or the next closest column that has any offsets.

The only argument is an object with the following properties:

  - source: The filename of the original source.
  - line: The line number in the original source.  The line number is 1-based.
  - column: Optional. the column number in the original source.
   The column number is 0-based.

and an array of objects is returned, each with the following properties:

  - line: The line number in the generated source, or null.  The
   line number is 1-based.
  - column: The column number in the generated source, or null.
   The column number is 0-based.
/
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    needle.source = this._findSourceIndex(needle.source);
	    if (needle.source < 0) {
	      return [];
	    }

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	exports.SourceMapConsumer = SourceMapConsumer;

	/**
A BasicSourceMapConsumer instance represents a parsed source map which we can
query for information about the original file positions by giving it a file
position in the generated source.

The first parameter is the raw source map (either as a JSON string, or
already parsed to an object). According to the spec, source maps have the
following attributes:

  - version: Which version of the source map spec this map is following.
  - sources: An array of URLs to the original source files.
  - names: An array of identifiers which can be referrenced by individual mappings.
  - sourceRoot: Optional. The URL root from which all sources are relative.
  - sourcesContent: Optional. An array of contents of the original source files.
  - mappings: A string of base64 VLQs which contain the actual mappings.
  - file: Optional. The generated file this source map is associated with.

Here is an example source map, taken from the source map spec[0]:

    {
      version : 3,
      file: "out.js",
      sourceRoot : "",
      sources: ["foo.js", "bar.js"],
      names: ["src", "maps", "are", "fun"],
      mappings: "AA,AB;;ABCDE;"
    }

The second parameter, if given, is a string whose value is the URL
at which the source map was found.  This URL is used to compute the
sources array.

[0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
/
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  if (sourceRoot) {
	    sourceRoot = util.normalize(sourceRoot);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);

	  this._absoluteSources = this._sources.toArray().map(function (s) {
	    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
	  });

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this._sourceMapURL = aSourceMapURL;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
Utility function to find the index of a source.  Returns -1 if not
found.
/
	BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
	  var relativeSource = aSource;
	  if (this.sourceRoot != null) {
	    relativeSource = util.relative(this.sourceRoot, relativeSource);
	  }

	  if (this._sources.has(relativeSource)) {
	    return this._sources.indexOf(relativeSource);
	  }

	  // Maybe aSource is an absolute URL as returned by |sources|.  In
	  // this case we can't simply undo the transform.
	  var i;
	  for (i = 0; i < this._absoluteSources.length; ++i) {
	    if (this._absoluteSources[i] == aSource) {
	      return i;
	    }
	  }

	  return -1;
	};

	/**
Create a BasicSourceMapConsumer from a SourceMapGenerator.

@param SourceMapGenerator aSourceMap
       The source map that will be consumed.
@param String aSourceMapURL
       The URL at which the source map can be found (optional)
@returns BasicSourceMapConsumer
/
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	    smc._sourceMapURL = aSourceMapURL;
	    smc._absoluteSources = smc._sources.toArray().map(function (s) {
	      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
	    });

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
The version of the source mapping spec that we are consuming.
/
	BasicSourceMapConsumer.prototype._version = 3;

	/**
The list of original sources.
/
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._absoluteSources.slice();
	  }
	});

	/**
Provide the JIT with a nice shape / hidden class.
/
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the `this.__generatedMappings` and
`this.__originalMappings` properties).
/
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
Find the mapping that best matches the hypothetical "needle" mapping that
we are searching for in the given "haystack" of mappings.
/
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
Compute the last column for each generated mapping. The last column is
inclusive.
/
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
Returns the original source, line, and column information for the generated
source's line and column positions provided. The only argument is an object
with the following properties:

  - line: The line number in the generated source.  The line number
    is 1-based.
  - column: The column number in the generated source.  The column
    number is 0-based.
  - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
    'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
    closest element that is smaller than or greater than the one we are
    searching for, respectively, if the exact element cannot be found.
    Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.

and an object is returned with the following properties:

  - source: The original source file, or null.
  - line: The line number in the original source, or null.  The
    line number is 1-based.
  - column: The column number in the original source, or null.  The
    column number is 0-based.
  - name: The original identifier, or null.
/
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
Return true if we have the source content for every source in the source
map, false otherwise.
/
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
Returns the original source content. The only argument is the url of the
original source file. Returns null if no original source content is
available.
/
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    var index = this._findSourceIndex(aSource);
	    if (index >= 0) {
	      return this.sourcesContent[index];
	    }

	    var relativeSource = aSource;
	    if (this.sourceRoot != null) {
	      relativeSource = util.relative(this.sourceRoot, relativeSource);
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + relativeSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
	    }
	  };

	/**
Returns the generated line and column information for the original source,
line, and column positions provided. The only argument is an object with
the following properties:

  - source: The filename of the original source.
  - line: The line number in the original source.  The line number
    is 1-based.
  - column: The column number in the original source.  The column
    number is 0-based.
  - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
    'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
    closest element that is smaller than or greater than the one we are
    searching for, respectively, if the exact element cannot be found.
    Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.

and an object is returned with the following properties:

  - line: The line number in the generated source, or null.  The
    line number is 1-based.
  - column: The column number in the generated source, or null.
    The column number is 0-based.
/
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    source = this._findSourceIndex(source);
	    if (source < 0) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

	/**
An IndexedSourceMapConsumer instance represents a parsed source map which
we can query for information. It differs from BasicSourceMapConsumer in
that it takes "indexed" source maps (i.e. ones with a "sections" field) as
input.

The first parameter is a raw source map (either as a JSON string, or already
parsed to an object). According to the spec for indexed source maps, they
have the following attributes:

  - version: Which version of the source map spec this map is following.
  - file: Optional. The generated file this source map is associated with.
  - sections: A list of section definitions.

Each value under the "sections" field has two fields:
  - offset: The offset into the original specified at which this section
      begins to apply, defined as an object with a "line" and "column"
      field.
  - map: A source map definition. This source map could also be indexed,
      but doesn't have to be.

Instead of the "map" field, it's also possible to have a "url" field
specifying a URL to retrieve a source map from, but that's currently
unsupported.

Here's an example source map, taken from the source map spec[0], but
modified to omit a section which uses the "url" field.

 {
   version : 3,
   file: "app.js",
   sections: [{
     offset: {line:100, column:10},
     map: {
       version : 3,
       file: "section.js",
       sources: ["foo.js", "bar.js"],
       names: ["src", "maps", "are", "fun"],
       mappings: "AAAA,E;;ABCDE;"
     }
   }],
 }

The second parameter, if given, is a string whose value is the URL
at which the source map was found.  This URL is used to compute the
sources array.

[0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
/
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = util.parseSourceMapInput(aSourceMap);
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet();
	  this._names = new ArraySet();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
The version of the source mapping spec that we are consuming.
/
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
The list of original sources.
/
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
Returns the original source, line, and column information for the generated
source's line and column positions provided. The only argument is an object
with the following properties:

  - line: The line number in the generated source.  The line number
    is 1-based.
  - column: The column number in the generated source.  The column
    number is 0-based.

and an object is returned with the following properties:

  - source: The original source file, or null.
  - line: The line number in the original source, or null.  The
    line number is 1-based.
  - column: The column number in the original source, or null.  The
    column number is 0-based.
  - name: The original identifier, or null.
/
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
Return true if we have the source content for every source in the source
map, false otherwise.
/
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
Returns the original source content. The only argument is the url of the
original source file. Returns null if no original source content is
available.
/
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
Returns the generated line and column information for the original source,
line, and column positions provided. The only argument is an object with
the following properties:

  - source: The filename of the original source.
  - line: The line number in the original source.  The line number
    is 1-based.
  - column: The column number in the original source.  The column
    number is 0-based.

and an object is returned with the following properties:

  - line: The line number in the generated source, or null.  The
    line number is 1-based. 
  - column: The column number in the generated source, or null.
    The column number is 0-based.
/
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
Parse the mappings in a string in to a data structure which we can easily
query (the ordered arrays in the `this.__generatedMappings` and
`this.__originalMappings` properties).
/
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = null;
	        if (mapping.name) {
	          name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	        }

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };

	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause

## search

Source: `my-backend/node_modules/source-map/dist/source-map.js`

Signature: `search(= function search(aNeedle, aHaystack, aCompare, aBias)`

JSDoc:

This is an implementation of binary search which will always try and return
the index of the closest element if there is no exact hit. This is because
mappings between original and generated line/col pairs are single points,
and there is an implicit region between each of them, so a miss just means
that you aren't on the very start of a region.

@param aNeedle The element you are looking for.
@param aHaystack The array that is being searched.
@param aCompare A function which takes the needle and an element in the
    array and returns -1, 0, or 1 depending on whether the needle is less
    than, equal to, or greater than the element, respectively.
@param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
    'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
    closest element that is smaller than or greater than the one we are
    searching for, respectively, if the exact element cannot be found.
    Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.

## quickSort

Source: `my-backend/node_modules/source-map/dist/source-map.js`

Signature: `quickSort(= function (ary, comparator)`

JSDoc:

/ }),
/* 9 */
/***/ (function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
Copyright 2011 Mozilla Foundation and contributors
Licensed under the New BSD license. See LICENSE or:
http://opensource.org/licenses/BSD-3-Clause
/

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
Swap the elements indexed by `x` and `y` in the array `ary`.

@param {Array} ary
       The array.
@param {Number} x
       The index of the first item.
@param {Number} y
       The index of the second item.
/
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
Returns a random integer within the range `low .. high` inclusive.

@param {Number} low
       The lower bound on the range.
@param {Number} high
       The upper bound on the range.
/
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
The Quick Sort algorithm.

@param {Array} ary
       An array to sort.
@param {function} comparator
       Function to use to compare two items.
@param {Number} p
       Start index of the array
@param {Number} r
       End index of the array
/
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
Sort the given array in-place with the given comparator function.

@param {Array} ary
       An array to sort.
@param {function} comparator
       Function to use to compare two items.

## encode

Source: `my-backend/node_modules/source-map/lib/base64-vlq.js`

Signature: `encode(= function base64VLQ_encode(aValue)`

JSDoc:

Converts from a two-complement value to a value where the sign bit is
placed in the least significant bit.  For example, as decimals:
  1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
  2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
/
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
Converts to a two-complement value from a value where the sign bit is
placed in the least significant bit.  For example, as decimals:
  2 (10 binary) becomes 1, 3 (11 binary) becomes -1
  4 (100 binary) becomes 2, 5 (101 binary) becomes -2
/
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
Returns the base 64 VLQ encoded value.

## decode

Source: `my-backend/node_modules/source-map/lib/base64-vlq.js`

Signature: `decode(= function base64VLQ_decode(aStr, aIndex, aOutParam)`

JSDoc:

Decodes the next base 64 VLQ value from the given string and returns the
value and the rest of the string via the out parameter.

## encode

Source: `my-backend/node_modules/source-map/lib/base64.js`

Signature: `encode(= function (number)`

JSDoc:

Encode an integer in the range of 0 to 63 to a single base 64 digit.

## decode

Source: `my-backend/node_modules/source-map/lib/base64.js`

Signature: `decode(= function (charCode)`

JSDoc:

Decode a single base 64 character code digit to an integer. Returns -1 on
failure.

## search

Source: `my-backend/node_modules/source-map/lib/binary-search.js`

Signature: `search(= function search(aNeedle, aHaystack, aCompare, aBias)`

JSDoc:

Recursive implementation of binary search.

@param aLow Indices here and lower do not contain the needle.
@param aHigh Indices here and higher do not contain the needle.
@param aNeedle The element being searched for.
@param aHaystack The non-empty array being searched.
@param aCompare Function which takes two elements and returns -1, 0, or 1.
@param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
    'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
    closest element that is smaller than or greater than the one we are
    searching for, respectively, if the exact element cannot be found.
/
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
This is an implementation of binary search which will always try and return
the index of the closest element if there is no exact hit. This is because
mappings between original and generated line/col pairs are single points,
and there is an implicit region between each of them, so a miss just means
that you aren't on the very start of a region.

@param aNeedle The element you are looking for.
@param aHaystack The array that is being searched.
@param aCompare A function which takes the needle and an element in the
    array and returns -1, 0, or 1 depending on whether the needle is less
    than, equal to, or greater than the element, respectively.
@param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
    'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
    closest element that is smaller than or greater than the one we are
    searching for, respectively, if the exact element cannot be found.
    Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.

## quickSort

Source: `my-backend/node_modules/source-map/lib/quick-sort.js`

Signature: `quickSort(= function (ary, comparator)`

JSDoc:

Swap the elements indexed by `x` and `y` in the array `ary`.

@param {Array} ary
       The array.
@param {Number} x
       The index of the first item.
@param {Number} y
       The index of the second item.
/
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
Returns a random integer within the range `low .. high` inclusive.

@param {Number} low
       The lower bound on the range.
@param {Number} high
       The upper bound on the range.
/
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
The Quick Sort algorithm.

@param {Array} ary
       An array to sort.
@param {function} comparator
       Function to use to compare two items.
@param {Number} p
       Start index of the array
@param {Number} r
       End index of the array
/
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
Sort the given array in-place with the given comparator function.

@param {Array} ary
       An array to sort.
@param {function} comparator
       Function to use to compare two items.

## Request

Source: `my-backend/node_modules/superagent/lib/node/index.js`

Signature: `Request(= Request;

/**
 * Expose the agent function
 */

exports.agent = require('./agent')`

JSDoc:

Module dependencies.
/

// eslint-disable-next-line node/no-deprecated-api
const _require = require('url'),
  parse = _require.parse,
  format = _require.format,
  resolve = _require.resolve;
const Stream = require('stream');
const https = require('https');
const http = require('http');
const fs = require('fs');
const zlib = require('zlib');
const util = require('util');
const qs = require('qs');
const mime = require('mime');
let methods = require('methods');
const FormData = require('form-data');
const formidable = require('formidable');
const debug = require('debug')('superagent');
const CookieJar = require('cookiejar');
const semverGte = require('semver/functions/gte');
const safeStringify = require('fast-safe-stringify');
const utils = require('../utils');
const RequestBase = require('../request-base');
const _require2 = require('./unzip'),
  unzip = _require2.unzip;
const Response = require('./response');
const mixin = utils.mixin,
  hasOwn = utils.hasOwn;
let http2;
if (semverGte(process.version, 'v10.10.0')) http2 = require('./http2wrapper');
function request(method, url) {
  // callback
  if (typeof url === 'function') {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (arguments.length === 1) {
    return new exports.Request('GET', method);
  }
  return new exports.Request(method, url);
}
module.exports = request;
exports = module.exports;

/**
Expose `Request`.

## Response

Source: `my-backend/node_modules/superagent/lib/node/index.js`

Signature: `Response(= Response;

/**
 * Define "form" mime type.
 */

mime.define({
  'application/x-www-form-urlencoded': ['form', 'urlencoded', 'form-data']
}, true)`

JSDoc:

Noop.
/

function noop() {}

/**
Expose `Response`.

## protocols

Source: `my-backend/node_modules/superagent/lib/node/index.js`

Signature: `protocols(= {
  'http:': http,
  'https:': https,
  'http2:': http2
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj)`

JSDoc:

Protocol map.

## parse

Source: `my-backend/node_modules/superagent/lib/node/index.js`

Signature: `parse(= require('./parsers')`

JSDoc:

Default parsers.

    superagent.parse['application/xml'] = function(res, fn){
      fn(null, res);
    };


## buffer

Source: `my-backend/node_modules/superagent/lib/node/index.js`

Signature: `buffer(= {};

/**
 * Initialize internal header tracking properties on a request instance.
 *
 * @param {Object} req the instance
 * @api private
 */
function _initHeaders(request_)`

JSDoc:

Default buffering map. Can be used to set certain
response types to buffer/not buffer.

    superagent.buffer['application/xml'] = true;

## unzip

Source: `my-backend/node_modules/superagent/lib/node/unzip.js`

Signature: `unzip(= (request, res)`

JSDoc:

Module dependencies.
/

const _require = require('string_decoder'),
  StringDecoder = _require.StringDecoder;
const Stream = require('stream');
const zlib = require('zlib');

/**
Buffers response data events and re-emits when they're unzipped.

@param {Request} req
@param {Response} res
@api private

## type

Source: `my-backend/node_modules/superagent/lib/utils.js`

Signature: `type(= string_ => string_.split(/ *; */)`

JSDoc:

Return the mime type for the given `str`.

@param {String} str
@return {String}
@api private

## params

Source: `my-backend/node_modules/superagent/lib/utils.js`

Signature: `params(= value => {
  const object = {};
  var _iterator = _createForOfIteratorHelper(value.split(/ *; */)`

JSDoc:

Return header field parameters.

@param {String} str
@return {Object}
@api private

## parseLinks

Source: `my-backend/node_modules/superagent/lib/utils.js`

Signature: `parseLinks(= value => {
  const object = {};
  var _iterator2 = _createForOfIteratorHelper(value.split(/ *, */)`

JSDoc:

Parse Link header fields.

@param {String} str
@return {Object}
@api private

## cleanHeader

Source: `my-backend/node_modules/superagent/lib/utils.js`

Signature: `cleanHeader(= (header, changesOrigin)`

JSDoc:

Strip content related fields from `header`.

@param {Object} header
@return {Object} header
@api private

## isObject

Source: `my-backend/node_modules/superagent/lib/utils.js`

Signature: `isObject(= object => {
  return object !== null && typeof object === 'object';
};

/**
 * Object.hasOwn fallback/polyfill.
 *
 * @type {(object: object, property: string)`

JSDoc:

Check if `obj` is an object.

@param {Object} object
@return {Boolean}
@api private

## formatArgs

Source: `my-backend/node_modules/superagent/node_modules/debug/src/browser.js`

Signature: `formatArgs(= formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage()`

JSDoc:

This is the web browser implementation of `debug()`.

## colors

Source: `my-backend/node_modules/superagent/node_modules/debug/src/browser.js`

Signature: `colors(= [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version)`

JSDoc:

Colors.

## log

Source: `my-backend/node_modules/superagent/node_modules/debug/src/browser.js`

Signature: `log(= console.debug || console.log || (()`

JSDoc:

Colorize log arguments if enabled.

@api public
/

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
Invokes `console.debug()` when available.
No-op when `console.debug` is not a "function".
If `console.debug` is not available, falls back
to `console.log`.

@api public

## init

Source: `my-backend/node_modules/superagent/node_modules/debug/src/node.js`

Signature: `init(= init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	()`

JSDoc:

Module dependencies.
/

const tty = require('tty');
const util = require('util');

/**
This is the Node.js implementation of `debug()`.

## colors

Source: `my-backend/node_modules/superagent/node_modules/debug/src/node.js`

Signature: `colors(= [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)`

JSDoc:

Colors.

## inspectOpts

Source: `my-backend/node_modules/superagent/node_modules/debug/src/node.js`

Signature: `inspectOpts(= Object.keys(process.env)`

JSDoc:

Build up the default `inspectOpts` object from the environment variables.

  $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js

## Test

Source: `my-backend/node_modules/supertest/index.js`

Signature: `Test(= Test;

/**
 * Expose the agent function
 */
module.exports.agent = agent;
)`

JSDoc:

Module dependencies.
/
const methods = require('methods');
const http = require('http');
let http2;
try {
  http2 = require('http2'); // eslint-disable-line global-require
} catch (_) {
  // eslint-disable-line no-empty
}
const Test = require('./lib/test.js');
const agent = require('./lib/agent.js');

/**
Test against the given `app`,
returning a new `Test`.

@param {Function|Server|String} app
@return {Test}
@api public
/
module.exports = function(app, options = {}) {
  const obj = {};

  if (typeof app === 'function') {
    if (options.http2) {
      if (!http2) {
        throw new Error(
          'supertest: this version of Node.js does not support http2'
        );
      }
      app = http2.createServer(app); // eslint-disable-line no-param-reassign
    } else {
      app = http.createServer(app); // eslint-disable-line no-param-reassign
    }
  }

  methods.forEach(function(method) {
    obj[method] = function(url) {
      var test = new Test(app, method, url);
      if (options.http2) {
        test.http2();
      }
      return test;
    };
  });

  // Support previous use of del
  obj.del = obj.delete;

  return obj;
};

/**
Expose `Test`

## parseMIMEType

Source: `my-backend/node_modules/undici-types/content-type.d.ts`

Signature: `parseMIMEType(input: string)`

JSDoc:

Parse a string to a {@link MIMEType} object. Returns `failure` if the string
couldn't be parsed.
@see https://mimesniff.spec.whatwg.org/#parse-a-mime-type

## serializeAMimeType

Source: `my-backend/node_modules/undici-types/content-type.d.ts`

Signature: `serializeAMimeType(mimeType: MIMEType)`

JSDoc:

Convert a MIMEType object to a string.
@see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type

## headerNameToString

Source: `my-backend/node_modules/undici-types/util.d.ts`

Signature: `headerNameToString(value: string | Buffer)`

JSDoc:

Retrieves a header name and returns its lowercase value.
@param value Header name

## parseHeaders

Source: `my-backend/node_modules/undici-types/util.d.ts`

Signature: `parseHeaders(
    headers: (Buffer | string | (Buffer | string)`

JSDoc:

Receives a header object and returns the parsed value.
@param headers Header object
@param obj Object to specify a proxy object. Used to assign parsed values.
@returns If `obj` is specified, it is equivalent to `obj`.

## sliceRange

Source: `my-backend/node_modules/v8-to-istanbul/lib/range.js`

Signature: `sliceRange(= (lines, startCol, endCol, inclusive = false)`

JSDoc:

...something resembling a binary search, to find the lowest line within the range.
And then you could break as soon as the line is longer than the range...

## iso7064Check

Source: `my-backend/node_modules/validator/es/lib/util/algorithms.js`

Signature: `iso7064Check(str)`

JSDoc:

Algorithmic validation functions
May be used as is or implemented in the workflow of other validators.
/

/*
ISO 7064 validation function
Called with a string of numbers (incl. check digit)
to validate according to ISO 7064 (MOD 11, 10).

## camelCase

Source: `my-backend/node_modules/yargs-parser/build/lib/string-utils.js`

Signature: `camelCase(str)`

JSDoc:

@license
Copyright (c) 2016, Contributors
SPDX-License-Identifier: ISC

