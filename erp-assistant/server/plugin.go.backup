package main

import (
	"strings"

	"github.com/mattermost/mattermost/server/public/model"
	"github.com/mattermost/mattermost/server/public/plugin"
)

// Plugin implements the interface expected by the Mattermost server to communicate between the server and plugin processes.
type Plugin struct {
	plugin.MattermostPlugin
	botID string
}

// OnActivate is invoked when the plugin is activated. It creates the ERP bot user.
func (p *Plugin) OnActivate() error {
	bot := &model.Bot{
		Username:    "erpbot",
		DisplayName: "ERP Assistant",
		Description: "Internal ERP helper - ask about invoices, POs, attendance, and more!",
	}
	
	// Try to create the bot, if it exists this will fail silently
	createdBot, err := p.API.CreateBot(bot)
	if err != nil {
		// If bot already exists, we'll get it in the message handler
		p.API.LogInfo("Bot might already exist, will handle in message handler")
		// Try to get the bot by checking user by username
		user, userErr := p.API.GetUserByUsername(bot.Username)
		if userErr == nil && user.IsBot {
			p.botID = user.Id
			p.API.LogInfo("Found existing ERP Assistant bot", "botID", p.botID)
			return nil
		}
		// If we can't find it, return the original error
		return err
	}
	
	p.botID = createdBot.UserId
	p.API.LogInfo("ERP Assistant bot activated successfully", "botID", p.botID)
	
	return nil
}

// reply generates rule-based responses based on the message content
func reply(msg string) string {
	m := strings.ToLower(msg)
	
	switch {
	case strings.Contains(m, "invoice"):
		return "ğŸ§¾ **Invoice Management**\n\nTo create an invoice, navigate to:\nâ†’ *Finance â†’ Billing â†’ New Invoice*\n\nFor viewing existing invoices:\nâ†’ *Finance â†’ Billing â†’ Invoice List*"
	
	case strings.Contains(m, "purchase") || strings.Contains(m, "po"):
		return "ğŸ“¦ **Purchase Orders**\n\nPurchase Orders are managed here:\nâ†’ *Procurement â†’ PO List*\n\nTo create a new PO:\nâ†’ *Procurement â†’ Create PO*"
	
	case strings.Contains(m, "leave") || strings.Contains(m, "attendance"):
		return "ğŸ•’ **Attendance & Leave**\n\nManage your attendance:\nâ†’ *HR â†’ Attendance â†’ My Records*\n\nApply for leave:\nâ†’ *HR â†’ Leave Management â†’ Apply Leave*"
	
	case strings.Contains(m, "inventory") || strings.Contains(m, "stock"):
		return "ğŸ“Š **Inventory Management**\n\nCheck stock levels:\nâ†’ *Warehouse â†’ Inventory â†’ Stock Status*\n\nManage items:\nâ†’ *Warehouse â†’ Items â†’ Item Master*"
	
	case strings.Contains(m, "customer") || strings.Contains(m, "client"):
		return "ğŸ‘¥ **Customer Management**\n\nView customers:\nâ†’ *Sales â†’ Customers â†’ Customer List*\n\nAdd new customer:\nâ†’ *Sales â†’ Customers â†’ New Customer*"
	
	case strings.Contains(m, "vendor") || strings.Contains(m, "supplier"):
		return "ğŸ¢ **Vendor Management**\n\nManage vendors:\nâ†’ *Procurement â†’ Vendors â†’ Vendor List*\n\nAdd new vendor:\nâ†’ *Procurement â†’ Vendors â†’ New Vendor*"
	
	case strings.Contains(m, "payment"):
		return "ğŸ’° **Payment Processing**\n\nRecord payments:\nâ†’ *Finance â†’ Payments â†’ Payment Entry*\n\nView payment history:\nâ†’ *Finance â†’ Payments â†’ Payment List*"
	
	case strings.Contains(m, "report") || strings.Contains(m, "analytics"):
		return "ğŸ“ˆ **Reports & Analytics**\n\nAccess reports:\nâ†’ *Dashboard â†’ Reports*\n\nCustom analytics:\nâ†’ *Dashboard â†’ Analytics â†’ Custom Reports*"
	
	case strings.Contains(m, "user") || strings.Contains(m, "employee"):
		return "ğŸ‘¤ **User Management**\n\nManage employees:\nâ†’ *HR â†’ Employees â†’ Employee List*\n\nAdd new user:\nâ†’ *Settings â†’ Users â†’ Create User*"
	
	case strings.Contains(m, "approval") || strings.Contains(m, "pending"):
		return "âœ… **Approvals & Workflow**\n\nView pending approvals:\nâ†’ *Dashboard â†’ Approvals â†’ Pending Items*\n\nApproval history:\nâ†’ *Dashboard â†’ Approvals â†’ History*"
	
	case strings.Contains(m, "help") || strings.Contains(m, "hello") || strings.Contains(m, "hi"):
		return "ğŸ¤– **Hi! I'm your ERP Assistant**\n\nI can help you with:\n" +
			"â€¢ ğŸ§¾ Invoices & Billing\n" +
			"â€¢ ğŸ“¦ Purchase Orders\n" +
			"â€¢ ğŸ•’ Attendance & Leave\n" +
			"â€¢ ğŸ“Š Inventory & Stock\n" +
			"â€¢ ğŸ‘¥ Customers & Vendors\n" +
			"â€¢ ğŸ’° Payments\n" +
			"â€¢ ğŸ“ˆ Reports & Analytics\n" +
			"â€¢ âœ… Approvals\n\n" +
			"Just ask me about any of these topics!"
	
	default:
		return "ğŸ¤” **I'm not sure about that...**\n\n" +
			"Try asking me about:\n" +
			"â€¢ Invoices or billing\n" +
			"â€¢ Purchase orders (PO)\n" +
			"â€¢ Attendance or leave\n" +
			"â€¢ Inventory or stock\n" +
			"â€¢ Customers or vendors\n" +
			"â€¢ Payments\n" +
			"â€¢ Reports\n\n" +
			"Or just say **help** to see all topics I can assist with!"
	}
}

// MessageHasBeenPosted is invoked after a message has been posted by a user.
// This is where the bot listens for mentions or DMs and responds accordingly.
func (p *Plugin) MessageHasBeenPosted(c *plugin.Context, post *model.Post) {
	// Ignore messages from the bot itself to prevent infinite loops
	if post.UserId == p.botID {
		return
	}
	
	// Get the channel information
	channel, appErr := p.API.GetChannel(post.ChannelId)
	if appErr != nil {
		p.API.LogError("Failed to get channel", "error", appErr.Error())
		return
	}
	
	// Check if it's a DM or Group message (always respond)
	isDM := channel != nil && (channel.Type == model.ChannelTypeDirect || channel.Type == model.ChannelTypeGroup)
	
	// In public channels, only respond if @erpbot is mentioned
	if !isDM && !strings.Contains(strings.ToLower(post.Message), "@erpbot") {
		return
	}
	
	// Generate the response
	answer := reply(post.Message)
	
	// Create and post the reply
	replyPost := &model.Post{
		UserId:    p.botID,
		ChannelId: post.ChannelId,
		RootId:    post.Id,
		Message:   answer,
	}
	
	if _, appErr := p.API.CreatePost(replyPost); appErr != nil {
		p.API.LogError("Failed to create reply post", "error", appErr.Error())
		return
	}
	
	p.API.LogDebug("ERP Assistant responded to message", "channelId", post.ChannelId, "isDM", isDM)
}
